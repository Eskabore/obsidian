{
    "version": 1602979200000,
    "changes": [
        {
            "timestamp": 1608872461984,
            "collection": "favIcons",
            "objectPk": "publish.obsidian.md",
            "operation": "create",
            "object": {
                "hostname": "publish.obsidian.md",
                "favIcon": "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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoDdKIqA3SnilO07QyVRpaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgN0oaoDdKcqA3SsegN0r+oDdK/7hIXf/MVmzhzFZsBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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bAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoDdKBaA3SkugN0qioDdK8aA3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+iOEv/yFNp/8xWbP/MVmz/zFZs/8xWbP/MVmz/zFZsaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmC5CMKA3StSgN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/7BCVv/MVmz/zFZs/8xWbP/MVmz/zFZs/8xWbP/MVmz/zFZs/8xWbP/MVmz/zFZs4cxWbAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACTKDyloDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/xVFm/8xWbP/MVmz/zFZs/8xWbP/MVmz/zFZs/8xWbP/MVmz/zFZs/8xWbP/MVmz/zFZsSgAA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AAAAAAAAoDdKB6A3SnSgN0rvoDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/9Fxg//0n6//9J+v//Sfr//0n6//9J+v//Sfr//0n6//9J+v//Sfr//0n6//9J+v//Sfr//0n6/a9J+vDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKA3ShOgN0qPoDdK+aA3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/xmZ4//Sfr//0n6//9J+v//Sfr//0n6//9J+v//Sfr//0n6//9J+v//Sfr//0n6//9J+v+/SfrzgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgN0ojoDdKqqA3Sv6gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv++XG7/9J+v//Sfr//0n6//9J+v//Sfr//0n6//9J+v//Sfr//0n6//9J+v//Sfr//0n6+CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoDdKOaA3SsSgN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/7hVZ//0n6//9J+v//Sfr//0n6//9J+v//Sfr//0n6//9J+v//Sfr//0n6//9J+vyvSfrwQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKA3SlOgN0raoDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/sU1f//Sfr//0n6//9J+v//Sfr//0n6//9J+v//Sfr//0n6//9J+v//Sfr/X0n68nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKA3SgagN0ptoDdK66A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+qRFb/9J+v//Sfr//0n6//9J+v//Sfr//0n6//9J+v//Sfr//0n6//9J+vagAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgN0oQoDdKiaA3SvagN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6M7Tv/0n6//9J+v//Sfr//0n6//9J+v//Sfr//0n6//9J+v//Sfr7b0n68BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoDdKH6A3SqOgN0r9oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK//Gbq//0n6//9J+v//Sfr//0n6//9J+v//Sfr//0n6/s9J+vGQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKA3SjOgN0q+oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/6pKj//Sfr//0n6//9J+v//Sfr//0n6//9J+v//Sfr1MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgN0pMoDdK1aA3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv/jipr/9J+v//Sfr//0n6//9J+v//Sfr//0n6+gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgN0oEoDdKZ6A3SuegN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/9yBkv/0n6//9J+v//Sfr//0n6//9J+v3/Sfrw4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoDdKDKA3SoOgN0r0oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/1nmK//Sfr//0n6//9J+v//Sfr/30n68+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKA3ShqgN0qcoDdK/aA3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv/OcIH/9J+v//Sfr//0n6//9J+viQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgN0otoDdKt6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/8doef/0n6//9J+v//Sfr8/0n68HAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoDdKRaA3StCgN0r/oDdK/6A3Sv+gN0r/wWBy//Sfr//0n6/39J+vLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoDdKAqA3SmGgN0rjoDdK/6A3Sv+6V2n/9J+v//Sfr3IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKA3SgmgN0p8oDdK8rNOYf/0n6+99J+vAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgN0oWsEpdj/Sfrx0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//////////////////////////////////////////////////////////////////////////////////////////////////8P///////////////////4B///////////////////wAf//////////////////gAD//////////////////AAA/////////////////+AAAH////////////////8AAAB////////////////4AAAAP///////////////wAAAAD///////////////wAAAAAf//////////////gAAAAAH//////////////gAAAAAA//////////////4AAAAAAP/////////////8AAAAAAD//////////////AAAAAAA//////////////gAAAAAAP/////////////4AAAAAAB/////////////+AAAAAAAf/////////////AAAAAAAH/////////////wAAAAAAB/////////////4AAAAAAAf////////////+AAAAAAAH/////////////AAAAAAAA/////////////wAAAAAAAP////////////4AAAAAAAD////////////+AAAAAAAA/////////////gAAAAAAAP////////////wAAAAAAAD////////////8AAAAAAAAf///////////+AAAAAAAAH////////////gAAAAAAAB////////////wAAAAAAAAf///////////8AAAAAAAAH////////////AAAAAAAAB////////////gAAAAAAAAP///////////4AAAAAAAAD///////////8AAAAAAAAA////////////AAAAAAAAAP///////////gAAAAAAAAD///////////4AAAAAAAAA///////////+AAAAAAAAAH///////////AAAAAAAAAB///////////wAAAAAAAAAf//////////4AAAAAAAAAH//////////+AAAAAAAAAB///////////AAAAAAAAAAf//////////wAAAAAAAAAD//////////4AAAAAAAAAA//////////+AAAAAAAAAAP//////////gAAAAAAAAAD//////////wAAAAAAAAAA//////////8AAAAAAAAAAP/////////+AAAAAAAAAAB//////////gAAAAAAAAAAf/////////wAAAAAAAAAAH/////////8AAAAAAAAAAB//////////AAAAAAAAAAAf/////////gAAAAAAAAAAH/////////4AAAAAAAAAAA/////////8AAAAAAAAAAAP/////////AAAAAAAAAAAD/////////gAAAAAAAAAAA/////////4AAAAAAAAAAAP////////+AAAAAAAAAAAD/////////AAAAAAAAAAAAf////////wAAAAAAAAAAAH////////8AAAAAAAAAAAB/////////gAAAAAAAAAAAf////////4AAAAAAAAAAAH/////////AAAAAAAAAAAB/////////wAAAAAAAAAAAP////////+AAAAAAAAAAAD/////////gAAAAAAAAAAA/////////4AAAAAAAAAAAP/////////AAAAAAAAAAAD/////////wAAAAAAAAAAA/////////+AAAAAAAAAAAH/////////gAAAAAAAAAAB/////////8AAAAAAAAAAAf/////////AAAAAAAAAAAH/////////4AAAAAAAAAAB/////////+AAAAAAAAAAAf/////////wAAAAAAAAAAD/////////8AAAAAAAAAAA//////////gAAAAAAAAAAP/////////4AAAAAAAAAAD/////////+AAAAAAAAAAA//////////wAAAAAAAAAAP/////////8AAAAAAAAAAD//////////gAAAAAAAAAA//////////4AAAAAAAAAAf//////////AAAAAAAAAAP//////////wAAAAAAAAAD//////////+AAAAAAAAAB///////////gAAAAAAAAA///////////8AAAAAAAAAP///////////AAAAAAAAAH///////////4AAAAAAAAD///////////+AAAAAAAAB////////////wAAAAAAAAf////////////AAAAAAAAP////////////4AAAAAAAH/////////////gAAAAAAB/////////////+AAAAAAA//////////////4AAAAAAf//////////////gAAAAAH//////////////+AAAAAD///////////////wAAAAB////////////////AAAAAf///////////////8AAAAP////////////////wAAAH/////////////////AAAD/////////////////4AAA//////////////////gAAf/////////////////+AAP//////////////////4AD///////////////////gB///////////////////8A////////////////////wP////////////////////H////////////////////////////////////////////////////////////////////////////////////////////8oAAAAQAAAAIAAAAABACAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKA3SgagN0pOoDdKprtKX8bMVmwCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgN0oEoDdKRqA3Sp6gN0rvoDdK/6Y8T//MVmz/zFZsVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoDdKAqA3Sj+gN0qXoDdK6qA3Sv+gN0r/oDdK/6A3Sv+7Sl//zFZs/8xWbNLMVmwCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKA3SgGgN0o4oDdKj6A3SuSgN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+lO07/y1Vr/8xWbP/MVmz/zFZsVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoDdKMKA3SoegN0reoDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/uUle/8xWbP/MVmz/zFZs/8xWbNLMVmwCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJguQgygN0qAoDdK16A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/pDpN/8pVa//MVmz/zFZs/8xWbP/MVmz/zFZsVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACSJztvoDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/7hIXP/MVmz/zFZs/8xWbP/MVmz/zFZs/8xWbK8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMIDQCkCU526A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6M5TP/KVWv/zFZs/8xWbP/MVmz/zFZs/8xWbP/MVmzaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjCA0TZEmOf+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+3R1z/zVdt/8xXbf/MV23/zFZs/8xWbP/MVmz/zFZs/MxWbAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIwgNLySJzv/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+iOUz/ylZs/81Ybv/NWG7/zVdt/81Xbf/MV23/zFZs/8xWbP/MVmwwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIwgNC2MIDT/kyg8/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/tUdb/85ab//OWW//zVlv/81Ybv/NWG7/zVhu/81Xbf/MV23/zFdtWgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMIDSbjCA0/5QqPf+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/ojhL/8pXbf/OWnD/zlpw/85ab//OWW//zVlv/81Ybv/NWG7/zVhu/81XbYUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMIDQUjCA09owgNP+WKz7/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/7RHW//PXHH/z1tx/89bcP/OWnD/zlpw/85ab//OWW//zllv/81Zbv/NWG6vAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjCA0eowgNP+MIDT/lyxA/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6E4S//KWG3/z1xy/89ccv/PXHH/z1tx/89bcf/OW3D/zlpw/85acP/OWm//zllv2gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjCA0BYwgNOSMIDT/jCA0/5guQf+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+zRlr/0F5z/9Bdc//QXXL/0F1y/89ccv/PXHH/z1xx/89bcf/PW3D/zlpw/85acPzOWnAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIwgNFiMIDT/jCA0/4wgNP+ZL0L/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+hN0v/yllu/9FfdP/QXnT/0F5z/9Bec//QXXP/0F1y/89ccv/PXHL/z1xx/89bcf/PW3D/z1twMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMIDTHjCA0/4wgNP+MIDT/mjBE/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/sUVZ/9Fgdf/RX3X/0V90/9FfdP/QXnT/0F5z/9Bec//QXXP/0F1y/89ccv/PXHL/z1xx/89ccVoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMIDQ3jCA0/4wgNP+MIDT/jCA0/5syRf+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/8labv/SYXb/0WB1/9Fgdf/RYHX/0V90/9FfdP/RXnT/0F5z/9Bec//QXXP/0F1y/9Bdcv/PXHKFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjCA0powgNP+MIDT/jCA0/4wgNP+cM0b/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/7BEWP/SYnf/0mJ3/9Jhdv/SYXb/0mF2/9Fgdf/RYHX/0V91/9FfdP/RX3T/0F50/9Bec//QXnP/0F1zrwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjCA0G4wgNPqMIDT/jCA0/4wgNP+MIDT/njRH/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv/IWm7/02N4/9Njd//SYnf/0mJ3/9Jhdv/SYXb/0mF2/9Fgdf/RYHX/0WB1/9FfdP/RX3T/0V50/9Bec9oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIwgNISMIDT/jCA0/4wgNP+MIDT/jCA0/581Sf+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+uQ1f/1GR5/9Nkef/TY3j/02N4/9NjeP/TYnf/0mJ3/9Jid//SYXb/0mF2/9Jhdv/RYHX/0WB1/9Ffdf/RX3T80V90CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIwgNAiMIDTrjCA0/4wgNP+MIDT/jCA0/4wgNP+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/x1pu/9Rlev/UZXn/1GR5/9Nkef/TY3j/02N4/9NjeP/TYnf/0mJ3/9Jid//SYXb/0mF2/9Jhdv/RYHX/0WB1/9FgdTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMIDRjjCA0/4wgNP+MIDT/jCA0/4wgNP+NITX/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/rEJV/9Vme//UZnv/1GV6/9Rlev/UZXn/1GR5/9Nkef/TZHj/02N4/9NjeP/TY3f/0mJ3/9Jid//SYXb/0mF2/9Jhdv/SYXZaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMIDQBjCA00YwgNP+MIDT/jCA0/4wgNP+MIDT/jiI2/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/8Zabv/VZ3z/1Wd7/9Vme//VZnv/1GZ6/9Rlev/UZXr/1GV5/9Rkef/TZHn/02N4/9NjeP/TY3j/02J3/9Jid//SYnf/0mF2hQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjCA0QowgNP+MIDT/jCA0/4wgNP+MIDT/jCA0/48kOP+gN0r/oDdK/6A3Sv+gN0r/oDdK/6tBVP/WaH3/1mh9/9VofP/VZ3z/1Wd8/9Vne//VZnv/1GZ7/9Rlev/UZXr/1GV5/9Rkef/TZHn/02R4/9NjeP/TY3j/02N3/9Jid68AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIwgNLGMIDT/jCA0/4wgNP+MIDT/jCA0/4wgNP+QJTn/oDdK/6A3Sv+gN0r/oDdK/6A3Sv/FWW3/1ml+/9Zpff/WaX3/1mh9/9ZofP/VaHz/1Wd8/9Vne//VZnv/1WZ7/9Rmev/UZXr/1GV6/9Rlef/UZHn/02R5/9NjeP/TY3jaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIwgNCOMIDT9jCA0/4wgNP+MIDT/jCA0/4wgNP+MIDT/kSY6/6A3Sv+gN0r/oDdK/6A3Sv+pP1P/12p+/9dqfv/Wan7/1ml+/9Zpff/WaX3/1mh9/9ZofP/VaHz/1Wd8/9Vne//VZnv/1WZ7/9Rmev/UZXr/1GV6/9Rlef/UZHn/02R5/NNkeQgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMIDSPjCA0/4wgNP+MIDT/jCA0/4wgNP+MIDT/jCA0/5MoO/+gN0r/oDdK/6A3Sv+gN0r/w1ls/9drgP/Xa3//12t//9dqf//Xan7/1mp+/9Zpfv/WaX3/1mh9/9Zoff/VaHz/1Wd8/9VnfP/VZ3v/1WZ7/9Rme//UZXr/1GV6/9Rlef/UZXkwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMIDQNjCA08YwgNP+MIDT/jCA0/4wgNP+MIDT/jCA0/4wgNP+UKT3/oDdK/6A3Sv+gN0r/pz5R/9dsgP/YbID/2GyA/9dsgP/Xa3//12t//9dqf//Xan7/1mp+/9Zpfv/WaX3/1ml9/9Zoff/WaHz/1Wh8/9VnfP/VZ3v/1WZ7/9Vme//UZnr/1GV6WgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjCA0bowgNP+MIDT/jCA0/4wgNP+MIDT/jCA0/4wgNP+MIDT/lSo+/6A3Sv+gN0r/oDdK/8JYa//ZboL/2G2B/9htgf/YbIH/2GyA/9hsgP/Xa4D/12t//9drf//Xan//12p+/9Zqfv/WaX7/1ml9/9Zoff/WaH3/1Wh8/9VnfP/VZ3z/1Wd7/9Vme4UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjCA0AowgNNuMIDT/jCA0/4wgNP+MIDT/jCA0/4wgNP+MIDT/jCA0/5YsP/+gN0r/oDdK/6Y9UP/XbYH/2W+C/9lugv/ZboL/2G2B/9htgf/YbYH/2GyA/9hsgP/XbID/12t//9drf//Xan//12p+/9Zqfv/WaX7/1ml9/9Zpff/WaH3/1mh8/9VofP/VZ3yvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIwgNEyMIDT/jCA0/4wgNP+MIDT/jCA0/4wgNP+MIDT/jCA0/4wgNP+XLUD/oDdK/6A3Sv/AV2r/2nCE/9lvg//Zb4P/2W+C/9lugv/ZboL/2G2B/9htgf/YbYH/2GyA/9hsgP/XbID/12t//9drf//Xan//12p+/9Zqfv/WaX7/1ml9/9Zpff/WaH3/1mh92gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMIDSujCA0/4wgNP+MIDT/jCA0/4wgNP+MIDT/jCA0/4wgNP+MIDT/mC5C/6A3Sv+lPE//2G+C/9pxhP/acIT/2nCE/9pvg//Zb4P/2W+D/9lugv/ZboL/2W6C/9htgf/YbYH/2GyB/9hsgP/YbID/12uA/9drf//Xa3//12p//9dqfv/Wan7/1ml+/9ZpffzWaX0IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjCA0aYwgNP+MIDT/jCA0/4wgNP+MIDT/jCA0/4wgNP+MIDT/jCA0/5kwQ/+gN0r/v1Zp/9tyhf/bcYX/2nGF/9pxhP/acIT/2nCE/9pwg//Zb4P/2W+D/9lvgv/ZboL/2W6C/9htgf/YbYH/2G2B/9hsgP/YbID/12yA/9drf//Xa3//12p//9dqfv/Wan7/1mp+MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIwgNAmMIDTqjCA0/4wgNP+MIDT/jCA0/4wgNP+MIDT/jCA0/4wgNP+bMUT/pDtO/9hvg//bc4b/23KG/9tyhv/bcoX/23GF/9pxhf/acYT/2nCE/9pwhP/ab4P/2W+D/9lvg//ZboL/2W6C/9lugv/YbYH/2G2B/9hsgf/YbID/2GyA/9drgP/Xa3//12t//9dqf1oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjCA0fYwgNP+MIDT/jCA0/4wgNP+MIDT/jCA0/4wgNP+MIDT/nDJF/71UaP/cdIf/3HSH/9xzh//bc4b/23OG/9tyhv/bcoX/23GF/9pxhf/acYT/2nCE/9pwhP/acIP/2W+D/9lvg//Zb4L/2W6C/9lugv/YbYH/2G2B/9htgf/YbID/2GyA/9dsgP/Xa3+FAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIwgNBKMIDT0jCA0/4wgNP+MIDT/jCA0/4wgNP+MIDT/jCA0/582Sf/YcIT/3HWI/9x1iP/cdIj/3HSH/9xzh//bc4b/23OG/9tyhv/bcoX/23GF/9pxhf/acYT/2nCE/9pwhP/acIP/2W+D/9lvg//Zb4L/2W6C/9lugv/YbYH/2G2B/9htgf/YbID/2GyArwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjCA0kIwgNP+MIDT/jCA0/4wgNP+MIDT/jCA0/4wgNP+5UWT/3XaJ/912if/ddYn/3HWI/9x1iP/cdIj/3HSH/9xzh//bc4f/23OG/9tyhv/bcob/23KF/9txhf/acYX/2nGE/9pwhP/acIT/2m+D/9lvg//Zb4P/2W6C/9lugv/ZboL/2G2B/9htgdoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIwgNB+MIDT7jCA0/4wgNP+MIDT/jCA0/4wgNP+MIDT/ymN2/953iv/dd4r/3XaK/912if/ddon/3XWI/9x1iP/cdIj/3HSH/9x0h//cc4f/23OG/9tzhv/bcob/23KF/9txhf/acYX/2nGE/9pwhP/acIT/2nCD/9lvg//Zb4P/2W+C/9lugv/ZboL82W6CCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjCA0o4wgNP+MIDT/jCA0/4wgNP+MIDT/jyQ3/6I5TP/GXnH/3niL/953iv/dd4r/3XaK/912if/ddon/3XWJ/9x1iP/cdYj/3HSI/9x0h//cc4f/23OH/9tzhv/bcob/23KG/9tyhf/bcYX/2nGF/9pxhP/acIT/2nCE/9pvg//Zb4P/2W+D/9lvgjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIwgNC6MIDT+jCA0/4wgNP+MIDT/jCA0/5MoPP+gN0r/oDdK/7hRZP/cdon/3niL/953i//ed4r/3XeK/912iv/ddon/3XaJ/911iP/cdYj/3HSI/9x0h//cdIf/3HOH/9tzhv/bc4b/23KG/9tyhf/bcYX/2nGF/9pxhP/acIT/2nCE/9pwg//Zb4NaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjCA0t4wgNP+MIDT/jCA0/4wgNP+XLUD/oDdK/6A3Sv+gN0r/rUVY/9dxhP/eeIv/3niL/954i//ed4r/3XeK/912iv/ddon/3XaJ/911iP/cdYj/3HSI/9x0h//cdIf/3HOH/9tzhv/bc4b/23KG/9tyhf/bcYX/2nGF/9pxhP/acIT/2nCEhQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIwgNEGMIDT/jCA0/4wgNP+MIDT/mzFE/6A3Sv+gN0r/oDdK/6A3Sv+lPVD/z2h7/955jP/eeIv/3niL/954i//ed4r/3XeK/912iv/ddon/3XaJ/911if/cdYj/3HWI/9x0iP/cdIf/3HOH/9tzh//bc4b/23KG/9tyhv/bcoX/23GF/9pxha8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMIDQAjCA0yowgNP+MIDT/jCA0/581SP+gN0r/oDdK/6A3Sv+gN0r/oDdK/6E4S//DW27/33mM/995jP/eeIz/3niL/954i//ed4v/3neK/913iv/ddor/3XaJ/912if/ddYj/3HWI/9x0iP/cdIf/3HSH/9xzh//bc4b/23OG/9tyhv/bcoXaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIwgNFSMIDT/jCA0/48jN/+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/7VOYf/cd4r/33mM/995jP/eeYz/3niL/954i//eeIv/3neK/913iv/ddor/3XaJ/912if/ddYn/3HWI/9x1iP/cdIj/3HSH/9xzh//eeIv/6IqcpgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMIDQDjCA024wgNP+SJzv/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/q0JV/9Zwg//feo3/33qN/995jP/feYz/3niM/954i//eeIv/3neL/953iv/dd4r/3XaK/912if/ddon/3XWI/912if/niJr/852t4/SfrxEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIwgNGiMIDT/liw//6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+kO07/zGZ5/996jf/feo3/33qN/995jP/feYz/3niM/954i//eeIv/3neL/953iv/dd4r/3XaK/+OAk//wmKn/9J+v/vSfr0QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMIDQIjCA06JowRP+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+/WGv/33qN/996jf/feo3/33qN/995jP/feYz/3nmM/954i//eeIv/4HuO/+yQov/0n6//9J+v//Sfr5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIwgNHueNUj/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/7JLXv/cd4r/4HuO/+B7jv/feo3/33qN/996jf/feo3/54ia//Ocrf/0n6//9J+v//Sfr9X0n68IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACRJjkQoDdKtaA3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/qUBT/9Rvgv/gfI7/4HuO/+B7jv/jgpT/8Jeo//Sfr//0n6//9J+v//Sfr/n0n68xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgN0pDoDdKzqA3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+jOk3/yWR2/+F+kf/skKH/9J+v//Sfr//0n6//9J+v//Sfr//0n695AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKA3SgKgN0pdoDdK4aA3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv/ghZb/9J+v//Sfr//0n6//9J+v//Sfr//0n6/D9J+vAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKA3SgmgN0p4oDdK8KA3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/2HyN//Sfr//0n6//9J+v//Sfr//0n6/y9J+vIQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKA3ShWgN0qToDdK+qA3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/9F0hf/0n6//9J+v//Sfr//0n6//9J+vYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKA3SiagN0quoDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/oDdK/6A3Sv/Ka33/9J+v//Sfr//0n6//9J+vr/SfrwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKA3SjygN0rIoDdK/6A3Sv+gN0r/oDdK/6A3Sv+gN0r/w2J0//Sfr//0n6//9J+v5/SfrxUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoDdKAaA3SlagN0rdoDdK/6A3Sv+gN0r/oDdK/7xabP/0n6//9J+v//Sfr0sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoDdKBqA3SnKgN0rtoDdK/6A3Sv+1UWT/9J+v//Sfr5cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoDdKEaA3SoygN0r4r0lc//Sfr9r0n68LAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoDdKIatEV6b0n683AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP///////////////////////////B/////////gH////////wAP///////4AA///////+AAB///////AAAH//////8AAAf//////gAAB//////+AAAD//////4AAAP//////AAAA//////8AAAD//////gAAAP/////+AAAA//////wAAAB//////AAAAH/////8AAAAf/////gAAAB/////+AAAAH/////wAAAAf/////AAAAA/////4AAAAD/////gAAAAP////8AAAAA/////wAAAAD/////AAAAAP////4AAAAAf////gAAAAB////8AAAAAH////wAAAAAf///+AAAAAB////4AAAAAH////gAAAAAP///+AAAAAA////4AAAAAD////wAAAAAP////AAAAAA////+AAAAAD////4AAAAAH////wAAAAAf////AAAAAB////+AAAAAH////4AAAAAf////gAAAAB/////AAAAAH////8AAAAAf////4AAAAD/////gAAAAf/////AAAAB/////8AAAAP/////8AAAB//////4AAAH//////4AAA///////4AAH///////4AAf///////4AD////////wAf////////wD/////////wP/////////x/////////////////////////KAAAADAAAABgAAAAAQAgAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoDdKB6I4S0jATmMnAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoDdKAqA3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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKA3ShygN0qeqkRW+vSfr5UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAq0RXL/SfrwsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP///////wAA////+P//AAD////Af/8AAP///gB//wAA///wAH//AAD//8AAP/8AAP//wAA//wAA//+AAD//AAD//4AAH/8AAP//AAAf/wAA//8AAB//AAD//gAAH/8AAP/+AAAf/wAA//4AAB//AAD//AAAD/8AAP/8AAAP/wAA//gAAA//AAD/+AAAD/8AAP/wAAAP/wAA//AAAA//AAD/8AAAD/8AAP/gAAAH/wAA/+AAAAf/AAD/wAAAB/8AAP/AAAAH/wAA/4AAAAf/AAD/gAAAA/8AAP/AAAAD/wAA/8AAAAP/AAD/4AAAA/8AAP/gAAAD/wAA//AAAAP/AAD/8AAAAf8AAP/4AAAB/wAA//gAAAH/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"
            }
        },
        {
            "timestamp": 1608872462005,
            "collection": "pages",
            "objectPk": "publish.obsidian.md/help/Advanced+topics/YAML+front+matter",
            "operation": "create",
            "object": {
                "url": "publish.obsidian.md/help/Advanced+topics/YAML+front+matter",
                "fullUrl": "https://publish.obsidian.md/help/Advanced+topics/YAML+front+matter",
                "domain": "obsidian.md",
                "hostname": "publish.obsidian.md",
                "fullTitle": "YAML front matter - Obsidian Help - Obsidian Publish",
                "text": " Obsidian Help Advanced topics Contributing to Obsidian Deleting files How Obsidian stores data HTML sanitization Insider builds Third-party plugins Using obsidian URI YAML front matter Attachments Slides demo Customization How to Licenses & add-on services Panes Plugins Accepted file formats Credits Index Obsidian Start here Obsidian Help YAML front matter YAML front matter aliases : front matter Metadata Aliases front matter YAML front matter is how file-level metadata lives in Obsidian. Front matter is essentially a section of plain text attributes placed at the very top of the file. Front matter was popularized by static generators like Jekyll, Hugo, and Gatsby. It's one of the most popular ways to put metadata in a Markdown file. Front matter is a YAML block with triple dashes both before and after. It also needs to be placed at the very top of the file. For example: --- key: value key2: value2 multiple: [one, two, three] multiple: - one - two - three --- As of 0.9.17, alias uses front matter. We'll gradually make it more accessible by plugin developers and more user friendly. Links to this page Add aliases to note Powered by Obsidian Publish Interactive graph Table of contents Annotate ",
                "urlTerms": [
                    "advanced",
                    "topics",
                    "yaml",
                    "front",
                    "matter"
                ],
                "titleTerms": [
                    "yaml",
                    "front",
                    "matter",
                    "obsidian",
                    "publish"
                ]
            }
        },
        {
            "timestamp": 1608872462019,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "publish.obsidian.md/help/Advanced+topics/YAML+front+matter"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "publish.obsidian.md/help/Advanced+topics/YAML+front+matter",
                "fullUrl": "https://publish.obsidian.md/help/Advanced+topics/YAML+front+matter",
                "createdAt": "2020-12-25T05:01:02.010Z"
            }
        },
        {
            "timestamp": 1608872462027,
            "collection": "visits",
            "objectPk": [
                1608872462024,
                "publish.obsidian.md/help/Advanced+topics/YAML+front+matter"
            ],
            "operation": "create",
            "object": {
                "url": "publish.obsidian.md/help/Advanced+topics/YAML+front+matter",
                "time": 1608872462024
            }
        },
        {
            "timestamp": 1608872462036,
            "collection": "annotations",
            "objectPk": "https://publish.obsidian.md/help/Advanced+topics/YAML+front+matter/#1608872461882",
            "operation": "create",
            "object": {
                "pageTitle": "YAML front matter - Obsidian Help - Obsidian Publish",
                "pageUrl": "publish.obsidian.md/help/Advanced+topics/YAML+front+matter",
                "body": "Front matter is essentially a section of plain text attributes placed at the very top of the file.",
                "comment": "#YAML #editing",
                "selector": {
                    "quote": "Front matter is essentially a section of plain text attributes placed at the very top of the file.",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[1]/div[2]/div[2]/div[2]/div[1]/div[1]/div[2]/div[1]/div[5]/p[1]",
                                "startOffset": 0,
                                "endContainer": "/div[1]/div[2]/div[2]/div[2]/div[1]/div[1]/div[2]/div[1]/div[5]/p[1]",
                                "endOffset": 98
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 590,
                                "end": 688
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Front matter is essentially a section of plain text attributes placed at the very top of the file.",
                                "prefix": "evel metadata lives in Obsidian.",
                                "suffix": " Front matter was popularized by"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-25T05:01:01.882Z",
                "lastEdited": "2020-12-25T05:04:28.635Z",
                "url": "https://publish.obsidian.md/help/Advanced+topics/YAML+front+matter/#1608872461882"
            }
        },
        {
            "timestamp": 1608872668646,
            "collection": "annotations",
            "objectPk": "https://publish.obsidian.md/help/Advanced+topics/YAML+front+matter/#1608872461882",
            "operation": "update",
            "object": {
                "pageTitle": "YAML front matter - Obsidian Help - Obsidian Publish",
                "pageUrl": "publish.obsidian.md/help/Advanced+topics/YAML+front+matter",
                "body": "Front matter is essentially a section of plain text attributes placed at the very top of the file.",
                "comment": "#YAML #editing",
                "selector": {
                    "quote": "Front matter is essentially a section of plain text attributes placed at the very top of the file.",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[1]/div[2]/div[2]/div[2]/div[1]/div[1]/div[2]/div[1]/div[5]/p[1]",
                                "startOffset": 0,
                                "endContainer": "/div[1]/div[2]/div[2]/div[2]/div[1]/div[1]/div[2]/div[1]/div[5]/p[1]",
                                "endOffset": 98
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 590,
                                "end": 688
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Front matter is essentially a section of plain text attributes placed at the very top of the file.",
                                "prefix": "evel metadata lives in Obsidian.",
                                "suffix": " Front matter was popularized by"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-25T05:01:01.882Z",
                "lastEdited": "2020-12-25T05:04:28.635Z",
                "url": "https://publish.obsidian.md/help/Advanced+topics/YAML+front+matter/#1608872461882"
            }
        },
        {
            "timestamp": 1608872734848,
            "collection": "annotations",
            "objectPk": "https://publish.obsidian.md/help/Advanced+topics/YAML+front+matter/#1608872734823",
            "operation": "create",
            "object": {
                "pageTitle": "YAML front matter - Obsidian Help - Obsidian Publish",
                "pageUrl": "publish.obsidian.md/help/Advanced+topics/YAML+front+matter",
                "body": "Front matter is a YAML block with triple dashes both before and after. It also needs to be placed at the very top of the file.",
                "comment": "#YAML #editing",
                "selector": {
                    "quote": "Front matter is a YAML block with triple dashes both before and after. It also needs to be placed at the very top of the file.",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[1]/div[2]/div[2]/div[2]/div[1]/div[1]/div[2]/div[1]/div[6]/p[1]",
                                "startOffset": 0,
                                "endContainer": "/div[1]/div[2]/div[2]/div[2]/div[1]/div[1]/div[2]/div[1]/div[6]/p[1]/mark[1]",
                                "endOffset": 55
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 839,
                                "end": 965
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Front matter is a YAML block with triple dashes both before and after. It also needs to be placed at the very top of the file.",
                                "prefix": "put metadata in a Markdown file.",
                                "suffix": "For example:---\nkey: value\nkey2:"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-25T05:05:34.823Z",
                "lastEdited": "2020-12-25T05:06:33.594Z",
                "url": "https://publish.obsidian.md/help/Advanced+topics/YAML+front+matter/#1608872734823"
            }
        },
        {
            "timestamp": 1608872793606,
            "collection": "annotations",
            "objectPk": "https://publish.obsidian.md/help/Advanced+topics/YAML+front+matter/#1608872734823",
            "operation": "update",
            "object": {
                "pageTitle": "YAML front matter - Obsidian Help - Obsidian Publish",
                "pageUrl": "publish.obsidian.md/help/Advanced+topics/YAML+front+matter",
                "body": "Front matter is a YAML block with triple dashes both before and after. It also needs to be placed at the very top of the file.",
                "comment": "#YAML #editing",
                "selector": {
                    "quote": "Front matter is a YAML block with triple dashes both before and after. It also needs to be placed at the very top of the file.",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[1]/div[2]/div[2]/div[2]/div[1]/div[1]/div[2]/div[1]/div[6]/p[1]",
                                "startOffset": 0,
                                "endContainer": "/div[1]/div[2]/div[2]/div[2]/div[1]/div[1]/div[2]/div[1]/div[6]/p[1]/mark[1]",
                                "endOffset": 55
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 839,
                                "end": 965
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Front matter is a YAML block with triple dashes both before and after. It also needs to be placed at the very top of the file.",
                                "prefix": "put metadata in a Markdown file.",
                                "suffix": "For example:---\nkey: value\nkey2:"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-25T05:05:34.823Z",
                "lastEdited": "2020-12-25T05:06:33.594Z",
                "url": "https://publish.obsidian.md/help/Advanced+topics/YAML+front+matter/#1608872734823"
            }
        },
        {
            "timestamp": 1608912011170,
            "collection": "favIcons",
            "objectPk": "visual-paradigm.com",
            "operation": "create",
            "object": {
                "hostname": "visual-paradigm.com",
                "favIcon": "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAnFBMVEX////////z0NDOPDzzz8/PPDzOOzvzzc3klZXhiYnjkpLiior////00dHOOzvNNDTMNDTOOjr////33d3QRUXNNzfNNzfPQkL22dn////ed3f45ubMNjbijIz////zz8/TT0/QRET////zz8/zz8/z0NDMMzP////yysrxx8fxycn22trtuLjxxcXstbXQQUHhhYXwxMTggoLmnJwy2y1tAAAAJnRSTlMAEtj42Pj42Pr5+vkR1/n9/vkIwfb6+/bCRvbE+/4P1Pn2ENXW17ZQCjgAAAABYktHRACIBR1IAAAACXBIWXMAAAMqAAADKgEQl1gYAAAAB3RJTUUH4gERCg8fRZqdjwAAAI5JREFUGNNVz9kSgjAMQNEUVFzqhgsiylIgdU/V//83aR2gzds9k+k0AP9hDJxhnsfc9v0Bs3uIOAqY3eNJL7qnUs5a4fMFLi9SXle4DngD4WaLuLvd94jRIdQr8UPL84jRKzZvJKQaOb3PH0oMpJmR/EtZCp0UheoaQJSkFJWi/6qoiCphH8Prmrvn8rZ/FTQNvifTdmIAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMTdUMTA6MTU6MzErMDE6MDBEa1RhAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTE3VDEwOjE1OjMxKzAxOjAwNTbs3QAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAABXelRYdFJhdyBwcm9maWxlIHR5cGUgaXB0YwAAeJzj8gwIcVYoKMpPy8xJ5VIAAyMLLmMLEyMTS5MUAxMgRIA0w2QDI7NUIMvY1MjEzMQcxAfLgEigSi4A6hcRdPJCNZUAAAAASUVORK5CYII="
            }
        },
        {
            "timestamp": 1608912011206,
            "collection": "pages",
            "objectPk": "visual-paradigm.com/guide/uml-unified-modeling-language/behavior-vs-structural-diagram",
            "operation": "create",
            "object": {
                "url": "visual-paradigm.com/guide/uml-unified-modeling-language/behavior-vs-structural-diagram",
                "fullUrl": "https://www.visual-paradigm.com/guide/uml-unified-modeling-language/behavior-vs-structural-diagram/",
                "domain": "visual-paradigm.com",
                "hostname": "visual-paradigm.com",
                "fullTitle": "UML - Behavioral Diagram vs Structural Diagram",
                "text": " What's New Features Editions Demo Videos Interactive Product Tours Solutions Tutorials Support Pricing Try Now Request Demo English 简体中文 繁體中文 Home Support Guides Current: UML - Behavioral Diagram vs Structural Diagram UML - Behavioral Diagram vs Structural Diagram UML - Behavioral Diagram vs Structural Diagram Static vs Dynamic View Behavioral Diagrams Structural Diagrams The Unified Modeling Language is a standardized general-purpose modeling language and nowadays is managed as a de facto industry standard by the Object Management Group (OMG) . The creation of UML was originally motivated by the desire to standardize the disparate notational systems and approaches to software design. It was developed by Grady Booch, Ivar Jacobson, and James Rumbaugh at Rational Software in 1994 1995, with further development led by them through 1996. Static vs Dynamic View Static modeling is used to specify the structure of the objects, classes or components that exist in the problem domain. These are expressed using class, object or component. While dynamic modeling refers to representing the object interactions during runtime. It is represented by sequence, activity, collaboration, and state. UML diagrams represent these two aspects of a system: Structural (or Static) view: emphasizes the static structure of the system using objects, attributes, operations and relationships. It includes class diagrams and composite structure diagrams. Behavioral (or Dynamic) view: emphasizes the dynamic behavior of the system by showing collaborations among objects and changes to the internal states of objects. This view includes sequence diagrams, activity diagrams, and state machine diagrams. In UML 2.2 there are 14 types of UML diagrams, which are divided into these two categories: 7 diagram types represent structural information Another 7 represents general UML diagram types for behavioral modeling, including four that represent different aspects of interactions. These diagrams can be categorized hierarchically as shown in the following UML diagram map: Behavioral Diagrams UML’s five behavioral diagrams are used to visualize, specify, construct, and document the dynamic aspects of a system. It shows how the system behaves and interacts with itself and other entities (users, other systems). They show how data moves through the system, how objects communicate with each other, how the passage of time affects the system, or what events cause the system to change internal states. Since behavior diagrams illustrate the behavior of a system, they are used extensively to describe the functionality of software systems. As an example, the activity diagram describes the business and operational step-by-step activities of the components in a system. In other words, a behavioral diagram shows how the system works ‘in motion’, that is how the system interacts with external entities and users, how it responds to input or event and what constraints it operates under. There are seven behavioral diagrams that you can model the dynamics of a system as listed in the Table below: Behavioral Diagram Brief Description Activity Diagram It is a graphical representations of workflows of stepwise activities and actions with support for choice, iteration and concurrency Use Case Diagram It describes a system’s functional requirements in terms of use cases that enable you to relate what you need from a system to how the system delivers on those needs. State Machine Diagram It shows the discrete behavior of a part of a designed system through finite state transitions. Sequence Diagram It shows the sequence of messages exchanged between the objects needed to carry out the functionality of the scenario. Communication Diagram It shows interactions between objects and/or parts (represented as lifelines) using sequenced messages in a free-form arrangement. Interaction Overview Diagram It depicts a control flow with nodes that can contain other interaction diagrams . Timing Diagram It shows interactions when the primary purpose of the diagram is to reason about time by focusing on conditions changing within and among lifelines along a linear time axis. Structural Diagrams Structure diagrams depict the static structure of the elements in your system. i.e., how one object relates to another. It shows the things in the system classes, objects, packages or modules, physical nodes, components, and interfaces. For example, just as the static aspects of a house encompass the existence and placement of such things as walls, doors, windows, pipes, wires, and vents. The Seven UML structural diagrams are roughly organized around the major groups of things you’ll find when modeling a system. Since structure diagrams represent the structure, they are used extensively in documenting the software architecture of software systems. For example, the component diagram describes how a software system is split up into components and shows the dependencies among these components. Structural Diagram Brief Description Composite Structure Diagram It shows the internal structure of a classifier, classifier interactions with the environment through ports, or behavior of a collaboration. Deployment Diagram It shows a set of nodes and their relationships that illustrates the static deployment view of an architecture. Package Diagram It groups related UML elements into a collection of logically related UML structure. Profile Diagram Class Diagram It shows a set of classes, interfaces, and collaborations and their relationships, typically, found in modeling object-oriented systems. Object Diagram It shows a set of objects and their relationships, which is the static snapshots of instances of the things found in class diagrams. Component Diagram It shows a set of components and their relationships that illustrates the static implementation view of a system. Turn every software project into a successful one. Try Visual Paradigm Free Product Features Editions Try Now Pricing Visual Paradigm Online Support Forums Request Help Customer Service Learn Community Circle Know-how Demo Videos Tutorials Documents About Us Visual Paradigm Newsroom YouTube Channel Academic Partnership We use cookies to offer you a better experience. By visiting our website, you agree to the use of cookies as described in our Cookie Policy . OK @2020 by Visual Paradigm. All rights reserved. Legal Privacy statement ",
                "urlTerms": [
                    "guide",
                    "uml",
                    "unified",
                    "modeling",
                    "language",
                    "behavior",
                    "structural",
                    "diagram"
                ],
                "titleTerms": [
                    "uml",
                    "behavioral",
                    "diagram",
                    "structural"
                ]
            }
        },
        {
            "timestamp": 1608912011233,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "visual-paradigm.com/guide/uml-unified-modeling-language/behavior-vs-structural-diagram"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "visual-paradigm.com/guide/uml-unified-modeling-language/behavior-vs-structural-diagram",
                "fullUrl": "https://www.visual-paradigm.com/guide/uml-unified-modeling-language/behavior-vs-structural-diagram/",
                "createdAt": "2020-12-25T16:00:11.219Z"
            }
        },
        {
            "timestamp": 1608912011243,
            "collection": "visits",
            "objectPk": [
                1608912011239,
                "visual-paradigm.com/guide/uml-unified-modeling-language/behavior-vs-structural-diagram"
            ],
            "operation": "create",
            "object": {
                "url": "visual-paradigm.com/guide/uml-unified-modeling-language/behavior-vs-structural-diagram",
                "time": 1608912011239
            }
        },
        {
            "timestamp": 1608912011250,
            "collection": "annotations",
            "objectPk": "https://www.visual-paradigm.com/guide/uml-unified-modeling-language/behavior-vs-structural-diagram//#1608912011059",
            "operation": "create",
            "object": {
                "pageTitle": "UML - Behavioral Diagram vs Structural Diagram",
                "pageUrl": "visual-paradigm.com/guide/uml-unified-modeling-language/behavior-vs-structural-diagram",
                "body": "Static vs Dynamic View\r\n\r\nStatic modeling is used to specify the structure of the objects, classes or components that exist in the problem domain. These are expressed using class, object or component. While dynamic modeling refers to representing the object interactions during runtime. It is represented by sequence, activity, collaboration, and state. UML diagrams represent these two aspects of a system:\r\n\r\n    Structural (or Static) view: emphasizes the static structure of the system using objects, attributes, operations and relationships. It includes class diagrams and composite structure diagrams.\r\n    Behavioral (or Dynamic) view: emphasizes the dynamic behavior of the system by showing collaborations among objects and changes to the internal states of objects. This view includes sequence diagrams, activity diagrams, and state machine diagrams.",
                "comment": "#ULM #Diagram",
                "selector": {
                    "quote": "Static vs Dynamic View\r\n\r\nStatic modeling is used to specify the structure of the objects, classes or components that exist in the problem domain. These are expressed using class, object or component. While dynamic modeling refers to representing the object interactions during runtime. It is represented by sequence, activity, collaboration, and state. UML diagrams represent these two aspects of a system:\r\n\r\n    Structural (or Static) view: emphasizes the static structure of the system using objects, attributes, operations and relationships. It includes class diagrams and composite structure diagrams.\r\n    Behavioral (or Dynamic) view: emphasizes the dynamic behavior of the system by showing collaborations among objects and changes to the internal states of objects. This view includes sequence diagrams, activity diagrams, and state machine diagrams.",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[1]/div[2]/div[1]/h2[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[1]/div[2]/div[1]/ul[1]/li[2]",
                                "endOffset": 247
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 2135,
                                "end": 2981
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Static vs Dynamic View\nStatic modeling is used to specify the structure of the objects, classes or components that exist in the problem domain. These are expressed using class, object or component. While dynamic modeling refers to representing the object interactions during runtime. It is represented by sequence, activity, collaboration, and state. UML diagrams represent these two aspects of a system:\n\nStructural (or Static) view: emphasizes the static structure of the system using objects, attributes, operations and relationships. It includes class diagrams and composite structure diagrams.\nBehavioral (or Dynamic) view: emphasizes the dynamic behavior of the system by showing collaborations among objects and changes to the internal states of objects. This view includes sequence diagrams, activity diagrams, and state machine diagrams.",
                                "prefix": "pment led by them through 1996.\n",
                                "suffix": "\n\nIn UML 2.2 there are 14 types "
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-25T16:00:11.059Z",
                "lastEdited": "2020-12-26T02:42:21.937Z",
                "url": "https://www.visual-paradigm.com/guide/uml-unified-modeling-language/behavior-vs-structural-diagram//#1608912011059"
            }
        },
        {
            "timestamp": 1608937338628,
            "collection": "pages",
            "objectPk": "mermaid-js.github.io/mermaid",
            "operation": "create",
            "object": {
                "url": "mermaid-js.github.io/mermaid",
                "fullUrl": "https://mermaid-js.github.io/mermaid/#/gantt?id=styling",
                "domain": "github.io",
                "hostname": "mermaid-js.github.io",
                "fullTitle": "mermaid - Markdownish syntax for generating flowcharts, sequence diagrams, class diagrams, gantt charts and git graphs.",
                "text": " ",
                "urlTerms": [
                    "mermaid"
                ],
                "titleTerms": [
                    "mermaid",
                    "markdownish",
                    "syntax",
                    "generating",
                    "flowcharts",
                    "sequence",
                    "diagrams",
                    "class",
                    "gantt",
                    "charts",
                    "git",
                    "graphs"
                ]
            }
        },
        {
            "timestamp": 1608937338641,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "mermaid-js.github.io/mermaid"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "mermaid-js.github.io/mermaid",
                "fullUrl": "https://mermaid-js.github.io/mermaid/#/gantt?id=styling",
                "createdAt": "2020-12-25T23:02:18.634Z"
            }
        },
        {
            "timestamp": 1608937338648,
            "collection": "visits",
            "objectPk": [
                1608937338646,
                "mermaid-js.github.io/mermaid"
            ],
            "operation": "create",
            "object": {
                "url": "mermaid-js.github.io/mermaid",
                "time": 1608937338646
            }
        },
        {
            "timestamp": 1608937338653,
            "collection": "annotations",
            "objectPk": "https://mermaid-js.github.io/mermaid/#/gantt?id=styling/#1608937338349",
            "operation": "create",
            "object": {
                "pageTitle": "Gantt",
                "pageUrl": "mermaid-js.github.io/mermaid",
                "body": "gantt\r\n    title A Gantt Diagram\r\n    %% this is a comment\r\n    dateFormat  YYYY-MM-DD\r\n    section Section\r\n    A task           :a1, 2014-01-01, 30d\r\n    Another task     :after a1  , 20d\r\n    section Another\r\n    Task in sec      :2014-01-12  , 12d\r\n    another task      : 24d",
                "comment": "",
                "selector": {
                    "quote": "gantt\r\n    title A Gantt Diagram\r\n    %% this is a comment\r\n    dateFormat  YYYY-MM-DD\r\n    section Section\r\n    A task           :a1, 2014-01-01, 30d\r\n    Another task     :after a1  , 20d\r\n    section Another\r\n    Task in sec      :2014-01-12  , 12d\r\n    another task      : 24d",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/main[1]/section[1]/article[1]/pre[9]/code[1]",
                                "startOffset": 0,
                                "endContainer": "/main[1]/section[1]/article[1]/pre[9]/code[1]",
                                "endOffset": 271
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 17747,
                                "end": 18018
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "gantt\n    title A Gantt Diagram\n    %% this is a comment\n    dateFormat  YYYY-MM-DD\n    section Section\n    A task           :a1, 2014-01-01, 30d\n    Another task     :after a1  , 20d\n    section Another\n    Task in sec      :2014-01-12  , 12d\n    another task      : 24d",
                                "prefix": "nt, including any diagram syntax",
                                "suffix": "\nStylingStyling of the a gantt d"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-25T23:02:18.349Z",
                "lastEdited": "2020-12-25T23:02:18.349Z",
                "url": "https://mermaid-js.github.io/mermaid/#/gantt?id=styling/#1608937338349"
            }
        },
        {
            "timestamp": 1608950398997,
            "collection": "favIcons",
            "objectPk": "docs.zettlr.com",
            "operation": "create",
            "object": {
                "hostname": "docs.zettlr.com",
                "favIcon": "AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAABMLAAATCwAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wAAAAA0AAAAzgAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADlAAAASv///wD///8A////AP///wD///8AAAAAzQAAACb///8A////AP///wD///8A////AP///wD///8AAAAALQAAANv///8A////AP///wD///8A////AAAAAOcAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA3AAAACIAAAC3AAAAMv///wD///8A////AP///wAAAAC/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAACQAAAAagAAAID///8A////AP///wD///8AAAAATQAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA4QAAAB0AAADN////AP///wD///8A////AAAAAAQAAAD3AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAAvAAAAzQAAABz///8A////AP///wD///8AAAAAjAAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAfAAAAIAAAABp////AP///wD///8A////AAAAAEEAAAD/AAAA8gAAAAv///8A////AP///wAAAAAFAAAA3QAAAMoAAAAzAAAAt////wD///8A////AP///wAAAAAGAAAA0wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD+AAAAGQAAAMn///8A////AP///wD///8A////AAAAAG8AAAD/AAAAo////wD///8A////AP///wAAAAA9AAAA/wAAAGQAAAA5////AP///wD///8A////AP///wAAAAAtAAAA/AAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAACm////AP///wD///8A////AP///wD///8A////AAAAAJcAAAD4AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD5AAAAbP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AACADwAAn88AAIAHAACABwAAgAcAAIADAADAAwAAw4MAAMADAADjwwAA4AcAAPAHAAD//wAA//8AAA=="
            }
        },
        {
            "timestamp": 1608950399032,
            "collection": "pages",
            "objectPk": "docs.zettlr.com/en/guides/guide-ide",
            "operation": "create",
            "object": {
                "url": "docs.zettlr.com/en/guides/guide-ide",
                "fullUrl": "https://docs.zettlr.com/en/guides/guide-ide/",
                "domain": "zettlr.com",
                "hostname": "docs.zettlr.com",
                "fullTitle": "Zettlr as an IDE - Zettlr Docs",
                "text": " Zettlr Docs Welcome First Steps Setup Installing Pandoc Installing LaTeX Getting Started Get involved FAQ Concepts File management Context WYSIWYM Guides Zettlr as a note taking app Zettlr as a Zettelkasten Zettlr as an IDE Step 1: Adjust the Settings Step 2: Write! Core The Editor Document Tabs The File List AutoCorrect and MagicQuotes Searching Importing Exporting Table Editor Custom CSS Localisation Sidebar YAML Frontmatter Print and Preview Math Academic Tools Citations Projects Presentations Pomodoro Timer Readability Zettelkasten Methods Custom Templates References Keyboard Shortcuts Markdown Basics Settings Spell Checking Zettlr Docs Docs » Guides » Zettlr as an IDE Edit on GitHub Next Previous Guide: Zettlr as an Integrated Development Environment (IDE) ¶ Zettlr is full with functions that help your workflow. You can use it as a small note-taking app, as a Zettelkasten, or, as explained in this guide, as a fully loaded integrated development (read: writing) environment. So let's get started! Using this guide, you can set up Zettlr to be a replacement for apps such as Ulysses, Atom, or Sublime Text. Step 1: Adjust the Settings ¶ The first step is to adjust some of the parameters of Zettlr. So hit Cmd/Ctrl+, or press the cog in the toolbar to open the settings dialog. Adjust the following settings: General Tab File Information: On Sidebar mode: Expanded Spellchecking Tab Select all dictionaries for languages in which you will write (e.g., en-UK, de-DE, and fr-FR) Export Tab Select the Current Working Directory as the export directory Remove internal links completely Zettelkasten Tab Adjust the settings according to the Zettelkasten Guide Advanced Tab Enter all file extensions of the files you are likely to be using. This way all of these files will show up in the attachment bar to the right of the app After you are finished setting Zettlr up, hit \"Save\". Now Zettlr should look like a real IDE with three segments (directory tree, file list, and editor) and all settings active. Step 2: Write! ¶ This guide is rather short, because it only shows you how you can set up Zettlr to create a fully loaded IDE. What you are then doing with it is completely up to you. A good point to start is to read the two guides on Zettelkasten and note-taking, because you will likely be using some concepts from these guides. Here are some resources that may be interesting for you: Guide: Zettlr as Zettelkasten Guide: Zettlr as Note-Taking App Zettlr Projects Create Presentations with Zettlr Markdown for Zettlr Exporting to PDF Next Previous © 2017-2020 by Zettlr Built with MkDocs using a theme provided by Read the Docs . GitHub « Previous Next » ",
                "urlTerms": [
                    "en",
                    "guides",
                    "guide",
                    "ide"
                ],
                "titleTerms": [
                    "zettlr",
                    "ide",
                    "docs"
                ]
            }
        },
        {
            "timestamp": 1608950399098,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "docs.zettlr.com/en/guides/guide-ide"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "docs.zettlr.com/en/guides/guide-ide",
                "fullUrl": "https://docs.zettlr.com/en/guides/guide-ide/",
                "createdAt": "2020-12-26T02:39:59.042Z"
            }
        },
        {
            "timestamp": 1608950399133,
            "collection": "visits",
            "objectPk": [
                1608950399126,
                "docs.zettlr.com/en/guides/guide-ide"
            ],
            "operation": "create",
            "object": {
                "url": "docs.zettlr.com/en/guides/guide-ide",
                "time": 1608950399126
            }
        },
        {
            "timestamp": 1608950399148,
            "collection": "bookmarks",
            "objectPk": "docs.zettlr.com/en/guides/guide-ide",
            "operation": "create",
            "object": {
                "url": "docs.zettlr.com/en/guides/guide-ide",
                "time": 1608950399144
            }
        },
        {
            "timestamp": 1608950452659,
            "collection": "annotations",
            "objectPk": "https://www.visual-paradigm.com/guide/uml-unified-modeling-language/behavior-vs-structural-diagram//#1608950452632",
            "operation": "create",
            "object": {
                "pageTitle": "UML - Behavioral Diagram vs Structural Diagram",
                "pageUrl": "visual-paradigm.com/guide/uml-unified-modeling-language/behavior-vs-structural-diagram",
                "body": "In UML 2.2 there are 14 types of UML diagrams, which are divided into these two categories:\r\n\r\n    7 diagram types represent structural information\r\n    Another 7 represents general UML diagram types for behavioral modeling, including four that represent different aspects of interactions.",
                "comment": "#ULM #Diagram",
                "selector": {
                    "quote": "In UML 2.2 there are 14 types of UML diagrams, which are divided into these two categories:\r\n\r\n    7 diagram types represent structural information\r\n    Another 7 represents general UML diagram types for behavioral modeling, including four that represent different aspects of interactions.",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[1]/div[2]/div[1]/p[3]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[1]/div[2]/div[1]/ul[2]/li[2]",
                                "endOffset": 136
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 2983,
                                "end": 3261
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "In UML 2.2 there are 14 types of UML diagrams, which are divided into these two categories:\n\n7 diagram types represent structural information\nAnother 7 represents general UML diagram types for behavioral modeling, including four that represent different aspects of interactions.",
                                "prefix": "s, and state machine diagrams.\n\n",
                                "suffix": "\n\nThese diagrams can be categori"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T02:40:52.632Z",
                "lastEdited": "2020-12-26T02:42:53.252Z",
                "url": "https://www.visual-paradigm.com/guide/uml-unified-modeling-language/behavior-vs-structural-diagram//#1608950452632"
            }
        },
        {
            "timestamp": 1608950541953,
            "collection": "annotations",
            "objectPk": "https://www.visual-paradigm.com/guide/uml-unified-modeling-language/behavior-vs-structural-diagram//#1608912011059",
            "operation": "update",
            "object": {
                "pageTitle": "UML - Behavioral Diagram vs Structural Diagram",
                "pageUrl": "visual-paradigm.com/guide/uml-unified-modeling-language/behavior-vs-structural-diagram",
                "body": "Static vs Dynamic View\r\n\r\nStatic modeling is used to specify the structure of the objects, classes or components that exist in the problem domain. These are expressed using class, object or component. While dynamic modeling refers to representing the object interactions during runtime. It is represented by sequence, activity, collaboration, and state. UML diagrams represent these two aspects of a system:\r\n\r\n    Structural (or Static) view: emphasizes the static structure of the system using objects, attributes, operations and relationships. It includes class diagrams and composite structure diagrams.\r\n    Behavioral (or Dynamic) view: emphasizes the dynamic behavior of the system by showing collaborations among objects and changes to the internal states of objects. This view includes sequence diagrams, activity diagrams, and state machine diagrams.",
                "comment": "#ULM #Diagram",
                "selector": {
                    "quote": "Static vs Dynamic View\r\n\r\nStatic modeling is used to specify the structure of the objects, classes or components that exist in the problem domain. These are expressed using class, object or component. While dynamic modeling refers to representing the object interactions during runtime. It is represented by sequence, activity, collaboration, and state. UML diagrams represent these two aspects of a system:\r\n\r\n    Structural (or Static) view: emphasizes the static structure of the system using objects, attributes, operations and relationships. It includes class diagrams and composite structure diagrams.\r\n    Behavioral (or Dynamic) view: emphasizes the dynamic behavior of the system by showing collaborations among objects and changes to the internal states of objects. This view includes sequence diagrams, activity diagrams, and state machine diagrams.",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[1]/div[2]/div[1]/h2[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[1]/div[2]/div[1]/ul[1]/li[2]",
                                "endOffset": 247
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 2135,
                                "end": 2981
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Static vs Dynamic View\nStatic modeling is used to specify the structure of the objects, classes or components that exist in the problem domain. These are expressed using class, object or component. While dynamic modeling refers to representing the object interactions during runtime. It is represented by sequence, activity, collaboration, and state. UML diagrams represent these two aspects of a system:\n\nStructural (or Static) view: emphasizes the static structure of the system using objects, attributes, operations and relationships. It includes class diagrams and composite structure diagrams.\nBehavioral (or Dynamic) view: emphasizes the dynamic behavior of the system by showing collaborations among objects and changes to the internal states of objects. This view includes sequence diagrams, activity diagrams, and state machine diagrams.",
                                "prefix": "pment led by them through 1996.\n",
                                "suffix": "\n\nIn UML 2.2 there are 14 types "
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-25T16:00:11.059Z",
                "lastEdited": "2020-12-26T02:42:21.937Z",
                "url": "https://www.visual-paradigm.com/guide/uml-unified-modeling-language/behavior-vs-structural-diagram//#1608912011059"
            }
        },
        {
            "timestamp": 1608950573263,
            "collection": "annotations",
            "objectPk": "https://www.visual-paradigm.com/guide/uml-unified-modeling-language/behavior-vs-structural-diagram//#1608950452632",
            "operation": "update",
            "object": {
                "pageTitle": "UML - Behavioral Diagram vs Structural Diagram",
                "pageUrl": "visual-paradigm.com/guide/uml-unified-modeling-language/behavior-vs-structural-diagram",
                "body": "In UML 2.2 there are 14 types of UML diagrams, which are divided into these two categories:\r\n\r\n    7 diagram types represent structural information\r\n    Another 7 represents general UML diagram types for behavioral modeling, including four that represent different aspects of interactions.",
                "comment": "#ULM #Diagram",
                "selector": {
                    "quote": "In UML 2.2 there are 14 types of UML diagrams, which are divided into these two categories:\r\n\r\n    7 diagram types represent structural information\r\n    Another 7 represents general UML diagram types for behavioral modeling, including four that represent different aspects of interactions.",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[1]/div[2]/div[1]/p[3]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[1]/div[2]/div[1]/ul[2]/li[2]",
                                "endOffset": 136
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 2983,
                                "end": 3261
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "In UML 2.2 there are 14 types of UML diagrams, which are divided into these two categories:\n\n7 diagram types represent structural information\nAnother 7 represents general UML diagram types for behavioral modeling, including four that represent different aspects of interactions.",
                                "prefix": "s, and state machine diagrams.\n\n",
                                "suffix": "\n\nThese diagrams can be categori"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T02:40:52.632Z",
                "lastEdited": "2020-12-26T02:42:53.252Z",
                "url": "https://www.visual-paradigm.com/guide/uml-unified-modeling-language/behavior-vs-structural-diagram//#1608950452632"
            }
        },
        {
            "timestamp": 1608950922970,
            "collection": "pages",
            "objectPk": "en.wikipedia.org/wiki/Profiling_(computer_programming)",
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Profiling_(computer_programming)",
                "fullUrl": "https://en.wikipedia.org/wiki/Profiling_(computer_programming)",
                "domain": "wikipedia.org",
                "hostname": "en.wikipedia.org",
                "fullTitle": "Profiling (computer programming) - Wikipedia",
                "text": " Profiling (computer programming) From Wikipedia, the free encyclopedia Jump to navigation Jump to search This article needs additional citations for verification . Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed. Find sources: \"Profiling\" computer programming news · newspapers · books · scholar · JSTOR ( January 2009) ( Learn how and when to remove this template message ) Program execution General concepts Code Translation Compiler Compile-time Optimizing compiler Intermediate representation (IR) Execution Runtime system Runtime Executable Interpreter Virtual machine Types of code Source code Object code Bytecode Machine code Microcode Compilation strategies Just-in-time (JIT) Tracing just-in-time Ahead-of-time (AOT) Transcompilation Recompilation Notable runtimes Android Runtime (ART) Common Language Runtime (CLR) & Mono crt0 HHVM Java virtual machine (JVM) Objective-C V8 Node.js PyPy Zend Engine Notable compilers & toolchains GNU Compiler Collection (GCC) LLVM Clang v t e In software engineering , profiling (\"program profiling\", \"software profiling\") is a form of dynamic program analysis that measures, for example, the space (memory) or time complexity of a program , the usage of particular instructions , or the frequency and duration of function calls. Most commonly, profiling information serves to aid program optimization . Profiling is achieved by instrumenting either the program source code or its binary executable form using a tool called a profiler (or code profiler). Profilers may use a number of different techniques, such as event-based, statistical, instrumented, and simulation methods. Contents 1 Gathering program events 2 Use of profilers 3 History 4 Profiler types based on output 4.1 Flat profiler 4.2 Call-graph profiler 4.3 Input-sensitive profiler 5 Data granularity in profiler types 5.1 Event-based profilers 5.2 Statistical profilers 5.3 Instrumentation 5.4 Interpreter instrumentation 5.5 Hypervisor/Simulator 6 See also 7 References 8 External links Gathering program events [ edit ] Profilers use a wide variety of techniques to collect data, including hardware interrupts , code instrumentation , instruction set simulation , operating system hooks , and performance counters . Profilers are used in the performance engineering process. Use of profilers [ edit ] Graphical output of the CodeAnalyst profiler. Program analysis tools are extremely important for understanding program behavior. Computer architects need such tools to evaluate how well programs will perform on new architectures . Software writers need tools to analyze their programs and identify critical sections of code. Compiler writers often use such tools to find out how well their instruction scheduling or branch prediction algorithm is performing... ATOM, PLDI , '94 The output of a profiler may be: A statistical summary of the events observed (a profile) Summary profile information is often shown annotated against the source code statements where the events occur, so the size of measurement data is linear to the code size of the program. /* ------------ source------------------------- count */ 0001 IF X = \"A\" 0055 0002 THEN DO 0003 ADD 1 to XCOUNT 0032 0004 ELSE 0005 IF X = \"B\" 0055 A stream of recorded events (a trace) For sequential programs, a summary profile is usually sufficient, but performance problems in parallel programs (waiting for messages or synchronization issues) often depend on the time relationship of events, thus requiring a full trace to get an understanding of what is happening. The size of a (full) trace is linear to the program's instruction path length , making it somewhat impractical. A trace may therefore be initiated at one point in a program and terminated at another point to limit the output. An ongoing interaction with the hypervisor (continuous or periodic monitoring via on-screen display for instance) This provides the opportunity to switch a trace on or off at any desired point during execution in addition to viewing on-going metrics about the (still executing) program. It also provides the opportunity to suspend asynchronous processes at critical points to examine interactions with other parallel processes in more detail. A profiler can be applied to an individual method or at the scale of a module or program, to identify performance bottlenecks by making long-running code obvious. [1] A profiler can be used to understand code from a timing point of view, with the objective of optimizing it to handle various runtime conditions [2] or various loads. [3] Profiling results can be ingested by a compiler that provides profile-guided optimization . [4] Profiling results can be used to guide the design and optimization of an individual algorithm; the Krauss matching wildcards algorithm is an example. [5] Profilers are built into some application performance management systems that aggregate profiling data to provide insight into transaction workloads in distributed applications. [6] History [ edit ] Performance-analysis tools existed on IBM/360 and IBM/370 platforms from the early 1970s, usually based on timer interrupts which recorded the program status word (PSW) at set timer-intervals to detect \"hot spots\" in executing code.[ citation needed ] This was an early example of sampling (see below). In early 1974 instruction-set simulators permitted full trace and other performance-monitoring features.[ citation needed ] Profiler-driven program analysis on Unix dates back to 1973, [7] when Unix systems included a basic tool, prof, which listed each function and how much of program execution time it used. In 1982 gprof extended the concept to a complete call graph analysis. [8] In 1994, Amitabh Srivastava and Alan Eustace of Digital Equipment Corporation published a paper describing ATOM [9] (Analysis Tools with OM). The ATOM platform converts a program into its own profiler: at compile time , it inserts code into the program to be analyzed. That inserted code outputs analysis data. This technique - modifying a program to analyze itself - is known as \" instrumentation \". In 2004 both the gprof and ATOM papers appeared on the list of the 50 most influential PLDI papers for the 20-year period ending in 1999. [10] Profiler types based on output [ edit ] Flat profiler [ edit ] Flat profilers compute the average call times, from the calls, and do not break down the call times based on the callee or the context. Call-graph profiler [ edit ] Call graph profilers [8] show the call times, and frequencies of the functions, and also the call-chains involved based on the callee. In some tools full context is not preserved. Input-sensitive profiler [ edit ] Input-sensitive profilers [11] [12] [13] add a further dimension to flat or call-graph profilers by relating performance measures to features of the input workloads, such as input size or input values. They generate charts that characterize how an application's performance scales as a function of its input. Data granularity in profiler types [ edit ] Profilers, which are also programs themselves, analyze target programs by collecting information on their execution. Based on their data granularity, on how profilers collect information, they are classified into event based or statistical profilers. Profilers interrupt program execution to collect information, which may result in a limited resolution in the time measurements, which should be taken with a grain of salt. Basic block profilers report a number of machine clock cycles devoted to executing each line of code, or a timing based on adding these together; the timings reported per basic block may not reflect a difference between cache hits and misses. [14] [15] Event-based profilers [ edit ] The programming languages listed here have event-based profilers: Java : the JVMTI (JVM Tools Interface) API, formerly JVMPI (JVM Profiling Interface), provides hooks to profilers, for trapping events like calls, class-load, unload, thread enter leave. .NET : Can attach a profiling agent as a COM server to the CLR using Profiling API. Like Java, the runtime then provides various callbacks into the agent, for trapping events like method JIT / enter / leave, object creation, etc. Particularly powerful in that the profiling agent can rewrite the target application's bytecode in arbitrary ways. Python : Python profiling includes the profile module, hotshot (which is call-graph based), and using the 'sys.setprofile' function to trap events like c_{call,return,exception}, python_{call,return,exception}. Ruby : Ruby also uses a similar interface to Python for profiling. Flat-profiler in profile.rb, module, and ruby-prof a C-extension are present. Statistical profilers [ edit ] Some profilers operate by sampling . A sampling profiler probes the target program's call stack at regular intervals using operating system interrupts . Sampling profiles are typically less numerically accurate and specific, but allow the target program to run at near full speed. The resulting data are not exact, but a statistical approximation. \"The actual amount of error is usually more than one sampling period. In fact, if a value is n times the sampling period, the expected error in it is the square-root of n sampling periods.\" [16] In practice, sampling profilers can often provide a more accurate picture of the target program's execution than other approaches, as they are not as intrusive to the target program, and thus don't have as many side effects (such as on memory caches or instruction decoding pipelines). Also since they don't affect the execution speed as much, they can detect issues that would otherwise be hidden. They are also relatively immune to over-evaluating the cost of small, frequently called routines or 'tight' loops. They can show the relative amount of time spent in user mode versus interruptible kernel mode such as system call processing. Still, kernel code to handle the interrupts entails a minor loss of CPU cycles, diverted cache usage, and is unable to distinguish the various tasks occurring in uninterruptible kernel code (microsecond-range activity). Dedicated hardware can go beyond this: ARM Cortex-M3 and some recent MIPS processors JTAG interface have a PCSAMPLE register, which samples the program counter in a truly undetectable manner, allowing non-intrusive collection of a flat profile. Some commonly used [17] statistical profilers for Java/managed code are SmartBear Software 's AQtime [18] and Microsoft 's CLR Profiler . [19] Those profilers also support native code profiling, along with Apple Inc. 's Shark (OSX), [20] OProfile (Linux), [21] Intel VTune and Parallel Amplifier (part of Intel Parallel Studio ), and Oracle Performance Analyzer , [22] among others. Instrumentation [ edit ] This technique effectively adds instructions to the target program to collect the required information. Note that instrumenting a program can cause performance changes, and may in some cases lead to inaccurate results and/or heisenbugs . The effect will depend on what information is being collected, on the level of timing details reported, and on whether basic block profiling is used in conjunction with instrumentation. [23] For example, adding code to count every procedure/routine call will probably have less effect than counting how many times each statement is obeyed. A few computers have special hardware to collect information; in this case the impact on the program is minimal. Instrumentation is key to determining the level of control and amount of time resolution available to the profilers. Manual: Performed by the programmer, e.g. by adding instructions to explicitly calculate runtimes, simply count events or calls to measurement APIs such as the Application Response Measurement standard. Automatic source level: instrumentation added to the source code by an automatic tool according to an instrumentation policy. Intermediate language: instrumentation added to assembly or decompiled bytecodes giving support for multiple higher-level source languages and avoiding (non-symbolic) binary offset re-writing issues. Compiler assisted Binary translation: The tool adds instrumentation to a compiled executable . Runtime instrumentation: Directly before execution the code is instrumented. The program run is fully supervised and controlled by the tool. Runtime injection: More lightweight than runtime instrumentation. Code is modified at runtime to have jumps to helper functions. Interpreter instrumentation [ edit ] Interpreter debug options can enable the collection of performance metrics as the interpreter encounters each target statement. A bytecode , control table or JIT interpreters are three examples that usually have complete control over execution of the target code, thus enabling extremely comprehensive data collection opportunities. Hypervisor/Simulator [ edit ] Hypervisor: Data are collected by running the (usually) unmodified program under a hypervisor . Example: SIMMON Simulator and Hypervisor: Data collected interactively and selectively by running the unmodified program under an Instruction Set Simulator . See also [ edit ] Algorithmic efficiency Benchmark Java performance List of performance analysis tools PAPI is a portable interface (in the form of a library) to hardware performance counters on modern microprocessors. Performance engineering Performance prediction Performance tuning Runtime verification Profile-guided optimization Static code analysis Software archaeology Worst-case execution time (WCET) References [ edit ] ^ \"How to find the performance bottleneck in C# desktop application?\" . Stack Overflow . 2012. ^ Krauss, Kirk J (2017). \"Performance Profiling with a Focus\" . Develop for Performance. ^ \"What is code profiling? Learn the 3 Types of Code Profilers\" . Stackify Developer Tips, Tricks and Resources. Disqus. 2016. ^ Lawrence, Eric (2016). \"Getting Started with Profile Guided Optimization\" . testslashplain. WordPress. ^ Krauss, Kirk (2018). \"Matching Wildcards: An Improved Algorithm for Big Data\" . Develop for Performance. ^ \"List of .Net Profilers: 3 Different Types and Why You Need All of Them\" . Stackify Developer Tips, Tricks and Resources. Disqus. 2016. ^ Unix Programmer's Manual, 4th Edition ^ Jump up to: a b S.L. Graham, P.B. Kessler, and M.K. McKusick, gprof: a Call Graph Execution Profiler , Proceedings of the SIGPLAN '82 Symposium on Compiler Construction, SIGPLAN Notices, Vol. 17, No 6, pp. 120-126; doi:10.1145/800230.806987 ^ A. Srivastava and A. Eustace, ATOM: A system for building customized program analysis tools , Proceedings of the ACM SIGPLAN Conference on Programming language design and implementation (PLDI '94), pp. 196-205, 1994; ACM SIGPLAN Notices - Best of PLDI 1979-1999 Homepage archive, Vol. 39, No. 4, pp. 528-539; doi:10.1145/989393.989446 ^ 20 Years of PLDI (1979 1999): A Selection , Kathryn S. McKinley , Editor ^ E. Coppa, C. Demetrescu, and I. Finocchi, Input-Sensitive Profiling , IEEE Trans. Software Eng. 40(12): 1185-1205 (2014); doi:10.1109/TSE.2014.2339825 ^ D. Zaparanuks and M. Hauswirth, Algorithmic Profiling, Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2012), ACM SIGPLAN Notices, Vol. 47, No. 6, pp. 67-76, 2012; doi:10.1145/2254064.2254074 ^ T. Kustner, J. Weidendorfer, and T. Weinzierl, Argument Controlled Profiling, Proceedings of Euro-Par 2009 Parallel Processing Workshops, Lecture Notes in Computer Science, Vol. 6043, pp. 177-184, 2010; doi:10.1007/978-3-642-14122-5 22 ^ \"Timing and Profiling - Basic Block Profilers\" . OpenStax CNX Archive. ^ Ball, Thomas; Larus, James R. (1994). \"Optimally profiling and tracing programs\" (PDF). ACM Transactions on Programming Languages and Systems. ACM Digital Library. 16 (4): 1319 1360. doi : 10.1145/183432.183527 . S2CID 6897138 . Archived from the original (PDF) on 2018-05-18 . Retrieved 2018-05-18. ^ Statistical Inaccuracy of gprof Output Archived 2012-05-29 at the Wayback Machine ^ \"Popular C# Profilers\" . Gingtage. 2014. ^ \"Sampling Profiler - Overview\" . AQTime 8 Reference. SmartBear Software. 2018. ^ Wenzal, Maira; et al. (2017). \"Profiling Overview\" . Microsoft .NET Framework Unmanaged API Reference. Microsoft. ^ \"Performance Tools\" . Apple Developer Tools . Apple, Inc. 2013. ^ Netto, Zanella; Arnold, Ryan S. (2012). \"Evaluate performance for Linux on Power\" . IBM DeveloperWorks . ^ Schmidl, Dirk; Terboven, Christian; an Mey, Dieter; Müller, Matthias S. (2013). Suitability of Performance Tools for OpenMP Task-Parallel Programs . Proc. 7th Int'l Workshop on Parallel Tools for High Performance Computing. pp. 25 37. ISBN 9783319081441 . ^ Carleton, Gary; Kirkegaard, Knud; Sehr, David (1998). \"Profile-Guided Optimizations\" . Dr. Dobb's Journal . External links [ edit ] Article \" Need for speed Eliminating performance bottlenecks \" on doing execution time analysis of Java applications using IBM Rational Application Developer . Profiling Runtime Generated and Interpreted Code using the VTune Performance Analyzer Retrieved from \" https://en.wikipedia.org/w/index.php?title=Profiling_(computer_programming)&oldid=990186127 \" Categories : Software optimization Profilers Hidden categories: Webarchive template wayback links Articles needing additional references from January 2009 All articles needing additional references Pages incorrectly using the quote template All articles with unsourced statements Articles with unsourced statements from February 2014 Pages using div col with small parameter Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version Languages Čeština Dansk Deutsch Español فارسی Français 한국어 Magyar Nederlands 日本語 Polski Português Русский Suomi Українська 中文 7 more Edit links This page was last edited on 23 November 2020, at 08:21 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License ; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement Enable previews Annotate ",
                "urlTerms": [
                    "wiki",
                    "profiling",
                    "computer",
                    "programming"
                ],
                "titleTerms": [
                    "profiling",
                    "computer",
                    "programming",
                    "wikipedia"
                ]
            }
        },
        {
            "timestamp": 1608950923005,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "en.wikipedia.org/wiki/Profiling_(computer_programming)"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "en.wikipedia.org/wiki/Profiling_(computer_programming)",
                "fullUrl": "https://en.wikipedia.org/wiki/Profiling_(computer_programming)",
                "createdAt": "2020-12-26T02:48:42.994Z"
            }
        },
        {
            "timestamp": 1608950923016,
            "collection": "visits",
            "objectPk": [
                1608950923011,
                "en.wikipedia.org/wiki/Profiling_(computer_programming)"
            ],
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Profiling_(computer_programming)",
                "time": 1608950923011
            }
        },
        {
            "timestamp": 1608950923024,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Profiling_(computer_programming)/#1608950922760",
            "operation": "create",
            "object": {
                "pageTitle": "Profiling (computer programming) - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Profiling_(computer_programming)",
                "body": "In software engineering, profiling (\"program profiling\", \"software profiling\") is a form of dynamic program analysis that measures, for example, the space (memory) or time complexity of a program, the usage of particular instructions, or the frequency and duration of function calls. Most commonly, profiling information serves to aid program optimization.\r\n\r\nProfiling is achieved by instrumenting either the program source code or its binary executable form using a tool called a profiler (or code profiler). Profilers may use a number of different techniques, such as event-based, statistical, instrumented, and simulation methods. ",
                "comment": "#programming #software",
                "selector": {
                    "quote": "In software engineering, profiling (\"program profiling\", \"software profiling\") is a form of dynamic program analysis that measures, for example, the space (memory) or time complexity of a program, the usage of particular instructions, or the frequency and duration of function calls. Most commonly, profiling information serves to aid program optimization.\r\n\r\nProfiling is achieved by instrumenting either the program source code or its binary executable form using a tool called a profiler (or code profiler). Profilers may use a number of different techniques, such as event-based, statistical, instrumented, and simulation methods. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[2]",
                                "endOffset": 275
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 2015,
                                "end": 2648
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "In software engineering, profiling (\"program profiling\", \"software profiling\") is a form of dynamic program analysis that measures, for example, the space (memory) or time complexity of a program, the usage of particular instructions, or the frequency and duration of function calls.  Most commonly, profiling information serves to aid program optimization.\nProfiling is achieved by instrumenting either the program source code or its binary executable form using a tool called a profiler (or code profiler). Profilers may use a number of different techniques, such as event-based, statistical, instrumented, and simulation methods.\n",
                                "prefix": "ign:left;margin-right:0.5em}vte\n",
                                "suffix": "\nContents\n\n1 Gathering program e"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T02:48:42.760Z",
                "lastEdited": "2020-12-26T02:49:19.872Z",
                "url": "https://en.wikipedia.org/wiki/Profiling_(computer_programming)/#1608950922760"
            }
        },
        {
            "timestamp": 1608950959901,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Profiling_(computer_programming)/#1608950922760",
            "operation": "update",
            "object": {
                "pageTitle": "Profiling (computer programming) - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Profiling_(computer_programming)",
                "body": "In software engineering, profiling (\"program profiling\", \"software profiling\") is a form of dynamic program analysis that measures, for example, the space (memory) or time complexity of a program, the usage of particular instructions, or the frequency and duration of function calls. Most commonly, profiling information serves to aid program optimization.\r\n\r\nProfiling is achieved by instrumenting either the program source code or its binary executable form using a tool called a profiler (or code profiler). Profilers may use a number of different techniques, such as event-based, statistical, instrumented, and simulation methods. ",
                "comment": "#programming #software",
                "selector": {
                    "quote": "In software engineering, profiling (\"program profiling\", \"software profiling\") is a form of dynamic program analysis that measures, for example, the space (memory) or time complexity of a program, the usage of particular instructions, or the frequency and duration of function calls. Most commonly, profiling information serves to aid program optimization.\r\n\r\nProfiling is achieved by instrumenting either the program source code or its binary executable form using a tool called a profiler (or code profiler). Profilers may use a number of different techniques, such as event-based, statistical, instrumented, and simulation methods. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[2]",
                                "endOffset": 275
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 2015,
                                "end": 2648
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "In software engineering, profiling (\"program profiling\", \"software profiling\") is a form of dynamic program analysis that measures, for example, the space (memory) or time complexity of a program, the usage of particular instructions, or the frequency and duration of function calls.  Most commonly, profiling information serves to aid program optimization.\nProfiling is achieved by instrumenting either the program source code or its binary executable form using a tool called a profiler (or code profiler). Profilers may use a number of different techniques, such as event-based, statistical, instrumented, and simulation methods.\n",
                                "prefix": "ign:left;margin-right:0.5em}vte\n",
                                "suffix": "\nContents\n\n1 Gathering program e"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T02:48:42.760Z",
                "lastEdited": "2020-12-26T02:49:19.872Z",
                "url": "https://en.wikipedia.org/wiki/Profiling_(computer_programming)/#1608950922760"
            }
        },
        {
            "timestamp": 1608951258659,
            "collection": "favIcons",
            "objectPk": "github.com",
            "operation": "create",
            "object": {
                "hostname": "github.com",
                "favIcon": "PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNiAwQzcuMTYgMCAwIDcuMTYgMCAxNkMwIDIzLjA4IDQuNTggMjkuMDYgMTAuOTQgMzEuMThDMTEuNzQgMzEuMzIgMTIuMDQgMzAuODQgMTIuMDQgMzAuNDJDMTIuMDQgMzAuMDQgMTIuMDIgMjguNzggMTIuMDIgMjcuNDRDOCAyOC4xOCA2Ljk2IDI2LjQ2IDYuNjQgMjUuNTZDNi40NiAyNS4xIDUuNjggMjMuNjggNSAyMy4zQzQuNDQgMjMgMy42NCAyMi4yNiA0Ljk4IDIyLjI0QzYuMjQgMjIuMjIgNy4xNCAyMy40IDcuNDQgMjMuODhDOC44OCAyNi4zIDExLjE4IDI1LjYyIDEyLjEgMjUuMkMxMi4yNCAyNC4xNiAxMi42NiAyMy40NiAxMy4xMiAyMy4wNkM5LjU2IDIyLjY2IDUuODQgMjEuMjggNS44NCAxNS4xNkM1Ljg0IDEzLjQyIDYuNDYgMTEuOTggNy40OCAxMC44NkM3LjMyIDEwLjQ2IDYuNzYgOC44MiA3LjY0IDYuNjJDNy42NCA2LjYyIDguOTggNi4yIDEyLjA0IDguMjZDMTMuMzIgNy45IDE0LjY4IDcuNzIgMTYuMDQgNy43MkMxNy40IDcuNzIgMTguNzYgNy45IDIwLjA0IDguMjZDMjMuMSA2LjE4IDI0LjQ0IDYuNjIgMjQuNDQgNi42MkMyNS4zMiA4LjgyIDI0Ljc2IDEwLjQ2IDI0LjYgMTAuODZDMjUuNjIgMTEuOTggMjYuMjQgMTMuNCAyNi4yNCAxNS4xNkMyNi4yNCAyMS4zIDIyLjUgMjIuNjYgMTguOTQgMjMuMDZDMTkuNTIgMjMuNTYgMjAuMDIgMjQuNTIgMjAuMDIgMjYuMDJDMjAuMDIgMjguMTYgMjAgMjkuODggMjAgMzAuNDJDMjAgMzAuODQgMjAuMyAzMS4zNCAyMS4xIDMxLjE4QzI3LjQyIDI5LjA2IDMyIDIzLjA2IDMyIDE2QzMyIDcuMTYgMjQuODQgMCAxNiAwVjBaIiBmaWxsPSIjMjQyOTJFIi8+Cjwvc3ZnPgo="
            }
        },
        {
            "timestamp": 1608951258689,
            "collection": "pages",
            "objectPk": "github.com/reuseman/flashcards-obsidian/wiki",
            "operation": "create",
            "object": {
                "url": "github.com/reuseman/flashcards-obsidian/wiki",
                "fullUrl": "https://github.com/reuseman/flashcards-obsidian/wiki",
                "domain": "github.com",
                "hostname": "github.com",
                "fullTitle": "Home · reuseman/flashcards-obsidian Wiki",
                "text": " Skip to content In this repository All GitHub Jump to No suggested jump to results In this repository All GitHub Jump to In this user All GitHub Jump to In this repository All GitHub Jump to Dashboard Pull requests Issues Marketplace Explore Settings Eskabore Sign out New repository Import repository New gist New organization This repository New issue Sorry, something went wrong. {{ message }} reuseman / flashcards-obsidian generated from obsidianmd/obsidian-sample-plugin Sponsor Sponsor reuseman/flashcards-obsidian Unwatch Stop ignoring Watch Notifications Participating and @mentions Only receive notifications from this repository when participating or @mentioned. All Activity Notified of all notifications on this repository. Ignore Never be notified. Custom Select events you want to be notified of in addition to participating and @mentions. Custom Custom Select events you want to be notified of in addition to participating and @mentions. Issues Pull requests Releases Discussions Apply Cancel 2 Custom notification settings Looking for a little more control? Now you can choose which types of activity you’d like to be notified about per repository. Got it Unstar 30 Star 30 Fork Fork flashcards-obsidian If this dialog fails to load, you can visit the fork page directly. 4 Code Issues 4 Pull requests 0 Discussions Actions Projects 1 Wiki Security Insights More Code Issues Pull requests Discussions Actions Projects Wiki Security Insights Home Jump to bottom Alex Colucci edited this page 4 days ago · 11 revisions First, Anki and AnkiConnect should be running and configured properly, as explained here . Write cards At the current time the hashtag is the way to define them. It can be customized in the settings, but the default one is #card. Here there is an example file ( Preview | Markdown ). #card hashtag To mark a line or a heading as the front of a card just write a #card tag after it. On a new line write the back of the card. And remember to space things out! # This could be a title ## This is the front #card This is the back of the card. This line will not be part of it, because there is an empty line above. ### This is a normal and reversed card #card-reverse Which means that two cards will be generated on Anki. This could be another question #card But this time without the heading. ## This is another way to define the front #card This style is usefull to avoid the hashtags when referencing in Obsidian Inline style with :: # This could be a title All of these works: My question::My answer My question:: My answer My question ::My Answer My question :: My answer You can even use it in lists: - My question:: My answer Spaced with #card-spaced hashtag This could be a beautifull quote that you want to see once in a while #card-spaced Generate cards on Anki In Obsidian, open the file where you have the flashcards Then to insert/update/delete just run inside Obsidian the command Ctrl+p and execute the command Flashcards: generate for the current file Insert Write the cards and just run the command above. The insertion operation will add cards on Anki. While, in Obsidian it will add an ID to keep track of them. Update Just edit the card in Obsidian, and run the command above. NOTE: Make certain that when you want to update the BROWSE window of Anki is closed. Unfortunately, this is a bug that is not my under control, but it's a problem tied up with the Anki APIs I am using. Delete Delete the content of the card in Obsidian, but without deleting the ID. The plugin will take care of it. So for example ## This is the front of the card to delete #card This is the back of the card to delete. ^1607361487244 This is what you should leave: ^1607361487244 Features Context-aware mode To make sense of notes, they should talk about a specific topic, so if you have two headings of level 1 (# heading), probably you should have two notes that talks about those topics. Moreover, the note itself is written with a tree-structure and then connected in a graph way. Based on this hypothesis, the context-aware mode creates the context in the front of the card. Where the context the outline of the headings in a tree structure. The demo shows is in action. This helps you out: during review, because the front will be unique and this helps the memory in reaching for the correct answer. If the front is repeated for multiple cards, it's impossible to remember what's in the back, it's pure randomness. during writing, because you can write following the same structure for different topics, and cards will always be unique. So you do not have to think too much about the writing itself. Example: # Computer Science ## Languages #card Stuff ### OOP #card Stuff #### C++ #card Stuff #### Java #card Answer ### Functional Stuff Generated card for the Java heading With context-aware mode on Front: Computer Science > Languages > OOP > Java Back: Answer With context-aware mode off Front: Java Back: Answer Deck To define in which deck in Anki the cards should go, write the name of the deck in the front matter . You can even specify sub decks by using two colons, My Deck Name::Sub deck --- cards-deck: My Deck Name --- ## This is the front #card This is the back of the card. Tags To define the tags that should be used in Anki, there are two approaches. Global tags: takes all the tags specified in the front matter of Obsidian. Local tags: takes the tag after the #card tag. --- tags: global-tag1, global-tag2 --- ## This is the front #card #my-local-tag This is the back of the card. Images To add images just embed them normally. Be aware that an attachment folder must be specified in Obsidian. Code highlight support This should be enabled in the settings. Default: Off Source support This should be enabled in the settings. Default: Off Note that whenever enabled, the previous cards created without the source support cannot be updated, unless you switch back. My suggestion is to stick with one mode. Customization To have coloured tags for the flashcards one, you can use this in obsidian.css. It's not added directly in the plugin, to do not mess with your styles . . tag { color: var( --text-normal); background-color: var( --text-accent); border: none; font-size: 11 px; padding: 1 px 8 px; text-align: center; text-decoration: none; margin: 0 px 0 px; cursor: pointer; border-radius: 14 px; display: inline; vertical-align: middle; } . tag: hover { color: var( --text-normal); background-color: var( --text-accent-hover); } . tag[ href = \"#card\"] { background-color: #821515; } . tag[ href = \"#card-reverse\"] { background-color: #821515; } Pages 1 Home Clone this wiki locally © 2020 GitHub, Inc. Terms Privacy Security Status Help Contact GitHub Pricing API Training Blog About You can’t perform that action at this time. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session. Octotree Release 6.2.1 Changes in 6.2.1 Learn more Improved styles in GitHub dark mode From user feedback, we removed \"Only sidebar\" and \"GitHub Dark\" themes. Instead, Octotree by default will use the same theme with GitHub. We also improved the styling so that it looks much better with GitHub dark mode. Version 6.2.0 summary Supported GitHub dark mode and improved performance pull request review's performance and reliability. Settings (v6.2.3) Authentication Login with GitHub Display Show sidebar on hover Shrink GitHub header Hotkeys Show in Others Sign up to unlock: File search Bookmarking Page display options Caching & lazy loading Collapse code tree 15-day Pro trial Already have an account? Sign in Apply settings Login with GitHub Select a color theme auto GitHub (default) Unlock 20+ code themes ",
                "urlTerms": [
                    "reuseman",
                    "flashcards",
                    "obsidian",
                    "wiki"
                ],
                "titleTerms": [
                    "home",
                    "·",
                    "reuseman",
                    "flashcards-obsidian",
                    "wiki",
                    "flashcards",
                    "obsidian"
                ]
            }
        },
        {
            "timestamp": 1608951258708,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "github.com/reuseman/flashcards-obsidian/wiki"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "github.com/reuseman/flashcards-obsidian/wiki",
                "fullUrl": "https://github.com/reuseman/flashcards-obsidian/wiki",
                "createdAt": "2020-12-26T02:54:18.699Z"
            }
        },
        {
            "timestamp": 1608951258726,
            "collection": "visits",
            "objectPk": [
                1608951258716,
                "github.com/reuseman/flashcards-obsidian/wiki"
            ],
            "operation": "create",
            "object": {
                "url": "github.com/reuseman/flashcards-obsidian/wiki",
                "time": 1608951258716
            }
        },
        {
            "timestamp": 1608951258739,
            "collection": "bookmarks",
            "objectPk": "github.com/reuseman/flashcards-obsidian/wiki",
            "operation": "create",
            "object": {
                "url": "github.com/reuseman/flashcards-obsidian/wiki",
                "time": 1608951258734
            }
        },
        {
            "timestamp": 1608951314374,
            "collection": "pages",
            "objectPk": "en.wikipedia.org/wiki/Zettelkasten",
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Zettelkasten",
                "fullUrl": "https://en.wikipedia.org/wiki/Zettelkasten",
                "domain": "wikipedia.org",
                "hostname": "en.wikipedia.org",
                "fullTitle": "Zettelkasten - Wikipedia",
                "text": " Zettelkasten From Wikipedia, the free encyclopedia Jump to navigation Jump to search Knowledge management and note-taking method A zettelkasten is made up of notes containing numbers, tags (blue) and cross-references to other notes (red). A tag index (bottom right) allows topical cross-referencing. A physical zettelkasten The zettelkasten (German: \"slip box\") is a knowledge management and note-taking method used in research and study. Contents 1 Method 2 History 3 See also 4 References Method [ edit ] A zettelkasten consists of many individual notes with ideas and other short pieces of information that are taken down as they occur or are acquired. The notes are numbered hierarchically, so that new notes may be inserted at the appropriate place, and contain metadata to allow the note-taker to associate notes with each other. For example, notes may contain tags that describe key aspects of the note, and they may reference other notes. The numbering, metadata, format and structure of the notes is subject to variation depending on the specific method employed. Creating and using a zettelkasten is made easier by taking the notes down digitally and using appropriate knowledge management software . But it can be and has long been done on paper using index cards . The method not only allows a researcher to store and retrieve information related to their research, but also intends to enhance creativity. Cross-referencing notes through tags allows the researcher to perceive connections and relationships between individual items of information that may not be apparent in isolation. These emergent aspects of the method make the zettelkasten somewhat similar to a neural network with which one may \"converse\". [1] History [ edit ] In the form of paper index cards in boxes, the zettelkasten ( plural : Zettelkästen) has long been used by individual researchers and by organizations to manage information, including notably in the specialized form of the library catalog . It was pioneered by Conrad Gessner (1516 1565) and was described in detail by Johann Jacob Moser (1701 1785). [2] The 1794 idyll Leben des Quintus Fixlein by Jean Paul is structured according to the zettelkasten in which the protagonist keeps his autobiography. One researcher famous for his extensive use of the method was the sociologist Niklas Luhmann (1927 1998). Luhmann built up a zettelkasten of some 90,000 index cards for his research, and credited it for enabling his extraordinarily prolific writing (including over 70 books and 400 scholarly articles). [3] He linked the cards together by assigning each a unique index number based on a branching hierarchy. [4] These index cards were digitized and made available online in 2019. [5] Luhmann described the zettelkasten as part of his research into systems theory in the essay \"Kommunikation mit Zettelkästen\". [6] See also [ edit ] Argument map Commonplace book Hypertext Issue-based information system Notetaking Comparison of notetaking software Outliner Personal knowledge base Personal knowledge management Personal wiki List of wiki software § Personal wiki software Reference management software Tag (metadata) § Knowledge tags References [ edit ] ^ Mittelmann, Angelika (2019). Wissensmanagement wird digital. pp. 63 65. ISBN 9783749461219 . ^ Haarkötter, Hektor. \" 'Alles Wesentliche findet sich im Zettelkasten '\" . heise online (in German) . Retrieved 2020-05-31. ^ Schmidt, Johannes. \"Niklas Luhmann's Card Index: Thinking Tool, Communication Partner, Publication Machine\". In Cevolini, Alberto (ed.). Forgetting Machines : Knowledge Management Evolution in Early Modern Europe (PDF). pp. 289 311. ^ Beaudoin Zapier, Jack (2 August 2020). \"This simple but powerful analog method will rocket your productivity\" . Fast Company . ^ Noack, Pit. \"Missing Link: Luhmanns Denkmaschine endlich im Netz\" . heise online (in German) . Retrieved 2020-05-31. ^ Luhmann, Niklas. \"Kommunikation mit Zettelkästen. Ein Erfahrungsbericht\", in: André Kieserling (ed.), Universität als Milieu. Kleine Schriften, Haux, Bielefeld 1992 (essay originally published 1981), ISBN 3-925471-13-8 , p. 53 61; translated in: \"Communicating with Slip Boxes\" . luhmann.surge.sh . Retrieved 2020-05-31. Retrieved from \" https://en.wikipedia.org/w/index.php?title=Zettelkasten&oldid=995591554 \" Categories : Note-taking Knowledge management German words and phrases Hidden categories: CS1 German-language sources (de) Articles with short description Short description is different from Wikidata Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version Languages Deutsch Español Français Edit links This page was last edited on 21 December 2020, at 22:04 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License ; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement Enable previews Annotate ",
                "urlTerms": [
                    "wiki",
                    "zettelkasten"
                ],
                "titleTerms": [
                    "zettelkasten",
                    "wikipedia"
                ]
            }
        },
        {
            "timestamp": 1608951314395,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "en.wikipedia.org/wiki/Zettelkasten"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "en.wikipedia.org/wiki/Zettelkasten",
                "fullUrl": "https://en.wikipedia.org/wiki/Zettelkasten",
                "createdAt": "2020-12-26T02:55:14.386Z"
            }
        },
        {
            "timestamp": 1608951314407,
            "collection": "visits",
            "objectPk": [
                1608951314403,
                "en.wikipedia.org/wiki/Zettelkasten"
            ],
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Zettelkasten",
                "time": 1608951314403
            }
        },
        {
            "timestamp": 1608951314413,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Zettelkasten/#1608951314257",
            "operation": "create",
            "object": {
                "pageTitle": "Zettelkasten - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Zettelkasten",
                "body": "Method\r\n\r\nA zettelkasten consists of many individual notes with ideas and other short pieces of information that are taken down as they occur or are acquired. The notes are numbered hierarchically, so that new notes may be inserted at the appropriate place, and contain metadata to allow the note-taker to associate notes with each other. For example, notes may contain tags that describe key aspects of the note, and they may reference other notes. The numbering, metadata, format and structure of the notes is subject to variation depending on the specific method employed.\r\n\r\nCreating and using a zettelkasten is made easier by taking the notes down digitally and using appropriate knowledge management software. But it can be and has long been done on paper using index cards.\r\n\r\nThe method not only allows a researcher to store and retrieve information related to their research, but also intends to enhance creativity. Cross-referencing notes through tags allows the researcher to perceive connections and relationships between individual items of information that may not be apparent in isolation. These emergent aspects of the method make the zettelkasten somewhat similar to a neural network with which one may \"converse\".[1]",
                "comment": "",
                "selector": {
                    "quote": "Method\r\n\r\nA zettelkasten consists of many individual notes with ideas and other short pieces of information that are taken down as they occur or are acquired. The notes are numbered hierarchically, so that new notes may be inserted at the appropriate place, and contain metadata to allow the note-taker to associate notes with each other. For example, notes may contain tags that describe key aspects of the note, and they may reference other notes. The numbering, metadata, format and structure of the notes is subject to variation depending on the specific method employed.\r\n\r\nCreating and using a zettelkasten is made easier by taking the notes down digitally and using appropriate knowledge management software. But it can be and has long been done on paper using index cards.\r\n\r\nThe method not only allows a researcher to store and retrieve information related to their research, but also intends to enhance creativity. Cross-referencing notes through tags allows the researcher to perceive connections and relationships between individual items of information that may not be apparent in isolation. These emergent aspects of the method make the zettelkasten somewhat similar to a neural network with which one may \"converse\".[1]",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/h2[1]/span[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/h2[1]/span[2]/span[1]",
                                "endOffset": 0
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 535,
                                "end": 541
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Method",
                                "prefix": "tory\n3 See also\n4 References\n\n\n\n",
                                "suffix": "[edit]\nA zettelkasten consists o"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T02:55:14.257Z",
                "lastEdited": "2020-12-26T02:55:14.257Z",
                "url": "https://en.wikipedia.org/wiki/Zettelkasten/#1608951314257"
            }
        },
        {
            "timestamp": 1608951395422,
            "collection": "favIcons",
            "objectPk": "w3docs.com",
            "operation": "create",
            "object": {
                "hostname": "w3docs.com",
                "favIcon": "AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAABILAAASCwAAAAAAAAAAAABPREL9T0RC/k9EQv5PREL+T0RC/k9EQv5PREL+T0RC/k9EQv5PREL+T0RC/k9EQv5PREL+T0RC/k9EQv5PREL+T0RC/k9EQv9PREL/T0RC/09EQv9PREL/T0RC/09EQv9PREL/T0RC/09EQv9PREL/T0RC/09EQv9PREL/T0RC/09EQv5PREL/T0RC/09EQv9PREL/T0RC/09EQv9PREL/T0RC/09EQv9PREL/T0RC/09EQv9PREL/T0RC/09EQv9PREL+T0RC/09EQv9OREL/TkRC/09EQv9PREL/TkRC/05EQv9PREL/TkVD/09DQf9PQkH/T0NB/09EQv9PREL/T0RC/k9EQv9OQ0H/WEg9/1pKPf9QREH/UERA/1pKPP9YSD7/TElF/0WMbP9HiGr/SmpY/01SSv9PREL/T0RC/09EQv5RRT//hmEt/7V7If+4fSH/lWoq/5hrKP+5fiD/s3oi/39nNv9Kimr/Rap//0S2hv9EroH/S25b/09DQv9NQkL+eFkx/8eGHP+6fyH/tn0h/8qHHP/Jhxz/tHwi/72BH//DhB7/cFg4/0xLR/9MXFD/RZx2/0Wnff9OTUf/TkNB/plsKP/FhR3/cFY4/2RPOf+9gB//tn0i/15MPf95WjL/yYUb/4qNRf9FjG3/SG9b/0Scdv9FqH3/Tk1I/05DQP6dbif/woMe/2NPPP9WRz3/tnwg/654Jf9SRkH/alI2/8aEG/+QjkP/RKd+/0O5iP9DvYr/SnRf/09DQv9OQ0D+nW4n/8KDHv9jTzz/V0c9/7d8IP+ueCT/U0ZB/2pVN//Ghh3/k2su/01JRf9Hd2D/Q7mI/0xgUv9PQkH/TkNA/p1uJ//Cgx7/ZE88/1dIPf+3fSD/r3kk/1JGQP9pZkH/x4ke/4+SRP9FjG3/RJp1/0S0hf9NWU7/T0NB/09DQf6Vair/t30i/2FOPP9WRz7/rXcj/6VzJ/9SRkH/aFg7/7t/IP+JikX/RKZ9/0Wnff9Kc17/T0VD/09EQv9PREL+W0o+/2BNPf9SRkH/UEVB/15MPf9dTD7/UERC/1NGQP9hTjz/WUo//05KRv9OS0b/T0RC/09EQv9PREL/T0RC/k5EQv9OQ0L/T0RC/09EQv9OQ0L/TkRC/09EQv9PREL/TkNC/05EQv9PREL/T0RC/09EQv9PREL/T0RC/09EQv5PREL/T0RC/09EQv9PREL/T0RC/09EQv9PREL/T0RC/09EQv9PREL/T0RC/09EQv9PREL/T0RC/09EQv9PREL+T0RC/09EQv9PREL/T0RC/09EQv9PREL/T0RC/09EQv9PREL/T0RC/09EQv9PREL/T0RC/09EQv9PREL/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
            }
        },
        {
            "timestamp": 1608951395477,
            "collection": "pages",
            "objectPk": "w3docs.com/learn-css/text-shadow.html",
            "operation": "create",
            "object": {
                "url": "w3docs.com/learn-css/text-shadow.html",
                "fullUrl": "https://www.w3docs.com/learn-css/text-shadow.html",
                "domain": "w3docs.com",
                "hostname": "w3docs.com",
                "fullTitle": "CSS text-shadow Property",
                "text": " We use cookies to improve user experience, and analyze website traffic. Accept Close the sidebar CSS Basic CSS Introduction CSS Usage CSS Syntax CSS id and class CSS Text CSS Font CSS Links CSS Tables CSS Border CSS Padding CSS Margin CSS Color Names CSS Gradients CSS Guides Flexbox Guide CSS3 Properties CSS Selectors * :active ::after ::before :checked :default :dir() :disabled :empty :enabled :first-child ::first-letter ::first-line :first-of-type :focus :fullscreen :hover :in-range :indeterminate :invalid :lang() :last-child :last-of-type :link :not() :nth-child() :nth-last-child :nth-last-of-type() :nth-of-type :only-child :only-of-type :optional :out-of-range ::placeholder :read-only :read-write :required :root :scope ::selection :target :valid :visited CSS Properties align-content align-items all animation align-self animation-delay animation-direction animation-duration animation-fill-mode animation-iteration-count animation-name animation-play-state animation-timing-function appearance backface-visibility background background-attachment background-blend-mode background-clip background-color background-image background-origin background-position background-position-x background-position-y background-repeat background-size bleed block-overflow border border-bottom border-bottom-color border-bottom-left-radius border-bottom-right-radius border-bottom-style border-bottom-width border-collapse border-color border-image border-image-outset border-image-repeat border-image-slice border-image-source border-image-width border-left border-left-color border-left-style border-left-width border-radius border-right border-right-color border-right-style border-right-width border-spacing border-style border-top border-top-color border-top-left-radius border-top-right-radius border-top-style border-top-width border-width bottom box-decoration-break box-shadow box-sizing break-after break-before break-inside caption-side caret-color @charset clear clip clip-path color columns column-count column-fill column-gap column-rule column-rule-color column-rule-style column-rule-width column-span column-width content counter-increment counter-reset cursor direction display empty-cells fill filter flex flex-basis flex-direction flex-flow flex-grow flex-shrink flex-wrap float font @font-face font-display font-family font-feature-settings @font-feature-values font-kerning font-size font-size-adjust font-language-override font-stretch font-style font-variant font-variant-alternates font-variant-caps font-variant-east-asian font-variant-ligatures font-variant-numeric font-weight grid grid-area grid-auto-columns grid-auto-flow grid-auto-rows grid-column grid-column-end grid-column-gap grid-column-start grid-gap grid-row grid-row-end grid-row-gap grid-row-start grid-template grid-template-areas grid-template-columns grid-template-rows hanging-punctuation height hyphens image-rendering @import initial-letter isolation justify-content justify-items @keyframes left letter-spacing line-break line-clamp line-height list-style list-style-image list-style-position list-style-type margin margin-bottom margin-left margin-right margin-top max-height max-lines max-width @media min-height min-width mix-blend-mode object-fit object-position offset offset-anchor offset-distance offset-path offset-position offset-rotate opacity order orphans outline outline-color outline-offset outline-style outline-width overflow overflow-anchor overflow-wrap overflow-x overflow-y padding padding-bottom padding-left padding-right padding-top page-break page-break-after page-break-before page-break-inside perspective perspective-origin place-items pointer-events position quotes resize right scroll-behavior scrollbar shape-outside speak stroke stroke-dasharray stroke-dashoffset stroke-linecap stroke-width tab-size table-layout text-align text-align-last text-combine-upright text-decoration text-decoration-color text-decoration-line text-decoration-skip text-decoration-skip-ink text-decoration-style text-fill-color text-indent text-justify text-orientation text-overflow text-rendering text-shadow text-stroke text-stroke-color text-stroke-width text-transform text-underline-position top transform transform-origin transform-style transition transition-delay transition-duration transition-property transition-timing-function unicode-bidi unicode-range user-select vertical-align visibility white-space widows width will-change word-break word-spacing word-wrap writing-mode z-index zoom Close the sidebar CSS Basic CSS Introduction CSS Usage CSS Syntax CSS id and class CSS Text CSS Font CSS Links CSS Tables CSS Border CSS Padding CSS Margin CSS Color Names CSS Gradients CSS Guides Flexbox Guide CSS3 Properties CSS Selectors * :active ::after ::before :checked :default :dir() :disabled :empty :enabled :first-child ::first-letter ::first-line :first-of-type :focus :fullscreen :hover :in-range :indeterminate :invalid :lang() :last-child :last-of-type :link :not() :nth-child() :nth-last-child :nth-last-of-type() :nth-of-type :only-child :only-of-type :optional :out-of-range ::placeholder :read-only :read-write :required :root :scope ::selection :target :valid :visited CSS Properties align-content align-items all animation align-self animation-delay animation-direction animation-duration animation-fill-mode animation-iteration-count animation-name animation-play-state animation-timing-function appearance backface-visibility background background-attachment background-blend-mode background-clip background-color background-image background-origin background-position background-position-x background-position-y background-repeat background-size bleed block-overflow border border-bottom border-bottom-color border-bottom-left-radius border-bottom-right-radius border-bottom-style border-bottom-width border-collapse border-color border-image border-image-outset border-image-repeat border-image-slice border-image-source border-image-width border-left border-left-color border-left-style border-left-width border-radius border-right border-right-color border-right-style border-right-width border-spacing border-style border-top border-top-color border-top-left-radius border-top-right-radius border-top-style border-top-width border-width bottom box-decoration-break box-shadow box-sizing break-after break-before break-inside caption-side caret-color @charset clear clip clip-path color columns column-count column-fill column-gap column-rule column-rule-color column-rule-style column-rule-width column-span column-width content counter-increment counter-reset cursor direction display empty-cells fill filter flex flex-basis flex-direction flex-flow flex-grow flex-shrink flex-wrap float font @font-face font-display font-family font-feature-settings @font-feature-values font-kerning font-size font-size-adjust font-language-override font-stretch font-style font-variant font-variant-alternates font-variant-caps font-variant-east-asian font-variant-ligatures font-variant-numeric font-weight grid grid-area grid-auto-columns grid-auto-flow grid-auto-rows grid-column grid-column-end grid-column-gap grid-column-start grid-gap grid-row grid-row-end grid-row-gap grid-row-start grid-template grid-template-areas grid-template-columns grid-template-rows hanging-punctuation height hyphens image-rendering @import initial-letter isolation justify-content justify-items @keyframes left letter-spacing line-break line-clamp line-height list-style list-style-image list-style-position list-style-type margin margin-bottom margin-left margin-right margin-top max-height max-lines max-width @media min-height min-width mix-blend-mode object-fit object-position offset offset-anchor offset-distance offset-path offset-position offset-rotate opacity order orphans outline outline-color outline-offset outline-style outline-width overflow overflow-anchor overflow-wrap overflow-x overflow-y padding padding-bottom padding-left padding-right padding-top page-break page-break-after page-break-before page-break-inside perspective perspective-origin place-items pointer-events position quotes resize right scroll-behavior scrollbar shape-outside speak stroke stroke-dasharray stroke-dashoffset stroke-linecap stroke-width tab-size table-layout text-align text-align-last text-combine-upright text-decoration text-decoration-color text-decoration-line text-decoration-skip text-decoration-skip-ink text-decoration-style text-fill-color text-indent text-justify text-orientation text-overflow text-rendering text-shadow text-stroke text-stroke-color text-stroke-width text-transform text-underline-position top transform transform-origin transform-style transition transition-delay transition-duration transition-property transition-timing-function unicode-bidi unicode-range user-select vertical-align visibility white-space widows width will-change word-break word-spacing word-wrap writing-mode z-index zoom Books Learn HTML Learn CSS Learn Git Learn Javascript Learn PHP Exercises HTML JavaScript Git CSS PHP Quizzes Snippets Tools String Functions Books Learn HTML Learn CSS Learn Git Learn Javascript Learn PHP Exercises HTML JavaScript Git CSS PHP Quizzes Snippets Tools String Functions CSS text-shadow Property The CSS text-shadow property is used to add shadows to the text. You can choose colors from here: HTML colors . The text-shadow property is one of the CSS3 properties . Each shadow is specified by 2 to 3 length values and a <color>. The first value sets the horizontal distance(x-offset), the second value sets the vertical distance(y-offset), the third value sets the blur radius and color value sets the shadow color. The x-offset and the y-offset are obligatory,the third value is optional. Initial Value none Applies to All elements. It also applies to ::first-letter and ::first-line . Inherited Yes. Animatable Yes. Version CSS3 DOM Syntax object.style.textShadow = \"1px 3px 3px #8ebf42\"; Syntax ¶ text- shadow: h- shadow v- shadow blur-radius color | none | initial | inherit; Example of the text-shadow property: ¶ <!DOCTYPE html> < html> < head> < title>Title of the document </ title> < style> .shadow { text-shadow: 2px 2px #1c87c9; } </ style> </ head> < body> < h2>Text-shadow property example </ h2> < p>Some paragraph for example. </ p> < p class= \"shadow\">Some paragraph with the text-shadow property. </ p> </ body> </ html> Try it Yourself » Result ¶ Example of the text-shadow property with the “x-offset”, “y-offset”, “blur-radius” and “color” values: ¶ <!DOCTYPE html> < html> < head> < style> p { text-shadow: 5px 3px 2px #8ebf42; font: 1em Roboto, Helvetica, sans-serif; } </ style> </ head> < body> < h2>Text-shadow property example </ h2> < p>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. </ p> </ body> </ html> Try it Yourself » Values ¶ Value Description Play it h-shadow The horizontal offset of the shadow. If positive the shadow is drawn on the right side of the text, if negative it is drawn on the left side. Play it » v-shadow The vertical offset of the shadow (y-axis). If the value is positive the shadow is below the text, if negative it is drawn above. Play it » blur-radius The blur radius defines how big and how much blurred the shadow is. We can't use negative values. Default value is 0. Play it » color Allows us to choose a color of the shadow. Color names, hexadecimal color codes, rgb(), rgba(), hsl(), hsla() can be used. Play it » none No shadow is specified. This is default value of this property. Play it » initial Makes the property use its default value. Play it » inherit Inherits the property from its parents element. Browser support 4.0+ 12.0+ 3.5+ 4.0+ 10.0+ Prev Next Related Resources ¶ Shadow Effects in CSS CSS box-shadow Property CSS font Property CSS color Property CSS background-color Property CSS border-radius Property Sorry about that How can we improve it? Thanks for your feedback! Error 404 Thanks for your feedback! Do you find this helpful? Yes No Related articles Quizzes HTML Basic CSS Basic JavaScript Basic PHP Basic ES6 Basic TypeScript Basic Angular React Sass Git Vue.js SQL Quizzes HTML Basic CSS Basic Javascript Basic PHP basic ES6 Basic TypeScript Basic Angular Basic React Basic Sass Basic Vue.js Basic Git Basic SQL Basic Snippets How To JavaScript How To NodeJs How To Linux How To AngularJs How To PHP How To HTML How To CSS How To Symfony How To Google Maps How To Git How To Apache How To Java How To Vue.js Our Books Learn HTML Learn CSS Learn Git Learn Javascript Learn PHP Exercises HTML JavaScript Git CSS PHP Our Tools Website Audit and SEO Typing Test Color Picker HTML Encoder HTML Editor CSS Maker Password Generator Base 64 Code Diff Geometric Images String Functions String Length Calculator String to MD5 Hash Generator String to Sha256 Hash Generator String Reverse URL Encoder URL Decoder Base 64 Encoder Base 64 Decoder Extra Spaces Remover String to Lowercase Converter About Us Privacy Policy for W3Docs Follow Us Company © W3docs. All rights reserved. Annotate ",
                "urlTerms": [
                    "learn",
                    "css",
                    "text",
                    "shadow",
                    "html"
                ],
                "titleTerms": [
                    "css",
                    "text-shadow",
                    "property",
                    "text",
                    "shadow"
                ]
            }
        },
        {
            "timestamp": 1608951395505,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "w3docs.com/learn-css/text-shadow.html"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "w3docs.com/learn-css/text-shadow.html",
                "fullUrl": "https://www.w3docs.com/learn-css/text-shadow.html",
                "createdAt": "2020-12-26T02:56:35.494Z"
            }
        },
        {
            "timestamp": 1608951395515,
            "collection": "visits",
            "objectPk": [
                1608951395510,
                "w3docs.com/learn-css/text-shadow.html"
            ],
            "operation": "create",
            "object": {
                "url": "w3docs.com/learn-css/text-shadow.html",
                "time": 1608951395510
            }
        },
        {
            "timestamp": 1608951395522,
            "collection": "annotations",
            "objectPk": "https://www.w3docs.com/learn-css/text-shadow.html/#1608951395248",
            "operation": "create",
            "object": {
                "pageTitle": "CSS text-shadow Property",
                "pageUrl": "w3docs.com/learn-css/text-shadow.html",
                "body": "CSS text-shadow Property\r\n\r\nThe CSS text-shadow property is used to add shadows to the text. You can choose colors from here: HTML colors.\r\n\r\nThe text-shadow property is one of the CSS3 properties.\r\n\r\nEach shadow is specified by 2 to 3 length values and a <color>. The first value sets the horizontal distance(x-offset), the second value sets the vertical distance(y-offset), the third value sets the blur radius and color value sets the shadow color.",
                "comment": "#css #programming",
                "selector": {
                    "quote": "CSS text-shadow Property\r\n\r\nThe CSS text-shadow property is used to add shadows to the text. You can choose colors from here: HTML colors.\r\n\r\nThe text-shadow property is one of the CSS3 properties.\r\n\r\nEach shadow is specified by 2 to 3 length values and a <color>. The first value sets the horizontal distance(x-offset), the second value sets the vertical distance(y-offset), the third value sets the blur radius and color value sets the shadow color.",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[2]/div[1]/div[1]/main[1]/div[2]/div[1]/div[1]/h1[1]",
                                "startOffset": 1,
                                "endContainer": "/div[2]/div[1]/div[1]/main[1]/div[2]/div[1]/p[3]",
                                "endOffset": 250
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 8641,
                                "end": 9090
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "CSS text-shadow Property       The CSS text-shadow property is used to add shadows to the text. You can choose colors from here: HTML colors.  The text-shadow property is one of the CSS3 properties. Each shadow is specified by 2 to 3 length values and a <color>. The first value sets the horizontal distance(x-offset), the second value sets the vertical distance(y-offset), the third value sets the blur radius and color value sets the shadow color.",
                                "prefix": "String Functions                ",
                                "suffix": " The x-offset and the y-offset a"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T02:56:35.248Z",
                "lastEdited": "2020-12-26T02:57:07.013Z",
                "url": "https://www.w3docs.com/learn-css/text-shadow.html/#1608951395248"
            }
        },
        {
            "timestamp": 1608951427026,
            "collection": "annotations",
            "objectPk": "https://www.w3docs.com/learn-css/text-shadow.html/#1608951395248",
            "operation": "update",
            "object": {
                "pageTitle": "CSS text-shadow Property",
                "pageUrl": "w3docs.com/learn-css/text-shadow.html",
                "body": "CSS text-shadow Property\r\n\r\nThe CSS text-shadow property is used to add shadows to the text. You can choose colors from here: HTML colors.\r\n\r\nThe text-shadow property is one of the CSS3 properties.\r\n\r\nEach shadow is specified by 2 to 3 length values and a <color>. The first value sets the horizontal distance(x-offset), the second value sets the vertical distance(y-offset), the third value sets the blur radius and color value sets the shadow color.",
                "comment": "#css #programming",
                "selector": {
                    "quote": "CSS text-shadow Property\r\n\r\nThe CSS text-shadow property is used to add shadows to the text. You can choose colors from here: HTML colors.\r\n\r\nThe text-shadow property is one of the CSS3 properties.\r\n\r\nEach shadow is specified by 2 to 3 length values and a <color>. The first value sets the horizontal distance(x-offset), the second value sets the vertical distance(y-offset), the third value sets the blur radius and color value sets the shadow color.",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[2]/div[1]/div[1]/main[1]/div[2]/div[1]/div[1]/h1[1]",
                                "startOffset": 1,
                                "endContainer": "/div[2]/div[1]/div[1]/main[1]/div[2]/div[1]/p[3]",
                                "endOffset": 250
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 8641,
                                "end": 9090
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "CSS text-shadow Property       The CSS text-shadow property is used to add shadows to the text. You can choose colors from here: HTML colors.  The text-shadow property is one of the CSS3 properties. Each shadow is specified by 2 to 3 length values and a <color>. The first value sets the horizontal distance(x-offset), the second value sets the vertical distance(y-offset), the third value sets the blur radius and color value sets the shadow color.",
                                "prefix": "String Functions                ",
                                "suffix": " The x-offset and the y-offset a"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T02:56:35.248Z",
                "lastEdited": "2020-12-26T02:57:07.013Z",
                "url": "https://www.w3docs.com/learn-css/text-shadow.html/#1608951395248"
            }
        },
        {
            "timestamp": 1608951517031,
            "collection": "pages",
            "objectPk": "en.wikipedia.org/wiki/Deployment_diagram",
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Deployment_diagram",
                "fullUrl": "https://en.wikipedia.org/wiki/Deployment_diagram",
                "domain": "wikipedia.org",
                "hostname": "en.wikipedia.org",
                "fullTitle": "Deployment diagram - Wikipedia",
                "text": " Deployment diagram From Wikipedia, the free encyclopedia Jump to navigation Jump to search A sample deployment diagram UML diagram types Structural UML diagrams Class diagram Component diagram Composite structure diagram Deployment diagram Object diagram Package diagram Profile diagram Behavioral UML diagrams Activity diagram Communication diagram Interaction overview diagram Sequence diagram State diagram Timing diagram Use case diagram v t e A deployment diagram in the Unified Modeling Language models the physical deployment of artifacts on nodes . [1] To describe a web site , for example, a deployment diagram would show what hardware components (\"nodes\") exist (e.g., a web server , an application server , and a database server ), what software components (\"artifacts\") run on each node (e.g., web application , database ), and how the different pieces are connected (e.g. JDBC , REST , RMI ). The nodes appear as boxes, and the artifacts allocated to each node appear as rectangles within the boxes. Nodes may have subnodes, which appear as nested boxes. A single node in a deployment diagram may conceptually represent multiple physical nodes, such as a cluster of database servers. There are two types of Nodes: Device Node Execution Environment Node Device nodes are physical computing resources with processing memory and services to execute software, such as typical computers or mobile phones. An execution environment node (EEN) is a software computing resource that runs within an outer node and which itself provides a service to host and execute other executable software elements. References [ edit ] ^ Deployment diagrams show \"the allocation of Artifacts to Nodes according to the Deployments defined between them.\" Unified Modeling Language, Superstructure, V2.1.2 Archived 2011-06-06 at the Wayback Machine p. 202. External links [ edit ] Wikimedia Commons has media related to Deployment diagrams . Introduction to UML 2 Deployment Diagrams by Scott W. Ambler UML 2 Deployment Diagram UML Deployment Diagrams hide v t e Unified Modeling Language Actors Organizations Object Management Group UML Partners Persons Grady Booch Ivar Jacobson James Rumbaugh Concepts Object oriented Object-oriented programming Object-oriented analysis and design Object-oriented modeling Structure Actor Attribute Artifact Class Component Interface Object Package Profile diagram Behavior Activity Event Message Method State Use case Relationships Association Composition Dependency Generalization (or Inheritance ) Extensibility Profile Stereotype Other Multiplicity Diagrams Structure Class Component Composite structure Deployment Object Package Behaviour Activity State Machine Use case Interaction Communications Sequence Interaction overview Timing Derived languages Systems Modeling Language (SysML) UML eXchange Format (UXF) XML Metadata Interchange (XMI) Executable UML (xUML) Other topics Glossary of UML terms Rational Unified Process List of Unified Modeling Language tools Object Modeling in Color This Unified Modeling Language article is a stub . You can help Wikipedia by expanding it . v t e Retrieved from \" https://en.wikipedia.org/w/index.php?title=Deployment_diagram&oldid=907475160 \" Categories : Unified Modeling Language diagrams Unified Modeling Language stubs Hidden categories: Webarchive template wayback links Commons category link is on Wikidata All stub articles Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version In other projects Wikimedia Commons Languages Català Deutsch Español Français Italiano עברית 日本語 Português Русский Slovenčina Türkçe Українська Zazaki 4 more Edit links This page was last edited on 23 July 2019, at 04:52 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License ; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement Enable previews ",
                "urlTerms": [
                    "wiki",
                    "deployment",
                    "diagram"
                ],
                "titleTerms": [
                    "deployment",
                    "diagram",
                    "wikipedia"
                ]
            }
        },
        {
            "timestamp": 1608951517054,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "en.wikipedia.org/wiki/Deployment_diagram"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "en.wikipedia.org/wiki/Deployment_diagram",
                "fullUrl": "https://en.wikipedia.org/wiki/Deployment_diagram",
                "createdAt": "2020-12-26T02:58:37.046Z"
            }
        },
        {
            "timestamp": 1608951517062,
            "collection": "visits",
            "objectPk": [
                1608951517059,
                "en.wikipedia.org/wiki/Deployment_diagram"
            ],
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Deployment_diagram",
                "time": 1608951517059
            }
        },
        {
            "timestamp": 1608951517072,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Deployment_diagram/#1608951516921",
            "operation": "create",
            "object": {}
        },
        {
            "timestamp": 1608951580495,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Deployment_diagram/#1608951580435",
            "operation": "create",
            "object": {
                "pageTitle": "Deployment diagram - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Deployment_diagram",
                "body": "Deployment diagram\r\nFrom Wikipedia, the free encyclopedia\r\nJump to navigation\r\nJump to search\r\nA sample deployment diagram\r\nUML diagram types\r\nStructural UML diagrams\r\n\r\n    Class diagram\r\n    Component diagram\r\n    Composite structure diagram\r\n    Deployment diagram\r\n    Object diagram\r\n    Package diagram\r\n    Profile diagram\r\n\r\nBehavioral UML diagrams\r\n\r\n    Activity diagram\r\n    Communication diagram\r\n    Interaction overview diagram\r\n    Sequence diagram\r\n    State diagram\r\n    Timing diagram\r\n    Use case diagram\r\n\r\n    vte\r\n\r\nA deployment diagram in the Unified Modeling Language models the physical deployment of artifacts on nodes.[1] To describe a web site, for example, a deployment diagram would show what hardware components (\"nodes\") exist (e.g., a web server, an application server, and a database server), what software components (\"artifacts\") run on each node (e.g., web application, database), and how the different pieces are connected (e.g. JDBC, REST, RMI).\r\n\r\nThe nodes appear as boxes, and the artifacts allocated to each node appear as rectangles within the boxes. Nodes may have subnodes, which appear as nested boxes. A single node in a deployment diagram may conceptually represent multiple physical nodes, such as a cluster of database servers.\r\n\r\nThere are two types of Nodes:\r\n\r\n    Device Node\r\n    Execution Environment Node\r\n\r\nDevice nodes are physical computing resources with processing memory and services to execute software, such as typical computers or mobile phones. An execution environment node (EEN) is a software computing resource that runs within an outer node and which itself provides a service to host and execute other executable software elements. ",
                "comment": "#diagram #ULM",
                "selector": {
                    "quote": "Deployment diagram\r\nFrom Wikipedia, the free encyclopedia\r\nJump to navigation\r\nJump to search\r\nA sample deployment diagram\r\nUML diagram types\r\nStructural UML diagrams\r\n\r\n    Class diagram\r\n    Component diagram\r\n    Composite structure diagram\r\n    Deployment diagram\r\n    Object diagram\r\n    Package diagram\r\n    Profile diagram\r\n\r\nBehavioral UML diagrams\r\n\r\n    Activity diagram\r\n    Communication diagram\r\n    Interaction overview diagram\r\n    Sequence diagram\r\n    State diagram\r\n    Timing diagram\r\n    Use case diagram\r\n\r\n    vte\r\n\r\nA deployment diagram in the Unified Modeling Language models the physical deployment of artifacts on nodes.[1] To describe a web site, for example, a deployment diagram would show what hardware components (\"nodes\") exist (e.g., a web server, an application server, and a database server), what software components (\"artifacts\") run on each node (e.g., web application, database), and how the different pieces are connected (e.g. JDBC, REST, RMI).\r\n\r\nThe nodes appear as boxes, and the artifacts allocated to each node appear as rectangles within the boxes. Nodes may have subnodes, which appear as nested boxes. A single node in a deployment diagram may conceptually represent multiple physical nodes, such as a cluster of database servers.\r\n\r\nThere are two types of Nodes:\r\n\r\n    Device Node\r\n    Execution Environment Node\r\n\r\nDevice nodes are physical computing resources with processing memory and services to execute software, such as typical computers or mobile phones. An execution environment node (EEN) is a software computing resource that runs within an outer node and which itself provides a service to host and execute other executable software elements. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "TextPositionSelector",
                                "start": 12,
                                "end": 127
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Deployment diagram\n\t\n\t\tFrom Wikipedia, the free encyclopedia\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tJump to navigation\n\t\tJump to search\n\t\t  ",
                                "prefix": "\n\n\n\t\n\t\n\t\n\t\n\t",
                                "suffix": "A sample deployment diagram\nUML "
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T02:59:40.435Z",
                "lastEdited": "2020-12-26T03:00:04.800Z",
                "url": "https://en.wikipedia.org/wiki/Deployment_diagram/#1608951580435"
            }
        },
        {
            "timestamp": 1608951604824,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Deployment_diagram/#1608951580435",
            "operation": "update",
            "object": {
                "pageTitle": "Deployment diagram - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Deployment_diagram",
                "body": "Deployment diagram\r\nFrom Wikipedia, the free encyclopedia\r\nJump to navigation\r\nJump to search\r\nA sample deployment diagram\r\nUML diagram types\r\nStructural UML diagrams\r\n\r\n    Class diagram\r\n    Component diagram\r\n    Composite structure diagram\r\n    Deployment diagram\r\n    Object diagram\r\n    Package diagram\r\n    Profile diagram\r\n\r\nBehavioral UML diagrams\r\n\r\n    Activity diagram\r\n    Communication diagram\r\n    Interaction overview diagram\r\n    Sequence diagram\r\n    State diagram\r\n    Timing diagram\r\n    Use case diagram\r\n\r\n    vte\r\n\r\nA deployment diagram in the Unified Modeling Language models the physical deployment of artifacts on nodes.[1] To describe a web site, for example, a deployment diagram would show what hardware components (\"nodes\") exist (e.g., a web server, an application server, and a database server), what software components (\"artifacts\") run on each node (e.g., web application, database), and how the different pieces are connected (e.g. JDBC, REST, RMI).\r\n\r\nThe nodes appear as boxes, and the artifacts allocated to each node appear as rectangles within the boxes. Nodes may have subnodes, which appear as nested boxes. A single node in a deployment diagram may conceptually represent multiple physical nodes, such as a cluster of database servers.\r\n\r\nThere are two types of Nodes:\r\n\r\n    Device Node\r\n    Execution Environment Node\r\n\r\nDevice nodes are physical computing resources with processing memory and services to execute software, such as typical computers or mobile phones. An execution environment node (EEN) is a software computing resource that runs within an outer node and which itself provides a service to host and execute other executable software elements. ",
                "comment": "#diagram #ULM",
                "selector": {
                    "quote": "Deployment diagram\r\nFrom Wikipedia, the free encyclopedia\r\nJump to navigation\r\nJump to search\r\nA sample deployment diagram\r\nUML diagram types\r\nStructural UML diagrams\r\n\r\n    Class diagram\r\n    Component diagram\r\n    Composite structure diagram\r\n    Deployment diagram\r\n    Object diagram\r\n    Package diagram\r\n    Profile diagram\r\n\r\nBehavioral UML diagrams\r\n\r\n    Activity diagram\r\n    Communication diagram\r\n    Interaction overview diagram\r\n    Sequence diagram\r\n    State diagram\r\n    Timing diagram\r\n    Use case diagram\r\n\r\n    vte\r\n\r\nA deployment diagram in the Unified Modeling Language models the physical deployment of artifacts on nodes.[1] To describe a web site, for example, a deployment diagram would show what hardware components (\"nodes\") exist (e.g., a web server, an application server, and a database server), what software components (\"artifacts\") run on each node (e.g., web application, database), and how the different pieces are connected (e.g. JDBC, REST, RMI).\r\n\r\nThe nodes appear as boxes, and the artifacts allocated to each node appear as rectangles within the boxes. Nodes may have subnodes, which appear as nested boxes. A single node in a deployment diagram may conceptually represent multiple physical nodes, such as a cluster of database servers.\r\n\r\nThere are two types of Nodes:\r\n\r\n    Device Node\r\n    Execution Environment Node\r\n\r\nDevice nodes are physical computing resources with processing memory and services to execute software, such as typical computers or mobile phones. An execution environment node (EEN) is a software computing resource that runs within an outer node and which itself provides a service to host and execute other executable software elements. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "TextPositionSelector",
                                "start": 12,
                                "end": 127
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Deployment diagram\n\t\n\t\tFrom Wikipedia, the free encyclopedia\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tJump to navigation\n\t\tJump to search\n\t\t  ",
                                "prefix": "\n\n\n\t\n\t\n\t\n\t\n\t",
                                "suffix": "A sample deployment diagram\nUML "
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T02:59:40.435Z",
                "lastEdited": "2020-12-26T03:00:04.800Z",
                "url": "https://en.wikipedia.org/wiki/Deployment_diagram/#1608951580435"
            }
        },
        {
            "timestamp": 1608951614121,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Deployment_diagram/#1608951516921",
            "operation": "delete",
            "object": {}
        },
        {
            "timestamp": 1608951663337,
            "collection": "pages",
            "objectPk": "en.wikipedia.org/wiki/Unified_Modeling_Language",
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Unified_Modeling_Language",
                "fullUrl": "https://en.wikipedia.org/wiki/Unified_Modeling_Language",
                "domain": "wikipedia.org",
                "hostname": "en.wikipedia.org",
                "fullTitle": "Unified Modeling Language - Wikipedia",
                "text": " Unified Modeling Language From Wikipedia, the free encyclopedia Jump to navigation Jump to search UML logo The Unified Modeling Language (UML) is a general-purpose, developmental, modeling language in the field of software engineering that is intended to provide a standard way to visualize the design of a system. [1] The creation of UML was originally motivated by the desire to standardize the disparate notational systems and approaches to software design. It was developed at Rational Software in 1994 1995, with further development led by them through 1996. [1] In 1997, UML was adopted as a standard by the Object Management Group (OMG), and has been managed by this organization ever since. In 2005, UML was also published by the International Organization for Standardization (ISO) as an approved ISO standard. [2] Since then the standard has been periodically revised to cover the latest revision of UML. [3] Contents 1 History 1.1 Before UML 1.0 1.2 UML 1.x 1.2.1 Cardinality notation 1.3 UML 2 2 Design 2.1 Software development methods 2.2 Modeling 3 Diagrams 3.1 Structure diagrams 3.2 Behavior diagrams 3.3 Interaction diagrams 4 Metamodeling 5 Adoption 6 See also 7 References 8 Further reading 9 External links History [ edit ] History of object-oriented methods and notation Before UML 1.0 [ edit ] UML has been evolving since the second half of the 1990s and has its roots in the object-oriented programming methods developed in the late 1980s and early 1990s. The timeline (see image) shows the highlights of the history of object-oriented modeling methods and notation. It is originally based on the notations of the Booch method , the object-modeling technique (OMT) and object-oriented software engineering (OOSE), which it has integrated into a single language. [4] Rational Software Corporation hired James Rumbaugh from General Electric in 1994 and after that the company became the source for two of the most popular object-oriented modeling approaches of the day: [5] Rumbaugh's object-modeling technique (OMT) and Grady Booch 's method. They were soon assisted in their efforts by Ivar Jacobson , the creator of the object-oriented software engineering (OOSE) method, who joined them at Rational in 1995. [1] UML 1.x [ edit ] Under the technical leadership of those three (Rumbaugh, Jacobson and Booch), a consortium called the UML Partners was organized in 1996 to complete the Unified Modeling Language (UML) specification, and propose it to the Object Management Group (OMG) for standardization. The partnership also contained additional interested parties (for example HP , DEC , IBM and Microsoft ). The UML Partners' UML 1.0 draft was proposed to the OMG in January 1997 by the consortium. During the same month the UML Partners formed a group, designed to define the exact meaning of language constructs, chaired by Cris Kobryn and administered by Ed Eykholt, to finalize the specification and integrate it with other standardization efforts. The result of this work, UML 1.1, was submitted to the OMG in August 1997 and adopted by the OMG in November 1997. [1] [6] After the first release a task force was formed [1] to improve the language, which released several minor revisions, 1.3, 1.4, and 1.5. [7] The standards it produced (as well as the original standard) have been noted as being ambiguous and inconsistent. [8] [9] Cardinality notation [ edit ] As with database Chen, Bachman, and ISO ER diagrams , class models are specified to use \"look-across\" cardinalities , even though several authors ( Merise , [10] Elmasri & Navathe [11] amongst others [12] ) prefer same-side or \"look-here\" for roles and both minimum and maximum cardinalities. Recent researchers (Feinerer, [13] Dullea et al. [14] ) have shown that the \"look-across\" technique used by UML and ER diagrams is less effective and less coherent when applied to n-ary relationships of order strictly greater than 2. Feinerer says: \"Problems arise if we operate under the look-across semantics as used for UML associations. Hartmann [15] investigates this situation and shows how and why different transformations fail.\", and: \"As we will see on the next few pages, the look-across interpretation introduces several difficulties which prevent the extension of simple mechanisms from binary to n-ary associations.\" UML 2 [ edit ] UML 2.0 major revision replaced version 1.5 in 2005, which was developed with an enlarged consortium to improve the language further to reflect new experience on usage of its features. [16] Although UML 2.1 was never released as a formal specification, versions 2.1.1 and 2.1.2 appeared in 2007, followed by UML 2.2 in February 2009. UML 2.3 was formally released in May 2010. [17] UML 2.4.1 was formally released in August 2011. [17] UML 2.5 was released in October 2012 as an \"In progress\" version and was officially released in June 2015. [17] Formal version 2.5.1 was adopted in December 2017. [18] There are four parts to the UML 2.x specification: The Superstructure that defines the notation and semantics for diagrams and their model elements The Infrastructure that defines the core metamodel on which the Superstructure is based The Object Constraint Language (OCL) for defining rules for model elements The UML Diagram Interchange that defines how UML 2 diagram layouts are exchanged Until UML 2.4.1, the latest versions of these standards were: [19] UML Superstructure version 2.4.1 UML Infrastructure version 2.4.1 OCL version 2.3.1 UML Diagram Interchange version 1.0. Since version 2.5, the UML Specification has been simplified (without Superstructure and Infrastructure), and the latest versions of these standards are now: [20] UML Specification 2.5.1 OCL version 2.4 It continues to be updated and improved by the revision task force, who resolve any issues with the language. [21] Design [ edit ] UML offers a way to visualize a system's architectural blueprints in a diagram, including elements such as: [4] any activities (jobs); individual components of the system; and how they can interact with other software components ; how the system will run; how entities interact with others (components and interfaces); external user interface . Although originally intended for object-oriented design documentation, UML has been extended to a larger set of design documentation (as listed above), [22] and been found useful in many contexts. [23] Software development methods [ edit ] UML is not a development method by itself; [24] however, it was designed to be compatible with the leading object-oriented software development methods of its time, for example OMT , Booch method , Objectory and especially RUP that it was originally intended to be used with when work began at Rational Software. Modeling [ edit ] It is important to distinguish between the UML model and the set of diagrams of a system. A diagram is a partial graphic representation of a system's model. The set of diagrams need not completely cover the model and deleting a diagram does not change the model. The model may also contain documentation that drives the model elements and diagrams (such as written use cases). UML diagrams represent two different views of a system model: [25] Static (or structural) view: emphasizes the static structure of the system using objects, attributes, operations and relationships. It includes class diagrams and composite structure diagrams . Dynamic (or behavioral) view: emphasizes the dynamic behavior of the system by showing collaborations among objects and changes to the internal states of objects. This view includes sequence diagrams , activity diagrams and state machine diagrams . UML models can be exchanged among UML tools by using the XML Metadata Interchange (XMI) format. In UML, one of the key tools for behavior modeling is the use-case model, caused by OOSE . Use cases are a way of specifying required usages of a system. Typically, they are used to capture the requirements of a system, that is, what a system is supposed to do. [26] Diagrams [ edit ] UML diagram types Structural UML diagrams Class diagram Component diagram Composite structure diagram Deployment diagram Object diagram Package diagram Profile diagram Behavioral UML diagrams Activity diagram Communication diagram Interaction overview diagram Sequence diagram State diagram Timing diagram Use case diagram v t e UML 2 has many types of diagrams, which are divided into two categories. [4] Some types represent structural information, and the rest represent general types of behavior, including a few that represent different aspects of interactions. These diagrams can be categorized hierarchically as shown in the following class diagram: [4] These diagrams may all contain comments or notes explaining usage, constraint, or intent. Structure diagrams [ edit ] Structure diagrams emphasize the things that must be present in the system being modeled. Since structure diagrams represent the structure, they are used extensively in documenting the software architecture of software systems. For example, the component diagram describes how a software system is split up into components and shows the dependencies among these components. Component diagram Class diagram Behavior diagrams [ edit ] Behavior diagrams emphasize what must happen in the system being modeled. Since behavior diagrams illustrate the behavior of a system, they are used extensively to describe the functionality of software systems. As an example, the activity diagram describes the business and operational step-by-step activities of the components in a system. Activity diagram Use case diagram Interaction diagrams [ edit ] Interaction diagrams, a subset of behavior diagrams, emphasize the flow of control and data among the things in the system being modeled. For example, the sequence diagram shows how objects communicate with each other regarding a sequence of messages. Sequence diagram Communication diagram Metamodeling [ edit ] Main article: Meta-Object Facility Illustration of the Meta-Object Facility The Object Management Group (OMG) has developed a metamodeling architecture to define the UML, called the Meta-Object Facility . [27] MOF is designed as a four-layered architecture, as shown in the image at right. It provides a meta-meta model at the top, called the M3 layer. This M3-model is the language used by Meta-Object Facility to build metamodels, called M2-models. The most prominent example of a Layer 2 Meta-Object Facility model is the UML metamodel, which describes the UML itself. These M2-models describe elements of the M1-layer, and thus M1-models. These would be, for example, models written in UML. The last layer is the M0-layer or data layer. It is used to describe runtime instances of the system. [28] The meta-model can be extended using a mechanism called stereotyping . This has been criticized as being insufficient/untenable by Brian Henderson-Sellers and Cesar Gonzalez-Perez in \"Uses and Abuses of the Stereotype Mechanism in UML 1.x and 2.0\". [29] Adoption [ edit ] UML has been marketed for many contexts. [23] [30] It has been treated, at times, as a design silver bullet , which leads to problems. UML misuse includes overuse (designing every part of the system with it, which is unnecessary) and assuming that novices can design with it. [31] It is considered a large language, with many constructs . Some people (including Jacobson ) feel that UML's size hinders learning (and therefore, using) it. [32] See also [ edit ] Applications of UML Business Process Model and Notation (BPMN) C4 model Model-based testing Model-driven engineering Object Oriented Role Analysis and Modeling Systems Modeling Language (SysML) List of Unified Modeling Language tools References [ edit ] ^ Jump up to: a b c d e Unified Modeling Language User Guide, The (2 ed.). Addison-Wesley. 2005. p. 496. ISBN 0321267974 . , See the sample content, look for history ^ \"ISO/IEC 19501:2005 - Information technology - Open Distributed Processing - Unified Modeling Language (UML) Version 1.4.2\" . Iso.org. 1 April 2005 . Retrieved 7 May 2015. ^ \"ISO/IEC 19505-1:2012 - Information technology - Object Management Group Unified Modeling Language (OMG UML) - Part 1: Infrastructure\" . Iso.org. 20 April 2012 . Retrieved 10 April 2014. ^ Jump up to: a b c d \"OMG Unified Modeling Language (OMG UML), Superstructure. Version 2.4.1\" . Object Management Group . Retrieved 9 April 2014. ^ Andreas Zendler (1997) Advanced Concepts, Life Cycle Models and Tools for Objeckt-Oriented Software Development. p. 122 ^ \"UML Specification version 1.1 (OMG document ad/97-08-11)\" . Omg.org . Retrieved 22 September 2011. ^ \"UML\" . Omg.org . Retrieved 10 April 2014. ^ Génova et alia 2004 \"Open Issues in Industrial Use Case Modeling\" ^ \"Will UML 2.0 Be Agile or Awkward?\" (PDF) . Retrieved 22 September 2011. ^ Hubert Tardieu, Arnold Rochfeld and René Colletti La methode MERISE: Principes et outils (Paperback - 1983) ^ Elmasri, Ramez, B. Shamkant, Navathe, Fundamentals of Database Systems, third ed., Addison-Wesley, Menlo Park, CA, USA, 2000. ^ ER 2004 : 23rd International Conference on Conceptual Modeling, Shanghai, China, 8-12 November 2004 Archived 27 May 2013 at the Wayback Machine ^ \"A Formal Treatment of UML Class Diagrams as an Efficient Method for Configuration Management 2007\" (PDF) . Retrieved 22 September 2011. ^ \"James Dullea, Il-Yeol Song, Ioanna Lamprou - An analysis of structural validity in entity-relationship modeling 2002\" (PDF) . Retrieved 22 September 2011. ^ \" \"Reasoning about participation constraints and Chen's constraints\" S Hartmann - 2003\" (PDF) . Retrieved 17 August 2013. ^ \"UML 2.0\" . Omg.org . Retrieved 22 September 2011. ^ Jump up to: a b c \"UML\" . Omg.org . Retrieved 22 September 2011. ^ \"UML 2.5.1 specification\" . Omg.org . Retrieved 24 October 2018. ^ OMG. \"OMG Formal Specifications (Modeling and Metadata paragraph)\" . Retrieved 12 February 2016. ^ OMG. \"about the unified modeling language specificationn\" . Retrieved 22 February 2020. ^ \"Issues for UML 2.6 Revision task Force mailing list\" . Omg.org . Retrieved 10 April 2014. ^ Satish Mishra (1997). \"Visual Modeling & Unified Modeling Language (UML): Introduction to UML\" . Rational Software Corporation. Accessed 9 November 2008. ^ Jump up to: a b \"UML, Success Stories\" . Retrieved 9 April 2014. ^ John Hunt (2000). The Unified Process for Practitioners: Object-oriented Design, UML and Java. Springer, 2000. ISBN 1-85233-275-1 . p. 5.door ^ Jon Holt Institution of Electrical Engineers (2004). UML for Systems Engineering: Watching the Wheels IET, 2004, ISBN 0-86341-354-4 . p. 58 ^ Manuel Almendros-Jiménez, Jesús & Iribarne, Luis. (2007). Describing Use-Case Relationships with Sequence Diagrams. Comput. J.. 50. 116-128. 10.1093/comjnl/bxl053. ^ Iman Poernomo (2006) \" The Meta-Object Facility Typed \" in: Proceeding SAC '06 Proceedings of the 2006 ACM symposium on Applied computing. pp. 1845 1849 ^ \"UML 2.4.1 Infrastructure\" . Omg.org. 5 August 2011 . Retrieved 10 April 2014. ^ B. Henderson-Sellers; C. Gonzalez-Perez (2006). \"Uses and Abuses of the Stereotype Mechanism in UML 1.x and 2.0\". in: Model Driven Engineering Languages and Systems. Springer Berlin / Heidelberg. ^ \"UML 2.5: Do you even care?\" . \"UML truly is ubiquitous\" ^ \"Death by UML Fever\" . ^ \"Ivar Jacobson on UML, MDA, and the future of methodologies\" . This article is based on material taken from the Free On-line Dictionary of Computing prior to 1 November 2008 and incorporated under the \"relicensing\" terms of the GFDL , version 1.3 or later. Further reading [ edit ] Ambler, Scott William (2004). The Object Primer: Agile Model Driven Development with UML 2 . Cambridge University Press. ISBN 0-521-54018-6 . Chonoles, Michael Jesse; James A. Schardt (2003). UML 2 for Dummies . Wiley Publishing. ISBN 0-7645-2614-6 . Fowler, Martin (2004). UML Distilled: A Brief Guide to the Standard Object Modeling Language (3rd ed.). Addison-Wesley. ISBN 0-321-19368-7 . Jacobson, Ivar ; Grady Booch; James Rumbaugh (1998). The Unified Software Development Process. Addison Wesley Longman. ISBN 0-201-57169-2 . Martin, Robert Cecil (2003). UML for Java Programmers . Prentice Hall. ISBN 0-13-142848-9 . Noran, Ovidiu S. \"Business Modelling: UML vs. IDEF\" (PDF) . Retrieved 28 December 2005. Horst Kargl. \"Interactive UML Metamodel with additional Examples\" . Penker, Magnus; Hans-Erik Eriksson (2000). Business Modeling with UML . John Wiley & Sons. ISBN 0-471-29551-5 . Douglass, Bruce Powel. \"Bruce Douglass: Real-Time Agile Systems and Software Development\" (web) . Retrieved 1 January 2019. Douglass, Bruce (2014). Real-Time UML Workshop 2nd Edition . Newnes. ISBN 978-0-471-29551-8 . Douglass, Bruce (2004). Real-Time UML 3rd Edition. Newnes. ISBN 978-0321160768 . Douglass, Bruce (2002). Real-Time Design Patterns. Addison-Wesley Professional. ISBN 978-0201699562 . Douglass, Bruce (2009). Real-Time Agility. Addison-Wesley Professional. ISBN 978-0321545497 . Douglass, Bruce (2010). Design Patterns for Embedded Systems in C. Newnes. ISBN 978-1856177078 . External links [ edit ] Wikimedia Commons has media related to Unified Modeling Language . Wikiversity has learning resources about UML Official website show v t e Unified Modeling Language Actors Organizations Object Management Group UML Partners Persons Grady Booch Ivar Jacobson James Rumbaugh Concepts Object oriented Object-oriented programming Object-oriented analysis and design Object-oriented modeling Structure Actor Attribute Artifact Class Component Interface Object Package Profile diagram Behavior Activity Event Message Method State Use case Relationships Association Composition Dependency Generalization (or Inheritance ) Extensibility Profile Stereotype Other Multiplicity Diagrams Structure Class Component Composite structure Deployment Object Package Behaviour Activity State Machine Use case Interaction Communications Sequence Interaction overview Timing Derived languages Systems Modeling Language (SysML) UML eXchange Format (UXF) XML Metadata Interchange (XMI) Executable UML (xUML) Other topics Glossary of UML terms Rational Unified Process List of Unified Modeling Language tools Object Modeling in Color show v t e Software engineering Fields Computer programming Requirements engineering Software deployment Software design Software maintenance Software testing Systems analysis Formal methods Concepts Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software verification and validation Structured analysis Essential Analysis Orientations Agile Aspect-oriented Object orientation Ontology Service orientation SDLC Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD UP Scrum Spiral model V-Model Waterfall model XP Other SPICE CMMI Data model ER model Function model Information model Metamodeling Object model Systems model View model Languages IDEF UML USL SysML Software engineers Victor Basili Kent Beck Grady Booch Fred Brooks Barry Boehm Peter Chen Danese Cooper Ward Cunningham Tom DeMarco Edsger W. Dijkstra Delores M. Etter Martin Fowler Adele Goldstine Margaret Hamilton C. A. R. Hoare Lois Haibt Mary Jean Harrold Grace Hopper Watts Humphrey Michael A. Jackson Ivar Jacobson Alan Kay Nancy Leveson Stephen J. Mellor Bertrand Meyer David Parnas Trygve Reenskaug Winston W. Royce James Rumbaugh Mary Shaw Peri Tarr Elaine Weyuker Niklaus Wirth Edward Yourdon Related fields Theoretical computer science Computer engineering Project management Risk management Systems engineering Category Commons show v t e ISO standards by standard number List of ISO standards / ISO romanizations / IEC standards 1 9999 1 2 3 4 5 6 7 9 16 17 31 -0 -1 -2 -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 -13 68-1 128 216 217 226 228 233 259 261 262 269 302 306 361 428 500 518 519 639 -1 -2 -3 -5 -6 646 657 668 690 704 732 764 838 843 860 898 965 999 1000 1004 1007 1073-1 1073-2 1155 1413 1538 1629 1745 1989 2014 2015 2022 2033 2047 2108 2145 2146 2240 2281 2533 2709 2711 2720 2788 2848 2852 3029 3103 3166 -1 -2 -3 3297 3307 3601 3602 3864 3901 3950 3977 4031 4157 4165 4217 4909 5218 5426 5427 5428 5725 5775 5776 5800 5807 5964 6166 6344 6346 6385 6425 6429 6438 6523 6709 6943 7001 7002 7010 7027 7064 7098 7185 7200 7498 -1 7637 7736 7810 7811 7812 7813 7816 7942 8000 8093 8178 8217 8373 8501-1 8571 8583 8601 8613 8632 8651 8652 8691 8805/8806 8807 8820-5 8859 -1 -2 -3 -4 -5 -6 -7 -8 -8-I -9 -10 -11 -12 -13 -14 -15 -16 8879 9000/9001 9036 9075 9126 9141 9227 9241 9293 9314 9362 9407 9496 9506 9529 9564 9592/9593 9594 9660 9797-1 9897 9899 9945 9984 9985 9995 10000 19999 10005 10006 10007 10116 10118-3 10160 10161 10165 10179 10206 10218 10303 -11 -21 -22 -28 -238 10383 10487 10585 10589 10646 10664 10746 10861 10957 10962 10967 11073 11170 11179 11404 11544 11783 11784 11785 11801 11889 11898 11940 ( -2 ) 11941 11941 (TR) 11992 12006 12182 12207 12234-2 12620 13211 -1 -2 13216 13250 13399 13406-2 13450 13485 13490 13567 13568 13584 13616 13816 14000 14031 14224 14289 14396 14443 14496 -2 -3 -6 -10 -11 -12 -14 -17 -20 14644 14649 14651 14698 14750 14764 14882 14971 15022 15189 15288 15291 15292 15398 15408 15444 -3 15445 15438 15504 15511 15686 15693 15706 -2 15707 15897 15919 15924 15926 15926 WIP 15930 16023 16262 16355-1 16612-2 16750 16949 (TS) 17024 17025 17100 17203 17369 17442 17799 18000 18004 18014 18245 18629 18916 19005 19011 19092 -1 -2 19114 19115 19125 19136 19407 19439 19500 19501 19502 19503 19505 19506 19507 19508 19509 19510 19600 19752 19757 19770 19775-1 19794-5 19831 20000+ 20000 20022 20121 20400 21000 21047 21500 21827 22000 22300 22395 23270 23271 23360 24517 24613 24617 24707 25178 25964 26000 26262 26300 26324 27000 series 27000 27001 27002 27005 27006 27729 28000 29110 29148 29199-2 29500 30170 31000 32000 37001 38500 40500 42010 45001 50001 55000 80000 -1 Category Authority control BNF : cb131836959 (data) GND : 4469781-8 LCCN : sh97003561 Retrieved from \" https://en.wikipedia.org/w/index.php?title=Unified_Modeling_Language&oldid=995671378 \" Categories : Unified Modeling Language Architecture description language Data modeling languages Data modeling diagrams Diagrams Knowledge representation ISO standards Specification languages Software modeling language Modeling languages Hidden categories: Webarchive template wayback links Use American English from March 2020 All Wikipedia articles written in American English Use dmy dates from September 2020 Commons link from Wikidata Wikipedia articles with BNF identifiers Wikipedia articles with GND identifiers Wikipedia articles with LCCN identifiers Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikibooks Wikiversity Languages Afrikaans العربية Azərbaycanca Български Bosanski Català Čeština Dansk Deutsch Eesti Ελληνικά Español Esperanto Euskara فارسی Français Galego 한국어 हिन्दी Bahasa Indonesia Interlingua Íslenska Italiano עברית Lietuvių Magyar Македонски മലയാളം Bahasa Melayu Монгол Nederlands 日本語 Norsk bokmål Polski Português Română Русский Shqip Simple English Slovenčina Slovenščina Српски / srpski Suomi Svenska தமிழ் తెలుగు ไทย Türkçe Українська Tiếng Việt Yorùbá 中文 43 more Edit links This page was last edited on 22 December 2020, at 06:58 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License ; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement Enable previews ",
                "urlTerms": [
                    "wiki",
                    "unified",
                    "modeling",
                    "language"
                ],
                "titleTerms": [
                    "unified",
                    "modeling",
                    "language",
                    "wikipedia"
                ]
            }
        },
        {
            "timestamp": 1608951663378,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "en.wikipedia.org/wiki/Unified_Modeling_Language"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "en.wikipedia.org/wiki/Unified_Modeling_Language",
                "fullUrl": "https://en.wikipedia.org/wiki/Unified_Modeling_Language",
                "createdAt": "2020-12-26T03:01:03.363Z"
            }
        },
        {
            "timestamp": 1608951663391,
            "collection": "visits",
            "objectPk": [
                1608951663386,
                "en.wikipedia.org/wiki/Unified_Modeling_Language"
            ],
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Unified_Modeling_Language",
                "time": 1608951663386
            }
        },
        {
            "timestamp": 1608951663401,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Unified_Modeling_Language/#1608951663022",
            "operation": "create",
            "object": {
                "pageTitle": "Unified Modeling Language - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Unified_Modeling_Language",
                "body": "UML offers a way to visualize a system's architectural blueprints in a diagram, including elements such as:[4]\r\n\r\n    any activities (jobs);\r\n    individual components of the system;\r\n        and how they can interact with other software components;\r\n    how the system will run;\r\n    how entities interact with others (components and interfaces);\r\n    external user interface.\r\n\r\nAlthough originally intended for object-oriented design documentation, UML has been extended to a larger set of design documentation (as listed above),[22] and been found useful in many contexts.[23]",
                "comment": "",
                "selector": {
                    "quote": "UML offers a way to visualize a system's architectural blueprints in a diagram, including elements such as:[4]\r\n\r\n    any activities (jobs);\r\n    individual components of the system;\r\n        and how they can interact with other software components;\r\n    how the system will run;\r\n    how entities interact with others (components and interfaces);\r\n    external user interface.\r\n\r\nAlthough originally intended for object-oriented design documentation, UML has been extended to a larger set of design documentation (as listed above),[22] and been found useful in many contexts.[23]",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[19]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[20]/sup[2]/a[1]",
                                "endOffset": 4
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 5857,
                                "end": 6399
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "UML offers a way to visualize a system's architectural blueprints in a diagram, including elements such as:[4]\n\nany activities (jobs);\nindividual components of the system;\nand how they can interact with other software components;\nhow the system will run;\nhow entities interact with others (components and interfaces);\nexternal user interface.\nAlthough originally intended for object-oriented design documentation, UML has been extended to a larger set of design documentation (as listed above),[22] and been found useful in many contexts.[23]",
                                "prefix": "the language.[21]\n\nDesign[edit]\n",
                                "suffix": "\n\nSoftware development methods[e"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:01:03.022Z",
                "lastEdited": "2020-12-26T03:01:03.022Z",
                "url": "https://en.wikipedia.org/wiki/Unified_Modeling_Language/#1608951663022"
            }
        },
        {
            "timestamp": 1608951756049,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Unified_Modeling_Language/#1608951756012",
            "operation": "create",
            "object": {
                "pageTitle": "Unified Modeling Language - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Unified_Modeling_Language",
                "body": "The Object Management Group (OMG) has developed a metamodeling architecture to define the UML, called the Meta-Object Facility.[27] MOF is designed as a four-layered architecture, as shown in the image at right. It provides a meta-meta model at the top, called the M3 layer. This M3-model is the language used by Meta-Object Facility to build metamodels, called M2-models.\r\n\r\nThe most prominent example of a Layer 2 Meta-Object Facility model is the UML metamodel, which describes the UML itself. These M2-models describe elements of the M1-layer, and thus M1-models. These would be, for example, models written in UML. The last layer is the M0-layer or data layer. It is used to describe runtime instances of the system.[28]\r\n\r\nThe meta-model can be extended using a mechanism called stereotyping. This has been criticized as being insufficient/untenable by Brian Henderson-Sellers and Cesar Gonzalez-Perez in \"Uses and Abuses of the Stereotype Mechanism in UML 1.x and 2.0\"",
                "comment": "#UML #diagram",
                "selector": {
                    "quote": "The Object Management Group (OMG) has developed a metamodeling architecture to define the UML, called the Meta-Object Facility.[27] MOF is designed as a four-layered architecture, as shown in the image at right. It provides a meta-meta model at the top, called the M3 layer. This M3-model is the language used by Meta-Object Facility to build metamodels, called M2-models.\r\n\r\nThe most prominent example of a Layer 2 Meta-Object Facility model is the UML metamodel, which describes the UML itself. These M2-models describe elements of the M1-layer, and thus M1-models. These would be, for example, models written in UML. The last layer is the M0-layer or data layer. It is used to describe runtime instances of the system.[28]\r\n\r\nThe meta-model can be extended using a mechanism called stereotyping. This has been criticized as being insufficient/untenable by Brian Henderson-Sellers and Cesar Gonzalez-Perez in \"Uses and Abuses of the Stereotype Mechanism in UML 1.x and 2.0\"",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[31]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[33]",
                                "endOffset": 246
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 11060,
                                "end": 12029
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "The Object Management Group (OMG) has developed a metamodeling architecture to define the UML, called the Meta-Object Facility.[27] MOF is designed as a four-layered architecture, as shown in the image at right. It provides a meta-meta model at the top, called the M3 layer. This M3-model is the language used by Meta-Object Facility to build metamodels, called M2-models.\nThe most prominent example of a Layer 2 Meta-Object Facility model is the UML metamodel, which describes the UML itself. These M2-models describe elements of the M1-layer, and thus M1-models. These would be, for example, models written in UML. The last layer is the M0-layer or data layer. It is used to describe runtime instances of the system.[28]\nThe meta-model can be extended using a mechanism called stereotyping. This has been criticized as being insufficient/untenable by Brian Henderson-Sellers and Cesar Gonzalez-Perez in \"Uses and Abuses of the Stereotype Mechanism in UML 1.x and 2.0\"",
                                "prefix": "ion of the Meta-Object Facility\n",
                                "suffix": ".[29]\n\nAdoption[edit]\nUML has be"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:02:36.012Z",
                "lastEdited": "2020-12-26T03:03:32.560Z",
                "url": "https://en.wikipedia.org/wiki/Unified_Modeling_Language/#1608951756012"
            }
        },
        {
            "timestamp": 1608951812577,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Unified_Modeling_Language/#1608951756012",
            "operation": "update",
            "object": {
                "pageTitle": "Unified Modeling Language - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Unified_Modeling_Language",
                "body": "The Object Management Group (OMG) has developed a metamodeling architecture to define the UML, called the Meta-Object Facility.[27] MOF is designed as a four-layered architecture, as shown in the image at right. It provides a meta-meta model at the top, called the M3 layer. This M3-model is the language used by Meta-Object Facility to build metamodels, called M2-models.\r\n\r\nThe most prominent example of a Layer 2 Meta-Object Facility model is the UML metamodel, which describes the UML itself. These M2-models describe elements of the M1-layer, and thus M1-models. These would be, for example, models written in UML. The last layer is the M0-layer or data layer. It is used to describe runtime instances of the system.[28]\r\n\r\nThe meta-model can be extended using a mechanism called stereotyping. This has been criticized as being insufficient/untenable by Brian Henderson-Sellers and Cesar Gonzalez-Perez in \"Uses and Abuses of the Stereotype Mechanism in UML 1.x and 2.0\"",
                "comment": "#UML #diagram",
                "selector": {
                    "quote": "The Object Management Group (OMG) has developed a metamodeling architecture to define the UML, called the Meta-Object Facility.[27] MOF is designed as a four-layered architecture, as shown in the image at right. It provides a meta-meta model at the top, called the M3 layer. This M3-model is the language used by Meta-Object Facility to build metamodels, called M2-models.\r\n\r\nThe most prominent example of a Layer 2 Meta-Object Facility model is the UML metamodel, which describes the UML itself. These M2-models describe elements of the M1-layer, and thus M1-models. These would be, for example, models written in UML. The last layer is the M0-layer or data layer. It is used to describe runtime instances of the system.[28]\r\n\r\nThe meta-model can be extended using a mechanism called stereotyping. This has been criticized as being insufficient/untenable by Brian Henderson-Sellers and Cesar Gonzalez-Perez in \"Uses and Abuses of the Stereotype Mechanism in UML 1.x and 2.0\"",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[31]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[33]",
                                "endOffset": 246
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 11060,
                                "end": 12029
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "The Object Management Group (OMG) has developed a metamodeling architecture to define the UML, called the Meta-Object Facility.[27] MOF is designed as a four-layered architecture, as shown in the image at right. It provides a meta-meta model at the top, called the M3 layer. This M3-model is the language used by Meta-Object Facility to build metamodels, called M2-models.\nThe most prominent example of a Layer 2 Meta-Object Facility model is the UML metamodel, which describes the UML itself. These M2-models describe elements of the M1-layer, and thus M1-models. These would be, for example, models written in UML. The last layer is the M0-layer or data layer. It is used to describe runtime instances of the system.[28]\nThe meta-model can be extended using a mechanism called stereotyping. This has been criticized as being insufficient/untenable by Brian Henderson-Sellers and Cesar Gonzalez-Perez in \"Uses and Abuses of the Stereotype Mechanism in UML 1.x and 2.0\"",
                                "prefix": "ion of the Meta-Object Facility\n",
                                "suffix": ".[29]\n\nAdoption[edit]\nUML has be"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:02:36.012Z",
                "lastEdited": "2020-12-26T03:03:32.560Z",
                "url": "https://en.wikipedia.org/wiki/Unified_Modeling_Language/#1608951756012"
            }
        },
        {
            "timestamp": 1608951835608,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Unified_Modeling_Language/#1608951835582",
            "operation": "create",
            "object": {
                "pageTitle": "Unified Modeling Language - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Unified_Modeling_Language",
                "body": "UML 2 has many types of diagrams, which are divided into two categories.[4] Some types represent structural information, and the rest represent general types of behavior, including a few that represent different aspects of interactions. These diagrams can be categorized hierarchically as shown in the following class diagram",
                "comment": "",
                "selector": {
                    "quote": "UML 2 has many types of diagrams, which are divided into two categories.[4] Some types represent structural information, and the rest represent general types of behavior, including a few that represent different aspects of interactions. These diagrams can be categorized hierarchically as shown in the following class diagram",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[26]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[26]",
                                "endOffset": 325
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 9268,
                                "end": 9593
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "UML 2 has many types of diagrams, which are divided into two categories.[4] Some types represent structural information, and the rest represent general types of behavior, including a few that represent different aspects of interactions. These diagrams can be categorized hierarchically as shown in the following class diagram",
                                "prefix": "ign:left;margin-right:0.5em}vte\n",
                                "suffix": ":[4]\n\n\nThese diagrams may all co"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:03:55.582Z",
                "lastEdited": "2020-12-26T03:03:55.582Z",
                "url": "https://en.wikipedia.org/wiki/Unified_Modeling_Language/#1608951835582"
            }
        },
        {
            "timestamp": 1608951899494,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Unified_Modeling_Language/#1608951899449",
            "operation": "create",
            "object": {
                "pageTitle": "Unified Modeling Language - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Unified_Modeling_Language",
                "body": "Modeling\r\n\r\nIt is important to distinguish between the UML model and the set of diagrams of a system. A diagram is a partial graphic representation of a system's model. The set of diagrams need not completely cover the model and deleting a diagram does not change the model. The model may also contain documentation that drives the model elements and diagrams (such as written use cases).\r\n\r\nUML diagrams represent two different views of a system model:[25]\r\n\r\n    Static (or structural) view: emphasizes the static structure of the system using objects, attributes, operations and relationships. It includes class diagrams and composite structure diagrams.\r\n    Dynamic (or behavioral) view: emphasizes the dynamic behavior of the system by showing collaborations among objects and changes to the internal states of objects. This view includes sequence diagrams, activity diagrams and state machine diagrams.\r\n\r\nUML models can be exchanged among UML tools by using the XML Metadata Interchange (XMI) format.\r\n\r\nIn UML, one of the key tools for behavior modeling is the use-case model, caused by OOSE. Use cases are a way of specifying required usages of a system. Typically, they are used to capture the requirements of a system, that is, what a system is supposed to do",
                "comment": "",
                "selector": {
                    "quote": "Modeling\r\n\r\nIt is important to distinguish between the UML model and the set of diagrams of a system. A diagram is a partial graphic representation of a system's model. The set of diagrams need not completely cover the model and deleting a diagram does not change the model. The model may also contain documentation that drives the model elements and diagrams (such as written use cases).\r\n\r\nUML diagrams represent two different views of a system model:[25]\r\n\r\n    Static (or structural) view: emphasizes the static structure of the system using objects, attributes, operations and relationships. It includes class diagrams and composite structure diagrams.\r\n    Dynamic (or behavioral) view: emphasizes the dynamic behavior of the system by showing collaborations among objects and changes to the internal states of objects. This view includes sequence diagrams, activity diagrams and state machine diagrams.\r\n\r\nUML models can be exchanged among UML tools by using the XML Metadata Interchange (XMI) format.\r\n\r\nIn UML, one of the key tools for behavior modeling is the use-case model, caused by OOSE. Use cases are a way of specifying required usages of a system. Typically, they are used to capture the requirements of a system, that is, what a system is supposed to do",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/h3[5]/span[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/h3[5]/span[2]/span[1]",
                                "endOffset": 0
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 6747,
                                "end": 6755
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Modeling",
                                "prefix": "rk began at Rational Software.\n\n",
                                "suffix": "[edit]\nIt is important to distin"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:04:59.449Z",
                "lastEdited": "2020-12-26T03:04:59.449Z",
                "url": "https://en.wikipedia.org/wiki/Unified_Modeling_Language/#1608951899449"
            }
        },
        {
            "timestamp": 1608951924262,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Unified_Modeling_Language/#1608951924243",
            "operation": "create",
            "object": {
                "pageTitle": "Unified Modeling Language - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Unified_Modeling_Language",
                "comment": "#UML #diagram",
                "createdWhen": "2020-12-26T03:05:24.243Z",
                "lastEdited": "2020-12-26T03:05:24.243Z",
                "url": "https://en.wikipedia.org/wiki/Unified_Modeling_Language/#1608951924243"
            }
        },
        {
            "timestamp": 1608951947566,
            "collection": "pages",
            "objectPk": "en.wikipedia.org/wiki/Distributed_computing",
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Distributed_computing",
                "fullUrl": "https://en.wikipedia.org/wiki/Distributed_computing#cite_ref-tanenbaum_1-0",
                "domain": "wikipedia.org",
                "hostname": "en.wikipedia.org",
                "fullTitle": "https://en.wikipedia.org/wiki/Distributed_computing#cite_ref-tanenbaum_1-0",
                "urlTerms": [
                    "wiki",
                    "distributed",
                    "computing"
                ],
                "titleTerms": []
            }
        },
        {
            "timestamp": 1608951947591,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "en.wikipedia.org/wiki/Distributed_computing"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "en.wikipedia.org/wiki/Distributed_computing",
                "fullUrl": "https://en.wikipedia.org/wiki/Distributed_computing#cite_ref-tanenbaum_1-0",
                "createdAt": "2020-12-26T03:05:47.574Z"
            }
        },
        {
            "timestamp": 1608951947603,
            "collection": "visits",
            "objectPk": [
                1608951947599,
                "en.wikipedia.org/wiki/Distributed_computing"
            ],
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Distributed_computing",
                "time": 1608951947599
            }
        },
        {
            "timestamp": 1608951947611,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Distributed_computing#cite_ref-tanenbaum_1-0/#1608951947458",
            "operation": "create",
            "object": {
                "pageTitle": "Distributed computing - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Distributed_computing",
                "body": "Distributed computing is a field of computer science that studies distributed systems. A distributed system is a system whose components are located on different networked computers, which communicate and coordinate their actions by passing messages to one another.[1] The components interact with one another in order to achieve a common goal. Three significant characteristics of distributed systems are: concurrency of components, lack of a global clock, and independent failure of components.[1] Examples of distributed systems vary from SOA-based systems to massively multiplayer online games to peer-to-peer applications.\r\n\r\nA computer program that runs within a distributed system is called a distributed program (and distributed programming is the process of writing such programs).[2] There are many different types of implementations for the message passing mechanism, including pure HTTP, RPC-like connectors and message queues.[3]\r\n\r\nDistributed computing also refers to the use of distributed systems to solve computational problems. In distributed computing, a problem is divided into many tasks, each of which is solved by one or more computers,[4] which communicate with each other via message passing.[5]",
                "comment": "Distributed Computing - Review priority [RP] medium\n\n#computing #networks",
                "selector": {
                    "quote": "Distributed computing is a field of computer science that studies distributed systems. A distributed system is a system whose components are located on different networked computers, which communicate and coordinate their actions by passing messages to one another.[1] The components interact with one another in order to achieve a common goal. Three significant characteristics of distributed systems are: concurrency of components, lack of a global clock, and independent failure of components.[1] Examples of distributed systems vary from SOA-based systems to massively multiplayer online games to peer-to-peer applications.\r\n\r\nA computer program that runs within a distributed system is called a distributed program (and distributed programming is the process of writing such programs).[2] There are many different types of implementations for the message passing mechanism, including pure HTTP, RPC-like connectors and message queues.[3]\r\n\r\nDistributed computing also refers to the use of distributed systems to solve computational problems. In distributed computing, a problem is divided into many tasks, each of which is solved by one or more computers,[4] which communicate with each other via message passing.[5]",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[1]/b[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[3]/sup[2]/a[1]",
                                "endOffset": 3
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 444,
                                "end": 1660
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Distributed computing is a field of computer science that studies distributed systems. A distributed system is a system whose components are located on different networked computers, which communicate and coordinate their actions by passing messages to one another.[1] The components interact with one another in order to achieve a common goal. Three significant characteristics of distributed systems are: concurrency of components, lack of a global clock, and independent failure of components.[1] Examples of distributed systems vary from SOA-based systems to massively multiplayer online games to peer-to-peer applications.\nA computer program that runs within a distributed system is called  a distributed program (and distributed programming is the process of writing such programs).[2] There are many different types of implementations for the message passing mechanism, including pure HTTP, RPC-like connectors and message queues.[3]\nDistributed computing also refers to the use of distributed systems to solve computational problems. In distributed computing, a problem is divided into many tasks, each of which is solved by one or more computers,[4] which communicate with each other via message passing.[5]",
                                "prefix": "uter company, see DIP Research.\n",
                                "suffix": "\n\nContents\n\n1 Introduction\n2 Par"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:05:47.458Z",
                "lastEdited": "2020-12-26T03:07:15.733Z",
                "url": "https://en.wikipedia.org/wiki/Distributed_computing#cite_ref-tanenbaum_1-0/#1608951947458"
            }
        },
        {
            "timestamp": 1608952022174,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Distributed_computing#cite_ref-tanenbaum_1-0/#1608951947458",
            "operation": "update",
            "object": {
                "pageTitle": "Distributed computing - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Distributed_computing",
                "body": "Distributed computing is a field of computer science that studies distributed systems. A distributed system is a system whose components are located on different networked computers, which communicate and coordinate their actions by passing messages to one another.[1] The components interact with one another in order to achieve a common goal. Three significant characteristics of distributed systems are: concurrency of components, lack of a global clock, and independent failure of components.[1] Examples of distributed systems vary from SOA-based systems to massively multiplayer online games to peer-to-peer applications.\r\n\r\nA computer program that runs within a distributed system is called a distributed program (and distributed programming is the process of writing such programs).[2] There are many different types of implementations for the message passing mechanism, including pure HTTP, RPC-like connectors and message queues.[3]\r\n\r\nDistributed computing also refers to the use of distributed systems to solve computational problems. In distributed computing, a problem is divided into many tasks, each of which is solved by one or more computers,[4] which communicate with each other via message passing.[5]",
                "comment": "Distributed Computing - Review priority [RP] medium\n\n#computing #networks",
                "selector": {
                    "quote": "Distributed computing is a field of computer science that studies distributed systems. A distributed system is a system whose components are located on different networked computers, which communicate and coordinate their actions by passing messages to one another.[1] The components interact with one another in order to achieve a common goal. Three significant characteristics of distributed systems are: concurrency of components, lack of a global clock, and independent failure of components.[1] Examples of distributed systems vary from SOA-based systems to massively multiplayer online games to peer-to-peer applications.\r\n\r\nA computer program that runs within a distributed system is called a distributed program (and distributed programming is the process of writing such programs).[2] There are many different types of implementations for the message passing mechanism, including pure HTTP, RPC-like connectors and message queues.[3]\r\n\r\nDistributed computing also refers to the use of distributed systems to solve computational problems. In distributed computing, a problem is divided into many tasks, each of which is solved by one or more computers,[4] which communicate with each other via message passing.[5]",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[1]/b[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[3]/sup[2]/a[1]",
                                "endOffset": 3
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 444,
                                "end": 1660
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Distributed computing is a field of computer science that studies distributed systems. A distributed system is a system whose components are located on different networked computers, which communicate and coordinate their actions by passing messages to one another.[1] The components interact with one another in order to achieve a common goal. Three significant characteristics of distributed systems are: concurrency of components, lack of a global clock, and independent failure of components.[1] Examples of distributed systems vary from SOA-based systems to massively multiplayer online games to peer-to-peer applications.\nA computer program that runs within a distributed system is called  a distributed program (and distributed programming is the process of writing such programs).[2] There are many different types of implementations for the message passing mechanism, including pure HTTP, RPC-like connectors and message queues.[3]\nDistributed computing also refers to the use of distributed systems to solve computational problems. In distributed computing, a problem is divided into many tasks, each of which is solved by one or more computers,[4] which communicate with each other via message passing.[5]",
                                "prefix": "uter company, see DIP Research.\n",
                                "suffix": "\n\nContents\n\n1 Introduction\n2 Par"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:05:47.458Z",
                "lastEdited": "2020-12-26T03:07:15.733Z",
                "url": "https://en.wikipedia.org/wiki/Distributed_computing#cite_ref-tanenbaum_1-0/#1608951947458"
            }
        },
        {
            "timestamp": 1608952035750,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Distributed_computing#cite_ref-tanenbaum_1-0/#1608951947458",
            "operation": "update",
            "object": {
                "pageTitle": "Distributed computing - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Distributed_computing",
                "body": "Distributed computing is a field of computer science that studies distributed systems. A distributed system is a system whose components are located on different networked computers, which communicate and coordinate their actions by passing messages to one another.[1] The components interact with one another in order to achieve a common goal. Three significant characteristics of distributed systems are: concurrency of components, lack of a global clock, and independent failure of components.[1] Examples of distributed systems vary from SOA-based systems to massively multiplayer online games to peer-to-peer applications.\r\n\r\nA computer program that runs within a distributed system is called a distributed program (and distributed programming is the process of writing such programs).[2] There are many different types of implementations for the message passing mechanism, including pure HTTP, RPC-like connectors and message queues.[3]\r\n\r\nDistributed computing also refers to the use of distributed systems to solve computational problems. In distributed computing, a problem is divided into many tasks, each of which is solved by one or more computers,[4] which communicate with each other via message passing.[5]",
                "comment": "Distributed Computing - Review priority [RP] medium\n\n#computing #networks",
                "selector": {
                    "quote": "Distributed computing is a field of computer science that studies distributed systems. A distributed system is a system whose components are located on different networked computers, which communicate and coordinate their actions by passing messages to one another.[1] The components interact with one another in order to achieve a common goal. Three significant characteristics of distributed systems are: concurrency of components, lack of a global clock, and independent failure of components.[1] Examples of distributed systems vary from SOA-based systems to massively multiplayer online games to peer-to-peer applications.\r\n\r\nA computer program that runs within a distributed system is called a distributed program (and distributed programming is the process of writing such programs).[2] There are many different types of implementations for the message passing mechanism, including pure HTTP, RPC-like connectors and message queues.[3]\r\n\r\nDistributed computing also refers to the use of distributed systems to solve computational problems. In distributed computing, a problem is divided into many tasks, each of which is solved by one or more computers,[4] which communicate with each other via message passing.[5]",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[1]/b[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[3]/sup[2]/a[1]",
                                "endOffset": 3
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 444,
                                "end": 1660
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Distributed computing is a field of computer science that studies distributed systems. A distributed system is a system whose components are located on different networked computers, which communicate and coordinate their actions by passing messages to one another.[1] The components interact with one another in order to achieve a common goal. Three significant characteristics of distributed systems are: concurrency of components, lack of a global clock, and independent failure of components.[1] Examples of distributed systems vary from SOA-based systems to massively multiplayer online games to peer-to-peer applications.\nA computer program that runs within a distributed system is called  a distributed program (and distributed programming is the process of writing such programs).[2] There are many different types of implementations for the message passing mechanism, including pure HTTP, RPC-like connectors and message queues.[3]\nDistributed computing also refers to the use of distributed systems to solve computational problems. In distributed computing, a problem is divided into many tasks, each of which is solved by one or more computers,[4] which communicate with each other via message passing.[5]",
                                "prefix": "uter company, see DIP Research.\n",
                                "suffix": "\n\nContents\n\n1 Introduction\n2 Par"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:05:47.458Z",
                "lastEdited": "2020-12-26T03:07:15.733Z",
                "url": "https://en.wikipedia.org/wiki/Distributed_computing#cite_ref-tanenbaum_1-0/#1608951947458"
            }
        },
        {
            "timestamp": 1608952099043,
            "collection": "pages",
            "objectPk": "en.wikipedia.org/wiki/Graph_theory",
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Graph_theory",
                "fullUrl": "https://en.wikipedia.org/wiki/Graph_theory",
                "domain": "wikipedia.org",
                "hostname": "en.wikipedia.org",
                "fullTitle": "Graph theory - Wikipedia",
                "text": " Graph theory From Wikipedia, the free encyclopedia Jump to navigation Jump to search This article is about sets of vertices connected by edges. For graphs of mathematical functions, see Graph of a function . For other uses, see Graph (disambiguation) . Area of discrete mathematics A drawing of a graph. In mathematics , graph theory is the study of graphs , which are mathematical structures used to model pairwise relations between objects. A graph in this context is made up of vertices (also called nodes or points) which are connected by edges (also called links or lines). A distinction is made between undirected graphs, where edges link two vertices symmetrically, and directed graphs, where edges link two vertices asymmetrically; see Graph (discrete mathematics) for more detailed definitions and for other variations in the types of graph that are commonly considered. Graphs are one of the prime objects of study in discrete mathematics . Refer to the glossary of graph theory for basic definitions in graph theory. Contents 1 Definitions 1.1 Graph 1.2 Directed graph 2 Applications 2.1 Computer science 2.2 Linguistics 2.3 Physics and chemistry 2.4 Social sciences 2.5 Biology 2.6 Mathematics 2.7 Other topics 3 History 4 Graph drawing 5 Graph-theoretic data structures 6 Problems 6.1 Enumeration 6.2 Subgraphs, induced subgraphs, and minors 6.3 Graph coloring 6.4 Subsumption and unification 6.5 Route problems 6.6 Network flow 6.7 Visibility problems 6.8 Covering problems 6.9 Decomposition problems 6.10 Graph classes 7 See also 7.1 Related topics 7.2 Algorithms 7.3 Subareas 7.4 Related areas of mathematics 7.5 Generalizations 7.6 Prominent graph theorists 8 Notes 9 References 10 External links 10.1 Online textbooks Definitions [ edit ] Definitions in graph theory vary. The following are some of the more basic ways of defining graphs and related mathematical structures . Graph [ edit ] A graph with three vertices and three edges. In one restricted but very common sense of the term, [1] [2] a graph is an ordered pair G = ( V , E ) {\\displaystyle G=(V,E)} comprising: V {\\displaystyle V} , a set of vertices (also called nodes or points); E { { x , y } x , y V and x y } {\\displaystyle E\\subseteq \\{\\{x,y\\}\\mid x,y\\in V\\;{\\textrm {and}}\\;x\\neq y\\}} , a set of edges (also called links or lines), which are unordered pairs of vertices (that is, an edge is associated with two distinct vertices). To avoid ambiguity, this type of object may be called precisely an undirected simple graph. In the edge { x , y } {\\displaystyle \\{x,y\\}} , the vertices x {\\displaystyle x} and y {\\displaystyle y} are called the endpoints of the edge. The edge is said to join x {\\displaystyle x} and y {\\displaystyle y} and to be incident on x {\\displaystyle x} and on y {\\displaystyle y} . A vertex may exist in a graph and not belong to an edge. Multiple edges , not allowed under the definition above, are two or more edges that join the same two vertices. In one more general sense of the term allowing multiple edges, [3] [4] a graph is an ordered triple G = ( V , E , ϕ ) {\\displaystyle G=(V,E,\\phi )} comprising: V {\\displaystyle V} , a set of vertices (also called nodes or points); E {\\displaystyle E} , a set of edges (also called links or lines); ϕ : E { { x , y } x , y V and x y } {\\displaystyle \\phi :E\\to \\{\\{x,y\\}\\mid x,y\\in V\\;{\\textrm {and}}\\;x\\neq y\\}} , an incidence function mapping every edge to an unordered pair of vertices (that is, an edge is associated with two distinct vertices). To avoid ambiguity, this type of object may be called precisely an undirected multigraph. A loop is an edge that joins a vertex to itself. Graphs as defined in the two definitions above cannot have loops, because a loop joining a vertex x {\\displaystyle x} to itself is the edge (for an undirected simple graph) or is incident on (for an undirected multigraph) { x , x } = { x } {\\displaystyle \\{x,x\\}=\\{x\\}} which is not in { { x , y } x , y V and x y } {\\displaystyle \\{\\{x,y\\}\\mid x,y\\in V\\;{\\textrm {and}}\\;x\\neq y\\}} . So to allow loops the definitions must be expanded. For undirected simple graphs, the definition of E {\\displaystyle E} should be modified to E { { x , y } x , y V } {\\displaystyle E\\subseteq \\{\\{x,y\\}\\mid x,y\\in V\\}} . For undirected multigraphs, the definition of ϕ {\\displaystyle \\phi } should be modified to ϕ : E { { x , y } x , y V } {\\displaystyle \\phi :E\\to \\{\\{x,y\\}\\mid x,y\\in V\\}} . To avoid ambiguity, these types of objects may be called undirected simple graph permitting loops and undirected multigraph permitting loops, respectively. V {\\displaystyle V} and E {\\displaystyle E} are usually taken to be finite, and many of the well-known results are not true (or are rather different) for infinite graphs because many of the arguments fail in the infinite case . Moreover, V {\\displaystyle V} is often assumed to be non-empty, but E {\\displaystyle E} is allowed to be the empty set. The order of a graph is | V | {\\displaystyle |V|} , its number of vertices. The size of a graph is | E | {\\displaystyle |E|} , its number of edges. The degree or valency of a vertex is the number of edges that are incident to it, where a loop is counted twice. In an undirected simple graph of order n, the maximum degree of each vertex is n 1 and the maximum size of the graph is n(n 1)/2. The edges of an undirected simple graph permitting loops G {\\displaystyle G} induce a symmetric homogeneous relation ~ on the vertices of G {\\displaystyle G} that is called the adjacency relation of G {\\displaystyle G} . Specifically, for each edge ( x , y ) {\\displaystyle (x,y)} , its endpoints x {\\displaystyle x} and y {\\displaystyle y} are said to be adjacent to one another, which is denoted x {\\displaystyle x} ~ y {\\displaystyle y} . Directed graph [ edit ] Main article: Directed graph A directed graph with three vertices and four directed edges (the double arrow represents an edge in each direction). A directed graph or digraph is a graph in which edges have orientations. In one restricted but very common sense of the term, [5] a directed graph is an ordered pair G = ( V , E ) {\\displaystyle G=(V,E)} comprising: V {\\displaystyle V} , a set of vertices (also called nodes or points); E { ( x , y ) ( x , y ) V 2 and x y } {\\displaystyle E\\subseteq \\left\\{(x,y)\\mid (x,y)\\in V^{2}\\;{\\textrm {and}}\\;x\\neq y\\right\\}} , a set of edges (also called directed edges, directed links, directed lines, arrows or arcs) which are ordered pairs of vertices (that is, an edge is associated with two distinct vertices). To avoid ambiguity, this type of object may be called precisely a directed simple graph. In the edge ( x , y ) {\\displaystyle (x,y)} directed from x {\\displaystyle x} to y {\\displaystyle y} , the vertices x {\\displaystyle x} and y {\\displaystyle y} are called the endpoints of the edge, x {\\displaystyle x} the tail of the edge and y {\\displaystyle y} the head of the edge. The edge is said to join x {\\displaystyle x} and y {\\displaystyle y} and to be incident on x {\\displaystyle x} and on y {\\displaystyle y} . A vertex may exist in a graph and not belong to an edge. The edge ( y , x ) {\\displaystyle (y,x)} is called the inverted edge of ( x , y ) {\\displaystyle (x,y)} . Multiple edges , not allowed under the definition above, are two or more edges with both the same tail and the same head. In one more general sense of the term allowing multiple edges, [5] a directed graph is an ordered triple G = ( V , E , ϕ ) {\\displaystyle G=(V,E,\\phi )} comprising: V {\\displaystyle V} , a set of vertices (also called nodes or points); E {\\displaystyle E} , a set of edges (also called directed edges, directed links, directed lines, arrows or arcs); ϕ : E { ( x , y ) ( x , y ) V 2 and x y } {\\displaystyle \\phi :E\\to \\left\\{(x,y)\\mid (x,y)\\in V^{2}\\;{\\textrm {and}}\\;x\\neq y\\right\\}} , an incidence function mapping every edge to an ordered pair of vertices (that is, an edge is associated with two distinct vertices). To avoid ambiguity, this type of object may be called precisely a directed multigraph. A loop is an edge that joins a vertex to itself. Directed graphs as defined in the two definitions above cannot have loops, because a loop joining a vertex x {\\displaystyle x} to itself is the edge (for a directed simple graph) or is incident on (for a directed multigraph) ( x , x ) {\\displaystyle (x,x)} which is not in { ( x , y ) ( x , y ) V 2 and x y } {\\displaystyle \\left\\{(x,y)\\mid (x,y)\\in V^{2}\\;{\\textrm {and}}\\;x\\neq y\\right\\}} . So to allow loops the definitions must be expanded. For directed simple graphs, the definition of E {\\displaystyle E} should be modified to E { ( x , y ) ( x , y ) V 2 } {\\displaystyle E\\subseteq \\left\\{(x,y)\\mid (x,y)\\in V^{2}\\right\\}} . For directed multigraphs, the definition of ϕ {\\displaystyle \\phi } should be modified to ϕ : E { ( x , y ) ( x , y ) V 2 } {\\displaystyle \\phi :E\\to \\left\\{(x,y)\\mid (x,y)\\in V^{2}\\right\\}} . To avoid ambiguity, these types of objects may be called precisely a directed simple graph permitting loops and a directed multigraph permitting loops (or a quiver ) respectively. The edges of a directed simple graph permitting loops G {\\displaystyle G} is a homogeneous relation ~ on the vertices of G {\\displaystyle G} that is called the adjacency relation of G {\\displaystyle G} . Specifically, for each edge ( x , y ) {\\displaystyle (x,y)} , its endpoints x {\\displaystyle x} and y {\\displaystyle y} are said to be adjacent to one another, which is denoted x {\\displaystyle x} ~ y {\\displaystyle y} . Applications [ edit ] The network graph formed by Wikipedia editors (edges) contributing to different Wikipedia language versions (vertices) during one month in summer 2013. [6] Graphs can be used to model many types of relations and processes in physical, biological, [7] [8] social and information systems. Many practical problems can be represented by graphs. Emphasizing their application to real-world systems, the term network is sometimes defined to mean a graph in which attributes (e.g. names) are associated with the vertices and edges, and the subject that expresses and understands the real-world systems as a network is called network science . Computer science [ edit ] In computer science , graphs are used to represent networks of communication, data organization, computational devices, the flow of computation, etc. For instance, the link structure of a website can be represented by a directed graph, in which the vertices represent web pages and directed edges represent links from one page to another. A similar approach can be taken to problems in social media, [9] travel, biology, computer chip design, mapping the progression of neuro-degenerative diseases, [10] [11] and many other fields. The development of algorithms to handle graphs is therefore of major interest in computer science. The transformation of graphs is often formalized and represented by graph rewrite systems . Complementary to graph transformation systems focusing on rule-based in-memory manipulation of graphs are graph databases geared towards transaction -safe, persistent storing and querying of graph-structured data . Linguistics [ edit ] Graph-theoretic methods, in various forms, have proven particularly useful in linguistics , since natural language often lends itself well to discrete structure. Traditionally, syntax and compositional semantics follow tree-based structures, whose expressive power lies in the principle of compositionality , modeled in a hierarchical graph. More contemporary approaches such as head-driven phrase structure grammar model the syntax of natural language using typed feature structures , which are directed acyclic graphs . Within lexical semantics , especially as applied to computers, modeling word meaning is easier when a given word is understood in terms of related words; semantic networks are therefore important in computational linguistics . Still, other methods in phonology (e.g. optimality theory , which uses lattice graphs ) and morphology (e.g. finite-state morphology, using finite-state transducers ) are common in the analysis of language as a graph. Indeed, the usefulness of this area of mathematics to linguistics has borne organizations such as TextGraphs , as well as various 'Net' projects, such as WordNet , VerbNet , and others. Physics and chemistry [ edit ] Graph theory is also used to study molecules in chemistry and physics . In condensed matter physics , the three-dimensional structure of complicated simulated atomic structures can be studied quantitatively by gathering statistics on graph-theoretic properties related to the topology of the atoms. Also, \"the Feynman graphs and rules of calculation summarize quantum field theory in a form in close contact with the experimental numbers one wants to understand.\" [12] In chemistry a graph makes a natural model for a molecule, where vertices represent atoms and edges bonds . This approach is especially used in computer processing of molecular structures, ranging from chemical editors to database searching. In statistical physics , graphs can represent local connections between interacting parts of a system, as well as the dynamics of a physical process on such systems. Similarly, in computational neuroscience graphs can be used to represent functional connections between brain areas that interact to give rise to various cognitive processes, where the vertices represent different areas of the brain and the edges represent the connections between those areas. Graph theory plays an important role in electrical modeling of electrical networks, here, weights are associated with resistance of the wire segments to obtain electrical properties of network structures. [13] Graphs are also used to represent the micro-scale channels of porous media , in which the vertices represent the pores and the edges represent the smaller channels connecting the pores. Chemical graph theory uses the molecular graph as a means to model molecules. Graphs and networks are excellent models to study and understand phase transitions and critical phenomena. Removal of nodes or edges lead to a critical transition where the network breaks into small clusters which is studied as a phase transition. This breakdown is studied via percolation theory. [14] [15] Social sciences [ edit ] Graph theory in sociology: Moreno Sociogram (1953). [16] Graph theory is also widely used in sociology as a way, for example, to measure actors' prestige or to explore rumor spreading , notably through the use of social network analysis software. Under the umbrella of social networks are many different types of graphs. [17] Acquaintanceship and friendship graphs describe whether people know each other. Influence graphs model whether certain people can influence the behavior of others. Finally, collaboration graphs model whether two people work together in a particular way, such as acting in a movie together. Biology [ edit ] Likewise, graph theory is useful in biology and conservation efforts where a vertex can represent regions where certain species exist (or inhabit) and the edges represent migration paths or movement between the regions. This information is important when looking at breeding patterns or tracking the spread of disease, parasites or how changes to the movement can affect other species. Graphs are also commonly used in molecular biology and genomics to model and analyse datasets with complex relationships. For example, graph-based methods are often used to 'cluster' cells together into cell-types in single-cell transcriptome analysis . Another use is to model genes or proteins in a pathway and study the relationships between them, such as metabolic pathways and gene regulatory networks. [18] Evolutionary trees, ecological networks, and hierarchical clustering of gene expression patterns are also represented as graph structures. Graph-based methods are pervasive that researchers in some fields of biology and these will only become far more widespread as technology develops to leverage this kind of high-throughout multidimensional data. Graph theory is also used in connectomics ; [19] nervous systems can be seen as a graph, where the nodes are neurons and the edges are the connections between them. Mathematics [ edit ] In mathematics, graphs are useful in geometry and certain parts of topology such as knot theory . Algebraic graph theory has close links with group theory . Algebraic graph theory has been applied to many areas including dynamic systems and complexity. Other topics [ edit ] A graph structure can be extended by assigning a weight to each edge of the graph. Graphs with weights, or weighted graphs , are used to represent structures in which pairwise connections have some numerical values. For example, if a graph represents a road network, the weights could represent the length of each road. There may be several weights associated with each edge, including distance (as in the previous example), travel time, or monetary cost. Such weighted graphs are commonly used to program GPS's, and travel-planning search engines that compare flight times and costs. History [ edit ] The Königsberg Bridge problem The paper written by Leonhard Euler on the Seven Bridges of Königsberg and published in 1736 is regarded as the first paper in the history of graph theory. [20] This paper, as well as the one written by Vandermonde on the knight problem , carried on with the analysis situs initiated by Leibniz . Euler's formula relating the number of edges, vertices, and faces of a convex polyhedron was studied and generalized by Cauchy [21] and L'Huilier , [22] and represents the beginning of the branch of mathematics known as topology . More than one century after Euler's paper on the bridges of Königsberg and while Listing was introducing the concept of topology, Cayley was led by an interest in particular analytical forms arising from differential calculus to study a particular class of graphs, the trees . [23] This study had many implications for theoretical chemistry . The techniques he used mainly concern the enumeration of graphs with particular properties. Enumerative graph theory then arose from the results of Cayley and the fundamental results published by Pólya between 1935 and 1937. These were generalized by De Bruijn in 1959. Cayley linked his results on trees with contemporary studies of chemical composition. [24] The fusion of ideas from mathematics with those from chemistry began what has become part of the standard terminology of graph theory. In particular, the term \"graph\" was introduced by Sylvester in a paper published in 1878 in Nature , where he draws an analogy between \"quantic invariants\" and \"co-variants\" of algebra and molecular diagrams: [25] \"[…] Every invariant and co-variant thus becomes expressible by a graph precisely identical with a Kekuléan diagram or chemicograph. […] I give a rule for the geometrical multiplication of graphs, i.e. for constructing a graph to the product of in- or co-variants whose separate graphs are given. […]\" (italics as in the original). The first textbook on graph theory was written by Dénes Kőnig , and published in 1936. [26] Another book by Frank Harary , published in 1969, was \"considered the world over to be the definitive textbook on the subject\", [27] and enabled mathematicians, chemists, electrical engineers and social scientists to talk to each other. Harary donated all of the royalties to fund the Pólya Prize . [28] One of the most famous and stimulating problems in graph theory is the four color problem : \"Is it true that any map drawn in the plane may have its regions colored with four colors, in such a way that any two regions having a common border have different colors?\" This problem was first posed by Francis Guthrie in 1852 and its first written record is in a letter of De Morgan addressed to Hamilton the same year. Many incorrect proofs have been proposed, including those by Cayley, Kempe , and others. The study and the generalization of this problem by Tait , Heawood , Ramsey and Hadwiger led to the study of the colorings of the graphs embedded on surfaces with arbitrary genus . Tait's reformulation generated a new class of problems, the factorization problems, particularly studied by Petersen and Kőnig . The works of Ramsey on colorations and more specially the results obtained by Turán in 1941 was at the origin of another branch of graph theory, extremal graph theory . The four color problem remained unsolved for more than a century. In 1969 Heinrich Heesch published a method for solving the problem using computers. [29] A computer-aided proof produced in 1976 by Kenneth Appel and Wolfgang Haken makes fundamental use of the notion of \"discharging\" developed by Heesch. [30] [31] The proof involved checking the properties of 1,936 configurations by computer, and was not fully accepted at the time due to its complexity. A simpler proof considering only 633 configurations was given twenty years later by Robertson , Seymour , Sanders and Thomas . [32] The autonomous development of topology from 1860 and 1930 fertilized graph theory back through the works of Jordan , Kuratowski and Whitney . Another important factor of common development of graph theory and topology came from the use of the techniques of modern algebra. The first example of such a use comes from the work of the physicist Gustav Kirchhoff , who published in 1845 his Kirchhoff's circuit laws for calculating the voltage and current in electric circuits . The introduction of probabilistic methods in graph theory, especially in the study of Erdős and Rényi of the asymptotic probability of graph connectivity, gave rise to yet another branch, known as random graph theory , which has been a fruitful source of graph-theoretic results. Graph drawing [ edit ] Main article: Graph drawing Graphs are represented visually by drawing a point or circle for every vertex, and drawing a line between two vertices if they are connected by an edge. If the graph is directed, the direction is indicated by drawing an arrow. A graph drawing should not be confused with the graph itself (the abstract, non-visual structure) as there are several ways to structure the graph drawing. All that matters is which vertices are connected to which others by how many edges and not the exact layout. In practice, it is often difficult to decide if two drawings represent the same graph. Depending on the problem domain some layouts may be better suited and easier to understand than others. The pioneering work of W. T. Tutte was very influential on the subject of graph drawing. Among other achievements, he introduced the use of linear algebraic methods to obtain graph drawings. Graph drawing also can be said to encompass problems that deal with the crossing number and its various generalizations. The crossing number of a graph is the minimum number of intersections between edges that a drawing of the graph in the plane must contain. For a planar graph , the crossing number is zero by definition. Drawings on surfaces other than the plane are also studied. Graph-theoretic data structures [ edit ] Main article: Graph (abstract data type) There are different ways to store graphs in a computer system. The data structure used depends on both the graph structure and the algorithm used for manipulating the graph. Theoretically one can distinguish between list and matrix structures but in concrete applications the best structure is often a combination of both. List structures are often preferred for sparse graphs as they have smaller memory requirements. Matrix structures on the other hand provide faster access for some applications but can consume huge amounts of memory. Implementations of sparse matrix structures that are efficient on modern parallel computer architectures are an object of current investigation. [33] List structures include the edge list , an array of pairs of vertices, and the adjacency list , which separately lists the neighbors of each vertex: Much like the edge list, each vertex has a list of which vertices it is adjacent to. Matrix structures include the incidence matrix , a matrix of 0's and 1's whose rows represent vertices and whose columns represent edges, and the adjacency matrix , in which both the rows and columns are indexed by vertices. In both cases a 1 indicates two adjacent objects and a 0 indicates two non-adjacent objects. The degree matrix indicates the degree of vertices. The Laplacian matrix is a modified form of the adjacency matrix that incorporates information about the degrees of the vertices, and is useful in some calculations such as Kirchhoff's theorem on the number of spanning trees of a graph. The distance matrix , like the adjacency matrix, has both its rows and columns indexed by vertices, but rather than containing a 0 or a 1 in each cell it contains the length of a shortest path between two vertices. Problems [ edit ] Enumeration [ edit ] There is a large literature on graphical enumeration : the problem of counting graphs meeting specified conditions. Some of this work is found in Harary and Palmer (1973). Subgraphs, induced subgraphs, and minors [ edit ] A common problem, called the subgraph isomorphism problem , is finding a fixed graph as a subgraph in a given graph. One reason to be interested in such a question is that many graph properties are hereditary for subgraphs, which means that a graph has the property if and only if all subgraphs have it too. Unfortunately, finding maximal subgraphs of a certain kind is often an NP-complete problem . For example: Finding the largest complete subgraph is called the clique problem (NP-complete). One special case of subgraph isomorphism is the graph isomorphism problem . It asks whether two graphs are isomorphic. It is not known whether this problem is NP-complete, nor whether it can be solved in polynomial time. A similar problem is finding induced subgraphs in a given graph. Again, some important graph properties are hereditary with respect to induced subgraphs, which means that a graph has a property if and only if all induced subgraphs also have it. Finding maximal induced subgraphs of a certain kind is also often NP-complete. For example: Finding the largest edgeless induced subgraph or independent set is called the independent set problem (NP-complete). Still another such problem, the minor containment problem, is to find a fixed graph as a minor of a given graph. A minor or subcontraction of a graph is any graph obtained by taking a subgraph and contracting some (or no) edges. Many graph properties are hereditary for minors, which means that a graph has a property if and only if all minors have it too. For example, Wagner's Theorem states: A graph is planar if it contains as a minor neither the complete bipartite graph K3,3 (see the Three-cottage problem ) nor the complete graph K5. A similar problem, the subdivision containment problem, is to find a fixed graph as a subdivision of a given graph. A subdivision or homeomorphism of a graph is any graph obtained by subdividing some (or no) edges. Subdivision containment is related to graph properties such as planarity . For example, Kuratowski's Theorem states: A graph is planar if it contains as a subdivision neither the complete bipartite graph K3,3 nor the complete graph K5. Another problem in subdivision containment is the Kelmans Seymour conjecture : Every 5-vertex-connected graph that is not planar contains a subdivision of the 5-vertex complete graph K5. Another class of problems has to do with the extent to which various species and generalizations of graphs are determined by their point-deleted subgraphs. For example: The reconstruction conjecture Graph coloring [ edit ] Main article: Graph coloring Many problems and theorems in graph theory have to do with various ways of coloring graphs. Typically, one is interested in coloring a graph so that no two adjacent vertices have the same color, or with other similar restrictions. One may also consider coloring edges (possibly so that no two coincident edges are the same color), or other variations. Among the famous results and conjectures concerning graph coloring are the following: Four-color theorem Strong perfect graph theorem Erdős Faber Lovász conjecture (unsolved) Total coloring conjecture , also called Behzad 's conjecture (unsolved) List coloring conjecture (unsolved) Hadwiger conjecture (graph theory) (unsolved) Subsumption and unification [ edit ] Constraint modeling theories concern families of directed graphs related by a partial order . In these applications, graphs are ordered by specificity, meaning that more constrained graphs which are more specific and thus contain a greater amount of information are subsumed by those that are more general. Operations between graphs include evaluating the direction of a subsumption relationship between two graphs, if any, and computing graph unification. The unification of two argument graphs is defined as the most general graph (or the computation thereof) that is consistent with (i.e. contains all of the information in) the inputs, if such a graph exists; efficient unification algorithms are known. For constraint frameworks which are strictly compositional , graph unification is the sufficient satisfiability and combination function. Well-known applications include automatic theorem proving and modeling the elaboration of linguistic structure . Route problems [ edit ] Hamiltonian path problem Minimum spanning tree Route inspection problem (also called the \"Chinese postman problem\") Seven bridges of Königsberg Shortest path problem Steiner tree Three-cottage problem Traveling salesman problem (NP-hard) Network flow [ edit ] There are numerous problems arising especially from applications that have to do with various notions of flows in networks , for example: Max flow min cut theorem Visibility problems [ edit ] Museum guard problem Covering problems [ edit ] Covering problems in graphs may refer to various set cover problems on subsets of vertices/subgraphs. Dominating set problem is the special case of set cover problem where sets are the closed neighborhoods . Vertex cover problem is the special case of set cover problem where sets to cover are every edges. The original set cover problem, also called hitting set, can be described as a vertex cover in a hypergraph. Decomposition problems [ edit ] Decomposition, defined as partitioning the edge set of a graph (with as many vertices as necessary accompanying the edges of each part of the partition), has a wide variety of question. Often, it is required to decompose a graph into subgraphs isomorphic to a fixed graph; for instance, decomposing a complete graph into Hamiltonian cycles. Other problems specify a family of graphs into which a given graph should be decomposed, for instance, a family of cycles, or decomposing a complete graph Kn into n 1 specified trees having, respectively, 1, 2, 3, ..., n 1 edges. Some specific decomposition problems that have been studied include: Arboricity , a decomposition into as few forests as possible Cycle double cover , a decomposition into a collection of cycles covering each edge exactly twice Edge coloring , a decomposition into as few matchings as possible Graph factorization , a decomposition of a regular graph into regular subgraphs of given degrees Graph classes [ edit ] Many problems involve characterizing the members of various classes of graphs. Some examples of such questions are below: Enumerating the members of a class Characterizing a class in terms of forbidden substructures Ascertaining relationships among classes (e.g. does one property of graphs imply another) Finding efficient algorithms to decide membership in a class Finding representations for members of a class See also [ edit ] Gallery of named graphs Glossary of graph theory List of graph theory topics List of unsolved problems in graph theory Publications in graph theory Related topics [ edit ] Algebraic graph theory Citation graph Conceptual graph Data structure Disjoint-set data structure Dual-phase evolution Entitative graph Existential graph Graph algebra Graph automorphism Graph coloring Graph database Graph data structure Graph drawing Graph equation Graph rewriting Graph sandwich problem Graph property Intersection graph Knight's Tour Logical graph Loop Network theory Null graph Pebble motion problems Percolation Perfect graph Quantum graph Random regular graphs Semantic networks Spectral graph theory Strongly regular graphs Symmetric graphs Transitive reduction Tree data structure Algorithms [ edit ] Bellman Ford algorithm Borůvka's algorithm Breadth-first search Depth-first search Dijkstra's algorithm Edmonds Karp algorithm Floyd Warshall algorithm Ford Fulkerson algorithm Hopcroft Karp algorithm Hungarian algorithm Kosaraju's algorithm Kruskal's algorithm Nearest neighbour algorithm Network simplex algorithm Planarity testing algorithms Prim's algorithm Push relabel maximum flow algorithm Tarjan's strongly connected components algorithm Topological sorting Subareas [ edit ] Algebraic graph theory Geometric graph theory Extremal graph theory Probabilistic graph theory Topological graph theory Related areas of mathematics [ edit ] Combinatorics Group theory Knot theory Ramsey theory Generalizations [ edit ] Hypergraph Abstract simplicial complex Prominent graph theorists [ edit ] Alon, Noga Berge, Claude Bollobás, Béla Bondy, Adrian John Brightwell, Graham Chudnovsky, Maria Chung, Fan Dirac, Gabriel Andrew Erdős, Paul Euler, Leonhard Faudree, Ralph Fleischner, Herbert Golumbic, Martin Graham, Ronald Harary, Frank Heawood, Percy John Kotzig, Anton Kőnig, Dénes Lovász, László Murty, U. S. R. Nešetřil, Jaroslav Rényi, Alfréd Ringel, Gerhard Robertson, Neil Seymour, Paul Sudakov, Benny Szemerédi, Endre Thomas, Robin Thomassen, Carsten Turán, Pál Tutte, W. T. Whitney, Hassler Notes [ edit ] ^ Bender & Williamson 2010 , p. 148. ^ See, for instance, Iyanaga and Kawada, 69 J, p. 234 or Biggs, p. 4. ^ Bender & Williamson 2010 , p. 149. ^ See, for instance, Graham et al., p. 5. ^ Jump up to: a b Bender & Williamson 2010 , p. 161. ^ Hale, Scott A. (2013). \"Multilinguals and Wikipedia Editing\". Proceedings of the 2014 ACM Conference on Web Science - WebSci '14: 99 108. arXiv : 1312.0976 . Bibcode : 2013arXiv1312.0976H . doi : 10.1145/2615569.2615684 . ISBN 9781450326223 . S2CID 14027025 . ^ Mashaghi, A.; et al. (2004). \"Investigation of a protein complex network\". European Physical Journal B. 41 (1): 113 121. arXiv : cond-mat/0304207 . Bibcode : 2004EPJB...41..113M . doi : 10.1140/epjb/e2004-00301-0 . S2CID 9233932 . ^ Shah, Preya; Ashourvan, Arian; Mikhail, Fadi; Pines, Adam; Kini, Lohith; Oechsel, Kelly; Das, Sandhitsu R; Stein, Joel M; Shinohara, Russell T (2019-07-01). \"Characterizing the role of the structural connectome in seizure dynamics\" . Brain. 142 (7): 1955 1972. doi : 10.1093/brain/awz125 . ISSN 0006-8950 . PMC 6598625 . PMID 31099821 . ^ Grandjean, Martin (2016). \"A social network analysis of Twitter: Mapping the digital humanities community\" (PDF). Cogent Arts & Humanities. 3 (1): 1171458. doi : 10.1080/23311983.2016.1171458 . S2CID 114999767 . ^ Vecchio, F (2017). \" \"Small World\" architecture in brain connectivity and hippocampal volume in Alzheimer's disease: a study via graph theory from EEG data\". Brain Imaging and Behavior. 11 (2): 473 485. doi : 10.1007/s11682-016-9528-3 . PMID 26960946 . S2CID 3987492 . ^ Vecchio, F (2013). \"Brain network connectivity assessed using graph theory in frontotemporal dementia\". Neurology. 81 (2): 134 143. doi : 10.1212/WNL.0b013e31829a33f8 . PMID 23719145 . S2CID 28334693 . ^ Bjorken, J. D.; Drell, S. D. (1965). Relativistic Quantum Fields . New York: McGraw-Hill. p. viii. ^ Kumar, Ankush; Kulkarni, G. U. (2016-01-04). \"Evaluating conducting network based transparent electrodes from geometrical considerations\". Journal of Applied Physics. 119 (1): 015102. Bibcode : 2016JAP...119a5102K . doi : 10.1063/1.4939280 . ISSN 0021-8979 . ^ Newman, Mark (2010). Networks: An Introduction (PDF). Oxford University Press. ^ Reuven Cohen, Shlomo Havlin (2010). Complex Networks: Structure, Robustness and Function Cambridge University Press. ^ Grandjean, Martin (2015). \"Social network analysis and visualization: Moreno’s Sociograms revisited\" . Redesigned network strictly based on Moreno (1934), Who Shall Survive. ^ Rosen, Kenneth H. (2011-06-14). Discrete mathematics and its applications (7th ed.). New York: McGraw-Hill. ISBN 978-0-07-338309-5 . ^ Kelly, S Thomas; Black, Michael A (2 March 2020). \"graphsim: An R package for simulating gene expression data from graph structures of biological pathways\" . bioRxiv. 2020.03.02.972471. doi : 10.1101/2020.03.02.972471 . S2CID 214722561 . Retrieved 27 May 2020. ^ Shah, Preya; Ashourvan, Arian; Mikhail, Fadi; Pines, Adam; Kini, Lohith; Oechsel, Kelly; Das, Sandhitsu R; Stein, Joel M; Shinohara, Russell T (2019-07-01). \"Characterizing the role of the structural connectome in seizure dynamics\" . Brain. 142 (7): 1955 1972. doi : 10.1093/brain/awz125 . ISSN 0006-8950 . PMC 6598625 . PMID 31099821 . ^ Biggs, N.; Lloyd, E.; Wilson, R. (1986), Graph Theory, 1736-1936 , Oxford University Press ^ Cauchy, A. L. (1813), \"Recherche sur les polyèdres - premier mémoire\", Journal de l'École Polytechnique , 9 (Cahier 16): 66 86. ^ L'Huillier, S.-A.-J. (1812 1813), \"Mémoire sur la polyèdrométrie\", Annales de Mathématiques, 3: 169 189. ^ Cayley, A. (1857), \"On the theory of the analytical forms called trees\", Philosophical Magazine , Series IV, 13 (85): 172 176, doi : 10.1017/CBO9780511703690.046 , ISBN 9780511703690 ^ Cayley, A. (1875), \"Ueber die Analytischen Figuren, welche in der Mathematik Bäume genannt werden und ihre Anwendung auf die Theorie chemischer Verbindungen\" , Berichte der Deutschen Chemischen Gesellschaft, 8 (2): 1056 1059, doi : 10.1002/cber.18750080252 . ^ Sylvester, James Joseph (1878). \"Chemistry and Algebra\" . Nature. 17 (432): 284. Bibcode : 1878Natur..17..284S . doi : 10.1038/017284a0 . ^ Tutte, W.T. (2001), Graph Theory , Cambridge University Press, p. 30, ISBN 978-0-521-79489-3 , retrieved 2016-03-14 ^ Gardner, Martin (1992), Fractal Music, Hypercards, and more…Mathematical Recreations from Scientific American, W. H. Freeman and Company, p. 203 ^ Society for Industrial and Applied Mathematics (2002), \"The George Polya Prize\", Looking Back, Looking Ahead: A SIAM History (PDF), p. 26 , retrieved 2016-03-14 ^ Heinrich Heesch: Untersuchungen zum Vierfarbenproblem. Mannheim: Bibliographisches Institut 1969. ^ Appel, K.; Haken, W. (1977), \"Every planar map is four colorable. Part I. Discharging\", Illinois J. Math., 21 (3): 429 490, doi : 10.1215/ijm/1256049011 . ^ Appel, K.; Haken, W. (1977), \"Every planar map is four colorable. Part II. Reducibility\", Illinois J. Math., 21 (3): 491 567, doi : 10.1215/ijm/1256049012 . ^ Robertson, N.; Sanders, D.; Seymour, P.; Thomas, R. (1997), \"The four color theorem\", Journal of Combinatorial Theory, Series B, 70: 2 44, doi : 10.1006/jctb.1997.1750 . ^ Kepner, Jeremy; Gilbert, John (2011). Graph Algorithms in the Language of Linear Algebra . SIAM. p. 1171458. ISBN 978-0-898719-90-1 . References [ edit ] Bender, Edward A.; Williamson, S. Gill (2010). Lists, Decisions and Graphs. With an Introduction to Probability . Claude, Claude (1958). Théorie des graphes et ses applications. Paris: Dunod. English edition, Wiley 1961; Methuen & Co, New York 1962; Russian, Moscow 1961; Spanish, Mexico 1962; Roumanian, Bucharest 1969; Chinese, Shanghai 1963; Second printing of the 1962 first English edition, Dover, New York 2001. Biggs, N.; Lloyd, E.; Wilson, R. (1986). Graph Theory, 1736 1936. Oxford University Press. Bondy, J. A.; Murty, U. S. R. (2008). Graph Theory. Springer. ISBN 978-1-84628-969-9 . Bollobás, Béla; Riordan, O. M. (2003). Mathematical results on scale-free random graphs in \"Handbook of Graphs and Networks\" (S. Bornholdt and H.G. Schuster (eds)) (1st ed.). Weinheim: Wiley VCH. Chartrand, Gary (1985). Introductory Graph Theory . Dover. ISBN 0-486-24775-9 . Deo, Narsingh (1974). Graph Theory with Applications to Engineering and Computer Science (PDF). Englewood, New Jersey: Prentice-Hall. ISBN 0-13-363473-6 . Gibbons, Alan (1985). Algorithmic Graph Theory. Cambridge University Press . Reuven Cohen, Shlomo Havlin (2010). Complex Networks: Structure, Robustness and Function . Cambridge University Press. ISBN 9781139489270 . Golumbic, Martin (1980). Algorithmic Graph Theory and Perfect Graphs. Academic Press . Harary, Frank (1969). Graph Theory. Reading, Massachusetts: Addison-Wesley. Harary, Frank; Palmer, Edgar M. (1973). Graphical Enumeration. New York, New York: Academic Press. Mahadev, N. V. R.; Peled, Uri N. (1995). Threshold Graphs and Related Topics. North-Holland . Newman, Mark (2010). Networks: An Introduction. Oxford University Press. Kepner, Jeremy; Gilbert, John (2011). Graph Algorithms in The Language of Linear Algebra . Philadelphia, Pennsylvania: SIAM. ISBN 978-0-898719-90-1 . External links [ edit ] Wikimedia Commons has media related to Graph theory . \"Graph theory\" , Encyclopedia of Mathematics , EMS Press , 2001 [1994] Graph theory tutorial A searchable database of small connected graphs Image gallery: graphs at the Wayback Machine (archived February 6, 2006) Concise, annotated list of graph theory resources for researchers rocs a graph theory IDE The Social Life of Routers non-technical paper discussing graphs of people and computers Graph Theory Software tools to teach and learn graph theory Online books , and library resources in your library and in other libraries about graph theory A list of graph algorithms with references and links to graph library implementations Online textbooks [ edit ] Phase Transitions in Combinatorial Optimization Problems, Section 3: Introduction to Graphs (2006) by Hartmann and Weigt Digraphs: Theory Algorithms and Applications 2007 by Jorgen Bang-Jensen and Gregory Gutin Graph Theory, by Reinhard Diestel show v t e Mathematics ( areas of mathematics ) Foundations Category theory Information theory Mathematical logic Philosophy of mathematics Set theory Algebra Abstract Commutative Elementary Group theory Linear Multilinear Universal Analysis Calculus Real analysis Complex analysis Differential equations Functional analysis Harmonic analysis Discrete Combinatorics Graph theory Order theory Game theory Geometry Algebraic Analytic Differential Discrete Euclidean Finite Number theory Arithmetic Algebraic number theory Analytic number theory Diophantine geometry Topology Algebraic Differential Geometric Applied Control theory Mathematical biology Mathematical chemistry Mathematical economics Mathematical finance Mathematical physics Mathematical psychology Mathematical sociology Mathematical statistics Operations research Probability Statistics Computational Computer science Theory of computation Numerical analysis Optimization Computer algebra Related topics History of mathematics Recreational mathematics Mathematics and art Mathematics education Category Portal Commons WikiProject show v t e Computer science Note: This template roughly follows the 2012 ACM Computing Classification System . Hardware Printed circuit board Peripheral Integrated circuit Very Large Scale Integration Systems on Chip (SoCs) Energy consumption (Green computing) Electronic design automation Hardware acceleration Computer systems organization Computer architecture Embedded system Real-time computing Dependability Networks Network architecture Network protocol Network components Network scheduler Network performance evaluation Network service Software organization Interpreter Middleware Virtual machine Operating system Software quality Software notations and tools Programming paradigm Programming language Compiler Domain-specific language Modeling language Software framework Integrated development environment Software configuration management Software library Software repository Software development Control variable Software development process Requirements analysis Software design Software construction Software deployment Software maintenance Programming team Open-source model Theory of computation Model of computation Formal language Automata theory Computability theory Computational complexity theory Logic Semantics Algorithms Algorithm design Analysis of algorithms Algorithmic efficiency Randomized algorithm Computational geometry Mathematics of computing Discrete mathematics Probability Statistics Mathematical software Information theory Mathematical analysis Numerical analysis Information systems Database management system Information storage systems Enterprise information system Social information systems Geographic information system Decision support system Process control system Multimedia information system Data mining Digital library Computing platform Digital marketing World Wide Web Information retrieval Security Cryptography Formal methods Security services Intrusion detection system Hardware security Network security Information security Application security Human computer interaction Interaction design Social computing Ubiquitous computing Visualization Accessibility Concurrency Concurrent computing Parallel computing Distributed computing Multithreading Multiprocessing Artificial intelligence Natural language processing Knowledge representation and reasoning Computer vision Automated planning and scheduling Search methodology Control method Philosophy of artificial intelligence Distributed artificial intelligence Machine learning Supervised learning Unsupervised learning Reinforcement learning Multi-task learning Cross-validation Graphics Animation Rendering Image manipulation Graphics processing unit Mixed reality Virtual reality Image compression Solid modeling Applied computing E-commerce Enterprise software Computational mathematics Computational physics Computational chemistry Computational biology Computational social science Computational engineering Computational healthcare Digital art Electronic publishing Cyberwarfare Electronic voting Video games Word processing Operations research Educational technology Document management Book Category Outline WikiProject Commons show v t e Graph analysis software Free Cytoscape Graphviz Gephi iGraph NetworkX Tulip Proprietary Maple Mathematica Authority control GND : 4113782-6 LCCN : sh85056471 NDL : 00562641 Retrieved from \" https://en.wikipedia.org/w/index.php?title=Graph_theory&oldid=995335959 \" Categories : Graph theory Hidden categories: CS1: long volume value Articles with short description Short description is different from Wikidata Pages using div col with small parameter Commons link from Wikidata Webarchive template wayback links Wikipedia articles with GND identifiers Wikipedia articles with LCCN identifiers Wikipedia articles with NDL identifiers Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikibooks Wikiquote Languages አማርኛ العربية Aragonés Asturianu Azərbaycanca বাংলা Башҡортса Беларуская Български Bosanski Català Чӑвашла Čeština Cymraeg Dansk Deutsch Eesti Ελληνικά Español Esperanto Euskara فارسی Français Galego 한국어 Հայերեն हिन्दी Hrvatski Bahasa Indonesia Íslenska Italiano עברית ქართული Қазақша Кыргызча Latviešu Lietuvių Magyar Македонски Malti Bahasa Melayu Монгол Nederlands 日本語 Norsk bokmål Norsk nynorsk Polski Português Română Русский Sicilianu Simple English Slovenčina Slovenščina کوردی Српски / srpski Srpskohrvatski / српскохрватски Suomi Svenska Tagalog தமிழ் ไทย Тоҷикӣ Türkçe Українська اردو Tiếng Việt 吴语 粵語 中文 61 more Edit links This page was last edited on 20 December 2020, at 13:52 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License ; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement Enable previews ",
                "urlTerms": [
                    "wiki",
                    "graph",
                    "theory"
                ],
                "titleTerms": [
                    "graph",
                    "theory",
                    "wikipedia"
                ]
            }
        },
        {
            "timestamp": 1608952099097,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "en.wikipedia.org/wiki/Graph_theory"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "en.wikipedia.org/wiki/Graph_theory",
                "fullUrl": "https://en.wikipedia.org/wiki/Graph_theory",
                "createdAt": "2020-12-26T03:08:19.083Z"
            }
        },
        {
            "timestamp": 1608952099106,
            "collection": "visits",
            "objectPk": [
                1608952099103,
                "en.wikipedia.org/wiki/Graph_theory"
            ],
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Graph_theory",
                "time": 1608952099103
            }
        },
        {
            "timestamp": 1608952099114,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Graph_theory/#1608952098649",
            "operation": "create",
            "object": {
                "pageTitle": "Graph theory - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Graph_theory",
                "body": "n mathematics, graph theory is the study of graphs, which are mathematical structures used to model pairwise relations between objects. A graph in this context is made up of vertices (also called nodes or points) which are connected by edges (also called links or lines). A distinction is made between undirected graphs, where edges link two vertices symmetrically, and directed graphs, where edges link two vertices asymmetrically; see Graph (discrete mathematics) for more detailed definitions and for other variations in the types of graph that are commonly considered. Graphs are one of the prime objects of study in discrete mathematics. ",
                "comment": "",
                "selector": {
                    "quote": "n mathematics, graph theory is the study of graphs, which are mathematical structures used to model pairwise relations between objects. A graph in this context is made up of vertices (also called nodes or points) which are connected by edges (also called links or lines). A distinction is made between undirected graphs, where edges link two vertices symmetrically, and directed graphs, where edges link two vertices asymmetrically; see Graph (discrete mathematics) for more detailed definitions and for other variations in the types of graph that are commonly considered. Graphs are one of the prime objects of study in discrete mathematics. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[1]",
                                "startOffset": 1,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[1]",
                                "endOffset": 644
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 339,
                                "end": 982
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "n mathematics, graph theory is the study of graphs, which are mathematical structures used to model pairwise relations between objects. A graph in this context is made up of vertices (also called nodes or points) which are connected by edges (also called links or lines). A distinction is made between undirected graphs, where edges link two vertices symmetrically, and directed graphs, where edges link two vertices asymmetrically; see Graph (discrete mathematics) for more detailed definitions and for other variations in the types of graph that are commonly considered. Graphs are one of the prime objects of study in discrete mathematics.\n",
                                "prefix": "matics\n  A drawing of a graph.\nI",
                                "suffix": "Refer to the glossary of graph t"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:08:18.649Z",
                "lastEdited": "2020-12-26T03:08:18.649Z",
                "url": "https://en.wikipedia.org/wiki/Graph_theory/#1608952098649"
            }
        },
        {
            "timestamp": 1608952139972,
            "collection": "pages",
            "objectPk": "en.wikipedia.org/wiki/Concurrent_computing",
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Concurrent_computing",
                "fullUrl": "https://en.wikipedia.org/wiki/Concurrent_computing",
                "domain": "wikipedia.org",
                "hostname": "en.wikipedia.org",
                "fullTitle": "Concurrent computing - Wikipedia",
                "text": " Concurrent computing From Wikipedia, the free encyclopedia Jump to navigation Jump to search Form of computing in which several computations are executing during overlapping time periods For a more theoretical discussion, see Concurrency (computer science) . This article needs additional citations for verification . Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed. Find sources: \"Concurrent computing\" news · newspapers · books · scholar · JSTOR ( February 2014) ( Learn how and when to remove this template message ) Programming paradigms Action Agent-oriented Array-oriented Automata-based Concurrent computing Relativistic programming Data-driven Declarative (contrast: Imperative ) Functional Functional logic Purely functional Logic Abductive logic Answer set Concurrent logic Functional logic Inductive logic Constraint Constraint logic Concurrent constraint logic Dataflow Flow-based Reactive Functional reactive Ontology Differentiable Dynamic/scripting Event-driven Function-level (contrast: Value-level ) Point-free style Concatenative Generic Imperative (contrast: Declarative ) Procedural Object-oriented Polymorphic Intentional Language-oriented Domain-specific Literate Natural-language programming Metaprogramming Automatic Inductive programming Reflective Attribute-oriented Macro Template Non-structured (contrast: Structured ) Array Nondeterministic Parallel computing Process-oriented Probabilistic Quantum Set-theoretic Stack-based Structured (contrast: Non-structured ) Block-structured Structured concurrency Object-oriented Actor-based Class-based Concurrent Prototype-based By separation of concerns : Aspect-oriented Role-oriented Subject-oriented Recursive Symbolic Value-level (contrast: Function-level ) v t e Concurrent computing is a form of computing in which several computations are executed concurrently during overlapping time periods instead of sequentially, with one completing before the next starts. This is a property of a system whether a program , computer , or a network where there is a separate execution point or \"thread of control\" for each process. A concurrent system is one where a computation can advance without waiting for all other computations to complete. [1] Concurrent computing is a form of modular programming . In its paradigm an overall computation is factored into subcomputations that may be executed concurrently. Pioneers in the field of concurrent computing include Edsger Dijkstra , Per Brinch Hansen , and C.A.R. Hoare . Contents 1 Introduction 1.1 Coordinating access to shared resources 1.2 Advantages 2 Models 3 Implementation 3.1 Interaction and communication 4 History 5 Prevalence 6 Languages supporting concurrent programming 7 See also 8 Notes 9 References 10 Sources 11 Further reading 12 External links Introduction [ edit ] See also: Parallel computing hide This section has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these template messages ) This section needs additional citations for verification . Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed. ( December 2016) ( Learn how and when to remove this template message ) This section possibly contains original research . Please improve it by verifying the claims made and adding inline citations . Statements consisting only of original research should be removed. ( December 2016) ( Learn how and when to remove this template message ) ( Learn how and when to remove this template message ) The concept of concurrent computing is frequently confused with the related but distinct concept of parallel computing , [2] [3] although both can be described as \"multiple processes executing during the same period of time\". In parallel computing, execution occurs at the same physical instant: for example, on separate processors of a multi-processor machine, with the goal of speeding up computations parallel computing is impossible on a ( one-core ) single processor, as only one computation can occur at any instant (during any single clock cycle). [a] By contrast, concurrent computing consists of process lifetimes overlapping, but execution need not happen at the same instant. The goal here is to model processes in the outside world that happen concurrently, such as multiple clients accessing a server at the same time. Structuring software systems as composed of multiple concurrent, communicating parts can be useful for tackling complexity, regardless of whether the parts can be executed in parallel. [4] : 1 For example, concurrent processes can be executed on one core by interleaving the execution steps of each process via time-sharing slices: only one process runs at a time, and if it does not complete during its time slice, it is paused, another process begins or resumes, and then later the original process is resumed. In this way, multiple processes are part-way through execution at a single instant, but only one process is being executed at that instant.[ citation needed ] Concurrent computations may be executed in parallel, [2] [5] for example, by assigning each process to a separate processor or processor core, or distributing a computation across a network. In general, however, the languages, tools, and techniques for parallel programming might not be suitable for concurrent programming, and vice versa.[ citation needed ] The exact timing of when tasks in a concurrent system are executed depend on the scheduling , and tasks need not always be executed concurrently. For example, given two tasks, T1 and T2:[ citation needed ] T1 may be executed and finished before T2 or vice versa (serial and sequential) T1 and T2 may be executed alternately (serial and concurrent) T1 and T2 may be executed simultaneously at the same instant of time (parallel and concurrent) The word \"sequential\" is used as an antonym for both \"concurrent\" and \"parallel\"; when these are explicitly distinguished, concurrent/sequential and parallel/serial are used as opposing pairs. [6] A schedule in which tasks execute one at a time (serially, no parallelism), without interleaving (sequentially, no concurrency: no task begins until the prior task ends) is called a serial schedule. A set of tasks that can be scheduled serially is serializable , which simplifies concurrency control .[ citation needed ] Coordinating access to shared resources [ edit ] The main challenge in designing concurrent programs is concurrency control : ensuring the correct sequencing of the interactions or communications between different computational executions, and coordinating access to resources that are shared among executions. [5] Potential problems include race conditions , deadlocks , and resource starvation . For example, consider the following algorithm to make withdrawals from a checking account represented by the shared resource balance: 1 bool withdraw ( int withdrawal ) 2 { 3 if ( balance >= withdrawal ) 4 { 5 balance -= withdrawal ; 6 return true ; 7 } 8 return false ; 9 } Suppose balance = 500, and two concurrent threads make the calls withdraw(300) and withdraw(350). If line 3 in both operations executes before line 5 both operations will find that balance >= withdrawal evaluates to true, and execution will proceed to subtracting the withdrawal amount. However, since both processes perform their withdrawals, the total amount withdrawn will end up being more than the original balance. These sorts of problems with shared resources benefit from the use of concurrency control, or non-blocking algorithms . Advantages [ edit ] This section does not cite any sources . Please help improve this section by adding citations to reliable sources . Unsourced material may be challenged and removed . ( December 2006) ( Learn how and when to remove this template message ) The advantages of concurrent computing include: Increased program throughput parallel execution of a concurrent program allows the number of tasks completed in a given time to increase proportionally to the number of processors according to Gustafson's law High responsiveness for input/output input/output-intensive programs mostly wait for input or output operations to complete. Concurrent programming allows the time that would be spent waiting to be used for another task.[ citation needed ] More appropriate program structure some problems and problem domains are well-suited to representation as concurrent tasks or processes.[ citation needed ] Models [ edit ] Models for understanding and analyzing concurrent computing systems include: Actor model Object-capability model for security Input/output automaton Software transactional memory (STM) Petri nets Process calculi such as Ambient calculus Calculus of communicating systems (CCS) Communicating sequential processes (CSP) Join-calculus π-calculus Implementation [ edit ] This section needs expansion. You can help by adding to it . ( February 2014) A number of different methods can be used to implement concurrent programs, such as implementing each computational execution as an operating system process , or implementing the computational processes as a set of threads within a single operating system process. Interaction and communication [ edit ] In some concurrent computing systems, communication between the concurrent components is hidden from the programmer (e.g., by using futures ), while in others it must be handled explicitly. Explicit communication can be divided into two classes: Shared memory communication Concurrent components communicate by altering the contents of shared memory locations (exemplified by Java and C# ). This style of concurrent programming usually needs the use of some form of locking (e.g., mutexes , semaphores , or monitors ) to coordinate between threads. A program that properly implements any of these is said to be thread-safe . Message passing communication Concurrent components communicate by exchanging messages (exemplified by MPI , Go , Scala , Erlang and occam ). The exchange of messages may be carried out asynchronously, or may use a synchronous \"rendezvous\" style in which the sender blocks until the message is received. Asynchronous message passing may be reliable or unreliable (sometimes referred to as \"send and pray\"). Message-passing concurrency tends to be far easier to reason about than shared-memory concurrency, and is typically considered a more robust form of concurrent programming.[ citation needed ] A wide variety of mathematical theories to understand and analyze message-passing systems are available, including the actor model , and various process calculi . Message passing can be efficiently implemented via symmetric multiprocessing , with or without shared memory cache coherence . Shared memory and message passing concurrency have different performance characteristics. Typically (although not always), the per-process memory overhead and task switching overhead is lower in a message passing system, but the overhead of message passing is greater than for a procedure call. These differences are often overwhelmed by other performance factors. History [ edit ] Concurrent computing developed out of earlier work on railroads and telegraphy , from the 19th and early 20th century, and some terms date to this period, such as semaphores. These arose to address the question of how to handle multiple trains on the same railroad system (avoiding collisions and maximizing efficiency) and how to handle multiple transmissions over a given set of wires (improving efficiency), such as via time-division multiplexing (1870s). The academic study of concurrent algorithms started in the 1960s, with Dijkstra (1965) credited with being the first paper in this field, identifying and solving mutual exclusion . [7] Prevalence [ edit ] Concurrency is pervasive in computing, occurring from low-level hardware on a single chip to worldwide networks. Examples follow. At the programming language level: Channel Coroutine Futures and promises At the operating system level: Computer multitasking , including both cooperative multitasking and preemptive multitasking Time-sharing , which replaced sequential batch processing of jobs with concurrent use of a system Process Thread At the network level, networked systems are generally concurrent by their nature, as they consist of separate devices. Languages supporting concurrent programming [ edit ] Concurrent programming languages are programming languages that use language constructs for concurrency . These constructs may involve multi-threading , support for distributed computing , message passing , shared resources (including shared memory ) or futures and promises . Such languages are sometimes described as concurrency-oriented languages or concurrency-oriented programming languages (COPL). [8] Today, the most commonly used programming languages that have specific constructs for concurrency are Java and C# . Both of these languages fundamentally use a shared-memory concurrency model, with locking provided by monitors (although message-passing models can and have been implemented on top of the underlying shared-memory model). Of the languages that use a message-passing concurrency model, Erlang is probably the most widely used in industry at present.[ citation needed ] Many concurrent programming languages have been developed more as research languages (e.g. Pict ) rather than as languages for production use. However, languages such as Erlang , Limbo , and occam have seen industrial use at various times in the last 20 years. Languages in which concurrency plays an important role include: Ada general purpose, with native support for message passing and monitor based concurrency Alef concurrent, with threads and message passing, for system programming in early versions of Plan 9 from Bell Labs Alice extension to Standard ML , adds support for concurrency via futures Ateji PX extension to Java with parallel primitives inspired from π-calculus Axum domain specific, concurrent, based on actor model and .NET Common Language Runtime using a C-like syntax BMDFM Binary Modular DataFlow Machine C++ std::thread Cω (C omega) for research, extends C#, uses asynchronous communication C# supports concurrent computing using lock, yield, also since version 5.0 async and await keywords introduced Clojure modern, functional dialect of Lisp on the Java platform Concurrent Clean functional programming, similar to Haskell Concurrent Collections (CnC) Achieves implicit parallelism independent of memory model by explicitly defining flow of data and control Concurrent Haskell lazy, pure functional language operating concurrent processes on shared memory Concurrent ML concurrent extension of Standard ML Concurrent Pascal by Per Brinch Hansen Curry D multi-paradigm system programming language with explicit support for concurrent programming ( actor model ) E uses promises to preclude deadlocks ECMAScript uses promises for asynchronous operations Eiffel through its SCOOP mechanism based on the concepts of Design by Contract Elixir dynamic and functional meta-programming aware language running on the Erlang VM. Erlang uses asynchronous message passing with nothing shared FAUST real-time functional, for signal processing, compiler provides automatic parallelization via OpenMP or a specific work-stealing scheduler Fortran coarrays and do concurrent are part of Fortran 2008 standard Go for system programming, with a concurrent programming model based on CSP Haskell concurrent, and parallel functional programming language [9] Hume functional, concurrent, for bounded space and time environments where automata processes are described by synchronous channels patterns and message passing Io actor-based concurrency Janus features distinct askers and tellers to logical variables, bag channels; is purely declarative Java thread class or Runnable interface Julia \"concurrent programming primitives: Tasks, async-wait, Channels.\" [10] JavaScript via web workers , in a browser environment, promises , and callbacks . JoCaml concurrent and distributed channel based, extension of OCaml , implements the join-calculus of processes Join Java concurrent, based on Java language Joule dataflow-based, communicates by message passing Joyce concurrent, teaching, built on Concurrent Pascal with features from CSP by Per Brinch Hansen LabVIEW graphical, dataflow, functions are nodes in a graph, data is wires between the nodes; includes object-oriented language Limbo relative of Alef , for system programming in Inferno (operating system) MultiLisp Scheme variant extended to support parallelism Modula-2 for system programming, by N. Wirth as a successor to Pascal with native support for coroutines Modula-3 modern member of Algol family with extensive support for threads, mutexes, condition variables Newsqueak for research, with channels as first-class values; predecessor of Alef occam influenced heavily by communicating sequential processes (CSP) occam-π a modern variant of occam , which incorporates ideas from Milner's π-calculus Orc heavily concurrent, nondeterministic, based on Kleene algebra Oz-Mozart multiparadigm, supports shared-state and message-passing concurrency, and futures ParaSail object-oriented, parallel, free of pointers, race conditions Pict essentially an executable implementation of Milner's π-calculus Raku includes classes for threads, promises and channels by default [11] Python using Stackless Python Reia uses asynchronous message passing between shared-nothing objects Red/System for system programming, based on Rebol Rust for system programming, using message-passing with move semantics, shared immutable memory, and shared mutable memory. [12] Scala general purpose, designed to express common programming patterns in a concise, elegant, and type-safe way SequenceL general purpose functional, main design objectives are ease of programming, code clarity-readability, and automatic parallelization for performance on multicore hardware, and provably free of race conditions SR for research SuperPascal concurrent, for teaching, built on Concurrent Pascal and Joyce by Per Brinch Hansen Unicon for research TNSDL for developing telecommunication exchanges, uses asynchronous message passing VHSIC Hardware Description Language ( VHDL ) IEEE STD-1076 XC concurrency-extended subset of C language developed by XMOS , based on communicating sequential processes , built-in constructs for programmable I/O Many other languages provide support for concurrency in the form of libraries, at levels roughly comparable with the above list. See also [ edit ] Asynchronous I/O Chu space Flow-based programming Java ConcurrentMap List of important publications in concurrent, parallel, and distributed computing Ptolemy Project Race condition § Computing Sheaf (mathematics) Transaction processing Notes [ edit ] ^ This is discounting parallelism internal to a processor core, such as pipelining or vectorized instructions. A one-core, one-processor machine may be capable of some parallelism, such as with a coprocessor , but the processor alone is not. References [ edit ] ^ Operating System Concepts 9th edition, Abraham Silberschatz. \"Chapter 4: Threads\" ^ Jump up to: a b Pike, Rob (2012-01-11). \"Concurrency is not Parallelism\". Waza conference, 11 January 2012. Retrieved from http://talks.golang.org/2012/waza.slide (slides) and http://vimeo.com/49718712 (video). ^ \"Parallelism vs. Concurrency\" . Haskell Wiki. ^ Schneider, Fred B. (1997-05-06). On Concurrent Programming. Springer. ISBN 9780387949420 . ^ Jump up to: a b Ben-Ari, Mordechai (2006). Principles of Concurrent and Distributed Programming (2nd ed.). Addison-Wesley. ISBN 978-0-321-31283-9 . ^ Patterson & Hennessy 2013 , p. 503. ^ \"PODC Influential Paper Award: 2002\" , ACM Symposium on Principles of Distributed Computing , retrieved 2009-08-24 ^ Armstrong, Joe (2003). \"Making reliable distributed systems in the presence of software errors\" (PDF). ^ Marlow, Simon (2013) Parallel and Concurrent Programming in Haskell : Techniques for Multicore and Multithreaded Programming ISBN 9781449335946 ^ https://juliacon.talkfunnel.com/2015/21-concurrent-and-parallel-programming-in-julia Concurrent and Parallel programming in Julia ^ \"Concurrency\" . docs.perl6.org . Retrieved 2017-12-24. ^ Blum, Ben (2012). \"Typesafe Shared Mutable State\" . Retrieved 2012-11-14. Sources [ edit ] Patterson, David A.; Hennessy, John L. (2013). Computer Organization and Design: The Hardware/Software Interface. The Morgan Kaufmann Series in Computer Architecture and Design (5 ed.). Morgan Kaufmann. ISBN 978-0-12407886-4 . Further reading [ edit ] Dijkstra, E. W. (1965). \"Solution of a problem in concurrent programming control\". Communications of the ACM . 8 (9): 569. doi : 10.1145/365559.365617 . Herlihy, Maurice (2008) [2008]. The Art of Multiprocessor Programming. Morgan Kaufmann. ISBN 978-0123705914 . Downey, Allen B. (2005) [2005]. The Little Book of Semaphores (PDF). Green Tea Press. ISBN 978-1-4414-1868-5 . Archived from the original (PDF) on 2016-03-04 . Retrieved 2009-11-21. Filman, Robert E.; Daniel P. Friedman (1984). Coordinated Computing: Tools and Techniques for Distributed Software . New York: McGraw-Hill. p. 370 . ISBN 978-0-07-022439-1 . Leppäjärvi, Jouni (2008). A pragmatic, historically oriented survey on the universality of synchronization primitives (PDF). University of Oulu. Taubenfeld, Gadi (2006). Synchronization Algorithms and Concurrent Programming . Pearson / Prentice Hall. p. 433. ISBN 978-0-13-197259-9 . External links [ edit ] Media related to Concurrent programming at Wikimedia Commons Concurrent Systems Virtual Library show v t e Edsger Dijkstra Notable works A Primer of ALGOL 60 Programming (book) Structured Programming (book) A Discipline of Programming (book) A Method of Programming (book) Predicate Calculus and Program Semantics (book) Selected Writings on Computing: A Personal Perspective (book) A Note on Two Problems in Connexion with Graphs Cooperating Sequential Processes Solution of a Problem in Concurrent Programming Control The Structure of the 'THE'-Multiprogramming System Go To Statement Considered Harmful Notes on Structured Programming The Humble Programmer Programming Considered as a Human Activity How Do We Tell Truths That Might Hurt? On the Role of Scientific Thought Self-stabilizing Systems in Spite of Distributed Control On the Cruelty of Really Teaching Computer Science Selected papers EWD manuscripts Main research areas Theoretical computing science Software engineering Systems science Algorithm design Concurrent computing Distributed computing Formal methods Programming methodology Programming language research Program design and development Software architecture Philosophy of computer programming and computing science Scientific contributions Concepts, methods ALGOL 60 implementation Call stack Concurrency Concurrent programming Cooperating sequential processes Critical section Deadly embrace ( deadlock ) Dining philosophers problem Dutch national flag problem Fault-tolerant system Goto-less programming Guarded Command Language Layered structure in software architecture Levels of abstraction Multithreaded programming Mutual exclusion ( mutex ) Producer consumer problem ( bounded buffer problem ) Program families Predicate transformer semantics Process synchronization Self-stabilizing distributed system Semaphore (programming) Separation of concerns Sleeping barber problem Software crisis Structured analysis Structured programming THE multiprogramming system Unbounded nondeterminism Weakest precondition calculus Algorithms Banker's algorithm Dijkstra's algorithm DJP algorithm ( Prim's algorithm ) Dijkstra-Scholten algorithm Dekker's algorithm (generalization) Smoothsort Shunting-yard algorithm Tri-color marking algorithm Concurrent algorithms Distributed algorithms Deadlock prevention algorithms Mutual exclusion algorithms Self-stabilizing algorithms Related people Shlomi Dolev Per Brinch Hansen Tony Hoare Ole-Johan Dahl Leslie Lamport David Parnas Carel S. Scholten Adriaan van Wijngaarden Niklaus Wirth Other topics Dijkstra Prize ( Edsger W. Dijkstra Prize in Distributed Computing ) Centrum Wiskunde & Informatica (CWI Amsterdam) Dijkstra Fellowship International Symposium on Stabilization, Safety, and Security of Distributed Systems E.W. Dijkstra Archive ( University of Texas at Austin ) List of important publications in computer science List of important publications in theoretical computer science List of important publications in concurrent, parallel, and distributed computing List of pioneers in computer science List of people considered father or mother of a technical field Wikiquote show v t e Concurrent computing General Concurrency Concurrency control Process calculi CSP CCS ACP LOTOS π-calculus Ambient calculus API-Calculus PEPA Join-calculus Classic problems ABA problem Cigarette smokers problem Deadlock Dining philosophers problem Producer consumer problem Race condition Readers writers problem Sleeping barber problem Read-of-non-persistent-write problem Category: Concurrent computing show v t e Types of programming languages Paradigm Actor-based Array Aspect-oriented Class-based Concatenative Concurrent Dataflow Declarative Domain-specific Dynamic Esoteric Event-driven Extensible Functional Imperative Logic Macro Metaprogramming Object-based Object-oriented Pipeline Procedural Prototype-based Reflective Rule-based Scripting Stack-oriented Synchronous Tactile Template Level Assembly Compiled Interpreted Machine Low-level High-level Very high-level Generation First Second Third Fourth Fifth Related Non-English-based Visual Retrieved from \" https://en.wikipedia.org/w/index.php?title=Concurrent_computing&oldid=992288651 \" Categories : Concurrent computing Operating system technology Edsger W. Dijkstra Dutch inventions Hidden categories: Articles with short description Short description matches Wikidata Articles needing additional references from February 2014 All articles needing additional references Articles needing additional references from December 2016 Articles that may contain original research from December 2016 All articles that may contain original research Articles with multiple maintenance issues All articles with unsourced statements Articles with unsourced statements from December 2016 Articles needing additional references from December 2006 Articles to be expanded from February 2014 All articles to be expanded Articles using small message boxes Articles with unsourced statements from May 2013 Articles with unsourced statements from August 2010 Commons category link is on Wikidata Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version In other projects Wikimedia Commons Languages العربية Български Català Español Euskara فارسی Français 한국어 हिन्दी Nederlands 日本語 Norsk bokmål Polski Português Русский Српски / srpski Suomi Українська 粵語 中文 11 more Edit links This page was last edited on 4 December 2020, at 14:29 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License ; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement Enable previews ",
                "urlTerms": [
                    "wiki",
                    "concurrent",
                    "computing"
                ],
                "titleTerms": [
                    "concurrent",
                    "computing",
                    "wikipedia"
                ]
            }
        },
        {
            "timestamp": 1608952140022,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "en.wikipedia.org/wiki/Concurrent_computing"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "en.wikipedia.org/wiki/Concurrent_computing",
                "fullUrl": "https://en.wikipedia.org/wiki/Concurrent_computing",
                "createdAt": "2020-12-26T03:09:00.007Z"
            }
        },
        {
            "timestamp": 1608952140036,
            "collection": "visits",
            "objectPk": [
                1608952140031,
                "en.wikipedia.org/wiki/Concurrent_computing"
            ],
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Concurrent_computing",
                "time": 1608952140031
            }
        },
        {
            "timestamp": 1608952140047,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Concurrent_computing/#1608952139635",
            "operation": "create",
            "object": {
                "pageTitle": "Concurrent computing - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Concurrent_computing",
                "body": "Concurrent computing is a form of computing in which several computations are executed concurrently—during overlapping time periods—instead of sequentially, with one completing before the next starts.\r\n\r\nThis is a property of a system—whether a program, computer, or a network—where there is a separate execution point or \"thread of control\" for each process. A concurrent system is one where a computation can advance without waiting for all other computations to complete",
                "comment": "",
                "selector": {
                    "quote": "Concurrent computing is a form of computing in which several computations are executed concurrently—during overlapping time periods—instead of sequentially, with one completing before the next starts.\r\n\r\nThis is a property of a system—whether a program, computer, or a network—where there is a separate execution point or \"thread of control\" for each process. A concurrent system is one where a computation can advance without waiting for all other computations to complete",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[1]/b[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[2]",
                                "endOffset": 269
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 2754,
                                "end": 3224
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Concurrent computing is a form of computing in which several computations are executed concurrently—during overlapping time periods—instead of sequentially, with one completing before the next starts.\nThis is a property of a system—whether a program, computer, or a network—where there is a separate execution point or \"thread of control\" for each process. A concurrent system is one where a computation can advance without waiting for all other computations to complete",
                                "prefix": "ign:left;margin-right:0.5em}vte\n",
                                "suffix": ".[1]\nConcurrent computing is a f"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:08:59.635Z",
                "lastEdited": "2020-12-26T03:08:59.635Z",
                "url": "https://en.wikipedia.org/wiki/Concurrent_computing/#1608952139635"
            }
        },
        {
            "timestamp": 1608952218796,
            "collection": "pages",
            "objectPk": "en.wikipedia.org/wiki/Modular_programming",
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Modular_programming",
                "fullUrl": "https://en.wikipedia.org/wiki/Modular_programming",
                "domain": "wikipedia.org",
                "hostname": "en.wikipedia.org",
                "fullTitle": "Modular programming - Wikipedia",
                "text": " Modular programming From Wikipedia, the free encyclopedia Jump to navigation Jump to search Programming paradigms Action Agent-oriented Array-oriented Automata-based Concurrent computing Relativistic programming Data-driven Declarative (contrast: Imperative ) Functional Functional logic Purely functional Logic Abductive logic Answer set Concurrent logic Functional logic Inductive logic Constraint Constraint logic Concurrent constraint logic Dataflow Flow-based Reactive Functional reactive Ontology Differentiable Dynamic/scripting Event-driven Function-level (contrast: Value-level ) Point-free style Concatenative Generic Imperative (contrast: Declarative ) Procedural Object-oriented Polymorphic Intentional Language-oriented Domain-specific Literate Natural-language programming Metaprogramming Automatic Inductive programming Reflective Attribute-oriented Macro Template Non-structured (contrast: Structured ) Array Nondeterministic Parallel computing Process-oriented Probabilistic Quantum Set-theoretic Stack-based Structured (contrast: Non-structured ) Block-structured Structured concurrency Object-oriented Actor-based Class-based Concurrent Prototype-based By separation of concerns : Aspect-oriented Role-oriented Subject-oriented Recursive Symbolic Value-level (contrast: Function-level ) v t e Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains everything necessary to execute only one aspect of the desired functionality. A module interface expresses the elements that are provided and required by the module. The elements defined in the interface are detectable by other modules. The implementation contains the working code that corresponds to the elements declared in the interface. Modular programming is closely related to structured programming and object-oriented programming , all having the same goal of facilitating construction of large software programs and systems by decomposition into smaller pieces, and all originating around the 1960s. While the historical usage of these terms has been inconsistent, \"modular programming\" now refers to the high-level decomposition of the code of an entire program into pieces: structured programming to the low-level code use of structured control flow , and object-oriented programming to the data use of objects , a kind of data structure . In object-oriented programming, the use of interfaces as an architectural pattern to construct modules is known as interface-based programming [ citation needed ]. Contents 1 Terminology 2 Language support 3 Key aspects 4 History 5 See also 6 Notes 7 References 8 External links Terminology [ edit ] The term assembly (as in .NET languages like C# , F# or Visual Basic .NET ) or package (as in Dart , Go or Java ) is sometimes used instead of module. In other implementations, these are distinct concepts; in Python a package is a collection of modules, while in Java 9 the introduction of the new module concept (a collection of packages with enhanced access control) is planned. Furthermore, the term \"package\" has other uses in software (for example .NET NuGet packages ). A component is a similar concept, but typically refers to a higher level; a component is a piece of a whole system , while a module is a piece of an individual program. The scale of the term \"module\" varies significantly between languages; in Python it is very small-scale and each file is a module, while in Java 9 it is planned to be large-scale, where a module is a collection of packages, which are in turn collections of files. Other terms for modules include unit, used in Pascal dialects. Language support [ edit ] Languages that formally support the module concept include Ada , Algol , BlitzMax , C++ , C# , Clojure , COBOL , Common_Lisp , D , Dart , eC , Erlang , Elixir , Elm , F , F# , Fortran , Go , Haskell , IBM/360 Assembler , IBM i Control Language (CL), IBM RPG , Java , [a] MATLAB , ML , Modula , Modula-2 , Modula-3 , Morpho, NEWP , Oberon , Oberon-2 , Objective-C , OCaml , several derivatives of Pascal ( Component Pascal , Object Pascal , Turbo Pascal , UCSD Pascal ), Perl , PL/I , PureBasic , Python , Ruby , [2] Rust , JavaScript , [3] Visual Basic .NET and WebDNA . Conspicuous examples of languages that lack support for modules are C and have been C++ and Pascal in their original form, C and C++ do, however, allow separate compilation and declarative interfaces to be specified using header files . Modules were added to Objective-C in iOS 7 (2013); to C++ with C++20 , [4] and Pascal was superseded by Modula and Oberon, which included modules from the start, and various derivatives that included modules. JavaScript has had native modules since ECMAScript 2015. Modular programming can be performed even where the programming language lacks explicit syntactic features to support named modules, like, for example, in C. This is done by using existing language features, together with, for example, coding conventions , programming idioms and the physical code structure. The IBM System i also uses modules when programming in the Integrated Language Environment (ILE). Key aspects [ edit ] With modular programming, concerns are separated such that modules perform logically discrete functions, interacting through well-defined interfaces. Often modules form a directed acyclic graph (DAG); in this case a cyclic dependency between modules is seen as indicating that these should be a single module. In the case where modules do form a DAG they can be arranged as a hierarchy, where the lowest-level modules are independent, depending on no other modules, and higher-level modules depend on lower-level ones. A particular program or library is a top-level module of its own hierarchy, but can in turn be seen as a lower-level module of a higher-level program, library, or system. When creating a modular system, instead of creating a monolithic application (where the smallest component is the whole), several smaller modules are written separately so when they are composed together, they construct the executable application program. Typically these are also compiled separately, via separate compilation , and then linked by a linker . A just-in-time compiler may perform some of this construction \"on-the-fly\" at run time . These independent functions are commonly classified as either program control functions or specific task functions. Program control functions are designed to work for one program. Specific task functions are closely prepared to be applicable for various programs. This makes modular designed systems, if built correctly, far more reusable than a traditional monolithic design, since all (or many) of these modules may then be reused (without change) in other projects. This also facilitates the \"breaking down\" of projects into several smaller projects. Theoretically, a modularized software project will be more easily assembled by large teams, since no team members are creating the whole system, or even need to know about the system as a whole. They can focus just on the assigned smaller task (this, it is claimed, counters the key assumption of The Mythical Man Month , making it actually possible to add more developers to a late software project without making it later still). History [ edit ] Modular programming, in the form of subsystems (particularly for I/O) and software libraries, dates to early software systems, where it was used for code reuse . Modular programming per se, with a goal of modularity, developed in the late 1960s and 1970s, as a larger-scale analog of the concept of structured programming (1960s). The term \"modular programming\" dates at least to the National Symposium on Modular Programming, organized at the Information and Systems Institute in July 1968 by Larry Constantine ; other key concepts were information hiding (1972) and separation of concerns (SoC, 1974). Modules were not included in the original specification for ALGOL 68 (1968), but were included as extensions in early implementations, ALGOL 68-R (1970) and ALGOL 68C (1970), and later formalized. [5] One of the first languages designed from the start for modular programming was the short-lived Modula (1975), by Niklaus Wirth . Another early modular language was Mesa (1970s), by Xerox PARC , and Wirth drew on Mesa as well as the original Modula in its successor, Modula-2 (1978), which influenced later languages, particularly through its successor, Modula-3 (1980s). Modula's use of dot- qualified names , like M.a to refer to object a from module M, coincides with notation to access a field of a record (and similarly for attributes or methods of objects), and is now widespread, seen in C#, Dart, Go, Java, and Python, among others. Modular programming became widespread from the 1980s: the original Pascal language (1970) did not include modules, but later versions, notably UCSD Pascal (1978) and Turbo Pascal (1983) included them in the form of \"units\", as did the Pascal-influenced Ada (1980). The Extended Pascal ISO 10206:1990 standard kept closer to Modula2 in its modular support. Standard ML (1984) [6] has one of the most complete module systems, including functors (parameterized modules) to map between modules. In the 1980s and 1990s, modular programming was overshadowed by and often conflated with object-oriented programming , particularly due to the popularity of C++ and Java. For example, the C family of languages had support for objects and classes in C++ (originally C with Classes , 1980) and Objective-C (1983), only supporting modules 30 years or more later. Java (1995) supports modules in the form of packages, though the primary unit of code organization is a class. However, Python (1991) prominently used both modules and objects from the start, using modules as the primary unit of code organization and \"packages\" as a larger-scale unit; and Perl 5 (1994) includes support for both modules and objects, with a vast array of modules being available from CPAN (1993). Modular programming is now widespread, and found in virtually all major languages developed since the 1990s. The relative importance of modules varies between languages, and in class-based object-oriented languages there is still overlap and confusion with classes as a unit of organization and encapsulation, but these are both well-established as distinct concepts. See also [ edit ] Architecture description language Cohesion (computer science) Component-based software engineering Conway's law Coupling (computer science) David Parnas Information hiding (encapsulation) Library (computing) List of system quality attributes Modular design Plug-in (computing) Snippet (programming) Structured Analysis Structured programming Notes [ edit ] ^ The term \"package\" is used for the analog of modules in the JLS; [1] see Java package . \" Modules \", a kind of collection of packages, are planned for Java 9 as part of Project Jigsaw ; these were earlier called \"superpackages\" and planned for Java 7. References [ edit ] ^ James Gosling, Bill Joy, Guy Steele, Gilad Bracha, The Java Language Specification, Third Edition, ISBN 0-321-24678-0 , 2005. In the Introduction, it is stated \"Chapter 7 describes the structure of a program, which is organized into packages similar to the modules of Modula.\" The word \"module\" has no special meaning in Java. ^ [1] ^ ECMAScript® 2015 Language Specification, 15.2 Modules ^ \"N4720: Working Draft, Extensions to C++ for Modules\" (PDF). ^ Lindsey, Charles H. (Feb 1976). \"Proposal for a Modules Facility in ALGOL 68\" (PDF). ALGOL Bulletin (39): 20 29. Archived from the original (PDF) on 2016-03-03 . Retrieved 2014-12-01. ^ David MacQueen (August 1984). \"Modules for Standard ML, LFP '84 Proceedings of the 1984 ACM Symposium on LISP and functional programming\": 198 207. Cite journal requires |journal= ( help ) External links [ edit ] How To Decompose a System into Modules Authority control BNF : cb133251240 (data) LCCN : sh85086464 NDL : 00567885 Retrieved from \" https://en.wikipedia.org/w/index.php?title=Modular_programming&oldid=994745807 \" Categories : Programming paradigms Modularity Hidden categories: CS1 errors: missing periodical All articles with unsourced statements Articles with unsourced statements from June 2015 Wikipedia articles with BNF identifiers Wikipedia articles with LCCN identifiers Wikipedia articles with NDL identifiers Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version Languages العربية Български Català Čeština Deutsch Español Euskara فارسی Français Galego 한국어 Italiano Norsk bokmål Русский Simple English Српски / srpski Türkçe Українська 中文 10 more Edit links This page was last edited on 17 December 2020, at 09:32 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License ; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement Enable previews ",
                "urlTerms": [
                    "wiki",
                    "modular",
                    "programming"
                ],
                "titleTerms": [
                    "modular",
                    "programming",
                    "wikipedia"
                ]
            }
        },
        {
            "timestamp": 1608952218849,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "en.wikipedia.org/wiki/Modular_programming"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "en.wikipedia.org/wiki/Modular_programming",
                "fullUrl": "https://en.wikipedia.org/wiki/Modular_programming",
                "createdAt": "2020-12-26T03:10:18.828Z"
            }
        },
        {
            "timestamp": 1608952218866,
            "collection": "visits",
            "objectPk": [
                1608952218860,
                "en.wikipedia.org/wiki/Modular_programming"
            ],
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Modular_programming",
                "time": 1608952218860
            }
        },
        {
            "timestamp": 1608952218882,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Modular_programming/#1608952218496",
            "operation": "create",
            "object": {
                "pageTitle": "Modular programming - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Modular_programming",
                "body": "Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains everything necessary to execute only one aspect of the desired functionality.\r\n\r\nA module interface expresses the elements that are provided and required by the module. The elements defined in the interface are detectable by other modules. The implementation contains the working code that corresponds to the elements declared in the interface. Modular programming is closely related to structured programming and object-oriented programming, all having the same goal of facilitating construction of large software programs and systems by decomposition into smaller pieces, and all originating around the 1960s. While the historical usage of these terms has been inconsistent, \"modular programming\" now refers to the high-level decomposition of the code of an entire program into pieces: structured programming to the low-level code use of structured control flow, and object-oriented programming to the data use of objects, a kind of data structure.\r\n\r\nIn object-oriented programming, the use of interfaces as an architectural pattern to construct modules is known as interface-based programming",
                "comment": "",
                "selector": {
                    "quote": "Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains everything necessary to execute only one aspect of the desired functionality.\r\n\r\nA module interface expresses the elements that are provided and required by the module. The elements defined in the interface are detectable by other modules. The implementation contains the working code that corresponds to the elements declared in the interface. Modular programming is closely related to structured programming and object-oriented programming, all having the same goal of facilitating construction of large software programs and systems by decomposition into smaller pieces, and all originating around the 1960s. While the historical usage of these terms has been inconsistent, \"modular programming\" now refers to the high-level decomposition of the code of an entire program into pieces: structured programming to the low-level code use of structured control flow, and object-oriented programming to the data use of objects, a kind of data structure.\r\n\r\nIn object-oriented programming, the use of interfaces as an architectural pattern to construct modules is known as interface-based programming",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[1]/b[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[3]/sup[1]",
                                "endOffset": 0
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 2254,
                                "end": 3520
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains everything necessary to execute only one aspect of the desired functionality.\nA module interface expresses the elements that are provided and required by the module. The elements defined in the interface are detectable by other modules. The implementation contains the working code that corresponds to the elements declared in the interface. Modular programming is closely related to structured programming and object-oriented programming, all having the same goal of facilitating construction of large software programs and systems by decomposition into smaller pieces, and all originating around the 1960s. While the historical usage of these terms has been inconsistent, \"modular programming\" now refers to the high-level decomposition of the code of an entire program into pieces: structured programming to the low-level code use of structured control flow, and object-oriented programming to the data use of objects, a kind of data structure.\nIn object-oriented programming, the use of interfaces as an architectural pattern to construct modules is known as interface-based programming",
                                "prefix": "ign:left;margin-right:0.5em}vte\n",
                                "suffix": "[citation needed].\n\nContents\n\n1 "
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:10:18.496Z",
                "lastEdited": "2020-12-26T03:10:18.496Z",
                "url": "https://en.wikipedia.org/wiki/Modular_programming/#1608952218496"
            }
        },
        {
            "timestamp": 1608952253458,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Modular_programming/#1608952253442",
            "operation": "create",
            "object": {
                "pageTitle": "Modular programming - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Modular_programming",
                "body": "Terminology\r\n\r\nThe term assembly (as in .NET languages like C#, F# or Visual Basic .NET) or package (as in Dart, Go or Java) is sometimes used instead of module. In other implementations, these are distinct concepts; in Python a package is a collection of modules, while in Java 9 the introduction of the new module concept (a collection of packages with enhanced access control) is planned.\r\n\r\nFurthermore, the term \"package\" has other uses in software (for example .NET NuGet packages). A component is a similar concept, but typically refers to a higher level; a component is a piece of a whole system, while a module is a piece of an individual program. The scale of the term \"module\" varies significantly between languages; in Python it is very small-scale and each file is a module, while in Java 9 it is planned to be large-scale, where a module is a collection of packages, which are in turn collections of files. ",
                "comment": "",
                "selector": {
                    "quote": "Terminology\r\n\r\nThe term assembly (as in .NET languages like C#, F# or Visual Basic .NET) or package (as in Dart, Go or Java) is sometimes used instead of module. In other implementations, these are distinct concepts; in Python a package is a collection of modules, while in Java 9 the introduction of the new module concept (a collection of packages with enhanced access control) is planned.\r\n\r\nFurthermore, the term \"package\" has other uses in software (for example .NET NuGet packages). A component is a similar concept, but typically refers to a higher level; a component is a piece of a whole system, while a module is a piece of an individual program. The scale of the term \"module\" varies significantly between languages; in Python it is very small-scale and each file is a module, while in Java 9 it is planned to be large-scale, where a module is a collection of packages, which are in turn collections of files. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/h2[1]/span[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/h2[1]/span[2]/span[1]",
                                "endOffset": 0
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 3659,
                                "end": 3670
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Terminology",
                                "prefix": " References\n8 External links\n\n\n\n",
                                "suffix": "[edit]\nThe term assembly (as in "
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:10:53.442Z",
                "lastEdited": "2020-12-26T03:10:53.442Z",
                "url": "https://en.wikipedia.org/wiki/Modular_programming/#1608952253442"
            }
        },
        {
            "timestamp": 1608952279145,
            "collection": "pages",
            "objectPk": "en.wikipedia.org/wiki/Interface_(computing)",
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Interface_(computing)",
                "fullUrl": "https://en.wikipedia.org/wiki/Interface_(computing)",
                "domain": "wikipedia.org",
                "hostname": "en.wikipedia.org",
                "fullTitle": "Interface (computing) - Wikipedia",
                "text": " Interface (computing) From Wikipedia, the free encyclopedia Jump to navigation Jump to search Concept of computer science; point of interaction between two things This article needs additional citations for verification . Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed. Find sources: \"Interface\" computing news · newspapers · books · scholar · JSTOR ( May 2010) ( Learn how and when to remove this template message ) In computing, an interface is a shared boundary across which two or more separate components of a computer system exchange information. The exchange can be between software , computer hardware , peripheral devices, humans , and combinations of these. [1] Some computer hardware devices, such as a touchscreen , can both send and receive data through the interface, while others such as a mouse or microphone may only provide an interface to send data to a given system. [2] Contents 1 Hardware interfaces 2 Software interfaces 2.1 In practice 2.2 In object-oriented languages 2.3 Programming to the interface 3 User interfaces 4 See also 5 References Hardware interfaces [ edit ] Main article: Hardware interface Hardware interfaces exist in many of the components, such as the various buses , storage devices , other I/O devices, etc. A hardware interface is described by the mechanical, electrical and logical signals at the interface and the protocol for sequencing them (sometimes called signaling). [3] A standard interface, such as SCSI , decouples the design and introduction of computing hardware, such as I/O devices, from the design and introduction of other components of a computing system, thereby allowing users and manufacturers great flexibility in the implementation of computing systems. [3] Hardware interfaces can be parallel with several electrical connections carrying parts of the data simultaneously, or serial where data are sent one bit at a time. [4] Software interfaces [ edit ] See also: Application binary interface and Application programming interface A software interface may refer to a wide range of different types of interface at different \"levels\": an operating system may interface with pieces of hardware. Applications or programs running on the operating system may need to interact via data streams , filters, and pipelines; [5] and in object oriented programs , objects within an application may need to interact via methods . [6] In practice [ edit ] A key principle of design is to prohibit access to all resources by default, allowing access only through well-defined entry points, i.e., interfaces. [7] Software interfaces provide access to computer resources (such as memory, CPU, storage, etc.) of the underlying computer system; direct access (i.e., not through well-designed interfaces) to such resources by software can have major ramifications sometimes disastrous ones for functionality and stability.[ citation needed ] Interfaces between software components can provide constants , data types , types of procedures , exception specifications, and method signatures . Sometimes, public variables are also defined as part of an interface. [8] The interface of a software module A is deliberately defined separately from the implementation of that module. The latter contains the actual code of the procedures and methods described in the interface, as well as other \"private\" variables, procedures, etc. Another software module B, for example the client to A, that interacts with A is forced to do so only through the published interface. One practical advantage of this arrangement is that replacing the implementation of A with another implementation of the same interface should not cause B to fail how A internally meets the requirements of the interface is not relevant to B, which is only concerned with the specifications of the interface. (See also Liskov substitution principle .)[ citation needed ] In object-oriented languages [ edit ] Main articles: Protocol (object-oriented programming) and Concept (generic programming) In some object-oriented languages, especially those without full multiple inheritance , the term interface is used to define an abstract type that contains no data but defines behaviours as method signatures. A class having code and data for all the methods corresponding to that interface and declaring so is said to implement that interface. [9] Furthermore, even in single-inheritance-languages, one can implement multiple interfaces, and hence can be of different types at the same time. [10] An interface is thus a type definition; anywhere an object can be exchanged (for example, in a function or method call) the type of the object to be exchanged can be defined in terms of one of its implemented interfaces or base-classes rather than specifying the specific class . This approach means that any class that implements that interface can be used.[ citation needed ] For example, a dummy implementation may be used to allow development to progress before the final implementation is available. In another case, a fake or mock implementation may be substituted during testing. Such stub implementations are replaced by real code later in the development process. Usually a method defined in an interface contains no code and thus cannot itself be called; it must be implemented by non-abstract code to be run when it is invoked.[ citation needed ] An interface called \" Stack \" might define two methods: push() and pop(). It can be implemented in different ways, for example, FastStack and GenericStack the first being fast, working with a data structure of fixed size, and the second using a data structure that can be resized, but at the cost of somewhat lower speed. Though interfaces can contain many methods they may contain only one or even none at all. For example, the Java language defines the interface Readable that has the single read () method; various implementations are used for different purposes, including BufferedReader, FileReader, InputStreamReader, PipedReader, and StringReader. Marker interfaces like Serializable contain no methods at all and serve to provide run-time information to generic processing using Reflection . [11] Programming to the interface [ edit ] The use of interfaces allows for a programming style called programming to the interface. The idea behind this approach is to base programming logic on the interfaces of the objects used, rather than on internal implementation details. Programming to the interface reduces dependency on implementation specifics and makes code more reusable. [12] Pushing this idea to the extreme, inversion of control leaves the context to inject the code with the specific implementations of the interface that will be used to perform the work. User interfaces [ edit ] Main article: User interface A user interface is a point of interaction between a computer and humans; it includes any number of modalities of interaction (such as graphics, sound, position, movement, etc.) where data is transferred between the user and the computer system. See also [ edit ] Abstraction inversion Application binary interface Application programming interface Business Interoperability Interface Computer bus Hard disk drive interface Implementation (computer science) Implementation inheritance Inheritance semantics Modular programming Software componentry Virtual inheritance References [ edit ] ^ Hookway, B. (2014). \"Chapter 1: The Subject of the Interface\". Interface . MIT Press. pp. 1 58. ISBN 9780262525503 . ^ IEEE 100 - The Authoritative Dictionary Of IEEE Standards Terms. NYC, NY, USA: IEEE Press. 2000. pp. 574 575. ISBN 9780738126012 . ^ Jump up to: a b Blaauw, Gerritt A.; Brooks, Jr., Frederick P. (1997), \"Chapter 8.6, Device Interfaces\", Computer Architecture-Concepts and Evolution, Addison-Wesley, pp. 489 493, ISBN 0-201-10557-8 See also: Patterson, David A.; Hennessey, John L. (2005), \"Chapter 8.5, Interfacing I/O Devices to the Processor, Memory and Operating System\", Computer Organization and Design - The Hardware/Software Interface, Third Edition , Morgan Kaufmann, pp. 588 596 , ISBN 1-55860-604-1 ^ Govindarajalu, B. (2008). \"3.15 Peripheral Interfaces and Controllers - OG\". IBM PC And Clones: Hardware, Troubleshooting And Maintenance . Tata McGraw-Hill Publishing Co. Ltd. pp. 142 144. ISBN 9780070483118 . Retrieved 15 June 2018. ^ Buyya, R. (2013). Mastering Cloud Computing . Tata McGraw-Hill Education. p. 2.13. ISBN 9781259029950 . ^ Poo, D.; Kiong, D.; Ashok, S. (2008). \"Chapter 2: Object, Class, Message and Method\". Object-Oriented Programming and Java . Springer-Verlag. pp. 7 15. ISBN 9781846289637 . ^ Bill Venners (2005-06-06). \"Leading-Edge Java: Design Principles from Design Patterns: Program to an interface, not an implementation - A Conversation with Erich Gamma, Part III\" . http://www.artima.com/index.jsp : artima developer. Archived from the original on 2011-08-05 . Retrieved 2011-08-03. Once you depend on interfaces only, you're decoupled from the implementation. That means the implementation can vary, and that is a healthy dependency relationship. For example, for testing purposes you can replace a heavy database implementation with a lighter-weight mock implementation. Fortunately, with today's refactoring support you no longer have to come up with an interface up front. You can distill an interface from a concrete class once you have the full insights into a problem. The intended interface is just one 'extract interface' refactoring away. ... ^ Patterson, D.A.; Hennessy, J.L. Computer Organization and Design: The Hardware/Software Interface (3rd ed.). Elsevier. p. 656. ISBN 9780080502571 . ^ \"What Is an Interface\" . The Java Tutorials. Oracle. Archived from the original on 2012-04-12 . Retrieved 2012-05-01. ^ \"Interfaces\" . The Java Tutorials. Oracle. Archived from the original on 2012-05-26 . Retrieved 2012-05-01. ^ \"Performance improvement techniques in Serialization\" . http://www.precisejava.com/ : Precise Java. Archived from the original on 2011-08-24 . Retrieved 2011-08-04. We will talk initially about Serializable interface. This is a marker interface and does not have any methods. ^ Gamma; Helm; Johnson; Vlissides (1995). Design Patterns: Elements of Reusable Object-Oriented Software . Addison Wesley. pp. 17 18 . Retrieved from \" https://en.wikipedia.org/w/index.php?title=Interface_(computing)&oldid=996000530 \" Categories : Interfaces Object-oriented programming Programming constructs Hidden categories: Articles with short description Short description matches Wikidata Articles needing additional references from May 2010 All articles needing additional references All articles with unsourced statements Articles with unsourced statements from June 2018 Articles with example Java code Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version In other projects Wikimedia Commons Languages العربية Asturianu Azərbaycanca বাংলা Беларуская Български Català Čeština Dansk Deutsch Eesti Ελληνικά Español Esperanto فارسی Français Frysk Galego 한국어 हिन्दी Hornjoserbsce Hrvatski Ido Interlingua Íslenska Italiano עברית Қазақша Кыргызча Magyar Nederlands 日本語 Norsk bokmål Олык марий Oʻzbekcha/ўзбекча Polski Português Română Русский Simple English Slovenčina Slovenščina کوردی Српски / srpski Svenska தமிழ் Українська اردو Tiếng Việt 中文 41 more Edit links This page was last edited on 24 December 2020, at 00:27 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License ; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement Enable previews ",
                "urlTerms": [
                    "wiki",
                    "interface",
                    "computing"
                ],
                "titleTerms": [
                    "interface",
                    "computing",
                    "wikipedia"
                ]
            }
        },
        {
            "timestamp": 1608952279189,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "en.wikipedia.org/wiki/Interface_(computing)"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "en.wikipedia.org/wiki/Interface_(computing)",
                "fullUrl": "https://en.wikipedia.org/wiki/Interface_(computing)",
                "createdAt": "2020-12-26T03:11:19.175Z"
            }
        },
        {
            "timestamp": 1608952279203,
            "collection": "visits",
            "objectPk": [
                1608952279198,
                "en.wikipedia.org/wiki/Interface_(computing)"
            ],
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Interface_(computing)",
                "time": 1608952279198
            }
        },
        {
            "timestamp": 1608952279218,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Interface_(computing)/#1608952278914",
            "operation": "create",
            "object": {
                "pageTitle": "Interface (computing) - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Interface_(computing)",
                "body": "In computing, an interface is a shared boundary across which two or more separate components of a computer system exchange information. The exchange can be between software, computer hardware, peripheral devices, humans, and combinations of these.[1] Some computer hardware devices, such as a touchscreen, can both send and receive data through the interface, while others such as a mouse or microphone may only provide an interface to send data to a given system",
                "comment": "",
                "selector": {
                    "quote": "In computing, an interface is a shared boundary across which two or more separate components of a computer system exchange information. The exchange can be between software, computer hardware, peripheral devices, humans, and combinations of these.[1] Some computer hardware devices, such as a touchscreen, can both send and receive data through the interface, while others such as a mouse or microphone may only provide an interface to send data to a given system",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[1]",
                                "endOffset": 463
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 525,
                                "end": 988
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "In computing, an interface is a shared boundary across which two or more separate components of a computer system exchange information. The exchange can be between software, computer hardware, peripheral devices, humans, and combinations of these.[1] Some computer hardware devices, such as a touchscreen, can both send and receive data through the interface, while others such as a mouse or microphone may only provide an interface to send data to a given system",
                                "prefix": "o remove this template message)\n",
                                "suffix": ".[2]\n\nContents\n\n1 Hardware inter"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:11:18.914Z",
                "lastEdited": "2020-12-26T03:11:18.914Z",
                "url": "https://en.wikipedia.org/wiki/Interface_(computing)/#1608952278914"
            }
        },
        {
            "timestamp": 1608952513861,
            "collection": "pages",
            "objectPk": "en.wikipedia.org/wiki/Getting_Things_Done",
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Getting_Things_Done",
                "fullUrl": "https://en.wikipedia.org/wiki/Getting_Things_Done",
                "domain": "wikipedia.org",
                "hostname": "en.wikipedia.org",
                "fullTitle": "Getting Things Done - Wikipedia",
                "text": " Getting Things Done From Wikipedia, the free encyclopedia Jump to navigation Jump to search Book by David Allen This article is about the action management system by David Allen. For other uses, see Getting Things Done (disambiguation) . This article contains content that is written like an advertisement . Please help improve it by removing promotional content and inappropriate external links , and by adding encyclopedic content written from a neutral point of view . ( April 2017) ( Learn how and when to remove this template message ) Getting Things Done: The Art of Stress-Free Productivity Getting Things Done: The Art of Stress-Free Productivity cover, first edition Author David Allen Subject Business Publisher Penguin Books Publication date 2001 Published in English 2001 Pages 267 ISBN 978-0-14-312656-0 (2015 Reprint Edition) OCLC 914220080 Getting Things Done (GTD) is a time management method, described in the book of the same title [1] by productivity consultant David Allen . The GTD method rests on the idea of moving planned tasks and projects out of the mind by recording them externally and then breaking them into actionable work items. This allows attention to be focused on taking action on tasks, instead of recalling them. [2] First published in 2001, a revised edition of the book was released in 2015 to reflect the changes in information technology during the preceding decade. Contents 1 Themes 1.1 Workflow 1.2 Implementation 1.3 Perspective 1.4 Summary 2 Reception 3 See also 4 References 5 Further reading 6 External links Themes [ edit ] Allen first demonstrates stress reduction from the method with the following exercise, centered on a task that has an unclear outcome or whose next action is not defined. Allen calls these sources of stress \"open loops\", \"incompletes\", or \"stuff\". [1] : 13 The most annoying, distracting, or interesting task is chosen, and defined as an \"incomplete\". A description of the successful outcome of the \"incomplete\" is written down in one sentence, along with the criteria by which the task will be considered completed. The next step required to approach completion of the task is written down. A self-assessment is made of the emotions experienced after completing the steps of this process. He claims stress can be reduced and productivity increased by putting reminders about everything you are not working on into a trusted system external to your mind. In this way, you can work on the task at hand without distraction from the \"incompletes\". [1] : 14 The system in GTD requires you to have the following tools within easy reach: An inbox A trash can A filing system for reference material Several lists (detailed below) A calendar. These tools can be physical or electronic as appropriate (e.g., a physical \"in\" tray or an email inbox). [1] : 88 Then, as \"stuff\" enters your life, it is captured in these tools and processed with the following workflow. [1] : 27 Workflow [ edit ] Logic tree diagram illustrating the second and third steps (process/clarify and organize) of the five-step Getting Things Done workflow. The GTD workflow consists of five stages: capture, clarify, organize, reflect, and engage. [3] (The first edition used the names collect, process, organize, plan, and do; the descriptions of the stages are similar in both editions). Once all the material (\"stuff\") is captured (or collected) in the inbox, [1] : 106 each item is clarified [1] : 122 and organized [1] : 141 by asking and answering questions about each item in turn as shown in the black boxes in the logic tree diagram. As a result, items end up in one of the eight oval end points in the diagram: in the trash on the someday/maybe list in a neat reference filing system on a list of tasks, with the outcome and next action defined if the \"incomplete\" is a \"project\" (i.e., if it will require two or more steps to complete it) immediately completed and checked off if it can be completed in under two minutes delegated to someone else and, if you want a reminder to follow up, added to a \"waiting for\" list on a context-based \"next action\" list if there is only one step to complete it on your calendar [1] : 27 Empty your inbox or inboxes daily or at least weekly (\"in\" to empty). [1] : 122 Don't use your inbox as a \"to do\" list. Don't put clarified items back into the inbox. [1] : 27 Emptying your inbox doesn't mean finishing everything. It just means applying the \"capture, clarify, organize\" steps to all your \"stuff\". [1] : 27 Next, reflection (termed planning in the first edition) occurs. Multi-step projects identified above are assigned a desired outcome and a single \"next action\". [1] : 191 Finally, a task from your task list is worked on (\"engage\" in the 2nd edition, \"do\" in the 1st edition) unless the calendar dictates otherwise. You select which task to work on next by considering where you are (i.e., the \"context\", such as at home, at work, out shopping, by the phone, at your computer, with a particular person), time available, energy available, and priority. [1] : 204 Implementation [ edit ] Because hardware and software is changing so rapidly, GTD is deliberately technologically-neutral. (In fact, Allen advises people to start with a paper-based system. [4] ) Many task management tools claim to implement GTD methodology [5] and Allen maintains a list of some technology that has been adopted in or designed for GTD. Some are designated \"GTD Enabled\", meaning Allen was involved in the design. [6] Perspective [ edit ] Allen emphasizes two key elements of GTD control and perspective. The workflow is the center of the control aspect. The goal of the control processes in GTD is to get everything except the current task out of your head and into this trusted system external to your mind. He borrows a simile used in martial arts termed \"mind like water\". When a small object is thrown into a pool of water, the water responds appropriately with a small splash followed by quiescence. When a large object is thrown in the water again responds appropriately with a large splash followed by quiescence. The opposite of \"mind like water\" is a mind that never returns to quiescence but remains continually stressed by every input. [1] : 12 With a trusted system and \"mind like water\" you can have a better perspective on your life. Allen recommends reflection from six levels, called \"Horizons of Focus\": [1] : 215 219 Horizon 5: Life Horizon 4: Long-term visions Horizon 3: 1-2 year goals Horizon 2: Areas of focus and accountability Horizon 1: Current projects Ground: Current actions Unlike some theories, which focus on top-down goal-setting, GTD works in the opposite direction. Allen argues that it is often difficult for individuals to focus on big picture goals if they cannot sufficiently control the day-to-day tasks that they frequently must face. [1] : 54 By developing and using the trusted system that deals with day-to-day inputs, an individual can free up mental space to begin moving up to the next level.[ citation needed ] Allen recommends scheduling a weekly review, reflecting on the different levels. The perspective gained from these reviews should drive one's priorities at the project level. [1] : 50 Priorities at the project level in turn determine the priority of the individual tasks and commitments gathered during the workflow process. During a weekly review, determine the context for the tasks and put each task on its appropriate list. An example of grouping together similar tasks would be making a list of outstanding telephone calls, or the tasks/errands to perform while out shopping. Context lists can be defined by the set of tools available or by the presence of individuals or groups for whom one has items to discuss or present.[ citation needed ] Summary [ edit ] GTD is based on storing, tracking, and retrieving the information related to the things that need to get done. Mental blocks we encounter are caused by insufficient 'front-end' planning . This means thinking in advance, generating a series of actions which can later be undertaken without further planning. The mind's \"reminder system\" is inefficient and seldom reminds us of what we need to do at the time and place when we can do it. Consequently, the \"next actions\" stored by context in the \"trusted system\" act as an external support which ensures that we are presented with the right reminders at the right time. As GTD relies on external reminders, it can be seen as an application of the theories of distributed cognition or the extended mind . [7] Reception [ edit ] In 2005, Wired called GTD a \"new cult for the info age\", [8] describing the enthusiasm for this method among information technology and knowledge workers as a kind of cult following . Allen's ideas have also been popularized through the Howard Stern Show (Stern referenced it daily throughout 2012's summer) and the Internet , especially via blogs such as 43 Folders , [9] Lifehacker , [10] and The Simple Dollar. [11] In 2005, Ben Hammersley interviewed David Allen for The Guardian article titled \"Meet the man who can bring order to your universe\", [12] saying: \"For me, as with the hundreds of thousands around the world who press the book into their friends' hands with fire in their eyes, Allen's ideas are nothing short of life-changing\". In 2007, Time Magazine called Getting Things Done the self-help business book of its time. [13] In 2007, Wired ran another article about GTD and Allen, [14] quoting him as saying \"the workings of an automatic transmission are more complicated than a manual transmission ... to simplify a complex event, you need a complex system\". A paper in the journal Long Range Planning by Francis Heylighen and Clément Vidal of the Free University of Brussels showed \"recent insights in psychology and cognitive science support and extend GTD's recommendations\". [7] See also [ edit ] Human multitasking Life hack Pomodoro Technique References [ edit ] ^ Jump up to: a b c d e f g h i j k l m n o p q r Allen, David (2015). Getting Things Done: The Art of Stress-Free Productivity (2 ed.). Penguin Books. ISBN 9780143126560 . ^ Fallows, James (November 2012). \"Busy and Busier\" . The Atlantic . Retrieved December 28, 2018. ^ David Allen (2001). \"Getting Things Done: Five Simple Steps That Apply Order To Chaos\" . gettingthingsdone.com . Retrieved 2019-07-27. ^ Forrister, Kelly (2010-08-02). \"Which list manager should I use for GTD?\" . GTD Times. The David Allen Company. Archived from the original on 2010-08-06 . Retrieved 2015-01-04. ^ Forrister, Kelly (2009-05-04). \"Simply GTD with Kelly: Getting Started\" . The David Allen Company. Archived from the original on 2010-08-29 . Retrieved 2010-08-22. If you're at all familiar with GTD you know that David Allen does not tell you which tools to use--GTD is tool agnostic--so those choices are up to you. Not saying all tools, software programs, paper planners work seamlessly with GTD, but where you organize your stuff is up to you. ^ \"Common Tools & Software\" . Getting Things Done website. David Allen Co . Retrieved 2014-05-30. ^ Jump up to: a b Heylighen, Francis ; Vidal, Clément (December 2008). \"Getting Things Done: The Science behind Stress-Free Productivity\" (PDF). Long Range Planning: International Journal of Strategic Management. 41 (6): 585 605. CiteSeerX 10.1.1.161.441 . doi : 10.1016/j.lrp.2008.09.004 . ISSN 0024-6301 . ^ Andrews, Robert (2005-07-12). \"A new cult for the info age\" . Wired.com. Condé Nast . Retrieved 2020-05-02. ^ Mann, Merlin (2004-09-08). \"Getting started with \"Getting Things Done \"\" . 43 Folders . Retrieved 2020-05-02. ^ Robinson, Keith (2006-03-21). \"Best of GTD\" . Lifehacker . Retrieved 2020-05-02. ^ \"Review: Getting Things Done\" . The Simple Dollar. 2020-04-09 . Retrieved 2020-05-02. ^ Hammersley, Ben (2005-09-28). \"Meet the man who can bring order to your universe\" . The Guardian. London: Guardian News and Media Limited . Retrieved 2010-03-05. ^ \"The Oracle of Organization\" . Time. 2007-03-12 . Retrieved 2010-03-05. ^ Wolf, Gary (2007-09-25). \"Getting Things Done Guru David Allen and His Cult of Hyperefficiency\" . Wired.com . Retrieved 2010-03-05. Further reading [ edit ] Allen, David (2001). Getting Things Done: The Art of Stress-Free Productivity (1 ed.). Penguin Books. ISBN 978-0-14-200028-1 . Allen, David (2003). Ready for Anything: 52 Productivity Principles for Work and Life . Viking Books. ISBN 978-0-670-03250-1 . Allen, David (2008). Making it All Work. Viking Books. ISBN 978-0-7499-4103-1 . External links [ edit ] Official site Retrieved from \" https://en.wikipedia.org/w/index.php?title=Getting_Things_Done&oldid=996090116 \" Categories : Management books Self-help books Personal development Time management 2001 non-fiction books Penguin Books books Hidden categories: Articles with short description Short description matches Wikidata Articles with a promotional tone from April 2017 All articles with a promotional tone All articles with unsourced statements Articles with unsourced statements from May 2018 Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version Languages العربية Беларуская Català Čeština Dansk Deutsch Español Esperanto Français 한국어 Italiano עברית Nederlands 日本語 Norsk bokmål Polski Português Русский Simple English Slovenčina Suomi Svenska தமிழ் Українська 中文 16 more Edit links This page was last edited on 24 December 2020, at 13:38 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License ; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement Enable previews Annotate ",
                "urlTerms": [
                    "wiki",
                    "things"
                ],
                "titleTerms": [
                    "things",
                    "wikipedia"
                ]
            }
        },
        {
            "timestamp": 1608952513898,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "en.wikipedia.org/wiki/Getting_Things_Done"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "en.wikipedia.org/wiki/Getting_Things_Done",
                "fullUrl": "https://en.wikipedia.org/wiki/Getting_Things_Done",
                "createdAt": "2020-12-26T03:15:13.885Z"
            }
        },
        {
            "timestamp": 1608952513911,
            "collection": "visits",
            "objectPk": [
                1608952513906,
                "en.wikipedia.org/wiki/Getting_Things_Done"
            ],
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Getting_Things_Done",
                "time": 1608952513906
            }
        },
        {
            "timestamp": 1608952513919,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Getting_Things_Done/#1608952513658",
            "operation": "create",
            "object": {
                "pageTitle": "Getting Things Done - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Getting_Things_Done",
                "body": "Allen first demonstrates stress reduction from the method with the following exercise, centered on a task that has an unclear outcome or whose next action is not defined. Allen calls these sources of stress \"open loops\", \"incompletes\", or \"stuff\".",
                "comment": "#book #achieve #PKM #workflow #organize",
                "selector": {
                    "quote": "Allen first demonstrates stress reduction from the method with the following exercise, centered on a task that has an unclear outcome or whose next action is not defined. Allen calls these sources of stress \"open loops\", \"incompletes\", or \"stuff\".",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[4]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[4]/sup[1]/a[1]",
                                "endOffset": 0
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 3545,
                                "end": 3792
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Allen first demonstrates stress reduction from the method with the following exercise, centered on a task that has an unclear outcome or whose next action is not defined. Allen calls these sources of stress \"open loops\", \"incompletes\", or \"stuff\".",
                                "prefix": " External links\n\n\n\nThemes[edit]\n",
                                "suffix": "[1]:13\n\nThe most annoying, distr"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:15:13.658Z",
                "lastEdited": "2020-12-26T03:16:13.235Z",
                "url": "https://en.wikipedia.org/wiki/Getting_Things_Done/#1608952513658"
            }
        },
        {
            "timestamp": 1608952573265,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Getting_Things_Done/#1608952513658",
            "operation": "update",
            "object": {
                "pageTitle": "Getting Things Done - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Getting_Things_Done",
                "body": "Allen first demonstrates stress reduction from the method with the following exercise, centered on a task that has an unclear outcome or whose next action is not defined. Allen calls these sources of stress \"open loops\", \"incompletes\", or \"stuff\".",
                "comment": "#book #achieve #PKM #workflow #organize",
                "selector": {
                    "quote": "Allen first demonstrates stress reduction from the method with the following exercise, centered on a task that has an unclear outcome or whose next action is not defined. Allen calls these sources of stress \"open loops\", \"incompletes\", or \"stuff\".",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[4]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[4]/sup[1]/a[1]",
                                "endOffset": 0
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 3545,
                                "end": 3792
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Allen first demonstrates stress reduction from the method with the following exercise, centered on a task that has an unclear outcome or whose next action is not defined. Allen calls these sources of stress \"open loops\", \"incompletes\", or \"stuff\".",
                                "prefix": " External links\n\n\n\nThemes[edit]\n",
                                "suffix": "[1]:13\n\nThe most annoying, distr"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:15:13.658Z",
                "lastEdited": "2020-12-26T03:16:13.235Z",
                "url": "https://en.wikipedia.org/wiki/Getting_Things_Done/#1608952513658"
            }
        },
        {
            "timestamp": 1608952583216,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Getting_Things_Done/#1608952583185",
            "operation": "create",
            "object": {
                "pageTitle": "Getting Things Done - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Getting_Things_Done",
                "body": "He claims stress can be reduced and productivity increased by putting reminders about everything you are not working on into a trusted system external to your mind. In this way, you can work on the task at hand without distraction from the \"incompletes\"",
                "comment": "",
                "selector": {
                    "quote": "He claims stress can be reduced and productivity increased by putting reminders about everything you are not working on into a trusted system external to your mind. In this way, you can work on the task at hand without distraction from the \"incompletes\"",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[5]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[5]",
                                "endOffset": 253
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 4233,
                                "end": 4486
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "He claims stress can be reduced and productivity increased by putting reminders about everything you are not working on into a trusted system external to your mind. In this way, you can work on the task at hand without distraction from the \"incompletes\"",
                                "prefix": "ting the steps of this process.\n",
                                "suffix": ".[1]:14 The system in GTD requir"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:16:23.186Z",
                "lastEdited": "2020-12-26T03:16:23.186Z",
                "url": "https://en.wikipedia.org/wiki/Getting_Things_Done/#1608952583185"
            }
        },
        {
            "timestamp": 1608952602541,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Getting_Things_Done/#1608952602511",
            "operation": "create",
            "object": {
                "pageTitle": "Getting Things Done - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Getting_Things_Done",
                "body": "The system in GTD requires you to have the following tools within easy reach:\r\n\r\n    An inbox\r\n    A trash can\r\n    A filing system for reference material\r\n    Several lists (detailed below)\r\n    A calendar.\r\n\r\nThese tools can be physical or electronic as appropriate (e.g., a physical \"in\" tray or an email inbox).[1]:88 Then, as \"stuff\" enters your life, it is captured in these tools and processed with the following workflow",
                "comment": "",
                "selector": {
                    "quote": "The system in GTD requires you to have the following tools within easy reach:\r\n\r\n    An inbox\r\n    A trash can\r\n    A filing system for reference material\r\n    Several lists (detailed below)\r\n    A calendar.\r\n\r\nThese tools can be physical or electronic as appropriate (e.g., a physical \"in\" tray or an email inbox).[1]:88 Then, as \"stuff\" enters your life, it is captured in these tools and processed with the following workflow",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[5]",
                                "startOffset": 261,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[6]",
                                "endOffset": 217
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 4494,
                                "end": 4893
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "The system in GTD requires you to have the following tools within easy reach:\n\nAn inbox\nA trash can\nA filing system for reference material\nSeveral lists (detailed below)\nA calendar.\nThese tools can be physical or electronic as appropriate (e.g., a physical \"in\" tray or an email inbox).[1]:88 Then, as \"stuff\" enters your life, it is captured in these tools and processed with the following workflow",
                                "prefix": "n from the \"incompletes\".[1]:14 ",
                                "suffix": ".[1]:27\n\nWorkflow[edit]\n  Logic "
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:16:42.512Z",
                "lastEdited": "2020-12-26T03:16:42.512Z",
                "url": "https://en.wikipedia.org/wiki/Getting_Things_Done/#1608952602511"
            }
        },
        {
            "timestamp": 1608952614634,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Getting_Things_Done/#1608952614617",
            "operation": "create",
            "object": {
                "pageTitle": "Getting Things Done - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Getting_Things_Done",
                "body": "The GTD workflow consists of five stages: capture, clarify, organize, reflect, and engage",
                "comment": "",
                "selector": {
                    "quote": "The GTD workflow consists of five stages: capture, clarify, organize, reflect, and engage",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[7]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[7]",
                                "endOffset": 89
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 5056,
                                "end": 5145
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "The GTD workflow consists of five stages: capture, clarify, organize, reflect, and engage",
                                "prefix": "p Getting Things Done workflow.\n",
                                "suffix": ".[3] (The first edition used the"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:16:54.617Z",
                "lastEdited": "2020-12-26T03:16:54.617Z",
                "url": "https://en.wikipedia.org/wiki/Getting_Things_Done/#1608952614617"
            }
        },
        {
            "timestamp": 1608952660894,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Getting_Things_Done/#1608952660859",
            "operation": "create",
            "object": {
                "pageTitle": "Getting Things Done - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Getting_Things_Done",
                "body": " As a result, items end up in one of the eight oval end points in the diagram:\r\n\r\n    in the trash\r\n    on the someday/maybe list\r\n    in a neat reference filing system\r\n    on a list of tasks, with the outcome and next action defined if the \"incomplete\" is a \"project\" (i.e., if it will require two or more steps to complete it)\r\n    immediately completed and checked off if it can be completed in under two minutes\r\n    delegated to someone else and, if you want a reminder to follow up, added to a \"waiting for\" list\r\n    on a context-based \"next action\" list if there is only one step to complete it\r\n    on your calendar[",
                "comment": "",
                "selector": {
                    "quote": " As a result, items end up in one of the eight oval end points in the diagram:\r\n\r\n    in the trash\r\n    on the someday/maybe list\r\n    in a neat reference filing system\r\n    on a list of tasks, with the outcome and next action defined if the \"incomplete\" is a \"project\" (i.e., if it will require two or more steps to complete it)\r\n    immediately completed and checked off if it can be completed in under two minutes\r\n    delegated to someone else and, if you want a reminder to follow up, added to a \"waiting for\" list\r\n    on a context-based \"next action\" list if there is only one step to complete it\r\n    on your calendar[",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[7]",
                                "startOffset": 475,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/ul[2]/li[8]/sup[1]/a[1]",
                                "endOffset": 1
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 5531,
                                "end": 6116
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": " As a result, items end up in one of the eight oval end points in the diagram:\n\nin the trash\non the someday/maybe list\nin a neat reference filing system\non a list of tasks, with the outcome and next action defined if the \"incomplete\" is a \"project\" (i.e., if it will require two or more steps to complete it)\nimmediately completed and checked off if it can be completed in under two minutes\ndelegated to someone else and, if you want a reminder to follow up, added to a \"waiting for\" list\non a context-based \"next action\" list if there is only one step to complete it\non your calendar[",
                                "prefix": "boxes in the logic tree diagram.",
                                "suffix": "1]:27\nEmpty your inbox or inboxe"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:17:40.859Z",
                "lastEdited": "2020-12-26T03:17:40.859Z",
                "url": "https://en.wikipedia.org/wiki/Getting_Things_Done/#1608952660859"
            }
        },
        {
            "timestamp": 1608952716342,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Getting_Things_Done/#1608952716317",
            "operation": "create",
            "object": {
                "pageTitle": "Getting Things Done - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Getting_Things_Done",
                "body": "Empty your inbox or inboxes daily or at least weekly (\"in\" to empty).[1]:122 Don't use your inbox as a \"to do\" list. Don't put clarified items back into the inbox.[1]:27 Emptying your inbox doesn't mean finishing everything. It just means applying the \"capture, clarify, organize\" steps to all your \"stuff\".[1]:27\r\n\r\nNext, reflection (termed planning in the first edition) occurs. Multi-step projects identified above are assigned a desired outcome and a single \"next action\".[1]:191 Finally, a task from your task list is worked on (\"engage\" in the 2nd edition, \"do\" in the 1st edition) unless the calendar dictates otherwise. You select which task to work on next by considering where you are (i.e., the \"context\", such as at home, at work, out shopping, by the phone, at your computer, with a particular person), time available, energy available, and priority.",
                "comment": "",
                "selector": {
                    "quote": "Empty your inbox or inboxes daily or at least weekly (\"in\" to empty).[1]:122 Don't use your inbox as a \"to do\" list. Don't put clarified items back into the inbox.[1]:27 Emptying your inbox doesn't mean finishing everything. It just means applying the \"capture, clarify, organize\" steps to all your \"stuff\".[1]:27\r\n\r\nNext, reflection (termed planning in the first edition) occurs. Multi-step projects identified above are assigned a desired outcome and a single \"next action\".[1]:191 Finally, a task from your task list is worked on (\"engage\" in the 2nd edition, \"do\" in the 1st edition) unless the calendar dictates otherwise. You select which task to work on next by considering where you are (i.e., the \"context\", such as at home, at work, out shopping, by the phone, at your computer, with a particular person), time available, energy available, and priority.",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[8]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[9]",
                                "endOffset": 546
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 6122,
                                "end": 6982
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Empty your inbox or inboxes daily or at least weekly (\"in\" to empty).[1]:122 Don't use your inbox as a \"to do\" list. Don't put clarified items back into the inbox.[1]:27 Emptying your inbox doesn't mean finishing everything. It just means applying the \"capture, clarify, organize\" steps to all your \"stuff\".[1]:27\nNext, reflection (termed planning in the first edition) occurs. Multi-step projects identified above are assigned a desired outcome and a single \"next action\".[1]:191 Finally, a task from your task list is worked on (\"engage\" in the 2nd edition, \"do\" in the 1st edition) unless the calendar dictates otherwise. You select which task to work on next by considering where you are (i.e., the \"context\", such as at home, at work, out shopping, by the phone, at your computer, with a particular person), time available, energy available, and priority.",
                                "prefix": "plete it\non your calendar[1]:27\n",
                                "suffix": "[1]:204\n\nImplementation[edit]\nBe"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:18:36.317Z",
                "lastEdited": "2020-12-26T03:18:36.317Z",
                "url": "https://en.wikipedia.org/wiki/Getting_Things_Done/#1608952716317"
            }
        },
        {
            "timestamp": 1608952950682,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Getting_Things_Done/#1608952950648",
            "operation": "create",
            "object": {
                "pageTitle": "Getting Things Done - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Getting_Things_Done",
                "body": "Allen emphasizes two key elements of GTD — control and perspective. The workflow is the center of the control aspect. The goal of the control processes in GTD is to get everything except the current task out of your head and into this trusted system external to your mind. ",
                "comment": "",
                "selector": {
                    "quote": "Allen emphasizes two key elements of GTD — control and perspective. The workflow is the center of the control aspect. The goal of the control processes in GTD is to get everything except the current task out of your head and into this trusted system external to your mind. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[11]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[11]",
                                "endOffset": 273
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 7438,
                                "end": 7711
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Allen emphasizes two key elements of GTD — control and perspective. The workflow is the center of the control aspect. The goal of the control processes in GTD is to get everything except the current task out of your head and into this trusted system external to your mind. ",
                                "prefix": "e design.[6]\n\nPerspective[edit]\n",
                                "suffix": "He borrows a simile used in mart"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:22:30.648Z",
                "lastEdited": "2020-12-26T03:22:30.648Z",
                "url": "https://en.wikipedia.org/wiki/Getting_Things_Done/#1608952950648"
            }
        },
        {
            "timestamp": 1608952973042,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Getting_Things_Done/#1608952973017",
            "operation": "create",
            "object": {
                "pageTitle": "Getting Things Done - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Getting_Things_Done",
                "body": "Allen recommends reflection from six levels, called \"Horizons of Focus\":[1]:215–219\r\n\r\n    Horizon 5: Life\r\n    Horizon 4: Long-term visions\r\n    Horizon 3: 1-2 year goals\r\n    Horizon 2: Areas of focus and accountability\r\n    Horizon 1: Current projects\r\n    Ground: Current actions",
                "comment": "",
                "selector": {
                    "quote": "Allen recommends reflection from six levels, called \"Horizons of Focus\":[1]:215–219\r\n\r\n    Horizon 5: Life\r\n    Horizon 4: Long-term visions\r\n    Horizon 3: 1-2 year goals\r\n    Horizon 2: Areas of focus and accountability\r\n    Horizon 1: Current projects\r\n    Ground: Current actions",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[11]",
                                "startOffset": 809,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/ul[3]/li[6]",
                                "endOffset": 23
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 8247,
                                "end": 8499
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Allen recommends reflection from six levels, called \"Horizons of Focus\":[1]:215–219\n\nHorizon 5: Life\nHorizon 4: Long-term visions\nHorizon 3: 1-2 year goals\nHorizon 2: Areas of focus and accountability\nHorizon 1: Current projects\nGround: Current actions",
                                "prefix": "etter perspective on your life. ",
                                "suffix": "\nUnlike some theories, which foc"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:22:53.017Z",
                "lastEdited": "2020-12-26T03:22:53.017Z",
                "url": "https://en.wikipedia.org/wiki/Getting_Things_Done/#1608952973017"
            }
        },
        {
            "timestamp": 1608953132673,
            "collection": "pages",
            "objectPk": "en.wikipedia.org/wiki/Mental_model",
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Mental_model",
                "fullUrl": "https://en.wikipedia.org/wiki/Mental_model",
                "domain": "wikipedia.org",
                "hostname": "en.wikipedia.org",
                "fullTitle": "Mental model - Wikipedia",
                "text": " Mental model From Wikipedia, the free encyclopedia Jump to navigation Jump to search For other uses, see Mind model . Explanation of someone's thought process about how something works in the real world Information mapping Topics and fields Business decision mapping Data visualization Graphic communication Infographics Information design Knowledge visualization Mental model Morphological analysis Visual analytics Visual language Node link approaches Argument map Cladistics Cognitive map Concept lattice Concept map Conceptual graph Decision tree Dendrogram Graph drawing Hyperbolic tree Hypertext Issue map Issue tree Layered graph drawing Mind map Object-role modeling Organizational chart Radial tree Semantic network Sociogram Timeline Topic map Tree structure See also Design rationale Diagrammatic reasoning Entity relationship model Geovisualization List of concept- and mind-mapping software Olog Problem structuring methods Semantic Web Treemapping Wicked problem v t e A mental model is an explanation of someone's thought process about how something works in the real world. It is a representation of the surrounding world, the relationships between its various parts and a person's intuitive perception about his or her own acts and their consequences. Mental models can help shape behaviour and set an approach to solving problems (similar to a personal algorithm ) and doing tasks. A mental model is a kind of internal symbol or representation of external reality, hypothesized to play a major role in cognition , reasoning and decision-making . Kenneth Craik suggested in 1943 that the mind constructs \"small-scale models\" of reality that it uses to anticipate events. Jay Wright Forrester defined general mental models as: The image of the world around us, which we carry in our head, is just a model. Nobody in his head imagines all the world, government or country. He has only selected concepts, and relationships between them, and uses those to represent the real system (Forrester, 1971). In psychology, the term mental models is sometimes used to refer to mental representations or mental simulation generally. At other times it is used to refer to § Mental models and reasoning and to the mental model theory of reasoning developed by Philip Johnson-Laird and Ruth M.J. Byrne . Contents 1 History 2 Mental models and reasoning 2.1 Principles of mental models 2.2 Reasoning with mental models 2.3 Criticisms 3 Mental models of dynamics systems: mental models in system dynamics 3.1 Characteristics 3.2 Expression of mental models of dynamic systems 3.3 Mental model in relation to system dynamics and systemic thinking 3.4 Single and double-loop learning 3.4.1 Single-loop learning 3.4.2 Double-loop learning 4 See also 5 Notes 6 References 7 Further reading 8 External links History [ edit ] The term mental model is believed to have originated with Kenneth Craik in his 1943 book The Nature of Explanation. [1] [2] Georges-Henri Luquet in Le dessin enfantin (Children's drawings), published in 1927 by Alcan, Paris, argued that children construct internal models, a view that influenced, among others, child psychologist Jean Piaget . Philip Johnson-Laird published Mental Models: Towards a Cognitive Science of Language, Inference and Consciousness in 1983. In the same year, Dedre Gentner and Albert Stevens edited a collection of chapters in a book also titled Mental Models. [3] The first line of their book explains the idea further: \"One function of this chapter is to belabor the obvious; people's views of the world, of themselves, of their own capabilities, and of the tasks that they are asked to perform, or topics they are asked to learn, depend heavily on the conceptualizations that they bring to the task.\" (see the book: Mental Models ). Since then, there has been much discussion and use of the idea in human-computer interaction and usability by researchers including Donald Norman and Steve Krug (in his book Don't Make Me Think ). Walter Kintsch and Teun A. van Dijk , using the term situation model (in their book Strategies of Discourse Comprehension, 1983), showed the relevance of mental models for the production and comprehension of discourse . Charlie Munger popularized the use of multi-disciplinary mental models for making business and investment decisions. [4] Mental models and reasoning [ edit ] Main article: Mental model theory of reasoning One view of human reasoning is that it depends on mental models. In this view, mental models can be constructed from perception, imagination, or the comprehension of discourse (Johnson-Laird, 1983). Such mental models are similar to architects' models or to physicists' diagrams in that their structure is analogous to the structure of the situation that they represent, unlike, say, the structure of logical forms used in formal rule theories of reasoning. In this respect, they are a little like pictures in the picture theory of language described by philosopher Ludwig Wittgenstein in 1922. Philip Johnson-Laird and Ruth M.J. Byrne developed their mental model theory of reasoning which makes the assumption that reasoning depends, not on logical form, but on mental models (Johnson-Laird and Byrne, 1991). Principles of mental models [ edit ] Mental models are based on a small set of fundamental assumptions ( axioms ), which distinguish them from other proposed representations in the psychology of reasoning (Byrne and Johnson-Laird, 2009). Each mental model represents a possibility. A mental model represents one possibility, capturing what is common to all the different ways in which the possibility may occur (Johnson-Laird and Byrne, 2002). Mental models are iconic, i.e., each part of a model corresponds to each part of what it represents (Johnson-Laird, 2006). Mental models are based on a principle of truth: they typically represent only those situations that are possible, and each model of a possibility represents only what is true in that possibility according to the proposition. However, mental models can represent what is false, temporarily assumed to be true, for example, in the case of counterfactual conditionals and counterfactual thinking (Byrne, 2005). Reasoning with mental models [ edit ] People infer that a conclusion is valid if it holds in all the possibilities. Procedures for reasoning with mental models rely on counter-examples to refute invalid inferences; they establish validity by ensuring that a conclusion holds over all the models of the premises. Reasoners focus on a subset of the possible models of multiple-model problems, often just a single model. The ease with which reasoners can make deductions is affected by many factors, including age and working memory (Barrouillet, et al., 2000). They reject a conclusion if they find a counterexample, i.e., a possibility in which the premises hold, but the conclusion does not (Schroyens, et al. 2003; Verschueren, et al., 2005). Criticisms [ edit ] Scientific debate continues about whether human reasoning is based on mental models, versus formal rules of inference (e.g., O'Brien, 2009), domain-specific rules of inference (e.g., Cheng & Holyoak, 2008; Cosmides, 2005), or probabilities (e.g., Oaksford and Chater, 2007). Many empirical comparisons of the different theories have been carried out (e.g., Oberauer, 2006). Mental models of dynamics systems: mental models in system dynamics [ edit ] Characteristics [ edit ] A mental model is generally: founded on unquantifiable, impugnable, obscure, or incomplete facts flexible is considerably variable in positive as well as in negative sense an information filter causes selective perception , perception of only selected parts of information very limited, compared with the complexities of the world, and even when a scientific model is extensive and in accordance with a certain reality in the derivation of logical consequences of it, it must take into account such restrictions as working memory ; i.e., rules on the maximum number of elements that people are able to remember, gestaltisms or failure of the principles of logic , etc. dependent on sources of information, which one can not find anywhere else, are available at any time and can be used. [5] [6] [7] Mental models are a fundamental way to understand organizational learning. Mental models, in popular science parlance, have been described as \"deeply held images of thinking and acting\". [8] Mental models are so basic to understanding the world that people are hardly conscious of them. Expression of mental models of dynamic systems [ edit ] S.N. Groesser and M. Schaffernicht (2012) describe three basic methods which are typically used: Causal loop diagrams displaying tendency and a direction of information connections and the resulting causality and feedback loops System structure diagrams another way to express the structure of a qualitative dynamic system Stock and flow diagrams - a way to quantify the structure of a dynamic system These methods allow showing a mental model of a dynamic system, as an explicit, written model about a certain system based on internal beliefs. Analyzing these graphical representations has been an increasing area of research across many social science fields. [9] Additionally software tools that attempt to capture and analyze the structural and functional properties of individual mental models such as Mental Modeler, \"a participatory modeling tool based in fuzzy-logic cognitive mapping\", [10] have recently been developed and used to collect/compare/combine mental model representations collected from individuals for use in social science research, collaborative decision-making, and natural resource planning. Mental model in relation to system dynamics and systemic thinking [ edit ] In the simplification of reality, creating a model can find a sense of reality, seeking to overcome systemic thinking and system dynamics . These two disciplines can help to construct a better coordination with the reality of mental models and simulate it accurately. They increase the probability that the consequences of how to decide and act in accordance with how to plan. [5] System dynamics extending mental models through the creation of explicit models, which are clear, easily communicated and can be compared with each other. Systemic thinking seeking the means to improve the mental models and thereby improve the quality of dynamic decisions that are based on mental models. Experimental studies carried out in weightlessness [11] and on Earth using neuroimaging [12] showed that humans are endowed with a mental model of the effects of gravity on object motion. Single and double-loop learning [ edit ] After analyzing the basic characteristics, it is necessary to bring the process of changing the mental models, or the process of learning. Learning is a back-loop process , and feedback loops can be illustrated as: single-loop learning or double-loop learning. Single-loop learning [ edit ] Mental models affect the way that people work with information, and also how they determine the final decision. The decision itself changes, but the mental models remain the same. It is the predominant method of learning, because it is very convenient. Double-loop learning [ edit ] Main article: Double-loop learning Double-loop learning (see diagram below) is used when it is necessary to change the mental model on which a decision depends. Unlike single loops, this model includes a shift in understanding, from simple and static to broader and more dynamic, such as taking into account the changes in the surroundings and the need for expression changes in mental models. [6] Process of learning Feedback process Single-loop learning Double-loop learning See also [ edit ] All models are wrong Cognitive map Cognitive psychology Conceptual model Educational psychology Folk psychology Internal model (motor control) Knowledge representation Lovemap Macrocognition Map territory relation Model-dependent realism Neuro-linguistic programming Neuroeconomics Neuroplasticity OODA loop Psyche (psychology) Self-stereotyping Social intuitionism Space mapping System dynamics Text and conversation theory Notes [ edit ] ^ Nersessian, Nancy J. (1992). \"In the Theoretician's Laboratory: Thought Experimenting as Mental Modeling\" (PDF). PSA: Proceedings of the Biennial Meeting of the Philosophy of Science Association. 1992 (2): 291 301. doi : 10.1086/psaprocbienmeetp.1992.2.192843 . S2CID 141149408 . Retrieved 17 July 2014. The contemporary notion that mental modelling plays a significant role in human reasoning was formulated, initially, by Kenneth Craik in 1943. ^ Staggers, Nancy; Norcio, A.F. (1993). \"Mental models: concepts for human-computer interaction research\" (PDF). International Journal of Man-Machine Studies. 38 (4): 587 605. doi : 10.1006/imms.1993.1028 . Retrieved 17 July 2014. Although Johnson-Laird (1989) is generally credited with coining the term mental model, the history of the concept may be traced to Craik's (1943) work entitled The Nature of Explanation. ^ \"Mental models\" , report at www.lauradove.info. ^ \"The Psychology of Human Misjudgement\" , speech by Charlie Munger ^ Jump up to: a b Šusta, Marek. \"Několik slov o systémové dynamice a systémovém myšlení\" (PDF) (in Czech). Proverbs, a.s. pp. 3 9 . Retrieved 2009-01-15. ^ Jump up to: a b Mildeova, S., Vojtko V. (2003). Systémová dynamika (in Czech). Prague: Oeconomica. pp. 19 24. ISBN 978-80-245-0626-5 . CS1 maint: multiple names: authors list ( link ) ^ Ford, David N., Sterman, John D. \"Expert Knowledge Elicitation to Improve Mental and Formal Models\" (PDF). Cambridge, Massachusetts, US - Massachusetts Institute of Technology. pp. 18 23 . Retrieved 2009-01-11. CS1 maint: multiple names: authors list ( link ) ^ \"Leading for a Change\", Ralph Jacobson, 2000, Chapter 5, Page102 ^ Jones, Natalie A.; Ross, Helen; Lynam, Timothy; Perez, Pascal; Leitch, Anne (2011). \"Mental Models: An Interdisciplinary Synthesis of Theory and Methods\" (PDF). Ecology and Society. 16 (1). doi : 10.5751/ES-03802-160146 . ^ \"Mental Modeler: A Fuzzy-Logic Cognitive Mapping Modeling Tool for Adaptive Environmental Management\" (PDF). mentalmodeler.com . Retrieved 28 May 2019. ^ McIntyre J, Zago M, Berthoz A, Lacquaniti F (2001). \"Does the brain model Newton's laws?\". Nature Neuroscience . 4 (7): 693 694. doi : 10.1038/89477 . PMID 11426224 . S2CID 30444364 . ^ Indovina I, et al. (2005). \"Representation of visual gravitational motion in the human vestibular cortex\". Science . 308 (5720): 416 419. doi : 10.1126/science.1107961 . hdl : 2108/19501 . PMID 15831760 . S2CID 22179461 . References [ edit ] Barrouillet, P. et al. (2000). Conditional reasoning by mental models: chronometric and developmental evidence . Cognit. 75, 237-266. Byrne, R.M.J. (2005). The Rational Imagination: How People Create Counterfactual Alternatives to Reality . Cambridge MA: MIT Press. Byrne, R.M.J. & Johnson-Laird, P.N. (2009). 'If' and the problems of conditional reasoning. Trends in Cognitive Sciences. 13, 282-287 Cheng, P.C. and Holyoak, K.J. (2008) Pragmatic reasoning schemas. In Reasoning: studies of human inference and its foundations (Adler, J.E. and Rips, L.J., eds), pp. 827 842, Cambridge University Press Cosmides, L. et al. (2005) Detecting cheaters. Trends in Cognitive Sciences. 9,505 506 Forrester, J. W. (1971) Counterintuitive behavior of social systems . Technology Review. Oberauer K. (2006) Reasoning with conditionals: A test of formal models of four theories . Cognit. Psychol. 53:238 283. O’Brien, D. (2009). Human reasoning includes a mental logic. Behav. Brain Sci. 32, 96 97 Oaksford, M. and Chater, N. (2007) Bayesian Rationality. Oxford University Press Johnson-Laird, P.N. (1983). Mental Models: Towards a Cognitive Science of Language, Inference, and Consciousness. Cambridge: Cambridge University Press. Johnson-Laird, P.N. (2006) How We Reason. Oxford University Press Johnson-Laird, P.N. and Byrne, R.M.J. (2002) Conditionals: a theory of meaning, inference, and pragmatics. Psychol. Rev. 109, 646 678 Schroyens, W. et al. (2003). In search of counterexamples: Deductive rationality in human reasoning . Quart. J. Exp. Psychol. 56(A), 1129 1145. Verschueren, N. et al. (2005). Everyday conditional reasoning: A working memory-dependent tradeoff between counterexample and likelihood use . Mem. Cognit. 33, 107-119. Further reading [ edit ] Georges-Henri Luquet (2001). Children's Drawings. Free Association Books . ISBN 1-85343-516-3 Chater, N. et al. (2006) Probabilistic Models of Cognition: Conceptual Foundations. Trends Cogn Sci 10(7):287-91. doi: 10.1016/j.tics.2006.05.007. Groesser, S.N. (2012). Mental model of dynamic systems . In N.M. Seel (Ed.). The encyclopedia of the sciences of learning (Vol. 5, pp. 2195 2200). New York: Springer. Groesser, S.N. & Schaffernicht, M. (2012). Mental Models of Dynamic Systems: Taking Stock and Looking Ahead. System Dynamics Review, 28(1): 46-68, Wiley. Johnson-Laird, P.N. 2005. The History of Mental Models Johnson-Laird, P.N., 2005. Mental Models, Deductive Reasoning, and the Brain Jones, N. A. et al. (2011). \" Mental Models: an interdisciplinary synthesis of theory and methods \" Ecology and Society.16 (1): 46. Jones, N. A. et al. (2014). \" Eliciting mental models: a comparison of interview procedures in the context of natural resource management \" Ecology and Society.19 (1): 13. Prediger, S. (2008). \" Discontinuities for mental models - a source for difficulties with the multiplication of fractions \" Proceedings of ICME-11, Topic Study Group 10, Research and Development of Number Systems and Arithmetic. (See also Prediger's references to Fischbein 1985 and Fischbein 1989, \"Tacit models and mathematical reasoning\".) Robles-De-La-Torre, G. & Sekuler, R. (2004). \" Numerically Estimating Internal Models of Dynamic Virtual Objects \". In: ACM Transactions on Applied Perception 1(2), pp. 102 117. Sterman, John D. A Skeptic’s Guide to Computer Models, Massachusetts Institute of Technology External links [ edit ] Mental Models and Reasoning Laboratory Systems Analysis, Modelling and Prediction Group, University of Oxford System Dynamics Society show v t e Worldview show Related terms Basic beliefs / Beliefs Collective consciousness / Collective unconscious Conceptual system Context Conventions Cultural movement Epic poetry / National epics Facts and factoids Framing Ideology Life stance Lifestyle Memes / Memeplex Mental model Metanarrative Mindset Norms Paradigm Philosophical theory Point of view Presuppositions Reality tunnel Received view Schemata School of thought Set Social reality Theory of everything Umwelt Value system show Aspects Biases Academic Attentional Attitude polarization Belief Cognitive ( list ) Collective narcissism Confirmation Congruence Cryptomnesia Cultural Ethnocentrism Filter bubble Homophily In-group favoritism Magical thinking Media Observer-expectancy Observational error Selective exposure Selective perception Self-deception Self-fulfilling prophecy ( Clever Hans effect , placebo effect , wishful thinking ) Status quo Stereotyping Change and maintenance Activism Argument Argumentum ad populum Attitude change Censorship Charisma Circular reporting Cognitive dissonance Critical thinking Crowd manipulation Cultural dissonance Deprogramming Echo chamber Education ( religious , values ) Euphemism Excommunication Fearmongering Historical revisionism Ideological repression Indoctrination Media manipulation Media regulation Mind control Missionaries Moral entrepreneurship Persuasion Polite fiction Political engineering Propaganda Propaganda model Proselytism Psychological manipulation Psychological warfare Religious conversion ( forced ) Religious persecution Religious uniformity Revolutions Rhetoric Self-censorship Social change Social control Social engineering Social influence Social progress Suppression of dissent Systemic bias Woozle effect Culture Anthropology ( cultural , social ) Calendars Ceremonies Coronations Cross-cultural psychology Cultural psychology Doctrine Employment / Serfdom / Slavery Families Funerals / Burial Games Holidays Hygiene ( ritual ) Identity (philosophy) ( cultural ) Institutions Liminality Liturgy Marriage Myth and ritual Oaths Pilgrimages Play Rites of passage ( secular ) Rituals Social class / Social status / Caste Symbols Symbolic boundaries Worship Groupthink Abilene paradox Bandwagon effect Collectives Collective behavior ( animal ) Collective effervescence Collective intelligence Conformity Consensus theory Crowd psychology Cults Culture-bound syndromes Deindividuation Democracy Emergence Emotional contagion Entitativity False-consensus effect Folie à deux Group action Group dynamics Group emotion Group polarization Groupshift Herd behavior Holism Hysterical contagion Information cascade Invisible hand Lynching Majoritarianism / Ochlocracy Mass action Mass hysteria Mass psychogenic illness Milieu control Mobbing Moral panic Organizations Peer pressure Pluralistic ignorance Political correctness Pseudoconsensus Scapegoating Self-organization Social action Social behavior Social emotions Social exclusion Social facilitation ( animal ) Social group Social proof Social psychology Sociology Spontaneous order Status quo Stigmergy Swarm behaviour System justification Viral phenomena Knowledge Axioms ( tacit assumptions ) Conceptual framework Epistemology ( outline ) Evidence ( anecdotal , scientific ) Explanations Faith ( fideism ) Gnosis Intuition Meaning-making Memory Metaknowledge Methodology Observation Observational learning Perception Reasoning ( fallacious , logic ) Revelation Testimony Tradition ( folklore ) Truth ( consensus theory , criteria ) World disclosure Metaphysics Ætiology Afterlife Anima mundi Being Causality Concepts Consciousness ( mind body problem ) Cosmogony Cosmology ( religious ) Creation myth Deities ( existence ) Destiny Eschatology Everything / Nothing Evolution Existence Fiction / Non-fiction Free will Future History Ideas Idios kosmos Illusions Incarnation Information Intelligence Magic Matter Miracles Mythology ( comparative ) National mythoi Nature ( philosophical ) Ontology Origin myths ( political myths ) Otherworlds ( axes mundi ) Problem of evil Physics ( natural philosophy ) Reality Souls Spirit Supernature Teleology Theology Time Unobservables Value Æsthetics Almsgiving / Charity Altruism Autonomy Beauty Codes of conduct Comedy Common good Conscience Consent Creativity Disgust Duty Economics Ecstasy ( emotional , religious ) Elegance Emotions ( æsthetic ) Entertainment Eroticism Ethics Étiquette Family values Food and drink prohibitions ( unclean animals ) Golden Rule Guilt / Culpability Happiness Harmony Honour Human rights Judgement Justice Laws ( jurisprudence , religious ) Liberty ( political freedom ) Love Magnificence Maxims Meaning of life Morality ( public ) Obligations Peace Piety Praxeology Principles Punishment Qualities Repentance Reverence Rights Sexuality ( ethics ) Sin Social stigma Stewardship Styles Sublime, The Suffering Sympathy Taboo Taste Theodicy Trust Unspoken rules Virtues and Vices Works of art Wrongdoing show Examples Attitudes Optimism Pessimism Reclusion Weltschmerz Economic and political ideologies Authoritarianism Anarchism Capitalism Christian democracy Collectivism Colonialism Communalism Communism Communitarianism Conservatism Constitutionalism Distributism Environmentalism Extremism Fanaticism Fascism Feminism Fundamentalism Globalism Green politics Imperialism Individualism Industrialism Intellectualism Islamism Liberalism Libertarianism Masculism Militarism Monarchism Nationalism Pacifism Progressivism Radicalism Reformism Republicanism Sentientism Social democracy Socialism Utilitarianism Veganism Religions African traditional religions Baháʼí Buddhism Cao Dai Cheondoism Chinese traditional religions Christianity Ethnic religions Hòa Hảo Hinduism Islam Jainism Judaism Korean shamanism Neo-Paganism Rastafarianism Secular / Nonreligious / Agnostic / Atheist Shinto Sikhism Spiritism Taoism Tenrikyo Tenriism Unitarian Universalism Zoroastrianism Schools of philosophy Agriculturalism Aristotelianism Atomism Averroism Cartesianism Cārvāka Collectivism Confucianism / New Confucianism Critical theory Cynicism Cyrenaics Determinism Dualism Eleatics Empiricism Eretrian school Epicureanism Existentialism Foundationalism Hedonism Hegelianism Hermeneutics Historicism / New Historicism Holism Humanism / Renaissance humanism Illuminationism ʿIlm al-Kalām Idealism Individualism Ionian Kantianism / Neo-Kantianism Kokugaku Legalism Logicians Materialism Mohism Megarian school Modernism / Postmodernism Monism Natural Law Naturalism (Chinese) Naturalism (western) Nihilism Peripatetic Phenomenology Platonism / Neoplatonism Pluralism Positivism Pragmatism Presocratic Pyrrhonism Pythagoreanism / Neopythagoreanism Rationalism Reductionism Scholasticism / Neo-Scholasticism Sentientism Social constructionism Sophism Spinozism Stoicism Structuralism / Post-structuralism Thomism Transcendentalism Utilitarianism Yangism Retrieved from \" https://en.wikipedia.org/w/index.php?title=Mental_model&oldid=995568694 \" Categories : Conceptual modelling Cognitive modeling Cognitive psychology Cognitive science Information Information science Scientific modeling Hidden categories: CS1 Czech-language sources (cs) CS1 maint: multiple names: authors list Articles with short description Short description matches Wikidata Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version Languages العربية Català Čeština Deutsch Español فارسی Français עברית 日本語 Português Русский Svenska Українська 中文 5 more Edit links This page was last edited on 21 December 2020, at 19:33 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License ; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement Enable previews ",
                "urlTerms": [
                    "wiki",
                    "mental",
                    "model"
                ],
                "titleTerms": [
                    "mental",
                    "model",
                    "wikipedia"
                ]
            }
        },
        {
            "timestamp": 1608953132710,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "en.wikipedia.org/wiki/Mental_model"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "en.wikipedia.org/wiki/Mental_model",
                "fullUrl": "https://en.wikipedia.org/wiki/Mental_model",
                "createdAt": "2020-12-26T03:25:32.701Z"
            }
        },
        {
            "timestamp": 1608953132717,
            "collection": "visits",
            "objectPk": [
                1608953132714,
                "en.wikipedia.org/wiki/Mental_model"
            ],
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Mental_model",
                "time": 1608953132714
            }
        },
        {
            "timestamp": 1608953132724,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Mental_model/#1608953132413",
            "operation": "create",
            "object": {
                "pageTitle": "Mental model - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Mental_model",
                "body": "A mental model is an explanation of someone's thought process about how something works in the real world. It is a representation of the surrounding world, the relationships between its various parts and a person's intuitive perception about his or her own acts and their consequences. Mental models can help shape behaviour and set an approach to solving problems (similar to a personal algorithm) and doing tasks.\r\n\r\nA mental model is a kind of internal symbol or representation of external reality, hypothesized to play a major role in cognition, reasoning and decision-making. Kenneth Craik suggested in 1943 that the mind constructs \"small-scale models\" of reality that it uses to anticipate events. ",
                "comment": "",
                "selector": {
                    "quote": "A mental model is an explanation of someone's thought process about how something works in the real world. It is a representation of the surrounding world, the relationships between its various parts and a person's intuitive perception about his or her own acts and their consequences. Mental models can help shape behaviour and set an approach to solving problems (similar to a personal algorithm) and doing tasks.\r\n\r\nA mental model is a kind of internal symbol or representation of external reality, hypothesized to play a major role in cognition, reasoning and decision-making. Kenneth Craik suggested in 1943 that the mind constructs \"small-scale models\" of reality that it uses to anticipate events. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[2]",
                                "endOffset": 286
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 1933,
                                "end": 2635
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "A mental model is an explanation of someone's thought process about how something works in the real world. It is a representation of the surrounding world, the relationships between its various parts and a person's intuitive perception about his or her own acts and their consequences. Mental models can help shape behaviour and set an approach to solving problems (similar to a personal algorithm) and doing tasks.\nA mental model is a kind of internal symbol or representation of external reality, hypothesized to play a major role in cognition, reasoning and decision-making. Kenneth Craik suggested in 1943 that the mind constructs \"small-scale models\" of reality that it uses to anticipate events.\n",
                                "prefix": "ign:left;margin-right:0.5em}vte\n",
                                "suffix": "Jay Wright Forrester defined gen"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:25:32.413Z",
                "lastEdited": "2020-12-26T03:25:32.413Z",
                "url": "https://en.wikipedia.org/wiki/Mental_model/#1608953132413"
            }
        },
        {
            "timestamp": 1608953168555,
            "collection": "favIcons",
            "objectPk": "sciencedirect.com",
            "operation": "create",
            "object": {
                "hostname": "sciencedirect.com",
                "favIcon": "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABYlBMVEX1giAAAAD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD1giD////FmzcrAAAAdHRSTlMAAAJSdW5lYWJmZmZjnJECUISX5f7dpKOjo6LdlAvCqwQCAgKFlgrCqgJgkKobMQEbCKoCDJ8oyFtZWGzQKeWysbG83yisBwUEGbkrBE8WITJ3cKoLuFkADRswzr4zLS0tNHDnQAOByNDj5+HRzs7O1OTWKV6xJFQAAAABYktHRHWoapj7AAAAB3RJTUUH3wEPDDs5IBKj6AAAALRJREFUGNNjYGJmYWVj5+Dk4ubm4eVjYGDgFxAUEhYRFROXkJSSlgEKMDIyyMqVyCsoKikzqKhCBNTUSzQ0QQwtbbiADlhAVw9ZgEHfwBDEgwgYGTMwmJiaIQTMLSytrG1sEQJ29g6OTs4uCAFXN3cPTy9vhADQWgYfXz8GVGsZGfwDUB3GEBgEEwgGC4SEhjEwhEdERkWXxMTGxSckJiWnMDCkpqVnZGZl5+Tm5RcUFhUzAAAxaCTKSc6wTgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNS0wMS0xNVQxMjo1OTo1NyswMTowMF4HujgAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTUtMDEtMTVUMTI6NTk6NTcrMDE6MDAvWgKEAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAABJRU5ErkJggg=="
            }
        },
        {
            "timestamp": 1608953168587,
            "collection": "pages",
            "objectPk": "sciencedirect.com/topics/computer-science/waterfall-model",
            "operation": "create",
            "object": {
                "url": "sciencedirect.com/topics/computer-science/waterfall-model",
                "fullUrl": "https://www.sciencedirect.com/topics/computer-science/waterfall-model",
                "domain": "sciencedirect.com",
                "hostname": "sciencedirect.com",
                "fullTitle": "Waterfall Model - an overview | ScienceDirect Topics",
                "text": " Skip to Main content Journals & Books Register Sign in Sign in Register Journals & Books Help Waterfall Model Related terms: Process Model Object Oriented Programming Software Development Software Engineering Spiral Model Application Development Development Model System Development Requirement Engineering View all Topics Download as PDF Set alert About this page Domain 8 Eric Conrad, in Eleventh Hour CISSP , 2011 Waterfall model The Waterfall Model is a linear application development model that uses rigid phases: When one phase ends, the next begins. Steps occur in sequence, and, if unmodified, the model does not allow developers to go back to previous steps (hence “waterfall”: Once water falls down, it cannot go back up). Exam Warning The phases in the Waterfall Model are not specifically testable: Learn the overall flow. Also, the model omits a critical final step: destruction. No development process that leads to an operational system with sensitive production data is truly complete until that system has been retired, the data archived, and the remaining data on the system securely destroyed. The Modified Waterfall Model allows a return to a previous phase for verification or validation, ideally confined to connecting steps. Barry Boehm's paper “A Spiral Model of Software Development and Enhancement” (see the next section) discusses a modified waterfall based on Royce's paper, shown in Figure 8.1. Sign in to download full-size image Figure 8.1. Modified Waterfall (Spiral) Development Model. Source: Boehm, Barry. A Spiral Model of Software Development and Enhancement. URL: http://portal.acm.org/citation.cfm?id=12948 (accessed July 23, 2010). View chapter Purchase book Read full chapter URL: https://www.sciencedirect.com/science/article/pii/B9781597495660000084 Software engineering Paul S. Ganney, ... Edwin Claridge, in Clinical Engineering (Second Edition) , 2020 Waterfall model The Waterfall model is one of the most common and classic of life cycle models, also referred to as a linear-sequential life cycle model. It is based on the factory assembly-line process. It follows a structured sequential path from Requirements to Maintenance, setting out milestones at each stage which must be accomplished before the next stage can begin ( Fig. 9.5). Sign in to download full-size image Fig. 9.5. The waterfall model. The rigidity of the Waterfall model aids project management with well-defined milestones and deliverables. It does however restrict flexibility and does not provide much scope for user feedback until software development has been completed. It is only suitable for insular projects where user requirements can be clearly defined at the outset and are unlikely to change over the software lifespan. View chapter Purchase book Read full chapter URL: https://www.sciencedirect.com/science/article/pii/B9780081026946000097 Domain 4: Software Development Security Eric Conrad, ... Joshua Feldman, in Eleventh Hour CISSP (Second Edition) , 2014 Application development methods As software has grown in complexity, software programming has increasingly become a team effort. Team-based projects require project management: providing a project framework with deliverables and milestones, divvying up tasks, team communication, progress evaluation and reporting, and (hopefully) a final delivered product. Waterfall Model The Waterfall Model is a linear application development model that uses rigid phases; when one phase ends, the next begins. Steps occur in sequence, and the unmodified Waterfall Model does not allow developers to go back to previous steps. It is called the waterfall because it simulates water falling: it cannot go back up. A modified Waterfall Model allows a return to a previous phase for verification or validation, ideally confined to connecting steps. Spiral The Spiral Model is a software development model designed to control risk. The Spiral Model repeats steps of a project, starting with modest goals and expanding outward in ever-wider spirals (called rounds). Each round of the spiral constitutes a project, and each round may follow traditional software development methodology such as modified waterfall. A risk analysis is performed each round. Fundamental flaws in the project or process are more likely to be discovered in the earlier phases, resulting in simpler fixes. This lowers the overall risk of the project: large risks should be identified and mitigated. Agile Software Development Agile Software Development evolved as a reaction to rigid software development models such as the Waterfall Model. Agile methods include Extreme Programming (XP). Agile embodies many modern development concepts, including more flexibility, fast turnaround with smaller milestones, strong communication within the team, and more customer involvement. Extreme Programming Extreme Programming (XP) is an Agile development method that uses pairs of programmers who work off a detailed specification. There is a high level of customer involvement and constant communication. Rapid Application Development Rapid Application Development (RAD) rapidly develops software via the use of prototypes, “dummy” GUIs, back-end databases, and more. The goal of RAD is quickly meeting the business need of the system; technical concerns are secondary. The customer is heavily involved in the process. SDLC The Systems Development Life Cycle (SDLC, also called the software development life cycle or simply the system life cycle) is a system development model. SDLC is used across the industry, but SDLC focuses on security when used in context of the exam. Think of “our” SDLC as the “secure systems development life cycle”: the security is implied. Fast Facts The following overview is summarized from NIST SP 800-14: Prepare a security plan: Ensure that security is considered during all phases of the IT system life cycle and that security activities are accomplished during each of the phases. Initiation: The need for a system is expressed and the purpose of the system is documented. Conduct a sensitivity assessment: Look at the security sensitivity of the system and the information to be processed. Development/acquisition: The system is designed, purchased, programmed, or developed. Determine security requirements: Determine technical features (like access controls), assurances (like background checks for system developers), or operational practices (like awareness and training). Incorporate security requirements into specifications: Ensure that the previously gathered information is incorporated in the project plan. Obtain the system and related security activities: May include developing the system's security features, monitoring the development process itself for security problems, responding to changes, and monitoring threats. Implementation: The system is tested and installed. Install/turn-on controls: A system often comes with security features disabled. These need to be enabled and configured. Security testing: Used to certify a system and may include testing security management, physical facilities, personnel, procedures, the use of commercial or in-house services (such as networking services), and contingency planning. Accreditation: The formal authorization by the accrediting (management) official for system operation and an explicit acceptance of risk. Operation/maintenance: The system is modified by the addition of hardware and software and by other events. Security operations and administration: Examples include backups, training, managing cryptographic keys, user administration, and patching. Operational assurance: Examines whether a system is operated according to its current security requirements. Audits and monitoring: A system audit is a one-time or periodic event to evaluate security. Monitoring refers to an ongoing activity that examines either the system or the users. Disposal: The secure decommission of a system. Information: Information may be moved to another system, archived, discarded, or destroyed. Media sanitization: There are three general methods of purging media: overwriting, degaussing (for magnetic media only), and destruction. 1 View chapter Purchase book Read full chapter URL: https://www.sciencedirect.com/science/article/pii/B9780124171428000042 Software Engineering Mehdi Jazayeri, in Encyclopedia of Physical Science and Technology (Third Edition) , 2003 IV.B Incremental Models The waterfall model defines the requirements at the beginning and delivers the product at the end. During the whole development time, the customer is not involved and does not gain any visibility into the state of the product. Some models try to remedy this problem by introducing different stages in which partial deliveries of the product are made to the customer. One such model is the prototyping approach. The first delivery to the customer is a prototype of the envisaged system. The purpose of the prototype is to assess the feasibility of the product and to verify that the requirements of the customer have been understood by the developer and will be met by the system. The prototype is then thrown away (in fact, it is sometimes called a throwaway prototype), and development starts on the real product based on the now firmly established requirements. The prototyping approach addresses the difficulty of understanding the real requirements but it does not eliminate the time gap between the definition of requirements and delivery of the application. Incremental process model addresses the delivery gap. It produces the product in increments that implement the needed functionality in increments. Increments may be delivered to the customer as they are developed; this is called evolutionary, or incremental , delivery. Increments to be delivered to the customer consist not only of code and internal project documentation but also of user-oriented documentation. In other words, a delivered increment is a self-contained functional unit of software that performs some useful purpose for the customer, along with all supporting material (requirements and design specifications, test plans and test cases, a user manual, and training material). This approach requires a phase in which the requirements are carefully subdivided into functionalities that may be decomposed and delivered independently. The decision as to what order to deliver the increments is a key negotiation point between the developer and the customer. One possibility is to deliver the basic functionality of the system first and increasingly sophisticated functionality later. Another is to deliver what can be delivered quickly and delay to later stages those features that take longer to build. A third option is to deliver the functionality that is most critical to the customer early. View chapter Purchase book Read full chapter URL: https://www.sciencedirect.com/science/article/pii/B0122274105008565 The Data Vault 2.0 Methodology Daniel Linstedt, Michael Olschimke, in Building a Scalable Data Warehouse with Data Vault 2.0 , 2016 3.2.1.5 Operation and Maintenance In the last phase of the waterfall model, the data warehouse is handed over to operations where the system is installed at the end-user premises for regular use. If end-users find bugs in the data warehouse, the operations team is responsible for correcting those bugs and handling other modifications of the data warehouse. This continuous process is performed until the data warehouse retires or is replaced by a new data warehouse [32]. In order to support the operations and maintenance team, the data warehouse team which develops the solution has to provide both an end-user and administration documentation, including specific instructions for the maintenance of the data warehouse (such as loading new data deliveries or customizing existing reports). View chapter Purchase book Read full chapter URL: https://www.sciencedirect.com/science/article/pii/B9780128025109000039 Performance Management James Farmer, ... Weyl Wang, in FTTx Networks , 2017 FTTx Network Phases Fig. 16.1 indicates, in a waterfall model, the different phases of the FTTx network lifecycle, and the activities that are included in each phase. Note that at the bottom of each phase the distinct activities for performance management are included. Sign in to download full-size image Figure 16.1. FTTx network lifecycles. PM goals strategic objectives for the performance management system; PM requirements what is required of the performance management system to meet the strategic objectives; PM design design of hardware and software systems, integrated to create the performance management data collection and reporting requirements; PM implementation deployment of the solution which implements the design, resulting in a system which the network operations team can use to proactively manage the network; PM in production ongoing operations using the performance management solution which allows the network operations team to accomplish production engineering activities. Using this approach, the performance management of the network will not be left to the end, but will be just as important as every other component of the network during the design, implementation, and production phases. On the top of the waterfall, the status and types of teams involved in each of the phases are specified. Once the network goes into production, the on-going operations and management of the network is aided by the performance management system, which is also designed and implemented during each of the phases. Even if the network you are involved in operating is in a later phase than the beginning planning phase, or any of the other phases, you can still work on creating a performance management solution for the network. This is especially true if you are faced with a network which is beset by technical problems and is difficult to control. Part of getting the network under control is a data-driven approach enabled by a performance management system. View chapter Purchase book Read full chapter URL: https://www.sciencedirect.com/science/article/pii/B9780124201378000160 Other Software Development Approaches Bill Holtsnider, ... Joseph Gee, in Agile Development & Business Goals , 2010 What to take from this It is very important to understand the waterfall model because the concepts involved in it show up in almost every software project. The moment that quality is down, people will suggest phases and gates, even the developers. This extreme (and sadly far too common) model shows in its extremity that the dynamics of software development are fundamentally different than the dynamics of manufacturing. Nearly every process improvement after this is an attempt to learn how to work effectively with the dynamics of software development, evolving now into the Six Week Solution, and undoubtedly will continue to evolve from here. View chapter Purchase book Read full chapter URL: https://www.sciencedirect.com/science/article/pii/B9780123815200000096 Practices of Software Architects in Business and Strategy An Industry Experience Report Michael Stal, in Economics-Driven Software Architecture , 2014 7.14 Development process for architecture design On one hand, using a strict waterfall model in design is neither effective nor efficient, as the previous sections illustrate, because they often turn later modifications into high economic risks.. On the other hand, projects might require models such as the V-Model, because of customer requirements, which is very common in government projects, safety-critical system development, and infrastructure projects. In the last-named case, an iterative waterfall model is recommendable which allows iterating through phases and returning to earlier development phases whenever required. War Story: For the development of an innovative control system, the organization strictly followed the V-Model. However, during development, the requirements specification used to change frequently. In addition, unexpected issues were encountered upon implementation of some innovative new patterns and algorithms. Late changes caused substantial modification efforts. Most of the errors and change requests emerged only after release of the first product version. Those modifications led to an overly complex architecture and other indicators for design erosion. As illustrated in figure 7.6, architects should use an agile model for their design activities. In each increment they focus on one or a few use cases or scenarios, starting with the ones of highest priority. The existing base-line architecture keeps growing with each architecture extension or refinement. After the design activity, architects invite stakeholders and other architects to conduct an assessment of the current state of the base-line architecture ( Clements et al., 2001). These reviews help identify design flaws, bugs, inefficient design decisions, quality defects, and other issues. Before continuing with fine design or the next increment, the detected issues are prioritized and, if possible, eliminated by architecture refactoring. Some refactoring necessities can be postponed for economic reasons to the next increments if the issues are less critical and require substantial rework shortly before important events such as product release. However, all postponed issues should be documented as design debt ( Sterling, 2010) that must be paid back later in the project. Sign in to download full-size image Figure 7.6. Architecture creation should follow a feedback loop that includes not only architecture refinement, but also architecture assessments and refactoring activities. View chapter Purchase book Read full chapter URL: https://www.sciencedirect.com/science/article/pii/B9780124104648000076 Agile Lifecycle Processes and the Funnel Model of Agile UX Rex Hartson, Pardha Pyla, in The UX Book (Second Edition) , 2019 4.2.1 The Waterfall Process was an Early SE Attempt to Get Organized The waterfall process (originally called the waterfall model ( Royce, 1970)) was among the earliest of formal software engineering lifecycle processes. The waterfall process is one of the simplest (in form, at least) ways to put lifecycle activities together to make an SE lifecycle process. The process was so named because it was described as an ordered, essentially linear sequence of phases (lifecycle activities), each of which flowed into the next like the set of cascading tiers of a waterfall ( Fig. 4-1). Sign in to download full-size image Fig. 4-1. Cascades from phase to phase in the waterfall model (adapted from Royce, 1970). The objective of the waterfall process was to deliver the full system at once. Because this process was an attempt to overcome the previous “Wild West” approach to software, it was methodical and tended to be rigorous. It also helps to know that the systems being built at that time were mostly large enterprise or government systems. But, because it operated with large scope in the extreme, the waterfall process was also slow, cumbersome, unmanageable, and not very responsive to change. For more about how the waterfall model got started see Section 6.5. View chapter Purchase book Read full chapter URL: https://www.sciencedirect.com/science/article/pii/B9780128053423000047 Persona adulthood Tamara Adlin, ... David Anderson, in The Essential Persona Lifecycle: Your Guide to Building and Using Personas , 2010 Plan, Design, Evaluate, Release: How to use Personas during the Stages of Product Development Let’s look back at the traditional waterfall model of product development we briefly discussed in Chapter 2 (see Figure 6.1). You will note that in an ideal situation persona adulthood extends over the majority of the development process. In fact, persona adulthood may even continue after development is complete, beyond the release phase, providing help to marketing, sales, operations, and support. For this chapter, we have further simplified the waterfall model into four distinct development stages (see Figure 6.2). The rest of this chapter is organized according to these four stages. For each stage, we provide several usage techniques and tools that engage your personas to the benefit of your team and product. Sign in to download full-size image Figure 6.1. The classic waterfall model of software development with persona lifecycle phases added. (Adapted from www.maxwideman.com/papers/plcmodels/1990s.htm.) Sign in to download full-size image Figure 6.2. Plan, design, evaluate, release. We have further simplified the waterfall process model into four stages: plan your product, design your product, evaluate your designs, and release your product. Stage 1 Plan your product (system requirements, software requirements, analysis) Determining the product vision and functional requirements Competitive reviews Feature brainstorming, prioritization, and work planning Stage 2 Explore design solutions (product design) Scenario-based design and mapping Design explorations and mood boards Stage 3 Evaluate your design solutions (coding and testing) Design reviews and cognitive walkthroughs User testing and ongoing user research Quality assurance testing and bug bashes Stage 4 Support the release (operations) Documentation and product support Marketing and sales Finally, note that this chapter covers only a handful of uses of personas, and we believe that personas can be used in many more ways than we have explored. Also note that the waterfall model of development is not the only model in use. Personas can be applied to any development model and design approach that lends itself to understanding users. View chapter Purchase book Read full chapter URL: https://www.sciencedirect.com/science/article/pii/B9780123814180000061 Recommended publications: Journal of Systems and Software Journal Advances in Computers Book series Information and Software Technology Journal International Journal of Human-Computer Studies Journal Browse Journals & Books About ScienceDirect Remote access Shopping cart Advertise Contact and support Terms and conditions Privacy policy We use cookies to help provide and enhance our service and tailor content and ads. By continuing you agree to the use of cookies . Copyright © 2020 Elsevier B.V. or its licensors or contributors. ScienceDirect ® is a registered trademark of Elsevier B.V. ScienceDirect ® is a registered trademark of Elsevier B.V. Annotate ",
                "urlTerms": [
                    "topics",
                    "computer",
                    "science",
                    "waterfall",
                    "model"
                ],
                "titleTerms": [
                    "waterfall",
                    "model",
                    "overview",
                    "sciencedirect",
                    "topics"
                ]
            }
        },
        {
            "timestamp": 1608953168616,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "sciencedirect.com/topics/computer-science/waterfall-model"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "sciencedirect.com/topics/computer-science/waterfall-model",
                "fullUrl": "https://www.sciencedirect.com/topics/computer-science/waterfall-model",
                "createdAt": "2020-12-26T03:26:08.608Z"
            }
        },
        {
            "timestamp": 1608953168626,
            "collection": "visits",
            "objectPk": [
                1608953168622,
                "sciencedirect.com/topics/computer-science/waterfall-model"
            ],
            "operation": "create",
            "object": {
                "url": "sciencedirect.com/topics/computer-science/waterfall-model",
                "time": 1608953168622
            }
        },
        {
            "timestamp": 1608953168635,
            "collection": "annotations",
            "objectPk": "https://www.sciencedirect.com/topics/computer-science/waterfall-model/#1608953168405",
            "operation": "create",
            "object": {
                "pageTitle": "Waterfall Model - an overview | ScienceDirect Topics",
                "pageUrl": "sciencedirect.com/topics/computer-science/waterfall-model",
                "body": "Waterfall model\r\n\r\nThe Waterfall model is one of the most common and classic of life cycle models, also referred to as a linear-sequential life cycle model. It is based on the factory assembly-line process. It follows a structured sequential path from Requirements to Maintenance, setting out milestones at each stage which must be accomplished before the next stage can begin",
                "comment": "#software #waterfall",
                "selector": {
                    "quote": "Waterfall model\r\n\r\nThe Waterfall model is one of the most common and classic of life cycle models, also referred to as a linear-sequential life cycle model. It is based on the factory assembly-line process. It follows a structured sequential path from Requirements to Maintenance, setting out milestones at each stage which must be accomplished before the next stage can begin",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[2]/div[1]/main[1]/section[2]/div[1]/div[2]/article[2]/div[1]/div[1]/section[1]/h3[1]",
                                "startOffset": 0,
                                "endContainer": "/div[2]/div[1]/main[1]/section[2]/div[1]/div[2]/article[2]/div[1]/div[1]/section[1]/div[1]/p[1]/span[1]",
                                "endOffset": 357
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 1876,
                                "end": 2248
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Waterfall modelThe Waterfall model is one of the most common and classic of life cycle models, also referred to as a linear-sequential life cycle model. It is based on the factory assembly-line process. It follows a structured sequential path from Requirements to Maintenance, setting out milestones at each stage which must be accomplished before the next stage can begin",
                                "prefix": "gineering (Second Edition), 2020",
                                "suffix": " (Fig. 9.5).Sign in to download "
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:26:08.405Z",
                "lastEdited": "2020-12-26T03:27:01.634Z",
                "url": "https://www.sciencedirect.com/topics/computer-science/waterfall-model/#1608953168405"
            }
        },
        {
            "timestamp": 1608953203927,
            "collection": "annotations",
            "objectPk": "https://www.sciencedirect.com/topics/computer-science/waterfall-model/#1608953203915",
            "operation": "create",
            "object": {
                "pageTitle": "Waterfall Model - an overview | ScienceDirect Topics",
                "pageUrl": "sciencedirect.com/topics/computer-science/waterfall-model",
                "comment": "#software #waterfall",
                "createdWhen": "2020-12-26T03:26:43.915Z",
                "lastEdited": "2020-12-26T03:26:43.915Z",
                "url": "https://www.sciencedirect.com/topics/computer-science/waterfall-model/#1608953203915"
            }
        },
        {
            "timestamp": 1608953221655,
            "collection": "annotations",
            "objectPk": "https://www.sciencedirect.com/topics/computer-science/waterfall-model/#1608953168405",
            "operation": "update",
            "object": {
                "pageTitle": "Waterfall Model - an overview | ScienceDirect Topics",
                "pageUrl": "sciencedirect.com/topics/computer-science/waterfall-model",
                "body": "Waterfall model\r\n\r\nThe Waterfall model is one of the most common and classic of life cycle models, also referred to as a linear-sequential life cycle model. It is based on the factory assembly-line process. It follows a structured sequential path from Requirements to Maintenance, setting out milestones at each stage which must be accomplished before the next stage can begin",
                "comment": "#software #waterfall",
                "selector": {
                    "quote": "Waterfall model\r\n\r\nThe Waterfall model is one of the most common and classic of life cycle models, also referred to as a linear-sequential life cycle model. It is based on the factory assembly-line process. It follows a structured sequential path from Requirements to Maintenance, setting out milestones at each stage which must be accomplished before the next stage can begin",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[2]/div[1]/main[1]/section[2]/div[1]/div[2]/article[2]/div[1]/div[1]/section[1]/h3[1]",
                                "startOffset": 0,
                                "endContainer": "/div[2]/div[1]/main[1]/section[2]/div[1]/div[2]/article[2]/div[1]/div[1]/section[1]/div[1]/p[1]/span[1]",
                                "endOffset": 357
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 1876,
                                "end": 2248
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Waterfall modelThe Waterfall model is one of the most common and classic of life cycle models, also referred to as a linear-sequential life cycle model. It is based on the factory assembly-line process. It follows a structured sequential path from Requirements to Maintenance, setting out milestones at each stage which must be accomplished before the next stage can begin",
                                "prefix": "gineering (Second Edition), 2020",
                                "suffix": " (Fig. 9.5).Sign in to download "
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T03:26:08.405Z",
                "lastEdited": "2020-12-26T03:27:01.634Z",
                "url": "https://www.sciencedirect.com/topics/computer-science/waterfall-model/#1608953168405"
            }
        },
        {
            "timestamp": 1608954276698,
            "collection": "pages",
            "objectPk": "notes.andymatuschak.org/About_these_notes?stackedNotes=z3SjnvsB5aR2ddsycyXofbYR7fCxo7RmKW2be&stackedNotes=z6cFzJWgj9vZpnrQsjrZ8yCNREzCTgyFeVZTb&stackedNotes=z6C5H4eYH2A4omfNLuUcDiKibQ1hZG2RGNZ97&stackedNotes=z6bci25mVUBNFdVWSrQNKr6u7AZ1jFzfTVbMF",
            "operation": "create",
            "object": {
                "url": "notes.andymatuschak.org/About_these_notes?stackedNotes=z3SjnvsB5aR2ddsycyXofbYR7fCxo7RmKW2be&stackedNotes=z6cFzJWgj9vZpnrQsjrZ8yCNREzCTgyFeVZTb&stackedNotes=z6C5H4eYH2A4omfNLuUcDiKibQ1hZG2RGNZ97&stackedNotes=z6bci25mVUBNFdVWSrQNKr6u7AZ1jFzfTVbMF",
                "fullUrl": "https://notes.andymatuschak.org/About_these_notes?stackedNotes=z3SjnvsB5aR2ddsycyXofbYR7fCxo7RmKW2be&stackedNotes=z6cFzJWgj9vZpnrQsjrZ8yCNREzCTgyFeVZTb&stackedNotes=z6C5H4eYH2A4omfNLuUcDiKibQ1hZG2RGNZ97&stackedNotes=z6bci25mVUBNFdVWSrQNKr6u7AZ1jFzfTVbMF",
                "domain": "andymatuschak.org",
                "hostname": "notes.andymatuschak.org",
                "fullTitle": "About these notes | Evergreen note-writing as fundamental unit of knowledge work | Evergreen note-writing helps insight accumulate | Evergreen notes permit smooth incremental progress in writing (“incremental writing”) | Evergreen notes should be concept-oriented",
                "text": " Andyʼs working notes About these notes About these notes Hi! I’m Andy Matuschak . You’ve stumbled upon my working notes. They’re kind of strange, so some context might help. These notes are mostly written for myself: they’re roughly my thinking environment ( Evergreen note-writing as fundamental unit of knowledge work ; My morning writing practice ). But I’m sharing them publicly as an experiment ( Work with the garage door up ). If a note seems confusing or under-explained, it’s probably because I didn’t write it for you! Sorry that’s sort of an essential tension of this experiment. For now, there’s no index or navigational aids: you’ll need to follow a link to some starting point. You might be interested in §What’s top of mind . Andy ( email , Twitter , main personal site ) PS: My work is made possible by a crowd-funded research grant. If you find these ideas interesting and want to see them developed further, please consider becoming a micro-grantmaker yourself on Patreon . PS: Many people ask, so I’ll just note here: no, I haven’t made this system available for others to use. It’s still an early research environment, and Premature scaling can stunt system iteration . About these notes Evergreen note-writing as fundamental unit of knowledge work If you had to set one metric to use as a leading indicator for yourself as a knowledge worker, the best I know might be the number of Evergreen notes written per day. Note-writing can be a virtuosic skill , but Most people use notes as a bucket for storage or scratch thoughts and Note-writing practices are generally ineffective . Evergreen note-writing helps insight accumulate Evergreen note-writing helps reading efforts accumulate Note-writing helps writing accumulate: these notes are the fuel for the Executable strategy for writing , particularly if you Create speculative outlines while you write . A caveat: “Better note-taking” misses the point; what matters is “better thinking” References Ahrens, S. (2017). How to Take Smart Notes: One Simple Technique to Boost Writing, Learning and Thinking for Students, Academics and Nonfiction Book Writers. If writing is the medium of research and studying nothing else than research, then there is no reason not to work as if nothing else counts than writing. Focusing on writing as if nothing else counts does not necessarily mean you should do everything else less well, but it certainly makes you do everything else differently. Having a clear, tangible purpose when you attend a lecture, discussion or seminar will make you more engaged and sharpen your focus. Even if you decide never to write a single line of a manuscript, you will improve your reading, thinking and other intellectual skills just by doing everything as if nothing counts other than writing. Links to this note Evergreen notes Evergreen notes are written and organized to evolve, contribute, and accumulate over time, across projects. This is an unusual way to think about writing notes: Most people take only transient notes. That’s because these practices aren’t about writing notes; they’re about effectively developing insight: “Better note-taking” misses the point; what matters is “better thinking”. When done well, these notes can be quite valuable: Evergreen note-writing as fundamental unit of knowledge work. Enabling environment A collection of densely-connected Evergreen notes is an enabling environment: Evergreen note-writing helps insight accumulate. (See also Evergreen note-writing as fundamental unit of knowledge work) Knowledge work should accrete Likewise, Most people take only transient notes, though with effective practices, they’re an essential foundation; see Evergreen note-writing as fundamental unit of knowledge work. Evergreen note titles are like APIs When Evergreen notes are factored and titled well, those titles become an abstraction for the note itself. The entire note’s ideas can then be referenced using that handle (see Concept handles, after Alexander). In fact, this property itself functions as a kind of litmus: as you develops ideas in notes over time and improve the “APIs,” you’ll be able to write individual notes which abstract over increasingly large subtrees (e.g. Enacted experiences have incredible potential as a mass medium, Evergreen note-writing as fundamental unit of knowledge work). Note-writing practices are generally ineffective By contrast: Evergreen note-writing as fundamental unit of knowledge work Executable strategy for writing Write durable notes continuously while reading and thinking. (Evergreen note-writing as fundamental unit of knowledge work) “Better note-taking” misses the point; what matters is “better thinking” Answers to these questions are unsatisfying because the questions are focused on the wrong thing. The goal is not to take notes the goal is to think effectively. Better questions are “what practices can help me reliably develop insights over time?”, “how can I shepherd my attention effectively?” etc. This is the frame in which Evergreen note-writing as fundamental unit of knowledge work makes sense: Evergreen note-writing helps insight accumulate. Evergreen note-writing helps reading efforts accumulate This is one reason for Evergreen note-writing as fundamental unit of knowledge work. Executable strategy Another common choice is to discretize the creative output. If you’re trying to write an essay, you might aim to write a certain number of words per day; if you’re designing an interface, you might aim to design one element of the UI per day. But these steps don’t consume a predictable amount of effort, and they often don’t feel doable. If you’re stuck in your writing because you’ve become confused about one of your ideas, you won’t be able to write 500 words for your manuscript. Instead, you need to spend more time thinking about the idea. A manuscript is a challenging place to do that. By contrast, see Evergreen note-writing as fundamental unit of knowledge work. Most people use notes as a bucket for storage or scratch thoughts These are not Evergreen notes. Most “storage-oriented” notes will never be useful again (Most people take only transient notes). More importantly, this framing misses that it’s possible for note-writing to be the “real” work (Evergreen note-writing as fundamental unit of knowledge work). §Enabling environments, games, and the Primer Knowledge workers usually have no specific methods for developing ideas over time vs. Evergreen note-writing as fundamental unit of knowledge work Note-writing system For more on my personal note-writing system, see Evergreen note-writing as fundamental unit of knowledge work. Let ideas and beliefs emerge organically Evergreen note-writing as fundamental unit of knowledge work Note-writing can be a virtuosic skill But some note-writing practices are vastly more effective than others. It’s possible to become much, much more skilled at writing notes, and that skill translates into valuable output: Evergreen note-writing as fundamental unit of knowledge work. Leaps of insight emerge from prior thought One practical implication of this notion: Evergreen note-writing as fundamental unit of knowledge work. Knowledge work rarely involves deliberate practice Ericsson claims (2016, p. 98) that there is no deliberate practice possible for knowledge work because there are no objective criteria (so, poor feedback), because the skills aren’t clearly defined, and because techniques for focused skill improvement in these domains aren’t known. I’m skeptical of the finality of these claims, in the face of e.g. Evergreen note-writing as fundamental unit of knowledge work, Spaced repetition memory systems make memory a choice, etc. But it’s true that at least for the moment, there’s nothing as straightforward as weightlifting that you can do to improve yout communication skills. Computer-supported thinking Evergreen note-writing as fundamental unit of knowledge work §What’s top of mind Evergreen note-writing as fundamental unit of knowledge work §Note-writing systems Evergreen note-writing as fundamental unit of knowledge work How to Take Smart Notes - Ahrens Notes are a way to focus on “inputs, not outputs” that isn’t just about time. Executable strategy for writing Evergreen note-writing as fundamental unit of knowledge work About these notes These notes are mostly written for myself: they’re roughly my thinking environment (Evergreen note-writing as fundamental unit of knowledge work; My morning writing practice). But I’m sharing them publicly as an experiment (Work with the garage door up). If a note seems confusing or under-explained, it’s probably because I didn’t write it for you! Sorry that’s sort of an essential tension of this experiment. §Knowledge work as serious discipline Evergreen note-writing as fundamental unit of knowledge work Evergreen note-writing as fundamental unit of knowledge work Evergreen note-writing helps insight accumulate Much of the day-to-day thinking involved in creative work is simply lost, like sand castles in the tide. Ephemerality can actually be useful in low-fidelity thought, but it’s simply an accidental property in many cases. We should do our serious thinking in the form of Evergreen notes so that the thinking accumulates. Leaps of insight emerge from prior thought . So where does that thought happen? It could happen in your head, or in a series of fleeting sketches in the pages of your notebook, but Knowledge work should accrete , and those mechanisms are awfully lossy. Consider some hypothetical leap of insight you’d like to be able to make. To make that leap, you’ll typically need to evolve many independent, partially-formed ideas simultaneously, until they suddenly converge in a flash of inspiration. If you need to iterate on more than a few pieces at once, you may struggle to keep them all in your head. By contrast, because Evergreen notes should be atomic , they’re small enough in scope that you can start and finish one note in well under half an hour (see Evergreen notes permit smooth incremental progress in writing (“incremental writing”) ). Yet each note you write represents an increment in your thinking about that specific idea, and each note enriches the broader network of links ( Evergreen notes should be densely linked ). Because these are Evergreen notes , you now have a clear place to stand as you iterate on this specific idea. The notes you write will interact with materials you read ( Evergreen note-writing helps reading efforts accumulate ) and will produce the foundations of new manuscripts ( Executable strategy for writing ). And if you can’t write even one atomic note on the idea you have, Spaced repetition may be a helpful tool to incrementally develop inklings . Related: “Better note-taking” misses the point; what matters is “better thinking” References Luhmann, N. (1992). Communicating with Slip Boxes. In A. Kieserling (Ed.), & M. Kuehn (Trans.), Universität als Milieu: Kleine Schriften (pp. 53 61). Retrieved from http://luhmann.surge.sh/communicating-with-slip-boxes Naturally, independence presupposes a minimal measure of intrinsic complexity. The slip box needs a number of years in order to reach critical mass. Until then, it functions as a mere container from which we can retrieve what we put in. This changes with its growth in size and complexity. On the one hand, the number of approaches and occasions for questions increases. The slip box becomes a universal instrument. Ahrens, S. (2017). How to Take Smart Notes: One Simple Technique to Boost Writing, Learning and Thinking for Students, Academics and Nonfiction Book Writers. Links to this note Enabling environment A collection of densely-connected Evergreen notes is an enabling environment: Evergreen note-writing helps insight accumulate. (See also Evergreen note-writing as fundamental unit of knowledge work) Evergreen notes should be concept-oriented Over time, we accumulate notes which we can combine in increasingly complex ways (Evergreen note titles are like APIs) to produce novel insights (Evergreen note-writing helps insight accumulate). “Better note-taking” misses the point; what matters is “better thinking” Answers to these questions are unsatisfying because the questions are focused on the wrong thing. The goal is not to take notes the goal is to think effectively. Better questions are “what practices can help me reliably develop insights over time?”, “how can I shepherd my attention effectively?” etc. This is the frame in which Evergreen note-writing as fundamental unit of knowledge work makes sense: Evergreen note-writing helps insight accumulate. Writing forces sharper understanding Writing is a great way to put pressure on your thinking: it’s hard to summarize something you don’t sharply understand. By trying to explain an idea, you’ll naturally try multiple framings, flesh out its edges, and see new connections. This is part of why Evergreen note-writing helps insight accumulate and why you should Write about what you read. Knowledge workers usually have no specific methods for developing ideas over time One possible solution: Evergreen note-writing helps insight accumulate. Evergreen notes lower the emotional stakes in editing manuscripts But if one uses the note-based Executable strategy for writing, then much of the work goes into writing Evergreen notes. Material which isn’t essential for a particular piece can become a durable note, seeding a network of links (Evergreen notes should be densely linked) and contributing to future insight (see Evergreen note-writing helps insight accumulate). Or if it needs more development, it can be added to one’s writing inbox (A writing inbox for transient and incomplete notes). §Taking knowledge work seriously (Stripe convergence talk, 2019-12-12) Evergreen note-writing helps insight accumulate Brainstorming may often substitute for missing insight accretion systems A brainstorm’s generative, uncritical mindset might lead to surprising results, but often we also use brainstorming as a practical way to brain-dump all our ideas about a subject in one place. That may be a sign that we haven’t designed our knowledge systems as described in Knowledge work should accrete. With Evergreen notes and dense associative structure (see Evergreen notes should be densely linked), our ideas are collected and distilled continuously. Evergreen note-writing helps insight accumulate, so there’s less need for brainstorming because those insights have already emerged and captured in an ongoing fashion in one’s day-to-day work. Where do ideas come from? Evergreen note-writing helps insight accumulate §Note-writing systems Evergreen note-writing helps insight accumulate Evergreen notes permit smooth incremental progress in writing (“incremental writing”) Evergreen notes’ atomic size ( Evergreen notes should be atomic ) and link structures ( Evergreen notes should be densely linked ) make it easy to stop and resume work. This helps us Close open loops . These small, self-contained notes represent regular checkpoints. Each note takes only a few minutes to write, but because they’re Evergreen notes , each note is solid ground to stand on fairly complete relative to its own concept ( Evergreen notes should be concept-oriented ). Of course, we’ll iterate on their contents over time, but each time we do, that note will remain a mostly-complete, self-contained unit. By contrast, when we’re working on a large work-in-progress manuscript, we’re juggling many ideas in various states of completion. Different parts of the document are at different levels of fidelity. The document is large enough that it’s easy to lose one’s place or to forget where other relevant points are when one returns. Starting and stopping work for the day feel like heavy tasks, drawing heavily on working memory. References Ahrens, S. (2017). How to Take Smart Notes: One Simple Technique to Boost Writing, Learning and Thinking for Students, Academics and Nonfiction Book Writers. As the outcome of each task is written down and possible connections become visible, it is easy to pick up the work any time where we left it without having to keep it in mind all the time. All this enables us to later pick up a task exactly where we stopped without the need to “keep in mind” that there still was something to do. That is one of the main advantages of thinking in writing everything is externalised anyway. Only if nothing else is lingering in our working memory and taking up valuable mental resources can we experience what Allen calls a “mind like water” - the state where we can focus on the work right in front of us without getting distracted by competing thoughts. Wozniak, P. (2018, June 9). Incremental writing. Retrieved December 30, 2019, from https://supermemo.guru/wiki/Incremental_writing Links to this note Prefer note titles with complete phrases to sharpen claims When writing Evergreen notes, I’ve found that using complete phrases as note titles helps maintain concept-orientation (Evergreen notes should be concept-oriented). For example: Educational objectives often subvert themselves, Evergreen notes permit smooth incremental progress in writing (“incremental writing”). Gingko The model relates to the practices suggested in Create speculative outlines while you write, but with a stronger connection between the outline note and its constituents. This structure emphasizes ease through atomicity (see Evergreen notes should be atomic, Evergreen notes permit smooth incremental progress in writing (“incremental writing”)). §Inboxes and attention management Evergreen notes permit smooth incremental progress in writing (“incremental writing”) Evergreen notes should be concept-oriented It’s best to factor Evergreen notes by concept (rather than by author, book, event, project, topic, etc). This way, you discover connections across books and domains as you update and link to the note over time ( Evergreen notes should be densely linked ). The most straightforward way to take notes is to start a new note for each book, each project, or each research topic. Because each note covers many concepts, it can be hard to find what you’ve written when a concept comes up again later: you have to remember the name of each book or project which dealt with the topic (by contrast: Evergreen notes should be atomic ). When you read another book which discusses the same concept, you’ll write a new note on that book. With this approach, there’s no accumulation (contra Knowledge work should accrete ). Your new thoughts on the concept don’t combine with the old ones to form a stronger whole: you just have a scattered set of notes on the concept, perhaps referring to it by different names, each embedded in some larger document. It’s not just about accumulation. There’s also no pressure to synthesize your new ideas on the concept with your prior thoughts about it. Is there tension between them? Is some powerful distillation only visible when all these ideas are considered simultaneously? Understanding requires effortful engagement If we read two books about exactly the same topic, we might easily link our notes about those two together. But novel connections tend to appear where they’re not quite so expected. When arranging notes by concept, you may make surprising links between ideas that came up in very different books. You might never have noticed that those books were related before and indeed, they might not have been, except for this one point. Organizing by concept makes note-taking a little harder, but in a useful way: when writing new notes, we have to find where they fit into the whole. So we explore some part of our prior web of notes, which may lead us somewhere unexpected. Over time, we accumulate notes which we can combine in increasingly complex ways ( Evergreen note titles are like APIs ) to produce novel insights ( Evergreen note-writing helps insight accumulate ). References Extend Your Mind and Memory With a Zettelkasten Zettelkasten Method When you’ve taken two texts apart already, a Zettelkasten will help you draw connections between them, see their similarities and oppositions. Thereby, you’ll be able to distill a bunch of texts and find out something new for yourself with time. you’ll generate new ideas by following connections and exploring a part of your web of notes. The non-apparent connections are generally more beneficial to creative thinking than the obvious ones as they generate greater surprise. when you analyze a text, you decompose its web-like whole into pieces and keep track of their relations to one another. Luhmann, N. (1992). Communicating with Slip Boxes. In A. Kieserling (Ed.), & M. Kuehn (Trans.), Universität als Milieu: Kleine Schriften (pp. 53 61). Retrieved from http://luhmann.surge.sh/communicating-with-slip-boxes We could try to generalize the experiences of Paris, Florence, New York under general concepts like “art” or “exhibitions,” or “crowding” (inter-actionistic), or “mass,” or “freedom” or “education,” in order to see how the slip box reacts. Usually it is more fruitful to look for formulations of problems that relate heterogeneous things with each other. Ahrens, S. (2017). How to Take Smart Notes: One Simple Technique to Boost Writing, Learning and Thinking for Students, Academics and Nonfiction Book Writers. In the old system, the question is: Under which topic do I store this note? In the new system, the question is: In which context will I want to stumble upon it again? Fleeting literature notes can make sense if you need an extra step to understand or grasp an idea, but they will not help you in the later stages of the writing process, as no underlined sentence will ever present itself when you need it in the development of an argument. Many students and academic writers think like the early ship owners when it comes to note-taking. They handle their ideas and findings in the way it makes immediate sense: If they read an interesting sentence, they underline it. If they have a comment to make, they write it into the margins. If they have an idea, they write it into their notebook, and if an article seems important enough, they make the effort and write an excerpt. Working like this will leave you with a lot of different notes in many different places. Writing, then, means to rely heavily on your brain to remember where and when these notes were written down. A text must then be conceptualised independently from these notes, which explains why so many resort to brainstorming to arrange the resources afterwards according to this preconceived idea. Links to this note Evergreen notes should be densely linked If we push ourselves to add lots of links between our notes, that makes us think expansively about what other concepts might be related to what we’re thinking about. It creates pressure to think carefully about how ideas relate to each other (see Understanding requires effortful engagement and Evergreen notes should be concept-oriented). It’ll also help you internalize the ideas more deeply through Elaborative encoding. Writing forces sharper understanding The additional step of making associations and integrating that writing with prior notes (i.e. to create Evergreen notes, particularly since Evergreen notes should be concept-oriented) makes this effect even more powerful because you have to understand how a given idea relates to other ideas. And when you’re comparing the new ideas to the old, you can see what’s not being said in the new work. Evergreen notes permit smooth incremental progress in writing (“incremental writing”) These small, self-contained notes represent regular checkpoints. Each note takes only a few minutes to write, but because they’re Evergreen notes, each note is solid ground to stand on fairly complete relative to its own concept (Evergreen notes should be concept-oriented). Of course, we’ll iterate on their contents over time, but each time we do, that note will remain a mostly-complete, self-contained unit. Notes should surprise you This is why we take Evergreen notes should be concept-oriented: so that when writing about an idea that seems new, we stumble onto what we’ve already written about it (perhaps unexpectedly). How to process reading annotations into evergreen notes First: what notes should even get written? We’ll write Evergreen notes should be concept-oriented, so what are the key concepts? You need to take a step back and form a picture of the overall structure of the ideas. Concretely, you might do that by clustering your scraps into piles and observing the structure that emerges. Or you might sketch a mind map or a visual outline. The structure you observe does not have to match the book’s structure: it’s whatever makes sense relative to your own personal ontology (Do your own thinking). Evergreen notes are a safe place to develop wild ideas Instead, nurture the wild idea and let it develop over time by incrementally writing Evergreen notes about small facets of the idea. Those notes have much tighter scope: they just have to describe one atomic concept (Evergreen notes should be atomic, Evergreen notes should be concept-oriented). Prefer note titles with complete phrases to sharpen claims When writing Evergreen notes, I’ve found that using complete phrases as note titles helps maintain concept-orientation (Evergreen notes should be concept-oriented). For example: Educational objectives often subvert themselves, Evergreen notes permit smooth incremental progress in writing (“incremental writing”). Literature notes are secondary and separate Because Evergreen notes should be concept-oriented reference-specific notes should be both brief and clearly separated from the note archive. They primarily exist to help you write durable notes. Taxonomy of note types These note types are weakly evergreen. I may add to them over time, but because they aren’t concept-oriented (Evergreen notes should be concept-oriented), they’re not as useful to build on as an evergreen note. Non-trivial writing about proper nouns typically gets factored into separate evergreen notes which can be used in multiple places. Collaborative knowledge management systems tend to decay It’s difficult to maintain concept-orientation (Evergreen notes should be concept-oriented) with multiple authors because each team member factors concepts differently. Without concept-orientation, it’s hard to know where to put a new insight, and it’s hard to maintain links (Evergreen notes should be densely linked). Advantages and disadvantages of using notes to form associations in content Writing a note is good because it forces you to Do your own thinking, but it’s a bit heavy because Evergreen notes should be concept-oriented. So to write the note, we have to extract the conceptual link between the two, name it, and arrange it in some way that might attract future linkages. ",
                "urlTerms": [
                    "notes"
                ],
                "titleTerms": [
                    "notes",
                    "evergreen",
                    "note-writing",
                    "fundamental",
                    "unit",
                    "knowledge",
                    "work",
                    "helps",
                    "insight",
                    "accumulate",
                    "permit",
                    "smooth",
                    "incremental",
                    "progress",
                    "writing",
                    "concept-oriented",
                    "note",
                    "concept",
                    "oriented"
                ]
            }
        },
        {
            "timestamp": 1608954276740,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "notes.andymatuschak.org/About_these_notes?stackedNotes=z3SjnvsB5aR2ddsycyXofbYR7fCxo7RmKW2be&stackedNotes=z6cFzJWgj9vZpnrQsjrZ8yCNREzCTgyFeVZTb&stackedNotes=z6C5H4eYH2A4omfNLuUcDiKibQ1hZG2RGNZ97&stackedNotes=z6bci25mVUBNFdVWSrQNKr6u7AZ1jFzfTVbMF"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "notes.andymatuschak.org/About_these_notes?stackedNotes=z3SjnvsB5aR2ddsycyXofbYR7fCxo7RmKW2be&stackedNotes=z6cFzJWgj9vZpnrQsjrZ8yCNREzCTgyFeVZTb&stackedNotes=z6C5H4eYH2A4omfNLuUcDiKibQ1hZG2RGNZ97&stackedNotes=z6bci25mVUBNFdVWSrQNKr6u7AZ1jFzfTVbMF",
                "fullUrl": "https://notes.andymatuschak.org/About_these_notes?stackedNotes=z3SjnvsB5aR2ddsycyXofbYR7fCxo7RmKW2be&stackedNotes=z6cFzJWgj9vZpnrQsjrZ8yCNREzCTgyFeVZTb&stackedNotes=z6C5H4eYH2A4omfNLuUcDiKibQ1hZG2RGNZ97&stackedNotes=z6bci25mVUBNFdVWSrQNKr6u7AZ1jFzfTVbMF",
                "createdAt": "2020-12-26T03:44:36.726Z"
            }
        },
        {
            "timestamp": 1608954276750,
            "collection": "visits",
            "objectPk": [
                1608954276746,
                "notes.andymatuschak.org/About_these_notes?stackedNotes=z3SjnvsB5aR2ddsycyXofbYR7fCxo7RmKW2be&stackedNotes=z6cFzJWgj9vZpnrQsjrZ8yCNREzCTgyFeVZTb&stackedNotes=z6C5H4eYH2A4omfNLuUcDiKibQ1hZG2RGNZ97&stackedNotes=z6bci25mVUBNFdVWSrQNKr6u7AZ1jFzfTVbMF"
            ],
            "operation": "create",
            "object": {
                "url": "notes.andymatuschak.org/About_these_notes?stackedNotes=z3SjnvsB5aR2ddsycyXofbYR7fCxo7RmKW2be&stackedNotes=z6cFzJWgj9vZpnrQsjrZ8yCNREzCTgyFeVZTb&stackedNotes=z6C5H4eYH2A4omfNLuUcDiKibQ1hZG2RGNZ97&stackedNotes=z6bci25mVUBNFdVWSrQNKr6u7AZ1jFzfTVbMF",
                "time": 1608954276746
            }
        },
        {
            "timestamp": 1608954276766,
            "collection": "bookmarks",
            "objectPk": "notes.andymatuschak.org/About_these_notes?stackedNotes=z3SjnvsB5aR2ddsycyXofbYR7fCxo7RmKW2be&stackedNotes=z6cFzJWgj9vZpnrQsjrZ8yCNREzCTgyFeVZTb&stackedNotes=z6C5H4eYH2A4omfNLuUcDiKibQ1hZG2RGNZ97&stackedNotes=z6bci25mVUBNFdVWSrQNKr6u7AZ1jFzfTVbMF",
            "operation": "create",
            "object": {
                "url": "notes.andymatuschak.org/About_these_notes?stackedNotes=z3SjnvsB5aR2ddsycyXofbYR7fCxo7RmKW2be&stackedNotes=z6cFzJWgj9vZpnrQsjrZ8yCNREzCTgyFeVZTb&stackedNotes=z6C5H4eYH2A4omfNLuUcDiKibQ1hZG2RGNZ97&stackedNotes=z6bci25mVUBNFdVWSrQNKr6u7AZ1jFzfTVbMF",
                "time": 1608954276761
            }
        },
        {
            "timestamp": 1608963983962,
            "collection": "pages",
            "objectPk": "en.wikipedia.org/wiki/Template:Braces",
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Template:Braces",
                "fullUrl": "https://en.wikipedia.org/wiki/Template:Braces",
                "domain": "wikipedia.org",
                "hostname": "en.wikipedia.org",
                "fullTitle": "Template:Braces - Wikipedia",
                "text": " Template:Braces From Wikipedia, the free encyclopedia Jump to navigation Jump to search {{ }} Template documentation [ view ] [ edit ] [ history ] [ purge ] This template returns the first unnamed parameter in double braces. To be used to demonstrate template code without the need for clunky nowiki'ing. Further unnamed parameters (up to 8 more) can be used without worrying for pipes. An alternative is to use &#123;{some text}&#125;. Set code=on / code=true / etc. to switch the font used to the HTML <code>-style monospaced font. To improve legibility, {{ thin space }}s are inserted either side of any pipe characters (\" | \") displayed by the template. To ensure equals-signs are handled as text by the template, use {{ = }} to produce them e.g. {{braces|Templatename|p1{{=}}v1|p2{{=}}v2|...}} (and see examples below). Examples Markup Output {{braces|Templatename|item1|item2}} {{Templatename | item1 | item2}} {{braces|code=on |Templatename|item1|item2}} {{Templatename | item1 | item2}} {{braces |Templatename|item1{{=}}XYZ|item2{{=}}PQR}} {{Templatename | item1=XYZ | item2=PQR}} {{braces|code=on |Templatename|item1{{=}}XYZ|item2{{=}}PQR}} {{Templatename | item1=XYZ | item2=PQR}} Note that omitting the double-braces around the equals signs in the last two examples does not work as intended: Markup Output {{braces |Templatename|item1=XYZ|item2=PQR}} {{Templatename}} {{braces|code=on |Templatename|item1{{=}}XYZ|item2{{=}}PQR}} {{Templatename}} See also {{ brackets }} {{ nowiki }} {{ mono }} {{ mset }} The above documentation is transcluded from Template:Braces/doc . ( edit | history ) Editors can experiment in this template's sandbox ( edit | diff ) and testcases ( edit ) pages. Please add categories to the /doc subpage. Subpages of this template . Retrieved from \" https://en.wikipedia.org/w/index.php?title=Template:Braces&oldid=897059047 \" Categories : Character-substitution templates Wikitext typing-aid templates Hidden categories: Wikipedia semi-protected templates Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Template Talk Variants Views Read View source View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Wikidata item Print/export Download as PDF Printable version Languages العربية Asturianu تۆرکجه বাংলা भोजपुरी Català Dansk فارسی Føroyskt Հայերեն हिन्दी Ilokano Bahasa Indonesia Kurdî मैथिली Македонски Bahasa Melayu မြန်မာဘာသာ नेपाली 日本語 ଓଡ଼ିଆ ਪੰਜਾਬੀ Português සිංහල Simple English سنڌي کوردی Српски / srpski Svenska ၽႃႇသႃႇတႆး ไทย Українська اردو Tiếng Việt 吴语 粵語 中文 28 more Edit links This page was last edited on 14 May 2019, at 14:25 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License ; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement Enable previews Annotate ",
                "urlTerms": [
                    "wiki",
                    "template",
                    "braces"
                ],
                "titleTerms": [
                    "template",
                    "braces",
                    "wikipedia"
                ]
            }
        },
        {
            "timestamp": 1608963983992,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "en.wikipedia.org/wiki/Template:Braces"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "en.wikipedia.org/wiki/Template:Braces",
                "fullUrl": "https://en.wikipedia.org/wiki/Template:Braces",
                "createdAt": "2020-12-26T06:26:23.982Z"
            }
        },
        {
            "timestamp": 1608963984005,
            "collection": "visits",
            "objectPk": [
                1608963984000,
                "en.wikipedia.org/wiki/Template:Braces"
            ],
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Template:Braces",
                "time": 1608963984000
            }
        },
        {
            "timestamp": 1608963984015,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Template:Braces/#1608963983838",
            "operation": "create",
            "object": {
                "pageTitle": "Template:Braces - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Template:Braces",
                "body": "    This template returns the first unnamed parameter in double braces. To be used to demonstrate template code without the need for clunky nowiki'ing. Further unnamed parameters (up to 8 more) can be used without worrying for pipes.\r\n    An alternative is to use &#123;{some text}&#125;.\r\n    Set code=on / code=true / etc. to switch the font used to the HTML <code>-style monospaced font.\r\n    To improve legibility, {{thin space}}s are inserted either side of any pipe characters (\" | \") displayed by the template.\r\n    To ensure equals-signs are handled as text by the template, use {{=}} to produce them – e.g. {{braces|Templatename|p1{{=}}v1|p2{{=}}v2|...}} (and see examples below).\r\n\r\nExamples\r\nMarkup \tOutput\r\n\r\n{{braces|Templatename|item1|item2}}\r\n\r\n\t\r\n\r\n{{Templatename | item1 | item2}}\r\n\r\n{{braces|code=on |Templatename|item1|item2}}\r\n\r\n\t\r\n\r\n{{Templatename | item1 | item2}}\r\n\r\n{{braces |Templatename|item1{{=}}XYZ|item2{{=}}PQR}}\r\n\r\n\t\r\n\r\n{{Templatename | item1=XYZ | item2=PQR}}\r\n\r\n{{braces|code=on |Templatename|item1{{=}}XYZ|item2{{=}}PQR}}\r\n\r\n\t\r\n\r\n{{Templatename | item1=XYZ | item2=PQR}}\r\n\t\r\n\r\nNote that omitting the double-braces around the equals signs in the last two examples does not work as intended:\r\nMarkup \tOutput\r\n\r\n{{braces |Templatename|item1=XYZ|item2=PQR}}\r\n\r\n\t\r\n\r\n{{Templatename}}\r\n\r\n{{braces|code=on |Templatename|item1{{=}}XYZ|item2{{=}}PQR}}\r\n\r\n\t\r\n\r\n{{Templatename}}\r\n\t",
                "comment": "Braces (Templates)",
                "selector": {
                    "quote": "    This template returns the first unnamed parameter in double braces. To be used to demonstrate template code without the need for clunky nowiki'ing. Further unnamed parameters (up to 8 more) can be used without worrying for pipes.\r\n    An alternative is to use &#123;{some text}&#125;.\r\n    Set code=on / code=true / etc. to switch the font used to the HTML <code>-style monospaced font.\r\n    To improve legibility, {{thin space}}s are inserted either side of any pipe characters (\" | \") displayed by the template.\r\n    To ensure equals-signs are handled as text by the template, use {{=}} to produce them – e.g. {{braces|Templatename|p1{{=}}v1|p2{{=}}v2|...}} (and see examples below).\r\n\r\nExamples\r\nMarkup \tOutput\r\n\r\n{{braces|Templatename|item1|item2}}\r\n\r\n\t\r\n\r\n{{Templatename | item1 | item2}}\r\n\r\n{{braces|code=on |Templatename|item1|item2}}\r\n\r\n\t\r\n\r\n{{Templatename | item1 | item2}}\r\n\r\n{{braces |Templatename|item1{{=}}XYZ|item2{{=}}PQR}}\r\n\r\n\t\r\n\r\n{{Templatename | item1=XYZ | item2=PQR}}\r\n\r\n{{braces|code=on |Templatename|item1{{=}}XYZ|item2{{=}}PQR}}\r\n\r\n\t\r\n\r\n{{Templatename | item1=XYZ | item2=PQR}}\r\n\t\r\n\r\nNote that omitting the double-braces around the equals signs in the last two examples does not work as intended:\r\nMarkup \tOutput\r\n\r\n{{braces |Templatename|item1=XYZ|item2=PQR}}\r\n\r\n\t\r\n\r\n{{Templatename}}\r\n\r\n{{braces|code=on |Templatename|item1{{=}}XYZ|item2{{=}}PQR}}\r\n\r\n\t\r\n\r\n{{Templatename}}\r\n\t",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/div[1]/div[1]/ul[1]/li[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/div[1]/div[1]/table[2]/tbody[1]/tr[4]/td[2]",
                                "endOffset": 1
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 782,
                                "end": 2203
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "This template returns the first unnamed parameter in double braces. To be used to demonstrate template code without the need for clunky nowiki'ing. Further unnamed parameters (up to 8 more) can be used without worrying for pipes.\nAn alternative is to use &#123;{some text}&#125;.\nSet .mw-parser-output .monospaced{font-family:monospace,monospace}code=on / code=true / etc. to switch the font used to the HTML <code>-style monospaced font.\nTo improve legibility, {{thin space}}s are inserted either side of any pipe characters (\" | \") displayed by the template.\nTo ensure equals-signs are handled as text by the template, use {{=}} to produce them – e.g. {{braces|Templatename|p1{{=}}v1|p2{{=}}v2|...}} (and see examples below).\nExamples\n\n\n\nMarkup\nOutput \n\n\n{{braces|Templatename|item1|item2}}\n\n\n{{Templatename | item1 | item2}}\n\n \n\n\n{{braces|code=on |Templatename|item1|item2}}\n\n\n{{Templatename | item1 | item2}}\n\n \n\n\n{{braces |Templatename|item1{{=}}XYZ|item2{{=}}PQR}}\n\n\n{{Templatename | item1=XYZ | item2=PQR}}\n\n \n\n\n{{braces|code=on |Templatename|item1{{=}}XYZ|item2{{=}}PQR}}\n\n\n{{Templatename | item1=XYZ | item2=PQR}}\n\n\n\n\n\n\n\n\nNote that omitting the double-braces around the equals signs in the last two examples does not work as intended:\n\n\n\n\nMarkup\nOutput \n\n\n{{braces |Templatename|item1=XYZ|item2=PQR}}\n\n\n{{Templatename}}\n\n \n\n\n{{braces|code=on |Templatename|item1{{=}}XYZ|item2{{=}}PQR}}\n\n\n{{Templatename}}\n\n\n\n\n\n\n\n",
                                "prefix": "[view] [edit] [history] [purge]\n",
                                "suffix": "\nSee also\n{{brackets}}\n{{nowiki}"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T06:26:23.838Z",
                "lastEdited": "2020-12-26T06:27:51.524Z",
                "url": "https://en.wikipedia.org/wiki/Template:Braces/#1608963983838"
            }
        },
        {
            "timestamp": 1608964071551,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Template:Braces/#1608963983838",
            "operation": "update",
            "object": {
                "pageTitle": "Template:Braces - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Template:Braces",
                "body": "    This template returns the first unnamed parameter in double braces. To be used to demonstrate template code without the need for clunky nowiki'ing. Further unnamed parameters (up to 8 more) can be used without worrying for pipes.\r\n    An alternative is to use &#123;{some text}&#125;.\r\n    Set code=on / code=true / etc. to switch the font used to the HTML <code>-style monospaced font.\r\n    To improve legibility, {{thin space}}s are inserted either side of any pipe characters (\" | \") displayed by the template.\r\n    To ensure equals-signs are handled as text by the template, use {{=}} to produce them – e.g. {{braces|Templatename|p1{{=}}v1|p2{{=}}v2|...}} (and see examples below).\r\n\r\nExamples\r\nMarkup \tOutput\r\n\r\n{{braces|Templatename|item1|item2}}\r\n\r\n\t\r\n\r\n{{Templatename | item1 | item2}}\r\n\r\n{{braces|code=on |Templatename|item1|item2}}\r\n\r\n\t\r\n\r\n{{Templatename | item1 | item2}}\r\n\r\n{{braces |Templatename|item1{{=}}XYZ|item2{{=}}PQR}}\r\n\r\n\t\r\n\r\n{{Templatename | item1=XYZ | item2=PQR}}\r\n\r\n{{braces|code=on |Templatename|item1{{=}}XYZ|item2{{=}}PQR}}\r\n\r\n\t\r\n\r\n{{Templatename | item1=XYZ | item2=PQR}}\r\n\t\r\n\r\nNote that omitting the double-braces around the equals signs in the last two examples does not work as intended:\r\nMarkup \tOutput\r\n\r\n{{braces |Templatename|item1=XYZ|item2=PQR}}\r\n\r\n\t\r\n\r\n{{Templatename}}\r\n\r\n{{braces|code=on |Templatename|item1{{=}}XYZ|item2{{=}}PQR}}\r\n\r\n\t\r\n\r\n{{Templatename}}\r\n\t",
                "comment": "Braces (Templates)",
                "selector": {
                    "quote": "    This template returns the first unnamed parameter in double braces. To be used to demonstrate template code without the need for clunky nowiki'ing. Further unnamed parameters (up to 8 more) can be used without worrying for pipes.\r\n    An alternative is to use &#123;{some text}&#125;.\r\n    Set code=on / code=true / etc. to switch the font used to the HTML <code>-style monospaced font.\r\n    To improve legibility, {{thin space}}s are inserted either side of any pipe characters (\" | \") displayed by the template.\r\n    To ensure equals-signs are handled as text by the template, use {{=}} to produce them – e.g. {{braces|Templatename|p1{{=}}v1|p2{{=}}v2|...}} (and see examples below).\r\n\r\nExamples\r\nMarkup \tOutput\r\n\r\n{{braces|Templatename|item1|item2}}\r\n\r\n\t\r\n\r\n{{Templatename | item1 | item2}}\r\n\r\n{{braces|code=on |Templatename|item1|item2}}\r\n\r\n\t\r\n\r\n{{Templatename | item1 | item2}}\r\n\r\n{{braces |Templatename|item1{{=}}XYZ|item2{{=}}PQR}}\r\n\r\n\t\r\n\r\n{{Templatename | item1=XYZ | item2=PQR}}\r\n\r\n{{braces|code=on |Templatename|item1{{=}}XYZ|item2{{=}}PQR}}\r\n\r\n\t\r\n\r\n{{Templatename | item1=XYZ | item2=PQR}}\r\n\t\r\n\r\nNote that omitting the double-braces around the equals signs in the last two examples does not work as intended:\r\nMarkup \tOutput\r\n\r\n{{braces |Templatename|item1=XYZ|item2=PQR}}\r\n\r\n\t\r\n\r\n{{Templatename}}\r\n\r\n{{braces|code=on |Templatename|item1{{=}}XYZ|item2{{=}}PQR}}\r\n\r\n\t\r\n\r\n{{Templatename}}\r\n\t",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/div[1]/div[1]/ul[1]/li[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/div[1]/div[1]/table[2]/tbody[1]/tr[4]/td[2]",
                                "endOffset": 1
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 782,
                                "end": 2203
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "This template returns the first unnamed parameter in double braces. To be used to demonstrate template code without the need for clunky nowiki'ing. Further unnamed parameters (up to 8 more) can be used without worrying for pipes.\nAn alternative is to use &#123;{some text}&#125;.\nSet .mw-parser-output .monospaced{font-family:monospace,monospace}code=on / code=true / etc. to switch the font used to the HTML <code>-style monospaced font.\nTo improve legibility, {{thin space}}s are inserted either side of any pipe characters (\" | \") displayed by the template.\nTo ensure equals-signs are handled as text by the template, use {{=}} to produce them – e.g. {{braces|Templatename|p1{{=}}v1|p2{{=}}v2|...}} (and see examples below).\nExamples\n\n\n\nMarkup\nOutput \n\n\n{{braces|Templatename|item1|item2}}\n\n\n{{Templatename | item1 | item2}}\n\n \n\n\n{{braces|code=on |Templatename|item1|item2}}\n\n\n{{Templatename | item1 | item2}}\n\n \n\n\n{{braces |Templatename|item1{{=}}XYZ|item2{{=}}PQR}}\n\n\n{{Templatename | item1=XYZ | item2=PQR}}\n\n \n\n\n{{braces|code=on |Templatename|item1{{=}}XYZ|item2{{=}}PQR}}\n\n\n{{Templatename | item1=XYZ | item2=PQR}}\n\n\n\n\n\n\n\n\nNote that omitting the double-braces around the equals signs in the last two examples does not work as intended:\n\n\n\n\nMarkup\nOutput \n\n\n{{braces |Templatename|item1=XYZ|item2=PQR}}\n\n\n{{Templatename}}\n\n \n\n\n{{braces|code=on |Templatename|item1{{=}}XYZ|item2{{=}}PQR}}\n\n\n{{Templatename}}\n\n\n\n\n\n\n\n",
                                "prefix": "[view] [edit] [history] [purge]\n",
                                "suffix": "\nSee also\n{{brackets}}\n{{nowiki}"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T06:26:23.838Z",
                "lastEdited": "2020-12-26T06:27:51.524Z",
                "url": "https://en.wikipedia.org/wiki/Template:Braces/#1608963983838"
            }
        },
        {
            "timestamp": 1608964071586,
            "collection": "tags",
            "objectPk": [
                "template",
                "https://en.wikipedia.org/wiki/Template:Braces/#1608963983838"
            ],
            "operation": "create",
            "object": {
                "url": "https://en.wikipedia.org/wiki/Template:Braces/#1608963983838",
                "name": "template"
            }
        },
        {
            "timestamp": 1608964071601,
            "collection": "tags",
            "objectPk": [
                "braces",
                "https://en.wikipedia.org/wiki/Template:Braces/#1608963983838"
            ],
            "operation": "create",
            "object": {
                "url": "https://en.wikipedia.org/wiki/Template:Braces/#1608963983838",
                "name": "braces"
            }
        },
        {
            "timestamp": 1608964071615,
            "collection": "tags",
            "objectPk": [
                "code",
                "https://en.wikipedia.org/wiki/Template:Braces/#1608963983838"
            ],
            "operation": "create",
            "object": {
                "url": "https://en.wikipedia.org/wiki/Template:Braces/#1608963983838",
                "name": "code"
            }
        },
        {
            "timestamp": 1608965590772,
            "collection": "pages",
            "objectPk": "en.wikipedia.org/wiki/Help:Transclusion",
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Help:Transclusion",
                "fullUrl": "https://en.wikipedia.org/wiki/Help:Transclusion",
                "domain": "wikipedia.org",
                "hostname": "en.wikipedia.org",
                "fullTitle": "Help:Transclusion - Wikipedia",
                "text": " Help:Transclusion From Wikipedia, the free encyclopedia (Redirected from Wikipedia:Transclusion ) Jump to navigation Jump to search \"WP:TRANS\" redirects here. You may be looking for Wikipedia:Transwiki log , Help:Transwiki , Wikipedia:Translation , Wikipedia:WikiProject Transwiki or Wikipedia:Transgender . Wikipedia information page This is an information page . It is not one of Wikipedia's policies or guidelines , but rather intends to describe some aspect(s) of Wikipedia's norms, customs, technicalities, or practices. It may reflect varying levels of consensus and vetting . Shortcut WP:TRANS Transclusion means the inclusion of the content of one document within another document by reference . In Wikipedia transclusion, the MediaWiki software will refer to the content of one page, the template , for inclusion into the content of any other page, the target page. Similar to the way any page name can become a link by placing its name in double square brackets, any page name can become a template by placing it in double curly braces, {{Namespace: Pagename }}. Changes made to the template are then automatically reflected on all pages into which that page has been transcluded (though a purge may sometimes be necessary). If the template's page name does not begin with a namespace, it is assumed to be in the Template namespace. To refer to a page in the \"Main\" (article) namespace, it is necessary to prefix it with a colon (:). Examples: {{Stochastic processes}} will transclude from the page Template:Stochastic processes {{:Stochastic processes}} will transclude from the page Stochastic processes (an article, in the Main namespace) {{WP:Assume good faith}} will transclude from the page Wikipedia:Assume good faith What will transclude from a page can be controlled with the tags <noinclude>, <onlyinclude> and <includeonly> placed in the source page wikitext. (See markup , below.) The use of tags enables the template to transclude partially, otherwise the double curly braces will always transclude all content. For selective transclusion the <includeonly> parts of the template are named (with the help of parser functions ) and that template is then called with the parameter transcludesection=name. Transclusion events occur every time the page is loaded, when the template is rendered. Another use of the same mechanism is a one-shot substitution of the template call itself by its transcluded source page. A template call {{ fullpagename }} with the \"subst:\" prefix {{subst:fullpagename}} is transcluded once but never again, because the wikitext of that call is replaced (substituted) when its page is saved. What was a one-time template call becomes the actual wikitext of the template at the time of its call. Contents 1 How transclusion works 2 Transclusion syntax 2.1 Template transclusion 2.2 Substitution 2.3 Magic words 2.4 Transclusion modifiers 3 Applications of transclusion 3.1 Composite pages 3.2 Pages with a common section 3.3 Repetition within a page 4 Partial transclusion 4.1 Markup 5 Selective transclusion 5.1 Standard section transclusion (Special source document markup not needed!) 5.1.1 Transcluded section hatnote 5.2 Using the labeled section method 5.3 Parametrization method 5.3.1 Source document markup 5.3.2 Target document markup 5.3.3 Example 6 Subpages 7 Special pages 8 See also 8.1 MediaWiki transclusion 8.2 Templates 8.3 Other How transclusion works Note: this section is transcluded from Help:Transclusion/How Transclusion Works To transclude any source page (within a single MediaWiki project, such as en:Wikipedia), include the following code in the target page: {{SOMEPAGE}} Whenever the target page A with this code is rendered, the engine will include in that place not the code itself, but the entire content of the source page B, SOMEPAGE. The top row shows what the target page renders as, while the bottom row shows the code. Note: foo will not be highlighted nor boxed on the target page. For example, you might decide to place a welcome message on every newcomer's talk page. Transclusion creates a \"live\" link between the template page and the target page(s) upon which the template's contents should appear. When the template is edited, the rendering of that template on the target pages is updated as well. For example, you create a (template) page in Wikipedia with your home mailing address and then transclude that template not only on your page, but all your friends' pages, too. Later, after moving to a new house, you then update your address template and the new address will automatically appear on all your friends' pages. There are further simple examples at mw:Transclusion . On the other hand, breaking existing transclusions in a template is called breakage. Transclusion syntax The general syntax for transclusion on Wikipedia is {{ Namespace : Pagename }}, where Namespace:Pagename describes the title of a Wikipedia page. Using transclusion syntax requires some knowledge of page titles. On Wikipedia, non-article pages have titles with a visible namespace and pagename separated by a colon; for example, the page Wikipedia:Tips has Wikipedia as the namespace, and Tips as the pagename. But encyclopedic articles only have a visible pagename in their titles: for example the article Potato has Potato as the pagename, and the namespace, called main namespace , is not visible. The wikitext {{Namespace:Pagename}} will transclude the page titled Namespace:Pagename. For example if a page has the wikitext {{Wikipedia:Notability}} in it, it will transclude the page Wikipedia:Notability into it. Please note that {{WP:Notability}} would do the exactly the same thing, as WP: is a namespace alias , which is automatically translated by the Wikipedia servers to Wikipedia:. If the namespace is omitted, but the colon is included, like {{:Pagename}}, the encyclopedic article Pagename will be transcluded. For example {{:Notability}} will transclude the article Notability . If both namepace and colon are omitted, like {{Pagename}}, the Template:Pagename will be transcluded. For example {{Notability}}, and also {{Template:Notability}}, will both transclude the Template:Notability . For transcluding subpages, see this section . Also see the template parameters and transclusion modifiers section. So, in summary, an example page having the wikitext {{Pagename}} or {{Template:Pagename}} included, will transclude the Template:Pagename into that example page. But {{:Pagename}} will have a different effect: it will transclude the article Pagename. Also, {{Namespace:Pagename}} will transclude the page Namespace:Pagename, for pages with titles of that format. Template transclusion Further information: Help:Template § Parameters For a quick guide to templates, see Help:A quick guide to templates . The most common application of transclusion is the transclusion of templates . Templates are pages that are written with the prime objective of being included in other pages, either through transclusion or substitution . As shown above, the usual syntax for transcluding a template titled Template:Pagename is {{Pagename}}. However, some templates can also use parameters . Parameters are variables that can be given values (also termed arguments ) that can be passed on to certain templates in order for them to work in different ways. Templates can either use no parameters, a fixed number of parameters, or a variable number of parameters. The number of parameters a template can use is from one upwards. The exact syntax for using parameters with templates can vary greatly, depending on the actual template being used. But, for an example template titled Template:Pagename, which happened to use three parameters, the general form would be: {{Pagename|parameter1|parameter2|parameter3}} Shortcuts WP:UNNAMED WP:POSPARAM WP:POSITIONAL with each parameter being substituted with a value, or a parameter name=value, when used in practice. Notice that each parameter is separated with a vertical bar . Parameters that take the form value are called unnamed or positional parameters. Parameters that take the form parameter name=value are called named parameters. With unnamed parameters, the first, second, third etc. parameters are equivalent to parameters '1', '2', '3' etc. in template documentation. Unnamed parameters must be in the correct order, and best placed before named parameters. An example of the syntax using the Template:Collapse top : {{Collapse top|This is the title text|This is a custom warning line|left=true}} In this particular example, three parameters are used, but Template:Collapse top can actually use a variable number of parameters. This is the title text and This is a custom warning line are the values of unnamed parameters '1' and '2'; and true is the value of the named parameter left. For more details, see Help:Template . Also, see Wikipedia:Template index for a list of links to available Main Namespace related templates (usually for encyclopedic articles); and other Namespace related templates (usually for non-article pages); there is also a search function. Substitution Substitution has a similar double curly-bracket syntax, and its action is similar to transclusion. When you preview a page with substitution wikitext in it, its action is identical to transclusion. But when you save a page with substitution wikitext in it, it differs in that it substitutes that wikitext with the actual wikitext of the template. For example when {{subst:Like}} is saved, it would substitute that wikitext with the actual wikitext from the Template:Like . In practice, the main difference that this makes is that if an update happened to the wikitext of the Template:Like, it would not update any pages where {{subst:Like}} had already been saved. Magic words Magic words are not examples of transclusion. But some have a similar double curly-bracket syntax and action to transclusion. For example, {{FULLPAGENAME}} renders the Fullpagename of any Wikipedia page. Like templates, some magic words can also take parameters, which are separated using a colon (:); for example {{FULLPAGENAME:value}}. Templates do exist for some magic words, for example Template:FULLPAGENAME ; but these just invoke the related magic word if passing parameters using a vertical bar (|); for example like {{FULLPAGENAME|value}}. But magic words parameters are best passed directly by using a colon, for example like {{FULLPAGENAME:value}}, which bypasses any templates. Transclusion modifiers As discussed above, with the example {{subst:Like}}, the subst: code alters the transclusion to substitution. This is a transclusion modifier, a type of specialist magic word for altering transclusion in some manner. Another example is {{:Notability}}, where the : (colon character) forces transclusion to the main namespace. There are additional transclusion modifiers such as safesubst:, int:, msg:, msgnw:, and raw:. For more details on their usage see mw:Help:Magic words#Transclusion modifiers . Also see the modified commands #section:, #section-x: and #section-h: used for labeled section transclusion . Applications of transclusion The most common application of transclusion is in the use of templates . However, other pages are also sometimes transcluded, mainly within project space. Composite pages Composite pages consist, wholly or partly, of transcluded component pages. The wikitext of such a page may, partly or fully, consist of tags, for the inclusion of component pages. The component pages are usually not in the template namespace, and are often full pages in their own right. Composite pages are intended to gather them into a central location. Examples of composite pages: Wikipedia:Village pump : mostly consists of the transcluded page Template:Village pump . A daily page like Wikipedia:Articles for deletion/Log/2005 May 31 , where each component page consists of the discussion on the deletion of one Wikipedia page, e.g. Wikipedia:Articles for deletion/Sp3tt . For this day, 75 component pages made up the composite page. m:Meta:Translation/Coordination , mainly containing m:Meta:Translation/Coordination/List/Meta m:Meta:Translation/Coordination/List/Main This allows the choice between viewing the component pages separately or together. Viewing a composite page is convenient when there are many small, related component pages, in that it allows an overview of all the components without the effort of following numerous links. In general, each component page and the composite page are treated separately. While the actual changes on the component pages will be transcluded onto the composite page, the edit history, recent changes, page-watch settings, page protection, TOC, \"what links here\" links, and other features of the composite page do not reflect, or affect, the histories, watch settings, protection levels, what links here lists of the component pages. The composite page is a page in its own right. The talk page of a composite page is used to talk about the composition and the page in general, not the component pages; although it in turn could be a composite of the talk pages of the component pages. Editing a section of a component page can be done directly from the composite page, see editing sections of included templates . After saving, one ends up editing the component page to which the section belongs. On projects with the interlanguage link feature , the composite page shows the combined interlanguage links of all component pages, hence possibly multiple links for one language or even for one page. See also Wikipedia talk:Template namespace/Archive 1#transcluding prose . Pages with a common section When two pages need to discuss the same material in the same way, they can share a section. This involves creating a third page and transcluding that page onto both pages. This third page may be a page in its own right or a subpage of either of the other two, and if the first it may be placed in the same namespace as the other pages or in template namespace. Common sections like this should be marked with an explanatory header, and/or given a special layout, to inform the reader that this section of the page is in a different location, since transcluding shared article sections can easily confuse novice editors and readers alike if left unmarked. This can be very useful when two disambiguation pages share content,[ disputed discuss ] or a list page and a disambiguation page share content (see third example below). Examples: The Help:Editing sections of included templates article is included in Help:Section with the markup {{Help:Editing sections of included templates}}. By including a heading in the included article, a user clicking the \"Edit\" link on that heading in Help:Section is automatically directed to edit Help:Editing sections of included templates . m:Help:Alphabetic order ( talk , backlinks , edit ) Joseph Gordon-Levitt transcludes the introduction of HitRecord into a summary section of the same name, rather than maintaining two copies of the identical text. Repetition within a page On pages where there is a lot of repetitive information various kinds of lists, usually it is sometimes useful to make a template that contains the repeating text, and then call that template multiple times. For example, Template:EH listed building row is used repeatedly to construct tables in many articles. Simple repetition of the same text can be handled with repetition of a parameter in a single template: e.g., {{ 3x }}, where {{3x| howdy!}} produces howdy! howdy! howdy!. For more information on repetition, see also m:Help:Recursive conversion of wikitext . For more information on the current template system, see Wikipedia:Template namespace . Partial transclusion Shortcut WP:PARTRANS By using <noinclude>, <includeonly> and <onlyinclude> markup, it is possible to transclude part of a page, rather than all of it. Such partial transclusions can be achieved by transcluding from any pages, including subpages. It is often useful to exclude part of a page in a transclusion, an example being with template documentation. For an example of how this technique can be applied to simplify the creation of summary articles , see how part of the History of pathology (see the diff here ) was transcluded into Pathology (see the diff here ) using the {{:History of pathology}} markup. The Pathology article at that time (see here ) mainly consisted of transcluded lead paragraphs and other sections from a number of articles. Look at the source to see how this was done. Since then, the Pathology article has been rewritten, and does not include all these transclusions. Another example can be found in the transclusion of part of HitRecord (introductory paragraph only) into a same-named summary section in Joseph Gordon-Levitt . Markup See also: Help:Template § Noinclude, includeonly, and onlyinclude ; and Help:Category § Categories and templates In transclusion, a source page is transcluded into a destination page. But with partial transclusion, only part of that source page will be transcluded into a destination page. But in addition, what is transcluded to a destination page does not have to be visible on the source page. Page rendering of a source page can be defined as the rendering of that source page when it is saved, which will be the same as the preview . We can call this rendering here. Transclusion rendering of a source page can be defined as the rendering of a destination page that has a source page transcluded into it; but only that part of the destination page that was transcluded from the source page. The preview of the transclusion rendering will again be identical. We can call this rendering there. There are three pairs of tags involved in cases where page rendering here should differ from transclusion rendering there. As described earlier, these are <noinclude>, <includeonly> and <onlyinclude>. These tags are invisible, but affect both page rendering here and transclusion rendering there. These tags pair-off to demarcate sections that will create differences. Each tag will describe exceptions to transcluding the whole page named. <noinclude> This section is visible here; but this section is not visible there. Sections outside of these tags will be visible both here and there. </noinclude> <onlyinclude> This section is visible here; this section is also visible there. Sections outside of these tags will be visible here, but will not be visible there. </onlyinclude> <includeonly> This section is not visible here; but it is visible there. Sections outside of these tags will be visible both here and there. </includeonly> Wikitext What is rendered here (source page) What is transcluded there (destination page) <noinclude>text1</noinclude> text2 text1 text2 text2 <onlyinclude>text1</onlyinclude> text2 text1 text2 text1 <includeonly>text1</includeonly> text2 text2 text1 text2 An important point to note is that <noinclude> and <onlyinclude> do not affect what is page rendered here at all, unlike <includeonly>. The <noinclude> tags stops text inside the tags being transcluded there, while <onlyinclude> has the opposite effect: it stops text outside of the tags from being transcluded there. Only <includeonly> stops text from being page rendered here. But naturally enough it is transcluded there. Text outside of the tags will be both rendered here and transcluded there. There can be several such sections. Also, they can be nested. All possible differences between here and there are achievable. One example is a content editor who picks an <onlyinclude> section, and then takes a <noinclude> section out of that; but then picks out yet another <onlyinclude> section to append to there; but none of this affects their article in any way. The other example is the template programmer, who will <includeonly> the code section and <noinclude> the documentation section of a page. A mis-example is, on a the user page, to use <includeonly> to \"comment out\" a section. While it might comment out sections here, such invisible ink may prove to be troublesome; if transcluded, the comments would be revealed. Use <!--...--> instead. NoInclude as a name about transcluding is pretty straightforward. A mnemonic for the other two transclusions there is: InclusionONLY; and Yet Another ONLYInclusion. Selective transclusion Shortcuts WP:SELECTIVETRANSCLUSION WP:SELTRANS See also: Template:Excerpt and Template:Transcluded section Selective transclusion is the process of partially transcluding one selected section of a document that has more than one transcludable section. As noted above, if only one section of a document is to be transcluded, this can be done by simply surrounding the section of interest with <onlyinclude> … </onlyinclude> tags, and transcluding the whole page. However, to selectively transclude one section from a template or document into one page, and another section from the same template or document into a second page and/or a different section of the same page, requires a way to: a) uniquely mark each transcludable section in the source document; and b) in the target document(s) (those to show the transcluded sections), a way to specify which section is to be transcluded. This section describes how to accomplish this. There are three ways of doing this: (1) Section header-based transclusion, (2) Labeled section transclusion, and (3) the parametrization method. Standard section transclusion (Special source document markup not needed!) Using {{#section-h:PAGENAME|SECTIONNAME}}, one can easily transclude the content within a section on one page to another by referring to the standard, ubiquitous headline-based section headers used throughout Wikipedia. To transclude the lead of an article with this method, one can use {{#section-h:PAGENAME}}. This is simpler than the already widely used selective transclusion methods of the sections below, which require special source document markup. This selective transclusion method often adds a line break above and/or below the section transclusion, depending upon the source and target document markup; to avoid this issue, wrap the selective transclusion template in a {{ trim }} template. In other words, use the following modifications to the transclusion code listed immediately above: Code for transcluding a section in the body of an article: {{trim|{{#section-h:PAGENAME|SECTIONNAME}}}} Code for transcluding the lead of an article: {{trim|{{#section-h:PAGENAME}}}} Transcluded section hatnote For the purpose of indicating where selectively transcluded article content is located, it is helpful to include a {{ Transcluded section }} hatnote at the top of the corresponding section of an article; i.e., use either {{transcluded section|source=PAGENAME}} or {{transcluded section|source=PAGENAME|part=yes}}, depending upon whether the transcluded content comprises an entire section of the target page. These templates render as follows. {{transcluded section|source=PAGENAME}} renders as: This section is transcluded from PAGENAME . ( edit | history ) {{transcluded section|source=PAGENAME|part=yes}} renders as: Part of this section is transcluded from PAGENAME . ( edit | history ) Using the labeled section method Main page: Help:Labeled section transclusion Labeled-section selective transclusion uses the parser functions listed in mw:Extension:Labeled Section Transclusion , which are enabled on all Wikimedia wikis, to selectively transclude content. See Help:Labeled section transclusion for how labeled section transclusion works. Parametrization method Source document markup Insert the following line into the \"source\" document (the one from which text is to be transcluded), immediately preceding the first line of each section to be transcluded, substituting SECTIONNAME (twice) with the unique name of the respective section. The section name can be any identifier and must be unique within that document: <onlyinclude>{{#ifeq:{{{transcludesection|SECTIONNAME}}}|SECTIONNAME| End each such transcludable section with: }}</onlyinclude> Target document markup To transclude a section marked as above into another page (the \"target page\"), use the following line on that page, substituting PAGENAME for the \"source\" document from which text to be transcluded, and SECTIONNAME with the name of the section you want to transclude: {{PAGENAME|transcludesection=SECTIONNAME}} Thus each section enclosed within <onlyinclude> … </onlyinclude> tags will always be rendered when the transcludesection parameter is not set (when the document is viewed ordinarily, or when the document is transcluded without setting the transcludesection parameter as shown below), and will be rendered by transclusion on any page that does set transcludesection to the section's name. It will not be rendered by transclusion that uses the transcludesection parameter but sets it to anything other than the name of the section. Also, when providing PAGENAME, without providing a Namespace , the wiki will assume that the PAGENAME belongs in the Template Namespace . To transclude from a Mainspace article, use :PAGENAME. {{:PAGENAME|transcludesection=SECTIONNAME}} Example If we want to make the \"Principal Criteria\" and \"Common Name\" sections of WP:TITLE be independently transcludable, we edit the WP:TITLE page and enclose the \"Principal Criteria\" section as follows: <onlyinclude> {{ # ifeq : {{{ transcludesection |principalcriteria }}} |principalcriteria | ... '' ( text of \"Principal Criteria\" section ) '' ... }} </onlyinclude> Similarly, we enclose the \"Common Name\" section with: <onlyinclude> {{ # ifeq : {{{ transcludesection |commonname }}} |commonname | ... '' ( text of \"Common Name\" section ) '' ... }} </onlyinclude> Then, to transclude the \"Principal Criteria\" section into another page, we insert into that page: {{WP:TITLE|transcludesection=principalcriteria}} To transclude the \"Common Name\" section into another page, we insert into that page: {{WP:TITLE|transcludesection=commonname}} Of course, the same page can transclude two or more sections this way by including multiple such lines. There is no limit to how many selectable sections for transclusion a document can have. The only requirement is that each transcludesection be given a value that is unique within that page. Subpages To transclude a subpage : The general syntax is {{Namespace:Pagename/subpagename}}. If it is a subpage of the page you are editing, then it is the general syntax, or {{/subpagename}}. For an encyclopedic article it is {{:Pagename/subpagename}}, although article subpages are normally disabled. For a template, it is the general syntax, or {{Pagename/subpagename}}. You have the option of using transclusion modifiers and template parameters , but in practice this is rare. For example, to transclude the Template:Like/doc , it would be either {{Template:Like/doc}} or {{Like/doc}}. Subpages are only allowed in certain namespaces, such as User, Talk or Wikipedia pages; currently, subpages of main article pages cannot be created . Subpages could be used for a shared discussion on talk pages. For example: you want to discuss the deletion and redirecting of the article Pussycat to the article Cat in both talk pages. First, create the subpage Talk:Pussycat/Let's delete Pussycat! , write your comment into it, then transclude it in Talk:Pussycat and Talk:Cat using the template {{Talk:Pussycat/Let's delete Pussycat!}}. Comments posted in this subpage will be shown in both talk pages. To ease the editing of the subpage, it may be helpful to precede the transcluded talk with {{ lat }}; for example the wikitext {{lat|Pussycat/Let's delete Pussycat!}} would produce Talk:Pussycat/Let's delete Pussycat! ( edit | article | history | links | watch | logs ). Transcluding in this way will not preserve a fixed record of the discussion at the time of any archiving, so discussions should be closed in conjunction with archiving. An alternative is not to use subpages at all. You could centralise the discussion, in the normal manner, on a single talk page, and point to it on the other talk page by substituting the {{ Please see }} template, as per WP:MULTI . As an example, a discussion could take place at Talk:Pussycat#Let's delete Pussycat! ; you could then place the wikitext {{subst:Please see|Talk:Pussycat#Let's delete Pussycat!}} in the Talk:Cat page. When the edit was saved, it would substitute it with the text: ==Discussion at Talk:Pussycat#Let's delete Pussycat!== [[File:Farm-Fresh eye.png|15px|link=|alt=]] You are invited to join the discussion at [[Talk:Pussycat#Let's delete Pussycat!]]. Thanks. [[User:Example|Example]] ([[User talk:Example|talk]]) 19:03, 20 October 2014 (UTC){{z48}}<!--Template:Please see--> Special pages See also: Wikipedia:Special pages § Miscellaneous Some pages on Special:Specialpages can be transcluded, such as Special:Allpages , Special:Prefixindex , Special:Newfiles , Special:Newpages , Special:Recentchanges and Special:Recentchangeslinked . Samples: {{Special:Allpages/General}} a list of pages starting at \"General\". {{Special:Prefixindex/General}} a list of pages with prefix \"General\". {{Special:Newfiles/4}} a gallery of the four most recently uploaded files. {{Special:Newpages/5}} a list of the five most recently created pages. {{Special:Recentchanges/5}} the five most recent changes. {{Special:Recentchangeslinked/General}} recent changes to the pages linked from \"General\". Attempting to transclude {{Special:Categories}} will not result in an actual list of categories, but {{Special:Prefixindex/Category:}} can be used for this purpose. Except for Special:Recentchangeslinked, the slash, and the word or number after the slash, can be omitted, giving a list of pages without a specific starting point, or a list of the default length. URL parameters can be given like template parameters: {{Special:Recentchanges|namespace=10|limit=5}} the five most recent changes in the \"Template\" namespace. {{Special:Prefixindex/Jimbo Wales/|namespace=2|stripprefix=1}} the subpages for User:Jimbo Wales , but without the user page prefix. Note: Transcluding certain special pages (such as Special:Newpages ) can change the displayed title of the page. See also MediaWiki transclusion mw:Transclusion : a simple introduction (at MediaWiki). meta:Help:Embed page : gives basic information (at Meta-Wiki). Wikipedia:MediaWiki namespace meta:Help:MediaWiki namespace : at Meta-Wiki. meta:Help:Variable : information on MediaWiki variables (at Meta-Wiki). Help:Labeled section transclusion : mw:Extension:Labeled Section Transclusion :at MediaWiki. meta:Help:Template#Labeled section transclusion : at Meta-Wiki. Templates Help:A quick guide to templates : a simple introduction. Help:Template : more detailed description. meta:Help:Template : help at Meta-Wiki. Links to various other guides in the lead. mw:Help:Template : a simple introduction at MediaWiki. Wikipedia:Template index : a directory of available templates. Wikipedia:Template namespace : about the template namespace . Wikipedia:Template limits : limitations to complexity of pages. Other This page is referenced in the Wikipedia Glossary . Transclusion for Dummies Wikipedia:Transclusion costs and benefits {{ User transclusion }} and {{ User transclusion no }} userboxes for declaring one's stance on transclusion Wikipedia:Purge : to force transclusion of newly updated templates. Wikipedia:Substitution : the opposite of transclusion. Wikipedia:WikiProject Modular Articles : now defunct. Bugzilla:Request for template transclusion from Commons : a proposal for interwiki template support. Mw:User:Peter17/Reasonably efficient interwiki transclusion show Wikipedia help pages Visit the Teahouse or the Help desk for an interactive Q & A forum. FAQs (?) Reference desks (?) Noticeboards (?) Cheatsheet (?) Directories (?) About Wikipedia (?) Administration Purpose Principles Policies and guidelines What Wikipedia is not Disclaimer ( parental advice ) Making requests Who writes Wikipedia? Help for readers (?) FAQ Books Copyright Glossary Mobile access Navigation Other languages Searching Students Viewing media Contributing to Wikipedia (?) Advice for young editors Avoiding common mistakes Etiquette Simplified Manual of Style Simplified rule-set \"Ignore all rules\" \"The rules are principles\" Style-tips Tip of the day Your first article ( article wizard ) Getting started (?) Why create an account? Introductions by topic The Wikipedia Adventure Graphics tutorials Picture tutorial IRC (live chat) tutorial VisualEditor user guide Dos and don'ts (?) Accessibility Biographies Biographies (living) Categorization Consensus Discussions Disambiguation Images Leads Links Lists References Tables Titles (of articles) How-to pages and information pages (?) Appealing blocks Article deletion Categories Citations/references Referencing for beginners Citation Style 1 Cite errors References and page numbers Convert Diff Editing Minor edit toolbar edit conflict Find sources Files Footnotes Image deletion Infoboxes Linking ( link color ) Logging in Merging Page name Renaming pages Redirect Passwords Email confirmation Reverting Simple vandalism cleanup Talk pages ( archiving ) User contributions Coding (?) Wiki markup Barcharts Calculations Characters Columns Hidden text HTML Lists Magic words Music symbols Sections Sounds Tables Templates Transclusion URL Visual files Directories (?) Abbreviations Contents (Encyclopedia proper) Departments Editor's index Essays FAQs Glossary Guidelines Manual of Style Policies Tasks Tips Tools Missing Manual Ask for help on your talk page (?) show v t e Wikipedia technical help Get personal technical help at the Teahouse , Help desk , Village pump (technical) , talk pages or IRC . General technical help Browser notes Bypass cache Keyboard shortcuts Troubleshooting Editing CharInsert Edit conflict Edit toolbar Reverting How to create a page IRC Tutorial Mobile access Multilingual support Page history Page information Page name Help Printing Software notices Editnotice Special Characters Entering User access levels VisualEditor User guide Special page -related Special page help Edit filter Emailing users Logging in Reset passwords Logs Moving a page Fixing cut-and-paste moves Notifications/Echo FAQ Page Curation Page import Pending changes Random pages Recent changes Related changes Searching Linksearch Tags User contributions Watchlist What links here Wikitext Wikitext Cheatsheet Columns Line-break handling Lists Magic words For beginners Conditional expressions Switch parser function Time function Redirects Sections and TOCs Tables Introduction Basics Advanced table formatting Collapsing Conditional tables Sorting Using colours Links and diffs Links Interlanguage Interwiki Permanent Diffs Simplest diff guide Simple diff and link guide Complete diff and link guide Colon trick Link color Magic links Pipe trick URLs Media files: images, videos and sounds Media help Files Creation and usage Moving files to Commons Images Introduction to images Picture tutorial Preparing images for upload Uploading images Options to hide an image Extended image syntax SVG help Gallery tag Graphics tutorials Basic bitmap image editing How to improve image quality Graphics Lab resources Sound file markup Visual file markup Other graphics Family trees Graphs and charts How to create Barcharts To scale charts Math formulas Math symbols LaTeX symbols Rendering math Musical scores Musical symbols Timeline EasyTimeline syntax WikiHiero syntax Templates and Lua modules Templates Advanced template coding Template documentation Template index Template limits Template sandbox and test cases Citation templates Lua help Lua project Resources To do Substitution Purge Job queue Transclusion Labeled section Guide to Scribbling Data structure Namespaces Main/Article Category Draft File File description page Help Portal Project/Wikipedia Talk Archiving Template User User page design MediaWiki Bug reports and feature requests System message TimedMediaHandler extension Module Special HTML and CSS Cascading Style Sheets HTML in wikitext Catalogue of CSS classes Common.js and common.css User CSS for monospaced coding font Classes in Ambox Classes in microformats Markup validation Span tags Useful styles Customisation and tools Preferences Gadgets Skins Citation tools Cleaning up vandalism tools Customizing watchlists Hide pages IRC Scripts User scripts Guide Techniques User style Tools Alternative browsing Browser tools Editing tools Navigation shortcuts Optimum tool set Wikimedia Cloud Services Beta Features at MediaWiki Automated editing AfC helper script AutoWikiBrowser Bots Creating HotCat Huggle Navigation popups RedWarn Twinkle WPCleaner Inactive igloo STiki See also: Category:Wikipedia how-to Category:Wikipedia information pages Further navigation at: Help pages Administrators Accessibility Accounts Bots Referencing Citation metadata Templates User scripts Retrieved from \" https://en.wikipedia.org/w/index.php?title=Help:Transclusion&oldid=991923884 \" Categories : Wikipedia information pages Wikipedia glossary items Wikipedia editing Wikipedia page help Wikipedia template help Hidden categories: Wikipedia semi-protected project pages Wikipedia indefinitely move-protected pages Help pages with short description Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Help page Talk Variants Views Read View source View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Wikidata item Print/export Download as PDF Printable version In other projects MediaWiki Meta-Wiki Languages Afrikaans العربية বাংলা भोजपुरी Català Dansk فارسی Français Gàidhlig 한국어 हिन्दी Ilokano Italiano Jawa Македонски مصرى مازِرونی Bahasa Melayu Norsk bokmål ଓଡ଼ିଆ Polski Português සිංහල Simple English Српски / srpski Sunda Türkçe 吴语 ייִדיש Zazaki 中文 22 more Edit links This page was last edited on 2 December 2020, at 15:19 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License ; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement Enable previews ",
                "urlTerms": [
                    "wiki",
                    "transclusion"
                ],
                "titleTerms": [
                    "transclusion",
                    "wikipedia"
                ]
            }
        },
        {
            "timestamp": 1608965590836,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "en.wikipedia.org/wiki/Help:Transclusion"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "en.wikipedia.org/wiki/Help:Transclusion",
                "fullUrl": "https://en.wikipedia.org/wiki/Help:Transclusion",
                "createdAt": "2020-12-26T06:53:10.824Z"
            }
        },
        {
            "timestamp": 1608965590845,
            "collection": "visits",
            "objectPk": [
                1608965590841,
                "en.wikipedia.org/wiki/Help:Transclusion"
            ],
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Help:Transclusion",
                "time": 1608965590841
            }
        },
        {
            "timestamp": 1608965590851,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Help:Transclusion/#1608965590466",
            "operation": "create",
            "object": {
                "pageTitle": "Help:Transclusion - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Help:Transclusion",
                "body": "Page rendering of a source page can be defined as the rendering of that source page when it is saved, which will be the same as the preview. We can call this rendering here.\r\n\r\nTransclusion rendering of a source page can be defined as the rendering of a destination page that has a source page transcluded into it; but only that part of the destination page that was transcluded from the source page. The preview of the transclusion rendering will again be identical. We can call this rendering there. ",
                "comment": "",
                "selector": {
                    "quote": "Page rendering of a source page can be defined as the rendering of that source page when it is saved, which will be the same as the preview. We can call this rendering here.\r\n\r\nTransclusion rendering of a source page can be defined as the rendering of a destination page that has a source page transcluded into it; but only that part of the destination page that was transcluded from the source page. The preview of the transclusion rendering will again be identical. We can call this rendering there. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[48]/i[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[49]",
                                "endOffset": 325
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 17715,
                                "end": 18215
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Page rendering of a source page can be defined as the rendering of that source page when it is saved, which will be the same as the preview.  We can call this rendering here.\nTransclusion rendering of a source page can be defined as the rendering of a destination page that has a source page transcluded into it; but only that part of the destination page that was transcluded from the source page. The preview of the transclusion rendering will again be identical. We can call this rendering there.\n",
                                "prefix": " be visible on the source page.\n",
                                "suffix": "There are three pairs of tags in"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T06:53:10.466Z",
                "lastEdited": "2020-12-26T06:53:10.466Z",
                "url": "https://en.wikipedia.org/wiki/Help:Transclusion/#1608965590466"
            }
        },
        {
            "timestamp": 1608966562142,
            "collection": "pages",
            "objectPk": "en.wikipedia.org/wiki/Wikipedia:Summary_style",
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Wikipedia:Summary_style",
                "fullUrl": "https://en.wikipedia.org/wiki/Wikipedia:Summary_style",
                "domain": "wikipedia.org",
                "hostname": "en.wikipedia.org",
                "fullTitle": "Wikipedia:Summary style - Wikipedia",
                "text": " Wikipedia:Summary style From Wikipedia, the free encyclopedia Jump to navigation Jump to search \"WP:SS\" redirects here. For secondary sources, see Wikipedia:No original research § Primary, secondary and tertiary sources . For stub sorting, see Wikipedia:WikiProject Stub sorting . For screenshots, see Wikipedia:Software screenshots . For the Solar System, see WP:WikiProject Solar System . \"WP:SUMMARY\" redirects here. For edit summaries, see Help:Edit summary . This page documents an English Wikipedia editing guideline . It is a generally accepted standard that editors should attempt to follow, though it is best treated with common sense , and occasional exceptions may apply. Any substantive edit to this page should reflect consensus . When in doubt, discuss first on the talk page . Shortcuts WP:SS WP:SUMMARY This page in a nutshell: Sections of long articles should be spun off into their own articles, leaving summaries in their place. Summary sections are linked to the detailed article with a {{ Main |name of detailed article}} or comparable template. To preserve links to the edit history of the moved text, the first edit summary of the new article links back to the original. World War II article in summary style World War II World War II ... was a global war that was underway by 1939 and ended in 1945 .... Chronology Main article: Timeline of World War II The start of the war is generally held to be 1 September 1939 .... Background Main article: Causes of World War II World War I radically altered the political map, with the defeat of the Central Powers .... Pre-war events Italian invasion of Ethiopia (1935) Main article: Second Italo-Abyssinian War The Second Italo Abyssinian War was a brief colonial war that began in October 1935 and ended in May 1936 .... Spanish Civil War (1936-39) Main article: Spanish Civil War Germany and Italy lent support to the Nationalist insurrection led by general Francisco Franco in Spain .... Wikipedia articles cover topics at several levels of detail: the lead contains a quick summary of the topic's most important points, and each major subtopic is detailed in its own section of the article. The length of a given Wikipedia article tends to grow as people add information to it. This does not go on forever: very long articles would cause problems and should be split . A fuller treatment of any major subtopic should go in a separate article of its own. Each subtopic or child article is a complete encyclopedic article in its own right and contains its own lead section that is quite similar to the summary in its parent article. It also contains a link back to the parent article and enough information about the broader parent subject to place the subject in context for the reader, even if this produces some duplication between the parent and child articles. The original article should contain a section with a summary of the subtopic's article as well as a link to it. This type of organization is made possible because Wikipedia is an online encyclopedia: unlike traditional paper encyclopedias, it only takes a click for readers to switch between articles, and there is no need to conserve paper by preventing duplication of content. It is advisable to develop new material in a subtopic article before summarizing it in the parent article. (An exception to this is when the subtopic is non-notable; see below.) For copyright purposes, the first edit summary of a subtopic article formed by cutting text out of a parent article should link back to the original (see WP:Copying within Wikipedia ). Templates are available to link to subtopics and to tag synchronization problems between a summary section and the article it summarizes. Contents 1 Rationale 1.1 Article size 1.2 Levels of detail 2 Technique 2.1 Naming conventions 3 When to avoid splits 3.1 Non-notable topics and relocating material 3.2 POV forks 4 Synchronization 4.1 Using excerpts for article synchronization 4.1.1 Additional markup for selectively transcluded sub-article leads 5 Other specifics 5.1 Lead section 5.2 Further reading/external links 6 Notes 7 See also 7.1 Templates Rationale [ edit ] Article size [ edit ] Main page: Wikipedia:Article size Articles over a certain size may not cover their topic in a way that is easy to find or read. Opinions vary as to what counts as an ideal length; judging the appropriate size depends on the topic and whether it easily lends itself to being split up. Size guidelines apply somewhat less to disambiguation pages and to list articles, especially if splitting them would require breaking up a sortable table. This style of organizing articles is somewhat related to news style except that it focuses on topics instead of articles. This is more helpful to the reader than a very long article that just keeps growing, eventually reaching book length. Summary style keeps the reader from being overwhelmed by too much information up front, by summarizing main points and going into more details on particular points (subtopics) in separate articles. What constitutes \"too long\" is largely based on the topic, but generally 40 kilobytes of readable prose is the starting point at which articles may be considered too long. Articles that go above this have a burden of proof that extra text is needed to efficiently cover their topics and that the extra reading time is justified. Sections that are less important for understanding the topic will tend to be lower in the article, while more important sections will tend to be higher (this is news style applied to sections). Often this is difficult to do for articles on history or that are otherwise chronologically based, unless there is some type of analysis section. However, ordering sections in this way is important because many readers will not finish reading the article. Levels of detail [ edit ] Shortcut WP:DETAIL Further information: Wikipedia:Writing better articles § Be concise Since Wikipedia, unlike the Encyclopædia Britannica , is not divided into a Macropædia , Micropædia , and concise version, we must serve all three user types in the same encyclopedia. Summary style is based on the premise that information about a topic need not all be contained in a single article since different readers have different needs: Many readers need just a quick summary of the topic's most important points (lead section). Others need a moderate amount of information on the topic's more important points (a set of multiparagraph sections). Some readers need a lot of details on one or more aspects of the topic (links to full-sized separate subarticles). The Wikipedia Glossary has an entry for parent article . The Wikipedia Glossary has an entry for child article . The parent article should have general summary information, and child articles should expand in more detail on subtopics summarized in the parent article. The child article in turn can also serve as a parent article for its own sections and subsections on the topic, and so on, until a topic is very thoroughly covered. The idea is to summarize and distribute information across related articles in a way that can serve readers who want varying amounts of details. Breakout methods should anticipate the various levels of detail that typical readers will look for. This can be thought of as layering inverted pyramids where the reader is first shown the lead section for a topic, and within its article any section may have a {{ Main |subpage name}} hatnote or similar link to a full article about the subtopic summarized in that section. For example, Yosemite National Park#History and History of the Yosemite area are two such related featured articles . Thus, by navigational choices, several different types of readers each get the amount of details they want. Technique [ edit ] Main page: Wikipedia:Splitting Longer articles are split into sections , each usually several good-sized paragraphs long. Subsectioning can increase this amount. Ideally, many of these sections will eventually provide summaries of separate articles on the subtopics covered in those sections. Each subtopic article is a complete encyclopedic article in its own right and contains its own lead section that is quite similar to the summary in the parent article. It also contains a link back to the parent article, and enough information about the broader parent subject to place the subject in context for the reader, even if this produces some duplication between the parent and child articles. In the parent article, the location of the detailed article for each subtopic is indicated at the top of the section by a link such as \"Main page: Wikipedia:Splitting \", generated by the template {{ Main |name of child article}}. Other template links include {{ Details }} and {{ Broader }}. For article pairs with a less hierarchical parent/child relationship, {{ See also }} may apply. Whenever you break up a page, please note the split (including the subtopic page names between double square brackets) in the edit summary . If possible, content should be split into logically separate articles. Long stand-alone lists may be split alphanumerically or chronologically or in another way that simplifies maintenance without regard to individual notability of the subsections (common selection criteria: lists created explicitly because most or all of the listed items do not warrant independent articles; short, complete lists of every item that is verifiably a member of the group). However, a split by subtopic is preferable. Judging the appropriate size depends on the topic, although there are rules of thumb that can be applied. In some cases, to improve the understanding of readers, complex subjects may be split into more technical and less technical articles, such as in Evolution and Introduction to evolution . Each article on Wikipedia must be able to stand alone as a self-contained unit (exceptions noted herein). For example, every article must follow the verifiability policy , which requires that all quotations and any material challenged or likely to be challenged be attributed to a reliable, published source in the form of an inline citation . This applies whether in a parent article or in a summary-style subarticle. Naming conventions [ edit ] Subarticles (not to be confused with subpages ) of a summary-style article are one of a few instances where an exception to the common-names principle for article naming is sometimes acceptable. Unless all subarticles of a summary-style article are fully compliant with the common-names principle, it is a good idea to provide a navigational template to connect the subarticles both among themselves and along with the summary-style parent article. An example of such a navigation template, used on subarticles of the Isaac Newton article, is {{ IsaacNewtonSegments }}. When to avoid splits [ edit ] Shortcut WP:AVOIDSPLIT Non-notable topics and relocating material [ edit ] Further information: Wikipedia:Notability Article and list topics must be notable, or \"worthy of notice\". Editors are cautioned not to immediately split articles if the new article would meet neither the general notability criterion nor the specific notability criteria for their topic. In this case, editors are encouraged to work on further developing the parent article first, locating coverage that applies to both the main topic and the subtopic. Through this process, it may become evident that subtopics or groups of subtopics can demonstrate their own notability, and thus can be split off into their own article. Also consider whether a concept can be cleanly trimmed, removed, or merged elsewhere on Wikipedia instead of creating a new article. Some topics are notable, but do not need their own article; see WP:NOPAGE . If only a few sentences could be written and supported by sources about the subject, that subject does not qualify for a separate article, but should instead be merged into an article about a larger topic or relevant list. It is not uncommon for editors to suggest that articles nominated for deletion instead be merged into a parent article. Note that notability guidelines only outline how suitable a topic is for its own article or list. They do not limit the content of an article or list because notability guidelines do not apply to article content . POV forks [ edit ] Further information: Wikipedia:Content forking § Article spinouts: \"Summary style\" articles In applying summary style to articles, care must be taken to avoid a POV fork (that is, a split that results in either the original article or the spinoff violating NPOV policy ), a difference in approach between the summary section and the spinoff article, etc. Note that this doesn't mean that an article treating one point of view is automatically considered a POV fork. A good example is Assassination of John F. Kennedy , which has a split or spinoff to John F. Kennedy assassination conspiracy theories . However, certain types of content can be difficult to write neutrally in independent articles, such as \"Criticism of...\" articles (see WP:CSECTION ), and if the subject is controversial it may also increase editors' maintenance burden. Where an article has lots of subtopics with their own articles, remember that the sections of the parent article need to be appropriately balanced. Do not put undue weight into one part of an article at the cost of other parts. If one subtopic has much more text than another subtopic, that may be an indication that that subtopic should have its own page, with only a summary section left on the main page. Synchronization [ edit ] Shortcut WP:SYNC Sometimes editors will add details to a parent article without adding those facts to the more detailed child article. To keep articles synchronized, editors should first add any new material to the appropriate places in the child article, and, if appropriate, summarize the material in the parent article. If the child article changes considerably without updating the parent article, the summary of the child article in the parent article will need to be rewritten to do it justice. These problems may be tagged with {{ Sync }}. [n 1] Since the lead of any article should be the best summary of the article, it can be convenient to use the subarticle's lead as the content in the summary section, with a {{ main }} hatnote pointing to the subarticle. High-level or conceptual articles (such as Philosophy ) are often composed mostly or entirely of summary sections, other than their own leads. Whether a detail is important enough to include in the lead of the detailed article is a good rule of thumb for whether it is important enough to be placed in the summary. Using excerpts for article synchronization [ edit ] Excerpts (aka selective transclusion) can be used to ensure that the content in the lead of a sub-article is perpetually synchronized with a summary-style section in its parent article. When this method is used, the citation templates for all of the references that cite the sub-article's lead must be included in sub-article's lead section. Otherwise, an undefined reference error message will appear in the parent article since the references in the body of the sub-article are not transcluded with its lead section. In order to transclude the lead of a sub-article into a section of the parent article, replace all of the content in the relevant section of the parent article with the following wikitext markup: {{ Excerpt |SUB-ARTICLE_PAGENAME}} Additional markup for selectively transcluded sub-article leads [ edit ] Per MOS:LEAD#Format of the first sentence , the first instance of the sub-article title should appear in bold in the first lead sentence of that article; this is often not desirable for a transclusion to a section of the parent article. In addition, the parent article is often wikilinked in the lead of a sub-article; when transcluded to the parent article, this wikilink will appear as bold text. The wikitext markup listed below can be used to address both of these problems. To ensure that the article title is bolded in the first sentence of the sub-article, but unbolded and wikilinked in the transclusion to the parent article, make the following replacement in the sub-article's first lead sentence: Replace '''SUB-ARTICLE_PAGENAME''' with <noinclude>'''</noinclude>{{No selflink|SUB-ARTICLE_PAGENAME}}<noinclude>'''</noinclude> If there is a wikilink to the parent article in the lead section of the sub-article, replacing the wikilink to the parent article with a {{ no selflink }} template will ensure that it is wikilinked in the sub-article's lead but not in the transclusion to the parent article. In other words: If the wikilink to the parent article is not a WP:Piped link , replace [[PARENT_ARTICLE]] with {{no selflink|PARENT_ARTICLE}} in the sub-article's lead If the wikilink to the parent article includes a pipe (e.g., this link) , replace [[PARENT_ARTICLE|Piped link wikitext]] with {{No selflink|PARENT_ARTICLE|Piped link wikitext}} in the sub-article's lead Other specifics [ edit ] Lead section [ edit ] Further information: Wikipedia:Lead section The lead section of an article is itself a summary of the article's content. For planned paper Wikipedia 1.0 , one recommendation is that the lead section of the web version will be used as the paper version of the article. Summary style and news style can help make a concise introduction that works as a standalone article. Further reading/external links [ edit ] Further information: Wikipedia:Manual_of_Style/Layout § \"See_also\"_section , and Wikipedia:Manual_of_Style/Embedded_lists § Related_topics_(navigational_lists) Summary style is a good way to give more structure to a long bibliography or list of external links. For example, the World War II summary-style article portrayed above could have a \"Further reading\" or \"External links\" section that treats the history of World War II as a whole, while a subarticle on the Pacific War could have \"External links\" containing works that deal with World War II in the Pacific region. Notes [ edit ] ^ To eliminate this maintenance burden, editors can use partial transclusion as explained at Wikipedia:Transclusion#Partial transclusion . However, discussions in 2010 highlighted issues with viewing historical renditions of the main page (the partial transclusion will be from the current subpage, which may even have been deleted). Therefore, it seems to be recommended to use this process only with consensus and when articles are rapidly evolving. In circumstances where there is consensus to delete a sub-article which has been transcluded to a parent article, the sub-article's edit history can be preserved by moving it to a sub-page of the parent article's talk page and deleting the redirect in the mainspace. See also [ edit ] Wikipedia:Article series Wikipedia:Article size Wikipedia:Broad-concept article Wikipedia:Content forking Wikipedia:Guide to writing better articles Wikipedia:Main article fixation (essay) Wikipedia:Merging Wikipedia:Naming conventions (long lists) Wikipedia:Naming conventions (common names) Wikipedia:Overcategorization Wikipedia:Splitting Special:Longpages Templates [ edit ] Template:Main , a template used at the start of a summary to point to the detailed article Template:Excerpt , a template used to transclude the lead section of the detailed article, instead of writing a summary that is essentially a duplicate Template:Split section , a cleanup message box suggesting a split Template:Summary in , a template placed on the talk page of the summarized article to make the relationship explicit to editors Template:Summarize , a template to be used when the {{ Main }} template is being used without actually providing a summary of the subarticle Template:Subarticle , a template that should be placed on the spinout article's talk page when {{ Main }} is used on an article to add a link to a spinout article Retrieved from \" https://en.wikipedia.org/w/index.php?title=Wikipedia:Summary_style&oldid=994546412 \" Categories : Wikipedia editing guidelines Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Project page Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Wikidata item Print/export Download as PDF Printable version Languages العربية Euskara فارسی हिन्दी Bahasa Indonesia Magyar 日本語 Türkçe 粵語 中文 3 more Edit links This page was last edited on 16 December 2020, at 07:45 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License ; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement Enable previews ",
                "urlTerms": [
                    "wiki",
                    "wikipedia",
                    "summary",
                    "style"
                ],
                "titleTerms": [
                    "wikipedia",
                    "summary",
                    "style"
                ]
            }
        },
        {
            "timestamp": 1608966562182,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "en.wikipedia.org/wiki/Wikipedia:Summary_style"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "en.wikipedia.org/wiki/Wikipedia:Summary_style",
                "fullUrl": "https://en.wikipedia.org/wiki/Wikipedia:Summary_style",
                "createdAt": "2020-12-26T07:09:22.171Z"
            }
        },
        {
            "timestamp": 1608966562192,
            "collection": "visits",
            "objectPk": [
                1608966562188,
                "en.wikipedia.org/wiki/Wikipedia:Summary_style"
            ],
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Wikipedia:Summary_style",
                "time": 1608966562188
            }
        },
        {
            "timestamp": 1608966562200,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Wikipedia:Summary_style/#1608966561949",
            "operation": "create",
            "object": {
                "pageTitle": "Wikipedia:Summary style - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Wikipedia:Summary_style",
                "body": "The idea is to summarize and distribute information across related articles in a way that can serve readers who want varying amounts of details. Breakout methods should anticipate the various levels of detail that typical readers will look for. ",
                "comment": "",
                "selector": {
                    "quote": "The idea is to summarize and distribute information across related articles in a way that can serve readers who want varying amounts of details. Breakout methods should anticipate the various levels of detail that typical readers will look for. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[8]",
                                "startOffset": 320,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[8]",
                                "endOffset": 565
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 7543,
                                "end": 7788
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "The idea is to summarize and distribute information across related articles in a way that can serve readers who want varying amounts of details. Breakout methods should anticipate the various levels of detail that typical readers will look for.\n",
                                "prefix": "pic is very thoroughly covered. ",
                                "suffix": "This can be thought of as layeri"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T07:09:21.949Z",
                "lastEdited": "2020-12-26T07:09:21.949Z",
                "url": "https://en.wikipedia.org/wiki/Wikipedia:Summary_style/#1608966561949"
            }
        },
        {
            "timestamp": 1608967010164,
            "collection": "pages",
            "objectPk": "en.wikipedia.org/w?gettingStartedReturn=true&title=Wikipedia%3ASummary_style",
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/w?gettingStartedReturn=true&title=Wikipedia%3ASummary_style",
                "fullUrl": "https://en.wikipedia.org/w/index.php?title=Wikipedia:Summary_style&gettingStartedReturn=true",
                "domain": "wikipedia.org",
                "hostname": "en.wikipedia.org",
                "fullTitle": "Wikipedia:Summary style - Wikipedia",
                "text": " Wikipedia:Summary style From Wikipedia, the free encyclopedia Jump to navigation Jump to search \"WP:SS\" redirects here. For secondary sources, see Wikipedia:No original research § Primary, secondary and tertiary sources . For stub sorting, see Wikipedia:WikiProject Stub sorting . For screenshots, see Wikipedia:Software screenshots . For the Solar System, see WP:WikiProject Solar System . \"WP:SUMMARY\" redirects here. For edit summaries, see Help:Edit summary . This page documents an English Wikipedia editing guideline . It is a generally accepted standard that editors should attempt to follow, though it is best treated with common sense , and occasional exceptions may apply. Any substantive edit to this page should reflect consensus . When in doubt, discuss first on the talk page . Shortcuts WP:SS WP:SUMMARY This page in a nutshell: Sections of long articles should be spun off into their own articles, leaving summaries in their place. Summary sections are linked to the detailed article with a {{ Main |name of detailed article}} or comparable template. To preserve links to the edit history of the moved text, the first edit summary of the new article links back to the original. World War II article in summary style World War II World War II ... was a global war that was underway by 1939 and ended in 1945 .... Chronology Main article: Timeline of World War II The start of the war is generally held to be 1 September 1939 .... Background Main article: Causes of World War II World War I radically altered the political map, with the defeat of the Central Powers .... Pre-war events Italian invasion of Ethiopia (1935) Main article: Second Italo-Abyssinian War The Second Italo Abyssinian War was a brief colonial war that began in October 1935 and ended in May 1936 .... Spanish Civil War (1936-39) Main article: Spanish Civil War Germany and Italy lent support to the Nationalist insurrection led by general Francisco Franco in Spain .... Wikipedia articles cover topics at several levels of detail: the lead contains a quick summary of the topic's most important points, and each major subtopic is detailed in its own section of the article. The length of a given Wikipedia article tends to grow as people add information to it. This does not go on forever: very long articles would cause problems and should be split . A fuller treatment of any major subtopic should go in a separate article of its own. Each subtopic or child article is a complete encyclopedic article in its own right and contains its own lead section that is quite similar to the summary in its parent article. It also contains a link back to the parent article and enough information about the broader parent subject to place the subject in context for the reader, even if this produces some duplication between the parent and child articles. The original article should contain a section with a summary of the subtopic's article as well as a link to it. This type of organization is made possible because Wikipedia is an online encyclopedia: unlike traditional paper encyclopedias, it only takes a click for readers to switch between articles, and there is no need to conserve paper by preventing duplication of content. It is advisable to develop new material in a subtopic article before summarizing it in the parent article. (An exception to this is when the subtopic is non-notable; see below.) For copyright purposes, the first edit summary of a subtopic article formed by cutting text out of a parent article should link back to the original (see WP:Copying within Wikipedia ). Templates are available to link to subtopics and to tag synchronization problems between a summary section and the article it summarizes. Contents 1 Rationale 1.1 Article size 1.2 Levels of detail 2 Technique 2.1 Naming conventions 3 When to avoid splits 3.1 Non-notable topics and relocating material 3.2 POV forks 4 Synchronization 4.1 Using excerpts for article synchronization 4.1.1 Additional markup for selectively transcluded sub-article leads 5 Other specifics 5.1 Lead section 5.2 Further reading/external links 6 Notes 7 See also 7.1 Templates Rationale [ edit source ] Article size [ edit source ] Main page: Wikipedia:Article size Articles over a certain size may not cover their topic in a way that is easy to find or read. Opinions vary as to what counts as an ideal length; judging the appropriate size depends on the topic and whether it easily lends itself to being split up. Size guidelines apply somewhat less to disambiguation pages and to list articles, especially if splitting them would require breaking up a sortable table. This style of organizing articles is somewhat related to news style except that it focuses on topics instead of articles. This is more helpful to the reader than a very long article that just keeps growing, eventually reaching book length. Summary style keeps the reader from being overwhelmed by too much information up front, by summarizing main points and going into more details on particular points (subtopics) in separate articles. What constitutes \"too long\" is largely based on the topic, but generally 40 kilobytes of readable prose is the starting point at which articles may be considered too long. Articles that go above this have a burden of proof that extra text is needed to efficiently cover their topics and that the extra reading time is justified. Sections that are less important for understanding the topic will tend to be lower in the article, while more important sections will tend to be higher (this is news style applied to sections). Often this is difficult to do for articles on history or that are otherwise chronologically based, unless there is some type of analysis section. However, ordering sections in this way is important because many readers will not finish reading the article. Levels of detail [ edit source ] Shortcut WP:DETAIL Further information: Wikipedia:Writing better articles § Be concise Since Wikipedia, unlike the Encyclopædia Britannica , is not divided into a Macropædia , Micropædia , and concise version, we must serve all three user types in the same encyclopedia. Summary style is based on the premise that information about a topic need not all be contained in a single article since different readers have different needs: Many readers need just a quick summary of the topic's most important points (lead section). Others need a moderate amount of information on the topic's more important points (a set of multiparagraph sections). Some readers need a lot of details on one or more aspects of the topic (links to full-sized separate subarticles). The Wikipedia Glossary has an entry for parent article . The Wikipedia Glossary has an entry for child article . The parent article should have general summary information, and child articles should expand in more detail on subtopics summarized in the parent article. The child article in turn can also serve as a parent article for its own sections and subsections on the topic, and so on, until a topic is very thoroughly covered. The idea is to summarize and distribute information across related articles in a way that can serve readers who want varying amounts of details. Breakout methods should anticipate the various levels of detail that typical readers will look for. This can be thought of as layering inverted pyramids where the reader is first shown the lead section for a topic, and within its article any section may have a {{ Main |subpage name}} hatnote or similar link to a full article about the subtopic summarized in that section. For example, Yosemite National Park#History and History of the Yosemite area are two such related featured articles . Thus, by navigational choices, several different types of readers each get the amount of details they want. Technique [ edit source ] Main page: Wikipedia:Splitting Longer articles are split into sections , each usually several good-sized paragraphs long. Subsectioning can increase this amount. Ideally, many of these sections will eventually provide summaries of separate articles on the subtopics covered in those sections. Each subtopic article is a complete encyclopedic article in its own right and contains its own lead section that is quite similar to the summary in the parent article. It also contains a link back to the parent article, and enough information about the broader parent subject to place the subject in context for the reader, even if this produces some duplication between the parent and child articles. In the parent article, the location of the detailed article for each subtopic is indicated at the top of the section by a link such as \"Main page: Wikipedia:Splitting \", generated by the template {{ Main |name of child article}}. Other template links include {{ Details }} and {{ Broader }}. For article pairs with a less hierarchical parent/child relationship, {{ See also }} may apply. Whenever you break up a page, please note the split (including the subtopic page names between double square brackets) in the edit summary . If possible, content should be split into logically separate articles. Long stand-alone lists may be split alphanumerically or chronologically or in another way that simplifies maintenance without regard to individual notability of the subsections (common selection criteria: lists created explicitly because most or all of the listed items do not warrant independent articles; short, complete lists of every item that is verifiably a member of the group). However, a split by subtopic is preferable. Judging the appropriate size depends on the topic, although there are rules of thumb that can be applied. In some cases, to improve the understanding of readers, complex subjects may be split into more technical and less technical articles, such as in Evolution and Introduction to evolution . Each article on Wikipedia must be able to stand alone as a self-contained unit (exceptions noted herein). For example, every article must follow the verifiability policy , which requires that all quotations and any material challenged or likely to be challenged be attributed to a reliable, published source in the form of an inline citation . This applies whether in a parent article or in a summary-style subarticle. Naming conventions [ edit source ] Subarticles (not to be confused with subpages ) of a summary-style article are one of a few instances where an exception to the common-names principle for article naming is sometimes acceptable. Unless all subarticles of a summary-style article are fully compliant with the common-names principle, it is a good idea to provide a navigational template to connect the subarticles both among themselves and along with the summary-style parent article. An example of such a navigation template, used on subarticles of the Isaac Newton article, is {{ IsaacNewtonSegments }}. When to avoid splits [ edit source ] Shortcut WP:AVOIDSPLIT Non-notable topics and relocating material [ edit source ] Further information: Wikipedia:Notability Article and list topics must be notable, or \"worthy of notice\". Editors are cautioned not to immediately split articles if the new article would meet neither the general notability criterion nor the specific notability criteria for their topic. In this case, editors are encouraged to work on further developing the parent article first, locating coverage that applies to both the main topic and the subtopic. Through this process, it may become evident that subtopics or groups of subtopics can demonstrate their own notability, and thus can be split off into their own article. Also consider whether a concept can be cleanly trimmed, removed, or merged elsewhere on Wikipedia instead of creating a new article. Some topics are notable, but do not need their own article; see WP:NOPAGE . If only a few sentences could be written and supported by sources about the subject, that subject does not qualify for a separate article, but should instead be merged into an article about a larger topic or relevant list. It is not uncommon for editors to suggest that articles nominated for deletion instead be merged into a parent article. Note that notability guidelines only outline how suitable a topic is for its own article or list. They do not limit the content of an article or list because notability guidelines do not apply to article content . POV forks [ edit source ] Further information: Wikipedia:Content forking § Article spinouts: \"Summary style\" articles In applying summary style to articles, care must be taken to avoid a POV fork (that is, a split that results in either the original article or the spinoff violating NPOV policy ), a difference in approach between the summary section and the spinoff article, etc. Note that this doesn't mean that an article treating one point of view is automatically considered a POV fork. A good example is Assassination of John F. Kennedy , which has a split or spinoff to John F. Kennedy assassination conspiracy theories . However, certain types of content can be difficult to write neutrally in independent articles, such as \"Criticism of...\" articles (see WP:CSECTION ), and if the subject is controversial it may also increase editors' maintenance burden. Where an article has lots of subtopics with their own articles, remember that the sections of the parent article need to be appropriately balanced. Do not put undue weight into one part of an article at the cost of other parts. If one subtopic has much more text than another subtopic, that may be an indication that that subtopic should have its own page, with only a summary section left on the main page. Synchronization [ edit source ] Shortcut WP:SYNC Sometimes editors will add details to a parent article without adding those facts to the more detailed child article. To keep articles synchronized, editors should first add any new material to the appropriate places in the child article, and, if appropriate, summarize the material in the parent article. If the child article changes considerably without updating the parent article, the summary of the child article in the parent article will need to be rewritten to do it justice. These problems may be tagged with {{ Sync }}. [n 1] Since the lead of any article should be the best summary of the article, it can be convenient to use the subarticle's lead as the content in the summary section, with a {{ main }} hatnote pointing to the subarticle. High-level or conceptual articles (such as Philosophy ) are often composed mostly or entirely of summary sections, other than their own leads. Whether a detail is important enough to include in the lead of the detailed article is a good rule of thumb for whether it is important enough to be placed in the summary. Using excerpts for article synchronization [ edit source ] Excerpts (aka selective transclusion) can be used to ensure that the content in the lead of a sub-article is perpetually synchronized with a summary-style section in its parent article. When this method is used, the citation templates for all of the references that cite the sub-article's lead must be included in sub-article's lead section. Otherwise, an undefined reference error message will appear in the parent article since the references in the body of the sub-article are not transcluded with its lead section. In order to transclude the lead of a sub-article into a section of the parent article, replace all of the content in the relevant section of the parent article with the following wikitext markup: {{ Excerpt |SUB-ARTICLE_PAGENAME}} Additional markup for selectively transcluded sub-article leads [ edit source ] Per MOS:LEAD#Format of the first sentence , the first instance of the sub-article title should appear in bold in the first lead sentence of that article; this is often not desirable for a transclusion to a section of the parent article. In addition, the parent article is often wikilinked in the lead of a sub-article; when transcluded to the parent article, this wikilink will appear as bold text. The wikitext markup listed below can be used to address both of these problems. To ensure that the article title is bolded in the first sentence of the sub-article, but unbolded and wikilinked in the transclusion to the parent article, make the following replacement in the sub-article's first lead sentence: Replace '''SUB-ARTICLE_PAGENAME''' with <noinclude>'''</noinclude>{{No selflink|SUB-ARTICLE_PAGENAME}}<noinclude>'''</noinclude> If there is a wikilink to the parent article in the lead section of the sub-article, replacing the wikilink to the parent article with a {{ no selflink }} template will ensure that it is wikilinked in the sub-article's lead but not in the transclusion to the parent article. In other words: If the wikilink to the parent article is not a WP:Piped link , replace [[PARENT_ARTICLE]] with {{no selflink|PARENT_ARTICLE}} in the sub-article's lead If the wikilink to the parent article includes a pipe (e.g., this link) , replace [[PARENT_ARTICLE|Piped link wikitext]] with {{No selflink|PARENT_ARTICLE|Piped link wikitext}} in the sub-article's lead Other specifics [ edit source ] Lead section [ edit source ] Further information: Wikipedia:Lead section The lead section of an article is itself a summary of the article's content. For planned paper Wikipedia 1.0 , one recommendation is that the lead section of the web version will be used as the paper version of the article. Summary style and news style can help make a concise introduction that works as a standalone article. Further reading/external links [ edit source ] Further information: Wikipedia:Manual_of_Style/Layout § \"See_also\"_section , and Wikipedia:Manual_of_Style/Embedded_lists § Related_topics_(navigational_lists) Summary style is a good way to give more structure to a long bibliography or list of external links. For example, the World War II summary-style article portrayed above could have a \"Further reading\" or \"External links\" section that treats the history of World War II as a whole, while a subarticle on the Pacific War could have \"External links\" containing works that deal with World War II in the Pacific region. Notes [ edit source ] ^ To eliminate this maintenance burden, editors can use partial transclusion as explained at Wikipedia:Transclusion#Partial transclusion . However, discussions in 2010 highlighted issues with viewing historical renditions of the main page (the partial transclusion will be from the current subpage, which may even have been deleted). Therefore, it seems to be recommended to use this process only with consensus and when articles are rapidly evolving. In circumstances where there is consensus to delete a sub-article which has been transcluded to a parent article, the sub-article's edit history can be preserved by moving it to a sub-page of the parent article's talk page and deleting the redirect in the mainspace. See also [ edit source ] Wikipedia:Article series Wikipedia:Article size Wikipedia:Broad-concept article Wikipedia:Content forking Wikipedia:Guide to writing better articles Wikipedia:Main article fixation (essay) Wikipedia:Merging Wikipedia:Naming conventions (long lists) Wikipedia:Naming conventions (common names) Wikipedia:Overcategorization Wikipedia:Splitting Special:Longpages Templates [ edit source ] Template:Main , a template used at the start of a summary to point to the detailed article Template:Excerpt , a template used to transclude the lead section of the detailed article, instead of writing a summary that is essentially a duplicate Template:Split section , a cleanup message box suggesting a split Template:Summary in , a template placed on the talk page of the summarized article to make the relationship explicit to editors Template:Summarize , a template to be used when the {{ Main }} template is being used without actually providing a summary of the subarticle Template:Subarticle , a template that should be placed on the spinout article's talk page when {{ Main }} is used on an article to add a link to a spinout article Retrieved from \" https://en.wikipedia.org/w/index.php?title=Wikipedia:Summary_style&oldid=994546412 \" Categories : Wikipedia editing guidelines Navigation menu Personal tools Eskabore777 Alerts (0) Notice (1) Talk Sandbox Preferences Beta Watchlist Contributions Log out Namespaces Project page Talk Variants Views Read Edit source View history Watch More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Wikidata item Print/export Download as PDF Printable version Languages العربية Euskara فارسی हिन्दी Bahasa Indonesia Magyar 日本語 Türkçe 粵語 中文 3 more Edit links This page was last edited on 16 December 2020, at 07:45 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License ; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement Enable previews ",
                "urlTerms": [],
                "titleTerms": [
                    "wikipedia",
                    "summary",
                    "style"
                ]
            }
        },
        {
            "timestamp": 1608967010208,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "en.wikipedia.org/w?gettingStartedReturn=true&title=Wikipedia%3ASummary_style"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "en.wikipedia.org/w?gettingStartedReturn=true&title=Wikipedia%3ASummary_style",
                "fullUrl": "https://en.wikipedia.org/w/index.php?title=Wikipedia:Summary_style&gettingStartedReturn=true",
                "createdAt": "2020-12-26T07:16:50.195Z"
            }
        },
        {
            "timestamp": 1608967010221,
            "collection": "visits",
            "objectPk": [
                1608967010216,
                "en.wikipedia.org/w?gettingStartedReturn=true&title=Wikipedia%3ASummary_style"
            ],
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/w?gettingStartedReturn=true&title=Wikipedia%3ASummary_style",
                "time": 1608967010216
            }
        },
        {
            "timestamp": 1608967010230,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/w/index.php?title=Wikipedia:Summary_style&gettingStartedReturn=true/#1608967009988",
            "operation": "create",
            "object": {
                "pageTitle": "Wikipedia:Summary style - Wikipedia",
                "pageUrl": "en.wikipedia.org/w?gettingStartedReturn=true&title=Wikipedia%3ASummary_style",
                "body": "Since Wikipedia, unlike the Encyclopædia Britannica, is not divided into a Macropædia, Micropædia, and concise version, we must serve all three user types in the same encyclopedia. Summary style is based on the premise that information about a topic need not all be contained in a single article since different readers have different needs:\r\n\r\n    Many readers need just a quick summary of the topic's most important points (lead section).\r\n    Others need a moderate amount of information on the topic's more important points (a set of multiparagraph sections).\r\n    Some readers need a lot of details on one or more aspects of the topic (links to full-sized separate subarticles).\r\n\r\n\t\r\nThe Wikipedia Glossary has an entry for parent article.\r\n\t\r\nThe Wikipedia Glossary has an entry for child article.\r\n\r\nThe parent article should have general summary information, and child articles should expand in more detail on subtopics summarized in the parent article. The child article in turn can also serve as a parent article for its own sections and subsections on the topic, and so on, until a topic is very thoroughly covered. The idea is to summarize and distribute information across related articles in a way that can serve readers who want varying amounts of details. Breakout methods should anticipate the various levels of detail that typical readers will look for. ",
                "comment": "",
                "selector": {
                    "quote": "Since Wikipedia, unlike the Encyclopædia Britannica, is not divided into a Macropædia, Micropædia, and concise version, we must serve all three user types in the same encyclopedia. Summary style is based on the premise that information about a topic need not all be contained in a single article since different readers have different needs:\r\n\r\n    Many readers need just a quick summary of the topic's most important points (lead section).\r\n    Others need a moderate amount of information on the topic's more important points (a set of multiparagraph sections).\r\n    Some readers need a lot of details on one or more aspects of the topic (links to full-sized separate subarticles).\r\n\r\n\t\r\nThe Wikipedia Glossary has an entry for parent article.\r\n\t\r\nThe Wikipedia Glossary has an entry for child article.\r\n\r\nThe parent article should have general summary information, and child articles should expand in more detail on subtopics summarized in the parent article. The child article in turn can also serve as a parent article for its own sections and subsections on the topic, and so on, until a topic is very thoroughly covered. The idea is to summarize and distribute information across related articles in a way that can serve readers who want varying amounts of details. Breakout methods should anticipate the various levels of detail that typical readers will look for. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[7]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[8]",
                                "endOffset": 565
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 6456,
                                "end": 7809
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Since Wikipedia, unlike the Encyclopædia Britannica, is not divided into a Macropædia, Micropædia, and concise version,  we must serve all three user types in the same encyclopedia. Summary style is based on the premise that information about a topic need not all be contained in a single article since different readers have different needs:\n\nMany readers need just a quick summary of the topic's most important points (lead section).\nOthers need a moderate amount of information on the topic's more important points (a set of multiparagraph sections).\nSome readers need a lot of details on one or more aspects of the topic (links to full-sized separate subarticles).\n\n\n\nThe Wikipedia Glossary has an entry for parent article.\n\n\n\n\nThe Wikipedia Glossary has an entry for child article.\n\nThe parent article should have general summary information, and child articles should expand in more detail on subtopics summarized in the parent article. The child article in turn can also serve as a parent article for its own sections and subsections on the topic, and so on, until a topic is very thoroughly covered. The idea is to summarize and distribute information across related articles in a way that can serve readers who want varying amounts of details. Breakout methods should anticipate the various levels of detail that typical readers will look for.\n",
                                "prefix": "ng better articles § Be concise\n",
                                "suffix": "This can be thought of as layeri"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T07:16:49.988Z",
                "lastEdited": "2020-12-26T07:16:49.988Z",
                "url": "https://en.wikipedia.org/w/index.php?title=Wikipedia:Summary_style&gettingStartedReturn=true/#1608967009988"
            }
        },
        {
            "timestamp": 1608967450444,
            "collection": "pages",
            "objectPk": "en.wikipedia.org/wiki/Wikipedia:Navigation_template",
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Wikipedia:Navigation_template",
                "fullUrl": "https://en.wikipedia.org/wiki/Wikipedia:Navigation_template",
                "domain": "wikipedia.org",
                "hostname": "en.wikipedia.org",
                "fullTitle": "Wikipedia:Navigation template - Wikipedia",
                "text": " Wikipedia:Navigation template From Wikipedia, the free encyclopedia (Redirected from Wikipedia:NAV ) Jump to navigation Jump to search For the applicable guideline, see Wikipedia:Categories, lists, and navigation templates § Navigation templates . \"WP:NAV\" redirects here. You may have been looking for Wikipedia:Tools/Navigation popups , or Wikipedia:Polling is not a substitute for discussion . This is an explanatory supplement to the Wikipedia:Categories, lists, and navigation templates guideline. This page is intended to provide additional information about concepts in the page(s) it supplements. This page is not one of Wikipedia's policies or guidelines , as it has not been thoroughly vetted by the community . Shortcut WP:NAV This page in a nutshell: A navigation template is a template that links between existing articles belonging to the same topic on English Wikipedia. There are two types of navigation templates: navigation boxes, or navboxes, and sidebars. Linking and page manipulation Linking and diffs [hide] URLs Links Orphans Interlanguage links Interwiki linking Shortcuts External links External link icons Link color Colon trick Pipe trick Self links What links here Linksearch Manual of Style on linking Navigation templates Hatnotes Template index for links Diffs Simplest diff guide Simple diff and link guide Complete diff and link guide Categorization [show] Category Categorization guideline Classification Container category FAQ for categorization FAQ for categories Categories, lists, and navigation templates Categorization of people By year By ethnicity, gender, religion and sexuality Redirect categories User categories Overcategorization User categories Template index for categories Moving and redirecting [show] How to move a page for beginners Redirects Moving a page Requested moves How to fix cut-and-paste moves Moving files to Commons Userfication Template index for moving Template index for redirects Merging [show] Merging Proposed article mergers Requests for history merge Merge and delete? Merge what? Delete or merge? Template index for merging WikiProject Merge Splitting [show] Splitting Template index for splitting Importing and copying [show] How to import articles Requests for page importation Import Export Copying within Wikipedia Protecting [show] Protection Protection policy High-risk templates Requests for page protection Rough guide to semi-protection Additional [show] How to create a page Article creation Editing Deletion process v t e A navigation template is a grouping of links used in multiple related articles to facilitate navigation between those articles. Editing of a navigation template is done in a central place, the template page. There are two main varieties of navigation template: navigation boxes (or navboxes), designed to sit at the very bottom of articles, and sidebars, designed to sit at the side of the article text. The two are complementary and either or both may be appropriate in different situations. The usual way to create navigation templates is to use the {{ navbox }} or {{ sidebar }} master templates. This simplifies the process of creating a functional and consistent template. Navboxes are categorized under Category:Navigational boxes . Some WikiProjects maintain a list of their navigation templates. Contents 1 Types 2 Properties 2.1 Navigation templates provide navigation within Wikipedia 2.2 Navigation templates provide navigation between existing articles 2.3 Navigation templates provide navigation between related articles 2.4 Navigation templates are not arbitrarily decorative 3 Advantages 4 Alternatives 5 Template limits 6 See also Types The two main types of navigation template are navboxes and sidebars. The two serve similar purposes: to allow related subjects to link to each other easily in a consistent manner. Navboxes are footer templates that sit below the standard article appendices and are laid out horizontally. They are created using the {{ navbox }} template. An example navbox template is shown below: hide v t e Named sapphires Bismarck Sapphire Necklace Black Star of Queensland Hall Sapphire and Diamond Necklace James J. Hill Sapphire Logan Sapphire Ruspoli Sapphire St Edward's Sapphire The Star of Adam Star of Artaban Star of Asia Star of Bombay Star of India Stuart Sapphire Related topics List of sapphires by size · List of individual gemstones Geodesy Fundamentals [show] Geodesy Geodynamics Geomatics History Concepts [show] Geographical distance Geoid Figure of the Earth ( Earth radius and Earth's circumference ) Geodetic datum Geodesic Geographic coordinate system Horizontal position representation Latitude / Longitude Map projection Reference ellipsoid Satellite geodesy Spatial reference system Spatial relations Technologies [show] Global Nav. Sat. Systems (GNSSs) Global Pos. System (GPS) GLONASS (Russia) BeiDou (BDS) (China) Galileo (Europe) NAVIC (India) Quasi-Zenith Sat. Sys. (QZSS) (Japan) Discrete Global Grid and Geocoding Standards (history) [show] NGVD 29 Sea Level Datum 1929 OSGB36 Ordnance Survey Great Britain 1936 SK-42 Systema Koordinat 1942 goda ED50 European Datum 1950 SAD69 South American Datum 1969 GRS 80 Geodetic Reference System 1980 ISO 6709 Geographic point coord. 1983 NAD 83 North American Datum 1983 WGS 84 World Geodetic System 1984 NAVD 88 N. American Vertical Datum 1988 ETRS89 European Terrestrial Ref. Sys. 1989 GCJ-02 Chinese obfuscated datum 2002 Geo URI Internet link to a point 2010 International Terrestrial Reference System Spatial Reference System Identifier (SRID) Universal Transverse Mercator (UTM) v t e Sidebars sit alongside content, in the same manner as infoboxes , and are predominantly laid out vertically. They are created using the {{ sidebar }} template. An example sidebar is shown to the right: The two types are used interchangeably, and either or both may be appropriate in different circumstances. The primary differences between the two are: Navboxes are laid out horizontally, and so work best for longer lists of links in a small number of sub-categories. As they are placed at the very bottom of articles, they are better for broader lists of links than would be appropriate in a sidebar. Articles often have more than one navbox and content may overlap to a degree: nevertheless, not everything needs a navbox , so navbox templates should only be created when they would be genuinely useful as navigational tools. Sidebars are laid out predominantly vertically, and are placed relatively prominently in the body of articles alongside the text. This makes them useful for smaller amounts of directly relevant links. Tangential information should be kept out of sidebars. Few articles have more than one sidebar. Properties Shortcut WP:NAV-WITHIN The style of any navigation template depends on its articles, how they are most intuitively presented, and previously established convention. Navigation templates provide navigation within Wikipedia They are intended to link articles to each other. That is, every article listed on a particular navigation template generally has the template placed on its page. The goal is not to cram as many related articles as possible into one space. Ask yourself, does this help the reader in reading up on related topics? Take any two articles in the template. Would a reader really want to go from A to B? They should be kept small in size as a large template has limited navigation value. For navigating among many articles, consider: Split them into multiple, smaller templates on each sub-topic. For example, {{ EMD diesels }} lists all models of diesel locomotives built by one manufacturer, but is too large to be transcluded on each of their articles. Instead, the individual sections of {{ EMD diesels }} were split out into their own templates: {{ EMD GPs }}, {{ EMD SDs }}, etc. Do the above with only one template using ParserFunctions . Link only the immediately related articles while hiding the rest, like in the case of Johnny Cash . Avoid repeating links to the same article within a template. They should not be too small. A navigation template with fewer than a handful of links can easily be replaced by \"See also\" sections, or relevant {{ main article }} and {{ see also }} links within the articles' sections. (See essays \" Not everything needs a navbox and \" A navbox on every page \".) Navigation templates do not provide external links to other websites. Navigation templates provide navigation between existing articles Shortcut WP:EXISTING Red links and redirects should normally be avoided unless they are very likely to be developed into articles. Red links can be retained in navigation templates that represent a well-defined and complete set of data (geographic divisions, annual events, filmographies, etc.), where deleting red links would leave an incomplete and misleading result. Even then, editors are encouraged to write the article first . Unlinked text should be avoided. Note: In navigation boxes about musical ensembles, it may be appropriate to list all of the members of the ensemble, to avoid the perception that the ensemble is a solo act, provided that at least one member of the ensemble is notable. Navigation templates provide navigation between related articles If the articles are not established as related by reliable sources in the actual articles, then it is probably not a good idea to interlink them. For complex topics in science, technology, history, etc., a navigation box can provide a comprehensive introduction to a topic. For example, {{ Wind power }} links to subsidiary and supporting topics that provide background and context necessary for understanding the main Wind power article. While the main Wind power article already contains inline links to the subsidiary articles, the subsidiary articles themselves are smaller and their prose may not place them into the overall context with each other. Editors who work on the subsidiary articles in isolation may be unaware of this context. The navigation template provides an easy way for the subsidiary articles, even when they begin as stubs, to instantly inherit the conceptual structure of the main article. Navigation templates are not arbitrarily decorative See also: Wikipedia:Manual of Style/Icons There should be justification for a template to deviate from the colors and styles contained in MediaWiki:Common.css and MediaWiki:Vector.css (and the other skin.css pages). There are two basic layouts: On the right side of page for example {{ History of China }}. For meta-template, see {{ sidebar }} Footer boxes for example {{ Health in China }}, designed to appear at the bottom of each article, stacked with other similar templates. See also: Wikipedia:Footers for information on placement For footer boxes, {{ Navbox }} is the standard. Existing hard-coded collapsible tables or NavFrames should be converted to {{ Navbox }} if possible. This standardizes the look and eases future maintenance. The width of footer boxes should be 100% unless the convention for that type of article is otherwise. It looks inconsistent if multiple boxes in the same article have varying widths. Advantages See also: Wikipedia:A navbox on every page § Benefits of navboxes ; and Wikipedia:Categories, lists, and navigation templates § Advantages Advantages of using navigation templates rather than listing all the links under \" See also \" sections include: reduction of clutter in that area of the article before \"References\" and \"External links\", compactness of the template compared to a standard list or table, in the case of many links, if the most immediately related links are kept under \"See also\", the reader has a better idea of scope, less directly related links are out of the way or in some cases hidden by default, ease of maintenance in updating the template as articles get created or deleted, aesthetically pleasing appearance to many users, new articles in a subject area immediately gain the basic link structure of existing related articles, eliminating the need for many editors to individually build up their own links and rewrite background material. when a new article or an older article that was orphaned is placed in a navbox, the page instantly has a large number of links to it Alternatives In certain cases, there are alternatives preferable over the creation of a new navigation template. If the group of articles overlaps significantly with an existing category or stand-alone list , consider adding a link to one of these to the see also section . For a series of articles whose only shared characteristic is that they hold the same position or title, such as peerage or world champion sporting titles, consider using {{ succession box }}. Variant templates for persons who have held several notable offices are discussed at Template talk:Succession box . For relating articles across different categories in a logical sequence, use a succession template . Use one of these Hatnotes : {{ Broader }}, {{ Further }} or {{ Main }}. Create an outline : a hierarchical list. Template limits Main page: Help:Templates § Template limits There are limits to the number of templates an article may have. When a page exceeds this limit it may look fine in preview but, after the edit is saved, one or more footer navboxes display as wikilinks to the now excess navboxes (for example, displaying a link to \"Template:Navbox\" rather than the Navbox template itself). Solutions for this problem include (a) removing a template, and (b) setting up the footer navboxes so the least important one becomes the \"extra\" navbox (the one the reader will have to navigate to a separate page to in order to view). See also Wikipedia:Template namespace for an introduction to templates Wikipedia:Requested templates for help in editing templates Wikipedia:Categories, lists, and navigation templates , for an actual guideline on the subject Wikipedia:Template index , for other types of templates Wikipedia:Manual of Style/Infoboxes Wikipedia:Article series , related information Wikipedia:Series templates , related information Wikipedia:A navbox on every page , an essay Wikipedia:Not everything needs a navbox , another essay Wikipedia:Navigational boxes redirects here; to view the historical archive, see Wikipedia:Navigational boxes (archive) Wikipedia:Redirect#Bypass redirects in navigational templates Wikipedia:WikiProject Navigation templates {{ Quicktemplates }}, a table of templates {{ Wikipedia editor navigation }}, an amalgamation of navboxes Navigation templates comparison view talk edit Collapsible Header color Image Groups Style (body) parameter/s Examples {{ Navbox }} collapsible navbox Left/right of body Yes Yes {{ Solar System }} {{ Governance of Greater London }} {{ Navbox with collapsible groups }} collapsible navbox Left/right of body and/or in each list Yes Yes {{ Tetrapodomorpha }} {{ Navbox with columns }} collapsible navbox Left/right of columns No Yes {{ Current U.S. Senators }} {{ Historical regions of the Czech Republic }} Collapsible attributes Type CSS classes JavaScript Collapses when Custom initial state Nesting Collapsible tables collapsible Defined in Common.js 2 or more autocollapse on page Yes Yes show v t e Wikipedia templates Main namespace General Cleanup Verifiability and sources Disputes Hatnotes Infoboxes Links External link templates Linking country articles Lists Main page Section Sources of articles Quick reference Standard boxes Stub types Translation Other namespaces Compact TOC Category File Talk Template User Userboxes User talk Wikipedia WikiProject banners All namespaces Deletion ( Speedy ) Formatting Maintenance Merging Moving Requested Navigation Redirect pages Functional index Language codes Splitting Wikimedia sister projects Navboxes with templates Archive Articles for deletion Birth, death and age Button Category header Citation and verifiability Citation Style 1 Deletion review Editnotice Hatnotes Help desk Inline cleanup Introduction cleanup IPA Math Notice and warnings Organization infoboxes Proposed article mergers Protection Quotation Redirects Search Semantics Speedy deletion Notices String-handling Sup and sub-related Top icon Transwiki maintenance Unicode User talk pages User noticeboard notices Userboxes User rights Userspace linking Userspace Disclaimers Wikibreak WikiLove Inline images Wikipedia icons Discussion icons Comment icons Emoji Related topics Template documentation Examples of templates Maintenance template removal Requested templates WikiProject Templates Template help Template namespace Search Category Retrieved from \" https://en.wikipedia.org/w/index.php?title=Wikipedia:Navigation_template&oldid=978175880 \" Categories : Wikipedia supplemental pages Wikipedia essays about templates Navigational boxes Wikipedia template help Navigation menu Personal tools Eskabore777 Alerts (0) Notice (1) Talk Sandbox Preferences Beta Watchlist Contributions Log out Namespaces Project page Talk Variants Views Read View source View history Watch More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Wikidata item Print/export Download as PDF Printable version Languages Afrikaans العربية Català Čeština Dansk Deutsch Español فارسی Français 한국어 Italiano Lëtzebuergesch Македонски Bahasa Melayu 日本語 Polski Português Русский Slovenščina Srpskohrvatski / српскохрватски ไทย Українська Vèneto 中文 15 more Edit links This page was last edited on 13 September 2020, at 10:13 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License ; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement Enable previews ",
                "urlTerms": [
                    "wiki",
                    "wikipedia",
                    "navigation",
                    "template"
                ],
                "titleTerms": [
                    "wikipedia",
                    "navigation",
                    "template"
                ]
            }
        },
        {
            "timestamp": 1608967450483,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "en.wikipedia.org/wiki/Wikipedia:Navigation_template"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "en.wikipedia.org/wiki/Wikipedia:Navigation_template",
                "fullUrl": "https://en.wikipedia.org/wiki/Wikipedia:Navigation_template",
                "createdAt": "2020-12-26T07:24:10.473Z"
            }
        },
        {
            "timestamp": 1608967450494,
            "collection": "visits",
            "objectPk": [
                1608967450490,
                "en.wikipedia.org/wiki/Wikipedia:Navigation_template"
            ],
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Wikipedia:Navigation_template",
                "time": 1608967450490
            }
        },
        {
            "timestamp": 1608967450502,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Wikipedia:Navigation_template/#1608967450247",
            "operation": "create",
            "object": {
                "pageTitle": "Wikipedia:Navigation template - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Wikipedia:Navigation_template",
                "body": "Types\r\n\r\nThe two main types of navigation template are navboxes and sidebars. The two serve similar purposes: to allow related subjects to link to each other easily in a consistent manner.\r\n\r\n    Navboxes are footer templates that sit below the standard article appendices and are laid out horizontally. They are created using the {{navbox}} template. An example navbox template is shown below:",
                "comment": "",
                "selector": {
                    "quote": "Types\r\n\r\nThe two main types of navigation template are navboxes and sidebars. The two serve similar purposes: to allow related subjects to link to each other easily in a consistent manner.\r\n\r\n    Navboxes are footer templates that sit below the standard article appendices and are laid out horizontally. They are created using the {{navbox}} template. An example navbox template is shown below:",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/h2[1]/span[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/ul[1]/li[1]",
                                "endOffset": 198
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 4599,
                                "end": 4984
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Types\nThe two main types of navigation template are navboxes and sidebars. The two serve similar purposes: to allow related subjects to link to each other easily in a consistent manner.\n\nNavboxes are footer templates that sit below the standard article appendices and are laid out horizontally. They are created using the {{navbox}} template. An example navbox template is shown below:",
                                "prefix": "5 Template limits\n6 See also\n\n\n\n",
                                "suffix": "\nhidevteNamed sapphires\nBismarck"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T07:24:10.247Z",
                "lastEdited": "2020-12-26T07:24:10.247Z",
                "url": "https://en.wikipedia.org/wiki/Wikipedia:Navigation_template/#1608967450247"
            }
        },
        {
            "timestamp": 1608967455609,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Wikipedia:Navigation_template/#1608967455561",
            "operation": "create",
            "object": {
                "pageTitle": "Wikipedia:Navigation template - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Wikipedia:Navigation_template",
                "body": "    Sidebars sit alongside content, in the same manner as infoboxes, and are predominantly laid out vertically. They are created using the {{sidebar}} template. An example sidebar is shown to the right:\r\n\r\n\r\nThe two types are used interchangeably, and either or both may be appropriate in different circumstances. The primary differences between the two are:\r\n\r\n    Navboxes are laid out horizontally, and so work best for longer lists of links in a small number of sub-categories. As they are placed at the very bottom of articles, they are better for broader lists of links than would be appropriate in a sidebar. Articles often have more than one navbox and content may overlap to a degree: nevertheless, not everything needs a navbox, so navbox templates should only be created when they would be genuinely useful as navigational tools.\r\n    Sidebars are laid out predominantly vertically, and are placed relatively prominently in the body of articles alongside the text. This makes them useful for smaller amounts of directly relevant links. Tangential information should be kept out of sidebars. Few articles have more than one sidebar.",
                "comment": "",
                "selector": {
                    "quote": "    Sidebars sit alongside content, in the same manner as infoboxes, and are predominantly laid out vertically. They are created using the {{sidebar}} template. An example sidebar is shown to the right:\r\n\r\n\r\nThe two types are used interchangeably, and either or both may be appropriate in different circumstances. The primary differences between the two are:\r\n\r\n    Navboxes are laid out horizontally, and so work best for longer lists of links in a small number of sub-categories. As they are placed at the very bottom of articles, they are better for broader lists of links than would be appropriate in a sidebar. Articles often have more than one navbox and content may overlap to a degree: nevertheless, not everything needs a navbox, so navbox templates should only be created when they would be genuinely useful as navigational tools.\r\n    Sidebars are laid out predominantly vertically, and are placed relatively prominently in the body of articles alongside the text. This makes them useful for smaller amounts of directly relevant links. Tangential information should be kept out of sidebars. Few articles have more than one sidebar.",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/ul[2]/li[1]/i[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/ul[3]/li[2]",
                                "endOffset": 296
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 6551,
                                "end": 7674
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Sidebars sit alongside content, in the same manner as infoboxes, and are predominantly laid out vertically. They are created using the {{sidebar}} template. An example sidebar is shown to the right:\n\nThe two types are used interchangeably, and either or both may be appropriate in different circumstances. The primary differences between the two are:\n\nNavboxes are laid out horizontally, and so work best for longer lists of links in a small number of sub-categories. As they are placed at the very bottom of articles, they are better for broader lists of links than would be appropriate in a sidebar. Articles often have more than one navbox and content may overlap to a degree: nevertheless, not everything needs a navbox, so navbox templates should only be created when they would be genuinely useful as navigational tools.\nSidebars are laid out predominantly vertically, and are placed relatively prominently in the body of articles alongside the text. This makes them useful for smaller amounts of directly relevant links. Tangential information should be kept out of sidebars. Few articles have more than one sidebar.",
                                "prefix": "l Transverse Mercator (UTM)\nvte\n",
                                "suffix": "\nProperties\n.mw-parser-output .m"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T07:24:15.561Z",
                "lastEdited": "2020-12-26T07:24:15.561Z",
                "url": "https://en.wikipedia.org/wiki/Wikipedia:Navigation_template/#1608967455561"
            }
        },
        {
            "timestamp": 1608967510163,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Wikipedia:Navigation_template/#1608967510135",
            "operation": "create",
            "object": {
                "pageTitle": "Wikipedia:Navigation template - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Wikipedia:Navigation_template",
                "body": "A navigation template is a grouping of links used in multiple related articles to facilitate navigation between those articles. Editing of a navigation template is done in a central place, the template page.\r\n\r\nThere are two main varieties of navigation template: navigation boxes (or navboxes), designed to sit at the very bottom of articles, and sidebars, designed to sit at the side of the article text. The two are complementary and either or both may be appropriate in different situations. ",
                "comment": "",
                "selector": {
                    "quote": "A navigation template is a grouping of links used in multiple related articles to facilitate navigation between those articles. Editing of a navigation template is done in a central place, the template page.\r\n\r\nThere are two main varieties of navigation template: navigation boxes (or navboxes), designed to sit at the very bottom of articles, and sidebars, designed to sit at the side of the article text. The two are complementary and either or both may be appropriate in different situations. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[2]",
                                "endOffset": 285
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 3449,
                                "end": 3942
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "A navigation template is a grouping of links used in multiple related articles to facilitate navigation between those articles. Editing of a navigation template is done in a central place, the template page.\nThere are two main varieties of navigation template: navigation boxes (or navboxes), designed to sit at the very bottom of articles, and sidebars, designed to sit at the side of the article text. The two are complementary and either or both may be appropriate in different situations.\n",
                                "prefix": "ign:left;margin-right:0.5em}vte\n",
                                "suffix": "The usual way to create navigati"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T07:25:10.136Z",
                "lastEdited": "2020-12-26T07:25:10.136Z",
                "url": "https://en.wikipedia.org/wiki/Wikipedia:Navigation_template/#1608967510135"
            }
        },
        {
            "timestamp": 1608968062159,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Help:Transclusion/#1608968062131",
            "operation": "create",
            "object": {
                "pageTitle": "Help:Transclusion - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Help:Transclusion",
                "body": "To transclude any source page (within a single MediaWiki project, such as en:Wikipedia), include the following code in the target page:\r\n\r\n{{SOMEPAGE}}\r\n\r\nWhenever the target page A with this code is rendered, the engine will include in that place not the code itself, but the entire content of the source page B, SOMEPAGE. The top row shows what the target page renders as, while the bottom row shows the code. Note: foo will not be highlighted nor boxed on the target page.\r\nTransclusion-multiple-foo.svg\r\n\r\nFor example, you might decide to place a welcome message on every newcomer's talk page.\r\n\r\nTransclusion creates a \"live\" link between the template page and the target page(s) upon which the template's contents should appear. When the template is edited, the rendering of that template on the target pages is updated as well. For example, you create a (template) page in Wikipedia with your home mailing address and then transclude that template not only on your page, but all your friends' pages, too. Later, after moving to a new house, you then update your address template and the new address will automatically appear on all your friends' pages.\r\n\r\nThere are further simple examples at mw:Transclusion.\r\n\r\nOn the other hand, breaking existing transclusions in a template is called breakage. ",
                "comment": "",
                "selector": {
                    "quote": "To transclude any source page (within a single MediaWiki project, such as en:Wikipedia), include the following code in the target page:\r\n\r\n{{SOMEPAGE}}\r\n\r\nWhenever the target page A with this code is rendered, the engine will include in that place not the code itself, but the entire content of the source page B, SOMEPAGE. The top row shows what the target page renders as, while the bottom row shows the code. Note: foo will not be highlighted nor boxed on the target page.\r\nTransclusion-multiple-foo.svg\r\n\r\nFor example, you might decide to place a welcome message on every newcomer's talk page.\r\n\r\nTransclusion creates a \"live\" link between the template page and the target page(s) upon which the template's contents should appear. When the template is edited, the rendering of that template on the target pages is updated as well. For example, you create a (template) page in Wikipedia with your home mailing address and then transclude that template not only on your page, but all your friends' pages, too. Later, after moving to a new house, you then update your address template and the new address will automatically appear on all your friends' pages.\r\n\r\nThere are further simple examples at mw:Transclusion.\r\n\r\nOn the other hand, breaking existing transclusions in a template is called breakage. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[6]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[12]",
                                "endOffset": 85
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 3996,
                                "end": 5256
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "To transclude any source page (within a single MediaWiki project, such as en:Wikipedia), include the following code in the target page: \n{{SOMEPAGE}}\nWhenever the target page A with this code is rendered, the engine will include in that place not the code itself, but the entire content of the source page B, SOMEPAGE.  The top row shows what the target page renders as, while the bottom row shows the code. Note: foo will not be highlighted nor boxed on the target page.\n\n\nFor example, you might decide to place a welcome message on every newcomer's talk page.\nTransclusion creates a \"live\" link between the template page and the target page(s) upon which the template's contents should appear. When the template is edited, the rendering of that template on the target pages is updated as well. For example, you create a (template) page in Wikipedia with your home mailing address and then transclude that template not only on your page, but all your friends' pages, too. Later, after moving to a new house, you then update your address template and the new address will automatically appear on all your friends' pages.\nThere are further simple examples at mw:Transclusion.\nOn the other hand, breaking existing transclusions in a template is called breakage.\n",
                                "prefix": "sclusion/How Transclusion Works\n",
                                "suffix": "\nTransclusion syntax\nThe general"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T07:34:22.131Z",
                "lastEdited": "2020-12-26T07:34:22.131Z",
                "url": "https://en.wikipedia.org/wiki/Help:Transclusion/#1608968062131"
            }
        },
        {
            "timestamp": 1608968435693,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Help:Transclusion/#1608968435658",
            "operation": "create",
            "object": {
                "pageTitle": "Help:Transclusion - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Help:Transclusion",
                "body": "So, in summary, an example page having the wikitext {{Pagename}} or {{Template:Pagename}} included, will transclude the Template:Pagename into that example page. But {{:Pagename}} will have a different effect: it will transclude the article Pagename. Also, {{Namespace:Pagename}} will transclude the page Namespace:Pagename, for pages with titles of that format.",
                "comment": "",
                "selector": {
                    "quote": "So, in summary, an example page having the wikitext {{Pagename}} or {{Template:Pagename}} included, will transclude the Template:Pagename into that example page. But {{:Pagename}} will have a different effect: it will transclude the article Pagename. Also, {{Namespace:Pagename}} will transclude the page Namespace:Pagename, for pages with titles of that format.",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[15]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[15]",
                                "endOffset": 362
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 6790,
                                "end": 7152
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "So, in summary, an example page having the wikitext {{Pagename}} or {{Template:Pagename}} included, will transclude the Template:Pagename into that example page. But {{:Pagename}} will have a different effect: it will transclude the article Pagename. Also, {{Namespace:Pagename}} will transclude the page Namespace:Pagename, for pages with titles of that format.",
                                "prefix": "transclusion modifiers section.\n",
                                "suffix": "\n\nTemplate transclusion\nFurther "
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T07:40:35.658Z",
                "lastEdited": "2020-12-26T07:40:35.658Z",
                "url": "https://en.wikipedia.org/wiki/Help:Transclusion/#1608968435658"
            }
        },
        {
            "timestamp": 1608968465645,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Help:Transclusion/#1608968465620",
            "operation": "create",
            "object": {
                "pageTitle": "Help:Transclusion - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Help:Transclusion",
                "body": "Templates are pages that are written with the prime objective of being included in other pages, either through transclusion or substitution",
                "comment": "",
                "selector": {
                    "quote": "Templates are pages that are written with the prime objective of being included in other pages, either through transclusion or substitution",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[16]",
                                "startOffset": 78,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[16]",
                                "endOffset": 217
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 7371,
                                "end": 7510
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Templates are pages that are written with the prime objective of being included in other pages, either through transclusion or substitution",
                                "prefix": " the transclusion of templates. ",
                                "suffix": ". As shown above, the usual synt"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T07:41:05.620Z",
                "lastEdited": "2020-12-26T07:41:05.620Z",
                "url": "https://en.wikipedia.org/wiki/Help:Transclusion/#1608968465620"
            }
        },
        {
            "timestamp": 1608968602149,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Help:Transclusion/#1608968602105",
            "operation": "create",
            "object": {
                "pageTitle": "Help:Transclusion - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Help:Transclusion",
                "body": "The exact syntax for using parameters with templates can vary greatly, depending on the actual template being used. But, for an example template titled Template:Pagename, which happened to use three parameters, the general form would be:\r\n\r\n{{Pagename|parameter1|parameter2|parameter3}}\r\nShortcuts\r\n\r\n    WP:UNNAMED\r\n    WP:POSPARAM\r\n    WP:POSITIONAL\r\n\r\nwith each parameter being substituted with a value, or a parameter name=value, when used in practice. Notice that each parameter is separated with a vertical bar. Parameters that take the form value are called unnamed or positional parameters. Parameters that take the form parameter name=value are called named parameters. With unnamed parameters, the first, second, third etc. parameters are equivalent to parameters '1', '2', '3' etc. in template documentation. Unnamed parameters must be in the correct order, and best placed before named parameters. An example of the syntax using the Template:Collapse top:\r\n\r\n{{Collapse top|This is the title text|This is a custom warning line|left=true}}\r\n\r\nIn this particular example, three parameters are used, but Template:Collapse top can actually use a variable number of parameters. This is the title text and This is a custom warning line are the values of unnamed parameters '1' and '2'; and true is the value of the named parameter left. ",
                "comment": "",
                "selector": {
                    "quote": "The exact syntax for using parameters with templates can vary greatly, depending on the actual template being used. But, for an example template titled Template:Pagename, which happened to use three parameters, the general form would be:\r\n\r\n{{Pagename|parameter1|parameter2|parameter3}}\r\nShortcuts\r\n\r\n    WP:UNNAMED\r\n    WP:POSPARAM\r\n    WP:POSITIONAL\r\n\r\nwith each parameter being substituted with a value, or a parameter name=value, when used in practice. Notice that each parameter is separated with a vertical bar. Parameters that take the form value are called unnamed or positional parameters. Parameters that take the form parameter name=value are called named parameters. With unnamed parameters, the first, second, third etc. parameters are equivalent to parameters '1', '2', '3' etc. in template documentation. Unnamed parameters must be in the correct order, and best placed before named parameters. An example of the syntax using the Template:Collapse top:\r\n\r\n{{Collapse top|This is the title text|This is a custom warning line|left=true}}\r\n\r\nIn this particular example, three parameters are used, but Template:Collapse top can actually use a variable number of parameters. This is the title text and This is a custom warning line are the values of unnamed parameters '1' and '2'; and true is the value of the named parameter left. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[17]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[21]",
                                "endOffset": 289
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 7997,
                                "end": 9310
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "The exact syntax for using parameters with templates can vary greatly, depending on the actual template being used. But, for an example template titled Template:Pagename, which happened to use three parameters, the general form would be: \n{{Pagename|parameter1|parameter2|parameter3}}\n\nShortcutsWP:UNNAMEDWP:POSPARAMWP:POSITIONAL\nwith each parameter being substituted with a value, or a parameter name=value, when used in practice. Notice that each parameter is separated with a vertical bar.  Parameters that take the form value are called unnamed or positional parameters. Parameters that take the form parameter name=value are called named parameters. With unnamed parameters, the first, second, third etc. parameters are equivalent to parameters '1', '2', '3' etc. in template documentation. Unnamed parameters must be in the correct order, and best placed before named parameters. An example of the syntax using the Template:Collapse top:\n{{Collapse top|This is the title text|This is a custom warning line|left=true}}\nIn this particular example, three parameters are used, but Template:Collapse top can actually use a variable number of parameters. This is the title text and This is a custom warning line are the values of unnamed parameters '1' and '2'; and true is the value of the named parameter left.\n",
                                "prefix": "te can use is from one upwards.\n",
                                "suffix": "For more details, see Help:Templ"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T07:43:22.105Z",
                "lastEdited": "2020-12-26T07:43:22.105Z",
                "url": "https://en.wikipedia.org/wiki/Help:Transclusion/#1608968602105"
            }
        },
        {
            "timestamp": 1608968843447,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Help:Transclusion/#1608968843362",
            "operation": "create",
            "object": {
                "pageTitle": "Help:Transclusion - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Help:Transclusion",
                "body": "Substitution\r\n\r\nSubstitution has a similar double curly-bracket syntax, and its action is similar to transclusion. When you preview a page with substitution wikitext in it, its action is identical to transclusion. But when you save a page with substitution wikitext in it, it differs in that it substitutes that wikitext with the actual wikitext of the template.\r\n\r\nFor example when {{subst:Like}} is saved, it would substitute that wikitext with the actual wikitext from the Template:Like. In practice, the main difference that this makes is that if an update happened to the wikitext of the Template:Like, it would not update any pages where {{subst:Like}} had already been saved.\r\nMagic words\r\n\r\nMagic words are not examples of transclusion. But some have a similar double curly-bracket syntax and action to transclusion. For example, {{FULLPAGENAME}} renders the Fullpagename of any Wikipedia page. Like templates, some magic words can also take parameters, which are separated using a colon (:); for example {{FULLPAGENAME:value}}.\r\n\r\nTemplates do exist for some magic words, for example Template:FULLPAGENAME; but these just invoke the related magic word if passing parameters using a vertical bar (|); for example like {{FULLPAGENAME|value}}. But magic words parameters are best passed directly by using a colon, for example like {{FULLPAGENAME:value}}, which bypasses any templates.\r\nTransclusion modifiers\r\n\r\nAs discussed above, with the example {{subst:Like}}, the subst: code alters the transclusion to substitution. This is a transclusion modifier, a type of specialist magic word for altering transclusion in some manner. Another example is {{:Notability}}, where the : (colon character) forces transclusion to the main namespace. There are additional transclusion modifiers such as safesubst:, int:, msg:, msgnw:, and raw:. For more details on their usage see mw:Help:Magic words#Transclusion modifiers. Also see the modified commands #section:, #section-x: and #section-h: used for labeled section transclusion. ",
                "comment": "",
                "selector": {
                    "quote": "Substitution\r\n\r\nSubstitution has a similar double curly-bracket syntax, and its action is similar to transclusion. When you preview a page with substitution wikitext in it, its action is identical to transclusion. But when you save a page with substitution wikitext in it, it differs in that it substitutes that wikitext with the actual wikitext of the template.\r\n\r\nFor example when {{subst:Like}} is saved, it would substitute that wikitext with the actual wikitext from the Template:Like. In practice, the main difference that this makes is that if an update happened to the wikitext of the Template:Like, it would not update any pages where {{subst:Like}} had already been saved.\r\nMagic words\r\n\r\nMagic words are not examples of transclusion. But some have a similar double curly-bracket syntax and action to transclusion. For example, {{FULLPAGENAME}} renders the Fullpagename of any Wikipedia page. Like templates, some magic words can also take parameters, which are separated using a colon (:); for example {{FULLPAGENAME:value}}.\r\n\r\nTemplates do exist for some magic words, for example Template:FULLPAGENAME; but these just invoke the related magic word if passing parameters using a vertical bar (|); for example like {{FULLPAGENAME|value}}. But magic words parameters are best passed directly by using a colon, for example like {{FULLPAGENAME:value}}, which bypasses any templates.\r\nTransclusion modifiers\r\n\r\nAs discussed above, with the example {{subst:Like}}, the subst: code alters the transclusion to substitution. This is a transclusion modifier, a type of specialist magic word for altering transclusion in some manner. Another example is {{:Notability}}, where the : (colon character) forces transclusion to the main namespace. There are additional transclusion modifiers such as safesubst:, int:, msg:, msgnw:, and raw:. For more details on their usage see mw:Help:Magic words#Transclusion modifiers. Also see the modified commands #section:, #section-x: and #section-h: used for labeled section transclusion. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/h3[2]/span[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[27]",
                                "endOffset": 609
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 9590,
                                "end": 11604
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Substitution\nSubstitution has a similar double curly-bracket syntax, and its action is similar to transclusion. When you preview a page with substitution wikitext in it, its action is identical to transclusion. But when you save a page with substitution wikitext in it, it differs in that it substitutes that wikitext with the actual wikitext of the template. \nFor example when {{subst:Like}} is saved, it would substitute that wikitext with the actual wikitext from the Template:Like. In practice, the main difference that this makes is that if an update happened to the wikitext of the Template:Like, it would not update any pages where {{subst:Like}} had already been saved.\n\nMagic words\nMagic words are not examples of transclusion. But some have a similar double curly-bracket syntax and action to transclusion. For example, {{FULLPAGENAME}} renders the Fullpagename of any Wikipedia page. Like templates, some magic words can also take parameters, which are separated using a colon (:); for example {{FULLPAGENAME:value}}. \nTemplates do exist for some magic words, for example Template:FULLPAGENAME; but these just invoke the related magic word if passing parameters using a vertical bar (|); for example like {{FULLPAGENAME|value}}. But magic words parameters are best passed directly by using a colon, for example like {{FULLPAGENAME:value}}, which bypasses any templates.\n\nTransclusion modifiers\nAs discussed above, with the example {{subst:Like}}, the subst: code alters the transclusion to substitution. This is a transclusion modifier, a type of specialist magic word for altering transclusion in some manner. Another example is {{:Notability}}, where the : (colon character) forces transclusion to the main namespace. There are additional transclusion modifiers such as safesubst:, int:, msg:, msgnw:, and raw:. For more details on their usage see mw:Help:Magic words#Transclusion modifiers. Also see the modified commands #section:, #section-x: and #section-h: used for labeled section transclusion.\n",
                                "prefix": "ere is also a search function.\n\n",
                                "suffix": "\nApplications of transclusion\nTh"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T07:47:23.363Z",
                "lastEdited": "2020-12-26T07:47:23.363Z",
                "url": "https://en.wikipedia.org/wiki/Help:Transclusion/#1608968843362"
            }
        },
        {
            "timestamp": 1608969102859,
            "collection": "favIcons",
            "objectPk": "mediawiki.org",
            "operation": "create",
            "object": {
                "hostname": "mediawiki.org",
                "favIcon": "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"
            }
        },
        {
            "timestamp": 1608969102895,
            "collection": "pages",
            "objectPk": "mediawiki.org/wiki/Transclusion",
            "operation": "create",
            "object": {
                "url": "mediawiki.org/wiki/Transclusion",
                "fullUrl": "https://www.mediawiki.org/wiki/Transclusion",
                "domain": "mediawiki.org",
                "hostname": "mediawiki.org",
                "fullTitle": "Transclusion - MediaWiki",
                "text": " Transclusion From mediawiki.org Jump to navigation Jump to search Translate this page Other languages: Deutsch English español français português русский українська العربية 中文 日本語 It has been suggested that this page or section be merged with Help:Transclusion . ( Discuss ) Transclusion is generally the inclusion of the content of a document into another document by reference. In a wiki context, it is the use of the template functionality of MediaWiki to include the same content in multiple documents without having to edit those documents separately. Contents 1 How transclusion works 2 Etymology 3 Partial transclusion 3.1 Transclusion markup 3.2 Subpages 3.3 Special pages 4 Alternatives to transclusion by template 4.1 Labeled Section Transclusion 4.2 Semantic MediaWiki 5 Pages related to MediaWiki transclusion 6 Templates 7 See also How transclusion works Syntax If the source is in the Template namespace (e.g. \" Template:Welcome \"), just use the name itself, alone: {{Welcome}} If the source is in the Main article namespace (e.g. \" VisualEditor \"), a colon (:) must be added in front of the name: {{:VisualEditor}} If the source is in any other namespace (e.g. \" User:Example \"), you must use the full name, including the namespace: {{User:Example}} If the source is a subpage of the target page, (e.g. \" Transclusion/ja \"), you can simply specify the name of the subpage regardless of namespace: {{/ja}} To transclude any source page (within a single MediaWiki project, such as Wikipedia ) within another target page, include the following code: {{SOMEPAGE}} Whenever the target page A is rendered, the entire content of the source page B (in this case, SOMEPAGE), will be rendered at the location where the transclusion tag was placed. For example, you might decide to place a welcome message on every newcomer's talk page. Transclusion creates a \"live\" link between the template-page and the target-page(s) upon which the message should appear. When the template is edited, all the target-pages are edited too. You might also decide to create a (template) page with your mailing address and include that template on not only your page, but all your friends' pages as well. When you move your television and couch to another apartment, you can change your address template, and that new information will automatically update on all your friends' pages. Etymology Ted Nelson coined the term \" transclusion \", as well as \" hypertext \" and \" hypermedia \", in his 1982 book Literary Machines . Partial transclusion By using \"noinclude\", \"onlyinclude\" and \"includeonly\" markup, it is possible to transclude part of a page rather than all of it. Such partial transclusions can also be achieved by transcluding from other pages such as subpages. It is often desirable not to transclude some information, such as template documentation and categories. Transclusion markup noinclude - The markup <noinclude>...</noinclude> means that the text between the tags will not be transcluded onto another page and will appear only on the page itself. This is useful for template documentation and categories. includeonly - The markup <includeonly>...</includeonly> means that the text between the tags will only be used when the page is transcluded onto another page, and will not appear on the page itself. This can be useful, for example, for adding categories to pages transcluding a template, without adding the template itself to these categories. onlyinclude - The markup <onlyinclude>...</onlyinclude> indicates that only text surrounded by \"onlyinclude\" markup should be transcluded onto another page, but will appear on the page itself if not accompanied by \"includeonly\" tags as well. This is the most subtle of the partial transclusion tags because it often overrules the others. If there is at least one pair of \"onlyinclude\" tags on a page, then whenever this page is transcluded, it is only the material within the \"onlyinclude\" tags which gets transcluded. There can be several such sections, and within each such section, some material might be further excluded by \"noinclude\" tags, and might also be surrounded by \"includeonly\" tags so that it does not appear on the original page itself. But material outside the \"onlyinclude\" tags will be ignored when the page is transcluded onto another page. This can be useful, for example, to repeat a small part of one page on a second one: just surround the small part by onlyinclude tags, and transclude it onto the second page. Note that unlike <noinclude> and <includeonly>, <onlyinclude> will take precedence over enclosing <nowiki> tags. In other words, <nowiki> <onlyinclude>My content</onlyinclude></nowiki> produces only \"My content\" when transcluded. Subpages You can cut and paste the text to be transcluded into a subpage , then use the name of the subpage in the transclusion template. This approach can be used only where subpages are enabled; for example, on the English Wikipedia, subpages can be used only from User, Talk or Wikipedia pages; currently, subpages cannot be created from main article pages . Example: you want to discuss the deletion and redirecting of Pussycat to Cat . First, create the subpage Talk:Pussycat/Let's delete Pussycat! , write your comment into it, then transclude it in Talk:Pussycat and Talk:Cat using the template {{Talk:Pussycat/Let's delete Pussycat!}}. Comments posted in either talk page will be shown in both. Special pages See also: w:Wikipedia:Transclusion#Special pages and Manual:$wgAllowSpecialInclusion Some pages on Special:Specialpages can be transcluded, such as Special:AllPages , Special:PrefixIndex , Special:NewFiles , Special:NewPages , Special:RecentChanges and Special:RecentChangesLinked . Sample: {{Special:Newpages/3}} gives 3 new pages. URL parameters can be given like template parameters, e. g. {{Special:RecentChanges|namespace=10|limit=5}}. Alternatives to transclusion by template Occasionally you may want to use a template, but for one reason or another may not want to use transclusion. The automatic one-time copying of a template's code/text to the location of a template tag is called Template substitution or subclusion (substitution + transclusion). To subclude a template's code/text, the template tag is modified from the standard transclusion tag to a substitution tag, simply by adding subst:, creating a tag with the form: {{subst:template name}}. Labeled Section Transclusion An extension called Labeled Section Transclusion enables marked sections of text to be transcluded. An extension with a somewhat similar function is PageVariableExtension . Semantic MediaWiki The Semantic MediaWiki extension uses inline queries to query and display semantic data. There are currently two ways to perform transclusion or something similar: Transclusion proper. The display format \"embedded\" ensures that selected pages (mainspace articles, templates, etc.) are transcluded. As with templates, sections placed between noinclude tags will be omitted. Selected passages in a page can be assigned a property of type 'Text'. These selections can be requested by running an inline query for this type of property. See inline queries for further information. Pages related to MediaWiki transclusion Wikipedia:MediaWiki namespace m:Help:MediaWiki namespace m:Help:Variable w:Wikipedia talk:Template namespace#transcluding prose Templates Help:Template w:Wikipedia:Template namespace w:Wikipedia:Template limits See also Request for template transclusion from Commons (interwiki templates, etc.) w:Wikipedia:Substitution (the opposite of transclusion) Extension:Labeled Section Transclusion Retrieved from \" https://www.mediawiki.org/w/index.php?title=Transclusion&oldid=4221763 \" Categories : Pages to be merged Templates Navigation menu Personal tools English Not logged in Talk Contributions Create account Log in Namespaces Page Discussion Variants Views Read View source View history More Search Navigation Main page Get MediaWiki Get extensions Tech blog Contribute Support User help FAQ Technical manual Support desk Communication Development Bug tracker Code docs Code repository Statistics MediaWiki.org Community portal Recent changes Translate content Random page Current issues Sandbox Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Create a book Download as PDF Printable version In other projects Meta-Wiki Wikipedia In other languages Afrikaans العربية مصرى भोजपुरी বাংলা Català Dansk Zazaki English فارسی Français Gàidhlig हिन्दी Ilokano Italiano Jawa 한국어 Македонски Bahasa Melayu مازِرونی Norsk ଓଡ଼ିଆ Polski Português සිංහල Simple English Српски / srpski Sunda Türkçe 吴语 ייִדיש 中文 23 more Edit links This page was last edited on 7 November 2020, at 07:57. Text is available under the Creative Commons Attribution-ShareAlike License ; additional terms may apply. See Terms of Use for details. Privacy policy About MediaWiki.org Disclaimers Code of Conduct Mobile view Developers Statistics Cookie statement ",
                "urlTerms": [
                    "wiki",
                    "transclusion"
                ],
                "titleTerms": [
                    "transclusion",
                    "mediawiki"
                ]
            }
        },
        {
            "timestamp": 1608969102962,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "mediawiki.org/wiki/Transclusion"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "mediawiki.org/wiki/Transclusion",
                "fullUrl": "https://www.mediawiki.org/wiki/Transclusion",
                "createdAt": "2020-12-26T07:51:42.949Z"
            }
        },
        {
            "timestamp": 1608969102976,
            "collection": "visits",
            "objectPk": [
                1608969102972,
                "mediawiki.org/wiki/Transclusion"
            ],
            "operation": "create",
            "object": {
                "url": "mediawiki.org/wiki/Transclusion",
                "time": 1608969102972
            }
        },
        {
            "timestamp": 1608969102988,
            "collection": "annotations",
            "objectPk": "https://www.mediawiki.org/wiki/Transclusion/#1608969102690",
            "operation": "create",
            "object": {
                "pageTitle": "Transclusion - MediaWiki",
                "pageUrl": "mediawiki.org/wiki/Transclusion",
                "body": "Transclusion is generally the inclusion of the content of a document into another document by reference.",
                "comment": "",
                "selector": {
                    "quote": "Transclusion is generally the inclusion of the content of a document into another document by reference.",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[2]/p[1]/b[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[2]/p[1]",
                                "endOffset": 104
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 1166,
                                "end": 1270
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Transclusion is generally the inclusion of the content of a document into another document by reference.",
                                "prefix": "th Help:Transclusion. (Discuss)\n",
                                "suffix": " In a wiki context, it is the us"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T07:51:42.690Z",
                "lastEdited": "2020-12-26T07:51:42.690Z",
                "url": "https://www.mediawiki.org/wiki/Transclusion/#1608969102690"
            }
        },
        {
            "timestamp": 1608969312901,
            "collection": "annotations",
            "objectPk": "https://www.mediawiki.org/wiki/Transclusion/#1608969312876",
            "operation": "create",
            "object": {
                "pageTitle": "Transclusion - MediaWiki",
                "pageUrl": "mediawiki.org/wiki/Transclusion",
                "body": "Syntax\r\n\r\nIf the source is in the Template namespace (e.g. \"Template:Welcome\"), just use the name itself, alone: {{Welcome}}\r\n\r\nIf the source is in the Main article namespace (e.g. \"VisualEditor\"), a colon (:) must be added in front of the name: {{:VisualEditor}}\r\n\r\nIf the source is in any other namespace (e.g. \"User:Example\"), you must use the full name, including the namespace: {{User:Example}}\r\n\r\nIf the source is a subpage of the target page, (e.g. \"Transclusion/ja\"), you can simply specify the name of the subpage regardless of namespace: {{/ja}}",
                "comment": "",
                "selector": {
                    "quote": "Syntax\r\n\r\nIf the source is in the Template namespace (e.g. \"Template:Welcome\"), just use the name itself, alone: {{Welcome}}\r\n\r\nIf the source is in the Main article namespace (e.g. \"VisualEditor\"), a colon (:) must be added in front of the name: {{:VisualEditor}}\r\n\r\nIf the source is in any other namespace (e.g. \"User:Example\"), you must use the full name, including the namespace: {{User:Example}}\r\n\r\nIf the source is a subpage of the target page, (e.g. \"Transclusion/ja\"), you can simply specify the name of the subpage regardless of namespace: {{/ja}}",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[2]/div[4]/div[1]/b[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[2]/div[4]/p[4]/code[1]",
                                "endOffset": 7
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 1774,
                                "end": 2317
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Syntax\nIf the source is in the Template namespace (e.g. \"Template:Welcome\"), just use the name itself, alone: {{Welcome}}\nIf the source is in the Main article namespace (e.g. \"VisualEditor\"), a colon (:) must be added in front of the name: {{:VisualEditor}}\nIf the source is in any other namespace (e.g. \"User:Example\"), you must use the full name, including the namespace: {{User:Example}}\nIf the source is a subpage of the target page, (e.g. \"Transclusion/ja\"), you can simply specify the name of the subpage regardless of namespace: {{/ja}}",
                                "prefix": "o\n\n\n\nHow transclusion works\n\n\n\n\n",
                                "suffix": "\n\n\n\n\n\n\nTo transclude any source "
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T07:55:12.876Z",
                "lastEdited": "2020-12-26T07:56:43.297Z",
                "url": "https://www.mediawiki.org/wiki/Transclusion/#1608969312876"
            }
        },
        {
            "timestamp": 1608969403461,
            "collection": "annotations",
            "objectPk": "https://www.mediawiki.org/wiki/Transclusion/#1608969312876",
            "operation": "update",
            "object": {
                "pageTitle": "Transclusion - MediaWiki",
                "pageUrl": "mediawiki.org/wiki/Transclusion",
                "body": "Syntax\r\n\r\nIf the source is in the Template namespace (e.g. \"Template:Welcome\"), just use the name itself, alone: {{Welcome}}\r\n\r\nIf the source is in the Main article namespace (e.g. \"VisualEditor\"), a colon (:) must be added in front of the name: {{:VisualEditor}}\r\n\r\nIf the source is in any other namespace (e.g. \"User:Example\"), you must use the full name, including the namespace: {{User:Example}}\r\n\r\nIf the source is a subpage of the target page, (e.g. \"Transclusion/ja\"), you can simply specify the name of the subpage regardless of namespace: {{/ja}}",
                "comment": "",
                "selector": {
                    "quote": "Syntax\r\n\r\nIf the source is in the Template namespace (e.g. \"Template:Welcome\"), just use the name itself, alone: {{Welcome}}\r\n\r\nIf the source is in the Main article namespace (e.g. \"VisualEditor\"), a colon (:) must be added in front of the name: {{:VisualEditor}}\r\n\r\nIf the source is in any other namespace (e.g. \"User:Example\"), you must use the full name, including the namespace: {{User:Example}}\r\n\r\nIf the source is a subpage of the target page, (e.g. \"Transclusion/ja\"), you can simply specify the name of the subpage regardless of namespace: {{/ja}}",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[2]/div[4]/div[1]/b[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[2]/div[4]/p[4]/code[1]",
                                "endOffset": 7
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 1774,
                                "end": 2317
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Syntax\nIf the source is in the Template namespace (e.g. \"Template:Welcome\"), just use the name itself, alone: {{Welcome}}\nIf the source is in the Main article namespace (e.g. \"VisualEditor\"), a colon (:) must be added in front of the name: {{:VisualEditor}}\nIf the source is in any other namespace (e.g. \"User:Example\"), you must use the full name, including the namespace: {{User:Example}}\nIf the source is a subpage of the target page, (e.g. \"Transclusion/ja\"), you can simply specify the name of the subpage regardless of namespace: {{/ja}}",
                                "prefix": "o\n\n\n\nHow transclusion works\n\n\n\n\n",
                                "suffix": "\n\n\n\n\n\n\nTo transclude any source "
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T07:55:12.876Z",
                "lastEdited": "2020-12-26T07:56:43.297Z",
                "url": "https://www.mediawiki.org/wiki/Transclusion/#1608969312876"
            }
        },
        {
            "timestamp": 1608969403647,
            "collection": "tags",
            "objectPk": [
                "namespace",
                "https://www.mediawiki.org/wiki/Transclusion/#1608969312876"
            ],
            "operation": "create",
            "object": {
                "url": "https://www.mediawiki.org/wiki/Transclusion/#1608969312876",
                "name": "namespace"
            }
        },
        {
            "timestamp": 1608969403662,
            "collection": "tags",
            "objectPk": [
                "transclusion",
                "https://www.mediawiki.org/wiki/Transclusion/#1608969312876"
            ],
            "operation": "create",
            "object": {
                "url": "https://www.mediawiki.org/wiki/Transclusion/#1608969312876",
                "name": "transclusion"
            }
        },
        {
            "timestamp": 1608969403676,
            "collection": "tags",
            "objectPk": [
                "programming",
                "https://www.mediawiki.org/wiki/Transclusion/#1608969312876"
            ],
            "operation": "create",
            "object": {
                "url": "https://www.mediawiki.org/wiki/Transclusion/#1608969312876",
                "name": "programming"
            }
        },
        {
            "timestamp": 1608969403692,
            "collection": "tags",
            "objectPk": [
                "wikipedia",
                "https://www.mediawiki.org/wiki/Transclusion/#1608969312876"
            ],
            "operation": "create",
            "object": {
                "url": "https://www.mediawiki.org/wiki/Transclusion/#1608969312876",
                "name": "wikipedia"
            }
        },
        {
            "timestamp": 1608970068196,
            "collection": "annotations",
            "objectPk": "https://www.mediawiki.org/wiki/Transclusion/#1608970068169",
            "operation": "create",
            "object": {
                "pageTitle": "Transclusion - MediaWiki",
                "pageUrl": "mediawiki.org/wiki/Transclusion",
                "body": "Partial transclusion\r\n\r\nBy using \"noinclude\", \"onlyinclude\" and \"includeonly\" markup, it is possible to transclude part of a page rather than all of it. Such partial transclusions can also be achieved by transcluding from other pages such as subpages. It is often desirable not to transclude some information, such as template documentation and categories.\r\nTransclusion markup\r\n\r\n    noinclude - The markup <noinclude>...</noinclude> means that the text between the tags will not be transcluded onto another page and will appear only on the page itself. This is useful for template documentation and categories.\r\n    includeonly - The markup <includeonly>...</includeonly> means that the text between the tags will only be used when the page is transcluded onto another page, and will not appear on the page itself. This can be useful, for example, for adding categories to pages transcluding a template, without adding the template itself to these categories.\r\n    onlyinclude - The markup <onlyinclude>...</onlyinclude> indicates that only text surrounded by \"onlyinclude\" markup should be transcluded onto another page, but will appear on the page itself if not accompanied by \"includeonly\" tags as well. This is the most subtle of the partial transclusion tags because it often overrules the others. If there is at least one pair of \"onlyinclude\" tags on a page, then whenever this page is transcluded, it is only the material within the \"onlyinclude\" tags which gets transcluded. There can be several such sections, and within each such section, some material might be further excluded by \"noinclude\" tags, and might also be surrounded by \"includeonly\" tags so that it does not appear on the original page itself. But material outside the \"onlyinclude\" tags will be ignored when the page is transcluded onto another page. This can be useful, for example, to repeat a small part of one page on a second one: just surround the small part by onlyinclude tags, and transclude it onto the second page. Note that unlike <noinclude> and <includeonly>, <onlyinclude> will take precedence over enclosing <nowiki> tags. In other words, <nowiki><onlyinclude>My content</onlyinclude></nowiki> produces only \"My content\" when transcluded.",
                "comment": "",
                "selector": {
                    "quote": "Partial transclusion\r\n\r\nBy using \"noinclude\", \"onlyinclude\" and \"includeonly\" markup, it is possible to transclude part of a page rather than all of it. Such partial transclusions can also be achieved by transcluding from other pages such as subpages. It is often desirable not to transclude some information, such as template documentation and categories.\r\nTransclusion markup\r\n\r\n    noinclude - The markup <noinclude>...</noinclude> means that the text between the tags will not be transcluded onto another page and will appear only on the page itself. This is useful for template documentation and categories.\r\n    includeonly - The markup <includeonly>...</includeonly> means that the text between the tags will only be used when the page is transcluded onto another page, and will not appear on the page itself. This can be useful, for example, for adding categories to pages transcluding a template, without adding the template itself to these categories.\r\n    onlyinclude - The markup <onlyinclude>...</onlyinclude> indicates that only text surrounded by \"onlyinclude\" markup should be transcluded onto another page, but will appear on the page itself if not accompanied by \"includeonly\" tags as well. This is the most subtle of the partial transclusion tags because it often overrules the others. If there is at least one pair of \"onlyinclude\" tags on a page, then whenever this page is transcluded, it is only the material within the \"onlyinclude\" tags which gets transcluded. There can be several such sections, and within each such section, some material might be further excluded by \"noinclude\" tags, and might also be surrounded by \"includeonly\" tags so that it does not appear on the original page itself. But material outside the \"onlyinclude\" tags will be ignored when the page is transcluded onto another page. This can be useful, for example, to repeat a small part of one page on a second one: just surround the small part by onlyinclude tags, and transclude it onto the second page. Note that unlike <noinclude> and <includeonly>, <onlyinclude> will take precedence over enclosing <nowiki> tags. In other words, <nowiki><onlyinclude>My content</onlyinclude></nowiki> produces only \"My content\" when transcluded.",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[2]/h2[3]/span[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[2]/ul[1]/li[3]",
                                "endOffset": 1264
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 3406,
                                "end": 5617
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Partial transclusion\nBy using \"noinclude\", \"onlyinclude\" and \"includeonly\" markup, it is possible to transclude part of a page rather than all of it. Such partial transclusions can also be achieved by transcluding from other pages such as subpages. It is often desirable not to transclude some information, such as template documentation and categories.\n\nTransclusion markup\nnoinclude - The markup <noinclude>...</noinclude> means that the text between the tags will not be transcluded onto another page and will appear only on the page itself. This is useful for template documentation and categories.\nincludeonly - The markup <includeonly>...</includeonly> means that the text between the tags will only be used when the page is transcluded onto another page, and will not appear on the page itself. This can be useful, for example, for adding categories to pages transcluding a template, without adding the template itself to these categories.\nonlyinclude - The markup <onlyinclude>...</onlyinclude> indicates that only text surrounded by \"onlyinclude\" markup should be transcluded onto another page, but will appear on the page itself if not accompanied by \"includeonly\" tags as well. This is the most subtle of the partial transclusion tags because it often overrules the others. If there is at least one pair of \"onlyinclude\" tags on a page, then whenever this page is transcluded, it is only the material within the \"onlyinclude\" tags which gets transcluded. There can be several such sections, and within each such section, some material might be further excluded by \"noinclude\" tags, and might also be surrounded by \"includeonly\" tags so that it does not appear on the original page itself. But material outside the \"onlyinclude\" tags will be ignored when the page is transcluded onto another page. This can be useful, for example, to repeat a small part of one page on a second one: just surround the small part by onlyinclude tags, and transclude it onto the second page. Note that unlike <noinclude> and <includeonly>, <onlyinclude> will take precedence over enclosing <nowiki> tags. In other words, <nowiki><onlyinclude>My content</onlyinclude></nowiki> produces only \"My content\" when transcluded.",
                                "prefix": "s 1982 book Literary Machines.\n\n",
                                "suffix": "\nSubpages\nYou can cut and paste "
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T08:07:48.169Z",
                "lastEdited": "2020-12-26T08:07:48.169Z",
                "url": "https://www.mediawiki.org/wiki/Transclusion/#1608970068169"
            }
        },
        {
            "timestamp": 1608970624325,
            "collection": "favIcons",
            "objectPk": "semantic-mediawiki.org",
            "operation": "create",
            "object": {
                "hostname": "semantic-mediawiki.org",
                "favIcon": "AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGEwEMBAHQcXAAAAAAAAAAAAAAAAbzU3AF4dIAAAAAAAAAAAAAAAAAAAAAAAdjYvAAAAAAAAAAAAAAAAAAAAAABqOxqxSSUMLQAAAABgKDFAAAtyBwAAAADjdBgAShEkCYk6Hp6KPSOQOiFQCQAAAAAAAAAAAAAAAAAAAAAAAAAAbDsaeVkqFHKUPhn1sk8V/51EGf9vKSNIAAAAAI06HNq1URf/sE4W/5M/HZ1KHj4BAAAAAAAAAAAAAAAAAAAAAGE4Hx2DPBr/uVUd/7pVHv6yTxb+nUMZ9n43J6ugRSL/3Ww6/r5YIv+cRBrHZykrBgAAAAAAAAAAAAAAAGM8IgBSHiAFnkYgvd9uPf/icD//uFQd/6ZJF+NiDQgPj0IsqslfLP+1Uhv/gzQdcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJNAKE/DXTL212Uu/7NKEv5aV2z5G4nk5xuM6MdJbqC9ci8pdYM3IZZwLygsAAAAAPF9GwAAAAAAczo8AAAAAAAAAAAAhzcd+1RKYvUwdbT/FZ3u/xKn9/8SpPX/F5Xr/zKI17WPPBr2q0wW9IE0H3UAAAAAAAAAAGUkIxCNPSFVgTIcl4Q7KLgik/PwFKH0/xCw/f8Psv//D7L+/xGq+P4ajuT/umdG5MFXIP+WQBmyAAAAAGIoMAqaQhq6rEwY/6xLFv+fRhvwJXrE/xKo+P4Ps///DrP//w+y//8QsP3/F5rt/nFebOydQx/WcywfNwAAAACOPiAltVMk/dxtOv/GXSn/sE4V/lJffP8Rp/f+D7L+/w+z//8Psv//Ea78/xaX7P5GYYuHAAAAAAAAAABmJSQAhjghILxYKfjldEL+zmMv/7NQFv9PY4vyFpbs/xGq+f4QsP3/EK77/xGj9/8kgc38XURSMgAAAAAAAAAAAAAAAAAAAACFNR6NtFId/rJQGfyINxr+Z05iWS2J3eoYj+b+Fpnt/ReV6v4shMz/iVI7/HUwJjsAAAAAAAAAAAAAAAD/lAsAAAAAAFQbJSxiICAwbC4vS5M+Gv+aSiP/bV1o8FpmhtBhVWn/yGM3/7pUG/+NPyKAAAAAAAAAAAAAAAAAAAAAAG4qJAAAAAAAAAAAAIc2HLfEXCb/vFch/6ZIFft3MCJ/j0k5KqNGJfSTPR7mUhkjFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACJOSR31mg3/9FkMP+iRxnsgjMeGAAAAAAAAAAAAAAAAAAAAABmIyEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAajM9BJ5HK2aVQCOagDYiNAAA8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3/8AAN/PAADxhwAA4AcAAOCPAADwFwAA8AMAAOABAACAAwAAgAcAAIAPAACEDwAA+AcAAPDPAAD4/wAA/f8AAA=="
            }
        },
        {
            "timestamp": 1608970624367,
            "collection": "pages",
            "objectPk": "semantic-mediawiki.org/wiki/Help:Inline_queries",
            "operation": "create",
            "object": {
                "url": "semantic-mediawiki.org/wiki/Help:Inline_queries",
                "fullUrl": "https://www.semantic-mediawiki.org/wiki/Help:Inline_queries",
                "domain": "semantic-mediawiki.org",
                "hostname": "semantic-mediawiki.org",
                "fullTitle": "Inline queries - semantic-mediawiki.org",
                "text": " Toggle navigation General Semantic MediaWiki Introduction Getting support Community portal Open Semantic Data Association SMWCon Recent changes Users Manual Getting started Report a bug Sandbox wiki MediaWiki Admini­strators Manual Store and search environment Features and supplementary functions Installation Configuration Maintenance Report a bug Sandbox wiki MediaWiki Devel­opers Manual Source code Code documentation Report a bug Sandbox wiki MediaWiki ? Getting support Frequent questions Missing content Missing translation Found an error ... Discussion View source History Log in Request account User manual Introduction to Semantic MediaWiki Editing Properties and types Special properties Inverse properties Custom units Semantic templates Service links Browsing and searching Browsing interfaces Special page \"Ask\" Special page \"Browse\" Factbox Semantic search Selecting pages Search operators Strict comparators Subqueries and property chains Unions (OR) of results Distance queries Namespace restrictions Range of pages Single page restriction Full-text search Search value substitution Displaying information Sorting Printouts and property chains Result formats Inline queries Querying for queries Concepts Inferencing Semantic Web RDF export Importing vocabulary v1.7.0+ Status: effective Progress: 100% Version: 1.7.0+ English Add a translation Inline queries From semantic-mediawiki.org User manual Semantic search Inline queries Examples/Different link parameter options Jump to: navigation , search Table of Contents Contents [ hide ] 1 Parser function #ask 2 Parser function #show 3 Standard parameters for inline queries 3.1 Result limits and links to further results 3.2 Styling of further results link 3.3 Introduction and default text 3.4 Sorting results 3.5 Configuring labels/table headers 3.6 Changing the first result column 4 Result formats 4.1 Exporting query results 5 Updating of inline queries 6 Avoid Self-Referencing 7 Related tips Semantic MediaWiki includes a simple query language for semantic search , so that users can directly request certain information from the wiki. Readers who do not wish to learn the query syntax can still profit from this feature: inline queries dynamically include query results into pages. So queries created by a few editors can be consumed by many readers. Inline queries are similar to other semantic search features, and can also be restricted on a site in order to ensure sufficient performance. Since inline queries exploit the existing caching mechanisms of MediaWiki , most requests for a page with such dynamic contents can be served without any performance impact whatsoever. Parser function #ask [ edit ] The basic way of writing an inline query is to use the parser function #ask. The query string (See selecting pages for syntax) and any printout statements are directly given as parameter, like in the following example: {{#ask: [[Category:City]] [[Located in::Germany]] |?Population |?Area#km² = Size in km² }} Here we query for all cities located in Germany, and two additional printout statements are used (a simple one and one with some extra settings). This displays the following result on a page: Population The number of inhabitants of some geographical place. Size in km² Berlin 3,520,061 891.85 km² 344.34 sqmi <br /> Cologne 1,080,394 405.02 km² 156.38 sqmi <br /> Frankfurt 679,664 248.31 km² 95.87 sqmi <br /> Munich 1,353,186 310.43 km² 119.86 sqmi <br /> Stuttgart 606,588 207.35 km² 80.06 sqmi <br /> Würzburg 126,635 87.63 km² 33.83 sqmi <br /> It is common to put the query as the first parameter behind #ask:. All other parameters are separated by |, just like for other parser functions . The exact formatting of the inline query is not essential, but it is good to use line breaks to make it more readable to other editors. As with all templates, one line per parameter, starting with the | is most accepted in practice. Note that all the arguments to the #ask: function are ignored by the page parsing, hence the above example does not add a category or a «located in» property annotation to this page. A few more things to note are: The pipe '|' symbol is used to separate the conditions from the property to display. The conditions for display are a single argument to the #ask function, so there are no '|' symbols between them. White space and line breaks can be used within the #ask function, SMW is fairly flexible there. The format of the results display changes when you request display of additional properties. SMW picks an appropriate default format for query results, but you also have detailed control of the appearance of query results. Knowing the basics of query string and printout statements therefore is enough to write many kinds of queries. But there are many cases where the standard table output of a query may not be the best choice, or where further settings are desired (like the maximum number of results that should be displayed). For this purpose, inline queries have a number of other possible parameters that one can use to control their appearance in detail. The general syntax for #ask therefore is the following: {{#ask: argument 1 | argument 2 | … }} Most of this page explains the various arguments one may use in inline queries. Parser function #show [ edit ] A common usage of queries is to display only a single property value for a single page. For example, one could insert the population of Berlin into some page, and use a query instead of manual copying to achieve this. SMW provides a special shortcut parser function to make such queries simpler: #show. For example, one can write the following to display the population of Berlin on a page: Syntax {{#show: Demo:Berlin |?Population }} Result 3,520,061 The parser function otherwise works like an inline query, and all parameters available for inline queries can also be used on #show if desired. However note that the #show parser function only takes one argument (a page) as the query condition, i.e. the name of the page that should be queried. The above query written with the #ask parser function looks as follows: Syntax {{#ask: [[Demo:Berlin]] |?Population= |mainlabel=- }} Result 3,520,061 Here the \" =\" added to the queried property \" ?Population\" removes the display of the property label and parameter \" mainlabel=\" followed by the \" -\" symbol removes the first result column and the label of the column. Without this, the result would display a table with two columns and rows: Syntax {{#ask: [[Berlin]] |?Population }} Result Population The number of inhabitants of some geographical place. Berlin 3,520,061 Standard parameters for inline queries [ edit ] In general, an inline query is a request to find a number of pages that satisfy certain requirements. The query must answer three questions: Which pages are requested? (See Selecting pages ) What information should be displayed about those pages? (See Printout statements ) How should the results be formatted within the page? (See Results formats ) The first two points are explained in their respective manual pages. The third point is important to smoothly include query results in pages, yet is largely independent of the first two. Without further settings, queries often produce tables like above or simple lists (if no additional printouts are used). An example of another possible format are bulleted lists, which one can create with the parameter format=ul: {{#ask: [[Category:City]] [[Located in::Germany]] |?Population |format=ul }} This will produce the following output: Berlin ( Population The number of inhabitants of some geographical place.: 3,520,061) Cologne ( Population The number of inhabitants of some geographical place.: 1,080,394) Frankfurt ( Population The number of inhabitants of some geographical place.: 679,664) Munich ( Population The number of inhabitants of some geographical place.: 1,353,186) Stuttgart ( Population The number of inhabitants of some geographical place.: 606,588) Würzburg ( Population The number of inhabitants of some geographical place.: 126,635) SMW implements a wide variety of output formats for inline queries, and allows you to further control results display using a MediaWiki template. The parameter format is one of the most important parameters for selecting the appearance of query results. See Results formats . The following table gives an overview of common parameters that can be used in basically all queries: Parameter Possible values Description format a format name selected output format; some formats allow further parameters (see Result formats ) limit non-negative number maximal number of pages selected (in the case of a table: rows) see configuration parameter $smwgQMaxInlineLimit Sets the maximal number of rows ever printed by queries and configuration parameter $smwgQMaxLimit Sets the maximal number of results ever retrieved by queries if not all results show see configuration parameter $smwgQDefaultLimit Default number of rows returned in a query. Can be increased with limit=... in #ask. to set the default if not specified, or to set the number of pages displayed in the new page if limit = 0 offset number where to start selecting pages Note: If the limit specified with this parameter exceeds the limit set with configuration parameter $smwgQUpperbound Sets the upper bound of the offset used for the maximal number of rows ever printed in an embedded query, the offset will fallback to the limit of \" 0\". 1 sort property name or a list of property names separated by , name of properties to use for sorting queries, a blank as a value stands for the main result column (see Selecting pages ) order ascending/ asc, descending/ desc/ reverse, random/ rand or a list of those if more than one property is used for sorting defines how results should be ordered, ascending is the default, without using parameter \"sort\" the sort order of the main result column is set (see Selecting pages ) headers show, plain, hide Show headers (with links), plain headers (just text) or hide them. show is default mainlabel plain text title of the first column (the one with the page titles in it), default is no title; set to - to suppress printing the page titles index number defines which value within a record should be displayed, only applicable for properties of type Record link none, subject, all defines which article names in the result are hyperlinked, all normally is the default. See also the examples page . Note: linking can also be controlled for individual printouts using the plain output format as described in Displaying information . default plain text if, for any reason, the query returns no results, this will be printed instead intro plain text initial text that prepends the output, if at least some results exist outro plain text text that is appended to the output, if at least some results exist searchlabel plain text text for continuing the search (default is «… further results») In addition to the above, some formats have their own parameters that control special aspects of the format. These special settings are described in the documentation of each format. See also the overview page on ask syntax elements . Result limits and links to further results [ edit ] You can set the parameter limit to restrict the maximum number of results that are returned. For example, the query {{#ask: [[Category:City]] [[Located in::Germany]] |limit=3 }} displays at most 3 cities in Germany. Even if you do not specify a value for limit, SMW always applies some limit to the results a query returns. Depending on a site's settings, it might be possible to increase the number of displayed results by specifying a higher value for limit. However, there is usually a maximum limit that cannot be exceeded, set by the wiki administrator based on performance considerations. For details, see the overview page on configuration parameters . Running the above query produces: Berlin , Cologne , Frankfurt ... further results This shows that whenever a query does not display all results due to a limit, it will normally show a link to «further results». The text of this link can be modified by setting the parameter searchlabel. If the value of searchlabel is empty, then no link to further results appears. Some output formats (see below) never display the search link, or display it only if a searchlabel was specified. An interesting application of limit and searchlabel is to display only a link to the results of a search, without showing any result inline. You achieve this by specifying a limit of «0» or «-1». For instance, the query {{#ask: [[Category:City]] | limit=0 | searchlabel=Click to browse a list of cities }} displays: Click to browse a list of cities . this link will only appear if there are any results at all. In other words, SMW will still compute the query to check if there are any results. If this is not needed, or if a link should be shown in any case, one can use the limit «-1». SMW will then only print a link to further results, even if no results exist at all. This also saves some computation time on the server. The query {{#ask: [[Category:City]] | limit=10 | searchlabel= }} in contrast will show a list of up to ten cities, but no link to further results, even if there are any. Styling of further results link [ edit ] Since SMW 1.9.0 it is possible to assign individual CSS styling to each result format's pending \"further results\" link. See the help page on styling further results for further information on this. Introduction and default text [ edit ] If no articles satisfy the conditions of a query, nothing is shown. This is sometimes a useful behavior, but often certain texts should be shown or not shown depending on whether the query has results or not. For example, one may want the query to show an output of the following form: Upcoming conferences: SMWCon Spring 2013 , SMWCon Fall 2013 , … where the list of conferences is generated by a suitable query. If the query (for whatever reason) would not return any results, the page would look as follows Upcoming conferences: which is not desirable. Two parameters exist to prevent this. default: this parameter can be set to a default text that should be returned when no results are obtained. In the above example, one would probably write something like Upcoming conferences: {{#ask: ... | default=none}} so that, if no result is obtained, the article will display Upcoming conferences: none intro: this parameter specifies a text that should be prepended to the output of a query, but only if one or more results exist. In the above example, one could write {{#ask: ... | intro=Upcoming conferences:&nbsp;}} so that, if no result is obtained, nothing will be printed at all. Note that we use \"&nbsp;\" to encode the final space (\"&#32;\" would have worked as well), because regular whitespace is trimmed off the beginning and end of parser-function parameters. Both of the above solutions will show the intended output if results are found. It is also possible to combine both parameters if desired. The parameters can also include MediaWiki markup, such as links or templates, as long as this does not confuse MediaWiki in recognizing the #ask function. Also note that if the set of pages selected in a query is empty, no header row or blank line, not even any blank space, is produced. This can also be useful to «hide» queries that are not applicable. However, it is not recommended to insert great amounts of queries into every page, based on the assumption that this can do no harm since no output is generated. Indeed, answering queries requires much computational resources and should not be done without a purpose. Using default texts for queries is also a good habit in general, since it may happen that a query will no longer have any results in some future, e.g. due to changes in the way the wiki organizes its data. Such queries that once worked properly may be forgotten so that nobody notices the query on a page laboring to display nothing. Note that in cases you want to display only a single property value for a single page (see #show ), the parameter default does not work since you are actually not querying for pages. Sorting results [ edit ] It has been explained in Selecting pages that query results can be ordered by one or more properties. As explained there, Special:Ask has additional input fields to specify sort properties and ordering. In inline queries, sort properties are defined with the parameter sort, and the order can be set with the parameter order. The value of order should be «ascending», «descending» or «reverse», or one of the short forms «asc» and «desc». You can also set the value to «random» (or «rand») for ordering results in an essentially random way (this feature can be disabled by the site administrator, see Configuration ). An example is the following query for the three largest cities in Germany: {{#ask: [[Category:City]] [[Located in::Germany]] |?Population |sort=Population |order=descending |limit=3 }} As explained in Selecting pages , sorting conditions may impose restrictions on the set of query results. In the above case, only German cities that have a value for population are considered. If more than one property is used for sorting, the parameters sort and order can be set to lists of property names and orders, respectively, separated by commas. The following is an example: {{#ask: [[Category:City]] [[Located in::Germany]] |?State |?Population |sort=State,Population |order=ascending,descending }} This query would return all German cities for which a state and population was specified. These results will be ordered by the name of the state they are located in (ordered alphabetically). Cities that are located in the same state will be ordered by their population, largest first (« descending»). It is also possible to explicitly define the main result column to be used for the sorting when more than one sorting condition should be used. This is done by either prepending or appending a comma to an empty statement. Example: {{#ask: [[Category:City]] [[Located in::Germany]] |?State |?Population |sort=State, |order=ascending,descending }} This query would return all German cities for which a state was specified. These results will be ordered by the name of the state they are located in (ordered alphabetically). Cities that are located in the same state will be ordered alphabetically (descending) by their name. Configuring labels/table headers [ edit ] Queries that return more than just the selected articles (e.g. the population in the above example) will display labels that describe the various output fields. By default, the label just displays the name of the requested property, or the text «Category» if categories are displayed. Labels for properties normally display as a link to the respective pages in the Property: namespace. In the table format, the labels appear as column headers. In other formats, the labels might appear right before the output fields. The texts used for these labels can be controlled as explained in Displaying information , using the equality symbol after printouts. Example: {{#ask: [[Category:City]] [[Population::+]] [[Area::+]] |?Population= |?Area#km²=Size in km² |?Category=Category memberships |format=table |default=nothing found in Category:City }} This query will produce: Size in km² Category memberships Amsterdam 783,364 219.00 km² 84.56 sqmi <br /> Europe Sample pages City Berlin 3,520,061 891.85 km² 344.34 sqmi <br /> Sample pages City Cologne 1,080,394 405.02 km² 156.38 sqmi <br /> City Frankfurt 679,664 248.31 km² 95.87 sqmi <br /> Sample pages City Karlsruhe 294,761 173.46 km² 66.97 sqmi <br /> Sample pages City London 7,825,200 1,706.80 km² 659.00 sqmi <br /> Sample pages City Munich 1,353,186 310.43 km² 119.86 sqmi <br /> Sample pages City Paris 2,234,105 105.40 km² 40.69 sqmi <br /> Sample pages City Porto 237.584 41.66 km² 16.08 sqmi <br /> Sample pages City Rome 2,761,477 1,285.31 km² 496.26 sqmi <br /> Sample pages City San Diego 1,307,402 963.60 km² 372.05 sqmi <br /> Sample pages City Stuttgart 606,588 207.35 km² 80.06 sqmi <br /> Sample pages City Sydney 4,575,532 2,058.00 km² 794.59 sqmi <br /> Sample pages City Vienna 1,888,776 414.87 km² 160.18 sqmi <br /> Sample pages City Warsaw 1,720,398 516.90 km² 199.58 sqmi <br /> Sample pages City Würzburg 126,635 87.63 km² 33.83 sqmi <br /> City It is possible to use empty printout labels or to have no label for a result column at all. In tables, however, the table header will still be shown even if all printouts use empty labels. To remove the header of a table completely, the parameter headers can be used. Three values are possible: show: display labels (default) plain: show labels and headers, but a plain text without links (available since SMW 1.4.3) hide: hide all labels and table headers This setting works for tables as well as for other outputs. In the latter case, the value hide will hide all printout labels, even if they have a non-empty label set in the query. Changing the first result column [ edit ] Most queries by default display the actual result pages in the first result position, e.g. as the first column in a table. The header of this column is usually blank. To change the label, or to hide the whole first column, the parameter mainlabel can be used. Normally, the text given to that parameter will simply be used as a header for the first column, for example in the query {{#ask: [[Category:City]] [[Located in::Germany]] |mainlabel=City |?Population=Number of inhabitants |limit=3 }} This will produce the table: City Number of inhabitants The number of inhabitants of some geographical place. Berlin 3,520,061 Cologne 1,080,394 Frankfurt 679,664 ... further results The parameter mainlabel can also be used to completely hide the first column. This happens if the value of this parameter is set to «-» (minus symbol). To insert the list of main results at another position, the printout statement «?», i.e. the question mark without any additions, can be used. For example, modifying the example above to display the city name after Population, {{#ask: [[Category:City]] [[Located in::Germany]] |?Population=Number of inhabitants |?=City |mainlabel=- |limit=3 }} This results in the table: Number of inhabitants The number of inhabitants of some geographical place.City 3,520,061 Berlin 1,080,394 Cologne 679,664 Frankfurt ... further results Result formats [ edit ] The parameter format determines how the results of a query are displayed in the article. For more info, see the Result formats page. Exporting query results [ edit ] Some SMW's result formats ( csv, dsv, json, rdf) enable data export from the wiki. In addition, other formats defined by the Extension \"Semantic Result Formats\" extension () also enable data export. These formats differ from other formats in two ways: Instead of displaying data on the page, they produce only a link to Special:Ask , which in turn outputs the data in a downloadable form. (This link is similar to the normal «further results» link, though it uses different default text, like «RSS»; it is possible to change the link text with the parameter searchlabel.) They use fixed standard formats for exporting (non-fixed, free-form) wiki content. Hence, for formats other than CSV and DSV, it must be explained which wiki properties belong to which part of the data export format. The second point makes it necessary to relate printout statements (properties) to the data fields available in the export format. For example, vCard is a data format that can encode many kinds of contact data about a person, but it cannot represent arbitrary properties. To specify which wiki properties belong to which of the available data fields, the label of the property printout is used. For example, vCard supports (among many others) the data fields «firstname», «lastname» and «homepage». A query could thus be {{#ask: [[Category:Person]] |?Firstname |?Lastname |?Url = homepage |format=vcard }} Here the wiki would have properties called «firstname» and «lastname», but the homepage of a person is stored in a property called «url». The label «homepage» is given to the latter so that vCard recognizes the special meaning of this property. With this method, wikis can use arbitrary property names (in any language) and still export to standard formats. See the pages of the above formats for details on the data fields they support. Updating of inline queries [ edit ] Why doesn't data I have just added show up in queries? Avoid Self-Referencing [ edit ] See Help:Self-Referencing for information about how using an inline query for a property set on the same page can cause unexpected behavior. Related tips [ edit ] Tip on excluding a page from an inline query Tip on adding specific pages to an inline query Tip on adding/displaying images in an inline query References ^ Semantic MediaWiki: GitHub issue gh:smw:4263 Retrieved from \" https://www.semantic-mediawiki.org/w/index.php?title=Help:Inline_queries&oldid=74920 \" Categories : User manual Document Hidden category: I18n reference page What links here Related changes Special pages Printable version Permanent link Page information Cite this page Browse properties This page was last edited on 12 March 2020, at 14:38. Content is available under \"Attribution 3.0 Germany\" (CC BY 3.0 DE) unless otherwise noted. Privacy policy About <semantic-mediawiki.org> (Imprint) Disclaimers ",
                "urlTerms": [
                    "wiki",
                    "inline",
                    "queries"
                ],
                "titleTerms": [
                    "inline",
                    "queries",
                    "semantic-mediawiki",
                    "org",
                    "semantic",
                    "mediawiki"
                ]
            }
        },
        {
            "timestamp": 1608970624459,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "semantic-mediawiki.org/wiki/Help:Inline_queries"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "semantic-mediawiki.org/wiki/Help:Inline_queries",
                "fullUrl": "https://www.semantic-mediawiki.org/wiki/Help:Inline_queries",
                "createdAt": "2020-12-26T08:17:04.444Z"
            }
        },
        {
            "timestamp": 1608970624473,
            "collection": "visits",
            "objectPk": [
                1608970624465,
                "semantic-mediawiki.org/wiki/Help:Inline_queries"
            ],
            "operation": "create",
            "object": {
                "url": "semantic-mediawiki.org/wiki/Help:Inline_queries",
                "time": 1608970624465
            }
        },
        {
            "timestamp": 1608970624485,
            "collection": "annotations",
            "objectPk": "https://www.semantic-mediawiki.org/wiki/Help:Inline_queries/#1608970624044",
            "operation": "create",
            "object": {
                "pageTitle": "Inline queries - semantic-mediawiki.org",
                "pageUrl": "semantic-mediawiki.org/wiki/Help:Inline_queries",
                "body": "Semantic MediaWiki includes a simple query language for semantic search, so that users can directly request certain information from the wiki. Readers who do not wish to learn the query syntax can still profit from this feature: inline queries dynamically include query results into pages. So queries created by a few editors can be consumed by many readers. ",
                "comment": "",
                "selector": {
                    "quote": "Semantic MediaWiki includes a simple query language for semantic search, so that users can directly request certain information from the wiki. Readers who do not wish to learn the query syntax can still profit from this feature: inline queries dynamically include query results into pages. So queries created by a few editors can be consumed by many readers. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[1]/div[2]/div[1]/div[1]/div[4]/div[1]/div[1]/p[1]/a[1]",
                                "startOffset": 0,
                                "endContainer": "/div[1]/div[2]/div[1]/div[1]/div[4]/div[1]/div[1]/p[1]",
                                "endOffset": 360
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 2930,
                                "end": 3290
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Semantic MediaWiki includes a simple query language for semantic search, so that users can directly request certain information from the wiki. Readers who do not wish to learn the query syntax can still profit from this feature: inline queries dynamically include query results into pages. So queries created by a few editors can be consumed by many readers. \n",
                                "prefix": "-Referencing\n7 Related tips\n\n\n\n\n",
                                "suffix": "Inline queries are similar to ot"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T08:17:04.044Z",
                "lastEdited": "2020-12-26T08:17:04.044Z",
                "url": "https://www.semantic-mediawiki.org/wiki/Help:Inline_queries/#1608970624044"
            }
        },
        {
            "timestamp": 1608971059422,
            "collection": "pages",
            "objectPk": "mediawiki.org/wiki/Extension:Labeled_Section_Transclusion",
            "operation": "create",
            "object": {
                "url": "mediawiki.org/wiki/Extension:Labeled_Section_Transclusion",
                "fullUrl": "https://www.mediawiki.org/wiki/Extension:Labeled_Section_Transclusion",
                "domain": "mediawiki.org",
                "hostname": "mediawiki.org",
                "fullTitle": "Extension:Labeled Section Transclusion - MediaWiki",
                "text": " Issue tracker : #mediawiki-extensions-labeledsectiontransclusion Extension:Labeled Section Transclusion From mediawiki.org Jump to navigation Jump to search Translate this page Other languages: Deutsch English Türkçe català dansk español français hrvatski italiano magyar polski português português do Brasil Ελληνικά беларуская (тарашкевіца) български русский українська العربية मराठी हिन्दी বাংলা 中文 日本語 MediaWiki extensions manual Labeled Section Transclusion Release status: stable Implementation Tag , Parser function Description Enables marked sections of text to be transcluded Author(s) Steve Sanbeg Compatibility policy release branches Database changes No License GNU General Public License 2.0 or later Download Download extension Git [ ? ]: Download Git master browse repository ( GitHub ) commit history repository contributors (GitHub) code review Expand Hooks used ParserFirstCallInit Translate the Labeled Section Transclusion extension if it is available at translatewiki.net Check usage and version matrix. Issues Open tasks · Report a bug The Labeled Section Transclusion extension allows selective transclusion of marked-off sections of text, parsing wikitext as normal. Its functionality is similar to an enhanced version of the <onlyinclude> tag with normal wiki transclusion, which selects sections for inclusion. It is enabled on all Wikimedia wikis. While normal transclusion is primarily intended to transclude large portions of small templates, labeled section transclusion is intended for small portions of large pages. However, there are some differences. In the native template transclusion, sections are marked by behavior; thus you can have only one (possibly non-contiguous) section to be included or skipped. Here, sections are marked by name, and behavior is chosen by the caller, which can include or skip sections as needed. Different pages can include or exclude selected sections; there can be arbitrary numbers of sections, which can also overlap arbitrarily. Marking sections by name rather than behavior allows edit section links to be rendered more appropriately for getting excerpts from larger texts, since the extension can now account for sections that are skipped in the beginning of the page, allowing transcluded sections to be offset appropriately. Contents 1 How it works 1.1 Step 1: Mark off sections 1.2 Step 2a: Transclude the section 1.3 Step 2b: Transclude the page but excluding the section 2 Other functions 2.1 Discontiguous sections 2.2 Section ranges 2.3 Substitution 3 Transcluding sections by headings 3.1 Transclude the introduction 3.2 Transclude a specific section 3.3 Transclude multiple sections 4 Notes about skipped headings 5 Localisation 6 Limitations 7 Download 8 Installation 9 Examples 10 See also How it works [ edit ] Step 1: Mark off sections [ edit ] Mark off sections in the text using <section> tags like this: <section begin=chapter1 />this is a chapter 1<section end=chapter1 /> Note that these tags are not HTML/XML, and do not use the normal attribute syntax. For this reason, and because the begin and end markers are individual, rather than normal XML open/close tags, this allows nested or overlapping sections. This allows you to insert section tags without worrying about interfering with other sections. Step 2a: Transclude the section [ edit ] Call the parser function #lst to transclude it, i.e. to transclude a section called chapter1 from a page called articleX: {{#lst:articleX|chapter1}} The target article defines the location of the section; its behavior is determined by the parser function. Step 2b: Transclude the page but excluding the section [ edit ] To transclude a page, but exclude a specified section, use the #lstx function: {{#lstx:articleX|chapter1}} Optionally, you may add replacement text to the excluded section. {{#lstx:articleX|chapter1|replacement_text}} Example: {{#lstx:articleX|chapter1|See chapter 1 in [[articleX]].}} The replacement text will appear in the area where the section is skipped (excluded). Other functions [ edit ] Discontiguous sections [ edit ] It is possible to have multiple sections with the same name; in this case, every section with that name will be included/excluded. This is especially useful to mark various discussions. Section ranges [ edit ] These functions have an additional, optional argument to specify a section range; i.e. {{#lst:articleX|chapter1|chapter3}}, to include everything from the beginning of chapter 1 to the end of chapter 3. This allows using empty marker pairs to mark one end of the section, possibly in a template. A similar mechanism is currently used at the French Wikisource. Substitution [ edit ] This also works with substitution; it's even possible for an article to substitute a section of itself. One use of this provides a neat way to archive talk pages: Mark the text to be archived using <section begin=archive />, etc. Then create an archive page with the text, using {{subst:#lst:talk_page|archive}}, which copies archived sections. Lastly, replace the contents of talk_page with {{subst:#lstx:talk_page|archive}} to remove those sections. Transcluding sections by headings [ edit ] There is optional support for transcluding sections of text marked with the normal headings, i.e. ==this section==. If installed, this is done with the lsth function. Transclude the introduction [ edit ] To transclude the introduction of a page (i.e. the content before the first heading), use {{#lsth:pagename}} Transclude a specific section [ edit ] You can also transclude the whole content of the sectionX (which includes all its sub-sections but excludes the heading of sectionX itself). {{#lsth:pagename|sectionX}} Things to note: Only the first occurrence of the sectionX is transcluded if you have more than one section with the same name. Make sure you type what the heading of sectionX is in wikitext, not how it is displayed. For example if the heading of the section is ==List of [[Extension]]==, you should type \" List of [[Extension]]\" not \" List of Extension\". When transcluding a section from a page marked for translation using the translate extension, transclude from the language-specific version. E.g. from pagename/en rather than from pagename. The matching is case insensitive, to prevent links from breaking due to case changes. Transclude multiple sections [ edit ] You can also transclude from the first occurrence of sectionX (excluding the heading of sectionX itself) until it reaches the next occurrence of sectionY. Note that sectionY acts as a stop point so the transclusion doesn't contain the content of sectionY. {{#lsth:pagename|sectionX|sectionY}} Notes about skipped headings [ edit ] Since the traditional transclusion in MediaWiki isn't intended to transclude sections, it doesn't account for skipped headings. As a result, if you were to transclude a template with multiple headings, and skip the first heading, then all of the edit sections links would point to the wrong section in the template. When this extension is used (with MediaWiki 1.9 or later), the #lst and #lsth functions count headings in the \"skipped\" beginning part, and offset transcluded headings appropriately. This will allow these links to point to the correct section in the simple case. Note that #lstx does not count skipped headings, and that skipped headings within discontiguous sections are not offset. But it seems it has been fixed now (likely when ported to MediaWiki's new preprocessor). The transcluded headings can be linked to the correct sections. Localisation [ edit ] Internally, the parser functions all use the lst prefix, for consistency with the name of the extension. Since this acronym may be confusing to non-developers, readable English variants have been introduced, so the functions can currently be called from either name. function English German Hebrew (RTL) Portuguese #lst #section #Abschnitt #קטע #trecho #lstx #section-x #Abschnitt-x #בלי קטע #trecho-x #lsth #section-h Additionally, the tag can now be localised; currently: English, German, Hebrew, Portuguese; i.e.: English <section begin=x/> ... <section end=x/> German <Abschnitt Anfang=x/> ... <Abschnitt Ende=x/> Hebrew (RTL) <קטע התחלה=א> ... <קטע סוף=א> (\"start\" code to the right and \"end\" code to the left) Portuguese <trecho começo=x/> ... <trecho fim=x/> Limitations [ edit ] While it is possible to use this extension across namespaces, interwiki references are not resolved. It is not yet possible, for example, to include part of a Wikisource page into a remote MediaWiki installation. Section tags cannot themselves be transcluded in order to work on other pages. {{#lst:}} and {{#lstx:}} work only if section tags appear directly in the wikitext of the transcluded page. This means, for instance, that these tags cannot be embedded in a template using template parameters and parser functions . The #tag magic word does not work with section tags. #tag produces balanced tags, while the section tags uses singular tags. See task T39256 . As of 2014, section tags don't have any effect when used inside a template parameter. If page A contains a text {{B|X}}, there's no way {{#lst:A|...}} can access X. Download [ edit ] The extension can be retrieved directly from Git [ ? ]: Browse code Some extensions have tags for stable releases. Browse tags Select the tag Click \"snapshot\" Each branch is associated with a past MediaWiki release. There is also a \"master\" branch containing the latest alpha version (might require an alpha version of MediaWiki). Browse branches Select a branch name Click \"Continue\" Extract the snapshot and place it in the extensions/LabeledSectionTransclusion/ directory of your MediaWiki installation. If you are familiar with git and have shell access to your server, you can also obtain the extension as follows: cd extensions/ git clone https://gerrit.wikimedia.org/r/mediawiki/extensions/LabeledSectionTransclusion.git Installation [ edit ] Download and place the file(s) in a directory called LabeledSectionTransclusion in your extensions/ folder. Add the following code at the bottom of your LocalSettings.php : wfLoadExtension ( 'LabeledSectionTransclusion' ); Done Navigate to Special:Version on your wiki to verify that the extension is successfully installed. To users running MediaWiki 1.27 or earlier: The instructions above describe the new way of installing this extension using wfLoadExtension(). If you need to install this extension on these earlier versions (MediaWiki 1.27 and earlier), instead of wfLoadExtension ( 'LabeledSectionTransclusion' );, you need to use: require_once \" $IP /extensions/LabeledSectionTransclusion/LabeledSectionTransclusion.php\" ; There is also a Gadget in use on various Wikisources that makes it possible to define sections with a simplified ## label ## syntax. Its code can be found at Wikisource:MediaWiki:Gadget-Easy_LST.js . Examples [ edit ] wikisource:user:sanbeg/Includer is an early demonstration that shows several of the basic features. See also [ edit ] DynamicPageList (third-party) includes a slightly modified built-in version of Labeled Section Transclusion This extension is being used on one or more Wikimedia projects . This probably means that the extension is stable and works well enough to be used by such high-traffic websites. Look for this extension's name in Wikimedia's CommonSettings.php and InitialiseSettings.php configuration files to see where it's installed. A full list of the extensions installed on a particular wiki can be seen on the wiki's Special:Version page. Retrieved from \" https://www.mediawiki.org/w/index.php?title=Extension:Labeled_Section_Transclusion&oldid=4182037 \" Categories : Stable extensions Extensions without an image Tag extensions Parser function extensions GPL licensed extensions Extensions in Wikimedia version control ParserFirstCallInit extensions All extensions Extensions used on Wikimedia Navigation menu Personal tools English Not logged in Talk Contributions Create account Log in Namespaces Extension Discussion Variants Views Read Edit View history More Search Navigation Main page Get MediaWiki Get extensions Tech blog Contribute Support User help FAQ Technical manual Support desk Communication Development Bug tracker Code docs Code repository Statistics MediaWiki.org Community portal Recent changes Translate content Random page Current issues Sandbox Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Create a book Download as PDF Printable version In other projects Wikipedia Wikisource In other languages English Edit links This page was last edited on 18 October 2020, at 02:01. Text is available under the Creative Commons Attribution-ShareAlike License ; additional terms may apply. See Terms of Use for details. Privacy policy About MediaWiki.org Disclaimers Code of Conduct Mobile view Developers Statistics Cookie statement ",
                "urlTerms": [
                    "wiki",
                    "extension",
                    "labeled",
                    "section",
                    "transclusion"
                ],
                "titleTerms": [
                    "extension",
                    "labeled",
                    "section",
                    "transclusion",
                    "mediawiki"
                ]
            }
        },
        {
            "timestamp": 1608971059516,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "mediawiki.org/wiki/Extension:Labeled_Section_Transclusion"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "mediawiki.org/wiki/Extension:Labeled_Section_Transclusion",
                "fullUrl": "https://www.mediawiki.org/wiki/Extension:Labeled_Section_Transclusion",
                "createdAt": "2020-12-26T08:24:19.502Z"
            }
        },
        {
            "timestamp": 1608971059534,
            "collection": "visits",
            "objectPk": [
                1608971059527,
                "mediawiki.org/wiki/Extension:Labeled_Section_Transclusion"
            ],
            "operation": "create",
            "object": {
                "url": "mediawiki.org/wiki/Extension:Labeled_Section_Transclusion",
                "time": 1608971059527
            }
        },
        {
            "timestamp": 1608971059545,
            "collection": "annotations",
            "objectPk": "https://www.mediawiki.org/wiki/Extension:Labeled_Section_Transclusion/#1608971059151",
            "operation": "create",
            "object": {
                "pageTitle": "Extension:Labeled Section Transclusion - MediaWiki",
                "pageUrl": "mediawiki.org/wiki/Extension:Labeled_Section_Transclusion",
                "body": "While normal transclusion is primarily intended to transclude large portions of small templates, labeled section transclusion is intended for small portions of large pages",
                "comment": "",
                "selector": {
                    "quote": "While normal transclusion is primarily intended to transclude large portions of small templates, labeled section transclusion is intended for small portions of large pages",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[2]/p[2]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[2]/p[2]",
                                "endOffset": 171
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 2164,
                                "end": 2335
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "While normal transclusion is primarily intended to transclude large portions of small templates, labeled section transclusion is intended for small portions of large pages",
                                "prefix": "enabled on all Wikimedia wikis.\n",
                                "suffix": ".\nHowever, there are some differ"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T08:24:19.151Z",
                "lastEdited": "2020-12-26T08:24:19.151Z",
                "url": "https://www.mediawiki.org/wiki/Extension:Labeled_Section_Transclusion/#1608971059151"
            }
        },
        {
            "timestamp": 1608971183100,
            "collection": "annotations",
            "objectPk": "https://www.mediawiki.org/wiki/Extension:Labeled_Section_Transclusion/#1608971183075",
            "operation": "create",
            "object": {
                "pageTitle": "Extension:Labeled Section Transclusion - MediaWiki",
                "pageUrl": "mediawiki.org/wiki/Extension:Labeled_Section_Transclusion",
                "body": "Mark off sections in the text using <section> tags like this:\r\n\r\n<section begin=chapter1 />this is a chapter 1<section end=chapter1 />\r\n\r\nNote that these tags are not HTML/XML, and do not use the normal attribute syntax. For this reason, and because the begin and end markers are individual, rather than normal XML open/close tags, this allows nested or overlapping sections. This allows you to insert section tags without worrying about interfering with other sections. ",
                "comment": "",
                "selector": {
                    "quote": "Mark off sections in the text using <section> tags like this:\r\n\r\n<section begin=chapter1 />this is a chapter 1<section end=chapter1 />\r\n\r\nNote that these tags are not HTML/XML, and do not use the normal attribute syntax. For this reason, and because the begin and end markers are individual, rather than normal XML open/close tags, this allows nested or overlapping sections. This allows you to insert section tags without worrying about interfering with other sections. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[2]/p[6]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[2]/p[7]",
                                "endOffset": 333
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 3628,
                                "end": 4095
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Mark off sections in the text using <section> tags like this:\n\n<section begin=chapter1 />this is a chapter 1<section end=chapter1 />\n\nNote that these tags are not HTML/XML, and do not use the normal attribute syntax.\nFor this reason, and because the begin and end markers are individual, rather than normal XML open/close tags, this allows nested or overlapping sections. This allows you to insert section tags without worrying about interfering with other sections.\n",
                                "prefix": "Step 1: Mark off sections[edit]\n",
                                "suffix": "\nStep 2a: Transclude the section"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T08:26:23.075Z",
                "lastEdited": "2020-12-26T08:27:13.243Z",
                "url": "https://www.mediawiki.org/wiki/Extension:Labeled_Section_Transclusion/#1608971183075"
            }
        },
        {
            "timestamp": 1608971233276,
            "collection": "annotations",
            "objectPk": "https://www.mediawiki.org/wiki/Extension:Labeled_Section_Transclusion/#1608971183075",
            "operation": "update",
            "object": {
                "pageTitle": "Extension:Labeled Section Transclusion - MediaWiki",
                "pageUrl": "mediawiki.org/wiki/Extension:Labeled_Section_Transclusion",
                "body": "Mark off sections in the text using <section> tags like this:\r\n\r\n<section begin=chapter1 />this is a chapter 1<section end=chapter1 />\r\n\r\nNote that these tags are not HTML/XML, and do not use the normal attribute syntax. For this reason, and because the begin and end markers are individual, rather than normal XML open/close tags, this allows nested or overlapping sections. This allows you to insert section tags without worrying about interfering with other sections. ",
                "comment": "",
                "selector": {
                    "quote": "Mark off sections in the text using <section> tags like this:\r\n\r\n<section begin=chapter1 />this is a chapter 1<section end=chapter1 />\r\n\r\nNote that these tags are not HTML/XML, and do not use the normal attribute syntax. For this reason, and because the begin and end markers are individual, rather than normal XML open/close tags, this allows nested or overlapping sections. This allows you to insert section tags without worrying about interfering with other sections. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[2]/p[6]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[2]/p[7]",
                                "endOffset": 333
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 3628,
                                "end": 4095
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Mark off sections in the text using <section> tags like this:\n\n<section begin=chapter1 />this is a chapter 1<section end=chapter1 />\n\nNote that these tags are not HTML/XML, and do not use the normal attribute syntax.\nFor this reason, and because the begin and end markers are individual, rather than normal XML open/close tags, this allows nested or overlapping sections. This allows you to insert section tags without worrying about interfering with other sections.\n",
                                "prefix": "Step 1: Mark off sections[edit]\n",
                                "suffix": "\nStep 2a: Transclude the section"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T08:26:23.075Z",
                "lastEdited": "2020-12-26T08:27:13.243Z",
                "url": "https://www.mediawiki.org/wiki/Extension:Labeled_Section_Transclusion/#1608971183075"
            }
        },
        {
            "timestamp": 1608971233314,
            "collection": "tags",
            "objectPk": [
                "wiki",
                "https://www.mediawiki.org/wiki/Extension:Labeled_Section_Transclusion/#1608971183075"
            ],
            "operation": "create",
            "object": {
                "url": "https://www.mediawiki.org/wiki/Extension:Labeled_Section_Transclusion/#1608971183075",
                "name": "wiki"
            }
        },
        {
            "timestamp": 1608971233335,
            "collection": "tags",
            "objectPk": [
                "transclusion",
                "https://www.mediawiki.org/wiki/Extension:Labeled_Section_Transclusion/#1608971183075"
            ],
            "operation": "create",
            "object": {
                "url": "https://www.mediawiki.org/wiki/Extension:Labeled_Section_Transclusion/#1608971183075",
                "name": "transclusion"
            }
        },
        {
            "timestamp": 1608972296174,
            "collection": "pages",
            "objectPk": "en.wikipedia.org/wiki/Help:Wikitext",
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Help:Wikitext",
                "fullUrl": "https://en.wikipedia.org/wiki/Help:Wikitext",
                "domain": "wikipedia.org",
                "hostname": "en.wikipedia.org",
                "fullTitle": "Help:Wikitext - Wikipedia",
                "text": " Help:Wikitext From Wikipedia, the free encyclopedia Jump to navigation Jump to search Wikipedia help page For the encyclopedic article on Wikitext, see Wikitext . Abbreviations Edit summaries Glossary HTML Shortcuts Templates Wikitext Directory This help page is a how-to guide . It details processes or procedures of some aspect(s) of Wikipedia's norms and practices. It is not one of Wikipedia's policies or guidelines , and may reflect varying levels of consensus and vetting . Shortcuts H:WT H:MARKUP H:WIKICODE Wikitext Cheatsheet All Wikitext Magic links Visual files Sound files Tables Using templates Using HTML codes within Wikitext v t e Wikitext, also known as Wiki markup or Wikicode, consists of the syntax and keywords used by the MediaWiki software to format a page. To learn how to see this hypertext markup , and to save an edit, see Help:Editing . Generally, coding can be copied and pasted, without writing new code. There is a short list of markup and tips at Help:Cheatsheet . In addition to Wikitext, some HTML elements are also allowed for presentation formatting. See Help:HTML in wikitext for information on this. Contents 1 Layout 1.1 Sections 1.1.1 Section headings 1.1.2 Horizontal rule 1.1.3 Table of contents 1.2 Line breaks 1.3 Indent text 1.4 Blockquote 1.5 Center text 1.6 Align text to right 1.7 Lists 1.7.1 Unordered lists 1.7.2 Ordered lists 1.7.3 Description lists 1.8 Retaining newlines and spaces 2 Format 2.1 Text formatting 2.2 Special characters 2.2.1 Diacritical marks 2.2.2 Punctuation special characters 2.2.3 Escaping punctuation characters 2.2.4 Commercial symbols 2.2.5 Greek characters 2.2.6 Egyptian hieroglyphs 2.2.7 Chess symbols 2.2.8 Subscripts and superscripts 2.2.9 Characters in the Private Use Area, and invisible formatting characters 2.3 Mathematical characters and formulae 2.3.1 Mathematical characters 2.3.2 Mathematical formulae 2.3.3 Spacing in simple math formulae 2.3.4 Complicated formulae 3 Links and URLs 3.1 Free links 3.1.1 Link to another wiki article 3.1.2 Renamed link 3.1.3 Automatically rename links 3.1.4 Blend link 3.1.5 Link to a section of a page 3.1.6 Create a page link 3.2 Redirects 3.3 Link to another namespace 3.4 Link to the same article in another language (interlanguage links) 3.5 Interwiki link 3.6 Categories 3.7 External links 3.8 Automatic links 3.8.1 Book sources 3.8.2 RFC number 3.9 Miscellaneous 3.9.1 \"As of\" template 3.9.2 Media link 3.9.3 Links directly into edit mode 3.9.4 Links partially italicized 4 Pronunciation aids 5 Musical notation 6 Images 7 Tables 8 Columns 9 References and citing sources 10 Templates and transcluding pages 11 Talk and project pages 11.1 Signing comments 11.2 Linking to old revisions of pages, diffs, and specific history pages 11.3 What links here, and recent changes linked 11.4 User edits 11.5 Coloring and highlighting text 11.6 Example text 11.7 Show deleted or inserted text 11.8 Strike through 12 Limiting formatting / escaping wiki markup 12.1 Nowiki 12.1.1 Displaying wikilinks 12.1.2 Displaying template calls 12.1.3 Displaying magic words 12.1.4 Displaying tags 12.2 Pre 13 Invisible text (comments) 14 Variables 15 HTML 16 Common templates 16.1 Image 16.2 Cite Web 16.3 Cite Journal 16.4 Cite Book (Short) 16.5 Cite Book (Extended) 16.6 Metric Conversions 16.7 Variables 16.8 Recalling Named Reference 16.9 Quote 16.10 Blockquote 16.11 About 16.12 Table (Borderless) 16.13 Table Style 1 16.14 Table Style 2 (Wikitable) 16.15 Collapsible Table, Default: Collapsed 16.16 Columns 16.17 Interwiki 16.18 Vandalism Response Templates 16.19 Page Citation 17 Notes 18 See also Layout Sections Sections in a page will follow the page's lead/introduction , and under certain conditions, the table of contents . Section headings Further information: Help:Section and MOS:HEAD The = through ====== markup are headings for the sections with which they are associated. A single = is styled as the article title and should not be used within an article. Headings are styled through CSS and add an [edit] link. See this section for the relevant CSS. Four or more headings cause a table of contents to be generated automatically. Do not use any markup after the final heading markup this will either break the heading, or will cause the heading to not be included in an edit summary. Markup Renders as = Heading 1 = == Heading 2 == === Heading 3 === ==== Heading 4 ==== ===== Heading 5 ===== ====== Heading 6 ====== Heading 1 Heading 2 Heading 3 Heading 4 Heading 5 Heading 6 Templates: {{ fake heading }} for use in documentation. Horizontal rule Further information: WP:LINE The horizontal rule represents a paragraph-level thematic break. Do not use in article content, as rules are used only after main sections, and this is automatic. Markup Renders as ---- HTML equivalent: <hr /> Table of contents Further information: WP:TOC When a page has at least four headings, a table of contents (TOC) will automatically appear after the lead and before the first heading. The TOC can be controlled by magic words or templates: __FORCETOC__ forces the TOC to appear at the normal location regardless of the number of headings. __TOC__ forces the TOC to appear at the point where the magic word is inserted instead of the normal location. __NOTOC__ disables the TOC entirely. {{ TOC limit }} can be used to control the depth of subsections included in the TOC. This is useful where the TOC is long and unwieldy. Category:Wikipedia table of contents templates contains a number of specialized TOC templates. Line breaks Further information: Help:Line-break handling and Wikipedia:Line breaks usage Line breaks or newlines are used to add whitespace between lines, such as separating paragraphs. A line break that is visible in the content is inserted by pressing Enter twice. Pressing Enter once will place a line break in the markup, but it will not show in the rendered content, except when using list markup. Markup such as bold or italics will be terminated at a line break. Markup Renders as A single newline here has no effect on the layout. But an empty line starts a new paragraph, or ends a list or an indented part. A single newline here has no effect on the layout. But an empty line starts a new paragraph, or ends a list or an indented part. HTML equivalent: <br> or <br /> can be used to break line layout. Templates for line breaks: {{ break }} adds multiple line breaks. {{ - }} and {{ clear }} adds a break with styling, to clear floating elements. (often used to prevent text from flowing next to unrelated tables or images) Unbulleted list: {{ plainlist }} and {{ unbulleted list }} both create an unbulleted list. Indent text Further information: WP:INDENT Indentation is most commonly used on talk pages. Markup Renders as Indentation as used on talk pages: :Each colon at the start of a line ::causes the line to be indented by three more character positions. :::(The indentation persists so long as no carriage return or line break is used.) :::Repeat the indentation at any line break. ::::Use an extra colon for each response. :::::And so forth ... ::::::And so on ... {{Outdent|::::::}}The outdent template can give a visual indicator that we're deliberately cancelling the indent (6 levels here) Indentation as used on talk pages: Each colon at the start of a line causes the line to be indented by three more character positions. (The indentation persists so long as no carriage return or line break is used.) Repeat the indentation at any line break. Use an extra colon for each response. And so forth ... And so on ... The outdent template can give a visual indicator that we're deliberately cancelling the indent (6 levels here) Templates: {{ outdent }}, {{ outdent2 }} Blockquote When there is a need for separating a block of text. This is useful for (as the name says) inserting blocks of quoted (and cited) text. Markup Renders as <blockquote> The '''blockquote''' tag will indent both margins when needed instead of the left margin only as the colon does. </blockquote> The blockquote tag will indent both margins when needed instead of the left margin only as the colon does. Template {{ quote }} results in the same render. Center text See also: Span and div , HTML tag , and Template:Align Markup Renders as < div class = \"center\" style = \"width: auto; margin-left: auto; margin-right: auto;\" >Centered text </ div > Centered text Template {{ center }} uses the same markup. To center a table, see Help:Table#Centering tables . Please do not use <center>...</center> tags, as it is obsolete. Align text to right You can align content in a separate container: Markup Renders as < div style = \"text-align: right; direction: ltr; margin-left: 1em;\" >Text on the right </ div > Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Text on the rightLorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Or; make the text float around it: Markup Renders as < div class = \"floatright\" >Text on the right </ div > Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Text on the rightLorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. {{stack|Text on the right}} Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Text on the rightLorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Lists Further information: Help:List and MOS:LIST Do not leave blank lines between items in a list unless there is a reason to do so, since this causes the MediaWiki software to interpret each item as beginning a new list. Unordered lists Markup Renders as * Item1 * Item2 * Item3 * Item4 ** Sub-item 4 a) *** Sub-item 4 a) 1. **** Sub-item 4 a) 1. i) **** Sub-item 4 a) 1. ii) ** Sub-item 4 b) * Item5 Item1 Item2 Item3 Item4 Sub-item 4 a) Sub-item 4 a) 1. Sub-item 4 a) 1. i) Sub-item 4 a) 1. ii) Sub-item 4 b) Item5 Ordered lists Markup Renders as # Item1 # Item2 # Item3 # Item4 ## Sub-item 1 ### Sub-sub-item #### Sub-sub-sub-item ## Sub-item 2 # Item5 Item1 Item2 Item3 Item4 Sub-item 1 Sub-sub-item Sub-sub-sub-item Sub-item 2 Item5 Description lists Shortcut H:DL To list terms and definitions, start a new line with a semicolon (;) followed by the term. Then, type a colon (:) followed by a definition. The format can also be used for other purposes, such as make and models of vehicles, etc. Description lists (formerly definition lists, and a.k.a. association lists) consist of group names corresponding to values. Group names (terms) are in bold. Values (definitions) are indented. Each group must include one or more definitions. For a single or first value, the : can be placed on the same line after ; but subsequent values must be placed on separate lines. Do not use a semicolon (;) simply to bold a line without defining a value using a colon (:). This usage renders invalid HTML5 and creates issues with screen readers . Markup Renders as ; Term : Definition1 Term Definition1 ; Term : Definition1 : Definition2 : Definition3 : Definition4 Term Definition1 Definition2 Definition3 Definition4 HTML equivalent: <dl> <dt>...</dt>, <dd>...</dd> </dl> Templates: {{ defn }} Retaining newlines and spaces Shortcut H:POEM The MediaWiki software suppresses single newlines and converts lines starting with a space to preformatted text in a dashed box. HTML suppresses multiple spaces. It is often desirable to retain these elements for poems, lyrics, mottoes, oaths and the like. The Poem extension adds HTML-like <poem>...</poem> tags to maintain newlines and spaces. These tags may be used inside other tags such as <blockquote>...</blockquote>; the template {{ poemquote }} provides a convenient shorthand. CSS styles may be applied to this tag, e.g.: <poem style=\"margin-left: 2em;\">. Markup Renders as <poem> In Xanadu did Kubla Khan A stately pleasure-dome decree: Where Alph, the sacred river, ran Through caverns measureless to man Down to a sunless sea. So twice five miles of fertile ground With walls and towers were girdled round: And there were gardens bright with sinuous rills, Where blossomed many an incense-bearing tree; And here were forests ancient as the hills, Enfolding sunny spots of greenery. </poem> In Xanadu did Kubla Khan A stately pleasure-dome decree: Where Alph, the sacred river, ran Through caverns measureless to man Down to a sunless sea. So twice five miles of fertile ground With walls and towers were girdled round: And there were gardens bright with sinuous rills, Where blossomed many an incense-bearing tree; And here were forests ancient as the hills, Enfolding sunny spots of greenery. Poems and their translation can be presented side by side, and the language can be indicated with lang=\"xx\". Following the last side-by-side block, {{ Clear |left}} must be used to cancel \"float:left;\" and to re-establish normal flow. Note that this method does not require a table and its columns to achieve the side-by-side presentation. Markup <poem lang= \"fr\" style= \"float:left;\" >Frère Jacques, frère Jacques, Dormez-vous? Dormez-vous? Sonnez les matines! Sonnez les matines! Ding, dang, dong. Ding, dang, dong. </poem> <poem style= \"margin-left:2em; float:left;\" >Are you sleeping? Are you sleeping? Brother John, Brother John, Morning bells are ringing! Morning bells are ringing! Ding, dang, dong. Ding, dang, dong. </poem>{{Clear|left}} Renders as Frère Jacques, frère Jacques, Dormez-vous? Dormez-vous? Sonnez les matines! Sonnez les matines! Ding, dang, dong. Ding, dang, dong. Are you sleeping? Are you sleeping? Brother John, Brother John, Morning bells are ringing! Morning bells are ringing! Ding, dang, dong. Ding, dang, dong. Format Text formatting Description What you type What it looks like italics, bold, small capital letters To ''italicize text'', put two consecutive apostrophes on each side of it. Three apostrophes each side will '''bold the text'''. Five consecutive apostrophes on each side (two for italics plus three for bold) produces '''''bold italics'''''. '''''Italic and bold formatting''''' works correctly only within a single line. For text as {{smallcaps|small caps}}, use the template {{tl|smallcaps}}. To italicize text, put two consecutive apostrophes on each side of it. Three apostrophes each side will bold the text. Five consecutive apostrophes on each side (two for italics plus three for bold) produces bold italics. Italic and bold formatting works correctly only within a single line. To reverse this effect where it has been automatically applied, use {{ nobold }} and {{ noitalic }}. For text as small caps, use the template {{ smallcaps }}. Small chunks of source code within a line of normal text. Code is displayed in a monospace font. function <code>int m2()</code> is nice. function int m2() is nice. Syntax highlighting for source code. Computer code has colored text and more stringent formatting. For example, to define a function: int m2(), with highlights. See here for a full list of supported languages that can be put in lang=\"????\" <syntaxhighlight lang=\"cpp\"> #include <iostream> int m2 (int ax, char *p_ax) { std::cout <<\"Hello World!\"; return 0; }</syntaxhighlight> #include <iostream> int m2 ( int ax , char * p_ax ) { std :: cout << \"Hello World!\" ; return 0 ; } Small text Use < small >small text </ small > only when necessary. Use small text only when necessary. a <small> span To match, for example, the font-size used in an [[Help:Visual file markup#Caption|image caption]], the \"small\" tag can also be used to < small style = \"font-size:87%;\" >reduce a text's font-size to 87% </ small >. To match, for example, the font-size used in an image caption , the \"small\" tag can also be used to reduce a text's font-size to 87%. Big text Better not use < big >big text </ big >, unless < small >it's < big >within </ big > small </ small > text. Better not use big text, unless it's within small text. To prevent two words from becoming separated by a linewrap (e.g. Mr. Smith or 400 km/h) a non-breaking space , sometimes also called a \"non-printing character\", may be used between them. (For three or more words, the template {{ nowrap }} is probably more suitable.) Mr.&nbsp;Smith or 400&nbsp;km/h Mr. Smith or 400 km/h Extra spacing within text is usually best achieved using the {{ pad }} template. Mary {{pad|4.0em}} had a little lamb. Mary had a little lamb. Special characters See also: Help:Special characters and List of XML and HTML character entity references Special characters can often be displayed using numeric character references or character entity references . See Character encodings in HTML for more information. For example, &Agrave; and &#xC0; both render À (A- grave ). Percent-encoding can't be used, as it works only in URLs . Diacritical marks Diacritic marks, using character entity references. What you type What it looks like &Agrave; &Aacute; &Acirc; &Atilde; &Auml; &Aring; &AElig; &Ccedil; &Egrave; &Eacute; &Ecirc; &Euml; &Igrave; &Iacute; &Icirc; &Iuml; &Ntilde; &Ograve; &Oacute; &Ocirc; &Otilde; &Ouml; &Oslash; &OElig; &Ugrave; &Uacute; &Ucirc; &Uuml; &Yuml; &szlig; &agrave; &aacute; &acirc; &atilde; &auml; &aring; &aelig; &ccedil; &egrave; &eacute; &ecirc; &euml; &igrave; &iacute; &icirc; &iuml; &ntilde; &ograve; &oacute; &ocirc; &otilde; &ouml; &oslash; &oelig; &ugrave; &uacute; &ucirc; &uuml; &yuml; À Á Â Ã Ä Å Æ Ç È É Ê Ë Ì Í Î Ï Ñ Ò Ó Ô Õ Ö Ø Œ Ù Ú Û Ü Ÿ ß à á â ã ä å æ ç è é ê ë ì í î ï ñ ò ó ô õ ö ø œ ù ú û ü ÿ Punctuation special characters Using character entity references. What you type What it looks like &iquest; &iexcl; &sect; &para; ¿ ¡ § ¶ &dagger; &Dagger; &bull; &ndash; &mdash; &lsaquo; &rsaquo; &laquo; &raquo; « » &lsquo; &rsquo; &ldquo; &rdquo; ‘ ’ “ ” &apos; &quot; ' \" Escaping punctuation characters The <pre> , <nowiki> , and <code> markup tags are also available, for writing \"[\", \"{\", \"&\", \"}\", \"]\" for example. These tags prevent these characters from being recognised as wiki markup, which is a possibility in some circumstances. Commercial symbols Using character entity references. What you type What it looks like &trade; &copy; &reg; © ® &cent; &euro; &yen; &pound; &curren; ¢ ¥ £ ¤ Greek characters Using character entity references. What you type What it looks like &alpha; &beta; &gamma; &delta; &epsilon; &zeta; α β γ δ ε ζ &Alpha; &Beta; &Gamma; &Delta; &Epsilon; &Zeta; Α Β Γ Δ Ε Ζ &eta; &theta; &iota; &kappa; &lambda; &mu; &nu; η θ ι κ λ μ ν &Eta; &Theta; &Iota; &Kappa; &Lambda; &Mu; &Nu; Η Θ Ι Κ Λ Μ Ν &xi; &omicron; &pi; &rho; &sigma; &sigmaf; ξ ο π ρ σ ς &Xi; &Omicron; &Pi; &Rho; &Sigma; Ξ Ο Π Ρ Σ &tau; &upsilon; &phi; &chi; &psi; &omega; τ υ φ χ ψ ω &Tau; &Upsilon; &Phi; &Chi; &Psi; &Omega; Τ Υ Φ Χ Ψ Ω Egyptian hieroglyphs Main page: Help:WikiHiero syntax WikiHiero is a software extension that renders Egyptian hieroglyphs as PNG images using < hiero > tags. Example: Markup Renders as <hiero>P2</hiero> Chess symbols Main article: Chess symbols in Unicode For example, &#9812; displays Subscripts and superscripts The Manual of Style prefers the <sub> and <sup> formats, for example x <sub>1</sub>. So this should be used under most circumstances. The latter methods of sub/superscripting cannot be used in the most general context, as they rely on Unicode support that may not be present on all users' machines. Description What you type What it looks like Subscripts x < sub >1 </ sub > x < sub >2 </ sub > x < sub >3 </ sub > or x &#8320; x &#8321; x &#8322; x &#8323; x &#8324; x &#8325; x &#8326; x &#8327; x &#8328; x &#8329; x1 x2 x3 or x x x x x x x x x x Superscripts x < sup >1 </ sup > x < sup >2 </ sup > x < sup >3 </ sup > or x &#8304; x &sup1; x &sup2; x &sup3; x &#8308; x &#8309; x &#8310; x &#8311; x &#8312; x &#8313; x1 x2 x3 or x x¹ x² x³ x x x x x x Combined &epsilon; <sub>0 </sub> = 8.85 &times; 10 <sup> &minus;12 </sup> C &sup2; / J m 1 [[ hectare]] = 1 E+4 m &sup2; ε0 = 8.85 × 10 12 C² / J m 1 hectare = 1 E+4 m² Characters in the Private Use Area, and invisible formatting characters Main article: MOS:TEXT § PUA and RTL Invisible and PUA (Private Use Areas) characters should be avoided where possible. When needed, they should both be replaced with their (hexa)decimal code values (as \"&#(x)...;\"). This renders invisible characters visible, for manual editing, and allows AWB to process pages with PUA characters. The latter should also be tagged with the {{ PUA }} template for tracking and future maintenance. Mathematical characters and formulae Mathematical characters See also Wikipedia:Mathematical symbols , WikiProject Mathematics and TeX . What you type What it looks like &int; &sum; &prod; &radic; &minus; &plusmn; &infin; ± &asymp; &prop; &equiv; &ne; &le; &ge; &times; &middot; &divide; &part; × · ÷ &prime; &Prime; &nabla; &permil; &deg; &there4; &alefsym; ° &oslash; ø &isin; &notin; &cap; &cup; &sub; &sup; &sube; &supe; &not; &and; &or; &exist; &forall; ¬ &rArr; &lArr; &dArr; &uArr; &hArr; &rarr; &larr; &darr; &uarr; &harr; Mathematical formulae Main page: Help:Displaying a formula Formulae that include mathematical letters, like x, and operators like × should not use the plain letter x. See math font formatting . For a comprehensive set of symbols, and comparison between <math> tags and the {{ math }} template see section TeX vs HTML . The <math> tag typesets using LaTeX markup , [a] which may render as an image or as HTML, depending on environmental settings. The <math> tag is best for the complex formula on its own line in an image format. If you use this tag to put a formula in the line with text, put it in the {{ nowrap }} template. The {{ math }} template uses HTML , and will size-match a serif font, and will also prevent line-wrap. All templates are sensitive to the = sign, so remember to replace = with {{ = }} in template input, or start the input with 1=. Use wikimarkup '' and ''' inside the {{ math }} template, as well as other HTML entities . The {{ math }} template is best for typeset formulas in line with the text. Markup Renders as <math>2x \\times 4y \\div 6z + 8 - \\frac {y }{z ^2 } = 0</math> {{math|2''x'' &times; 4''y'' &divide; 6''z'' + 8 &minus; {{sfrac|''y''|''z'' < sup >2 </ sup >}} {{=}} 0}} <math> \\sin 2 \\pi x + \\ln e</math> {{math|sin 2&pi;''x'' + ln ''e''}} 2 x × 4 y ÷ 6 z + 8 y z 2 = 0 {\\displaystyle 2x\\times 4y\\div 6z+8-{\\frac {y}{z^{2}}}=0} 2x × 4y ÷ 6z + 8 y / z2 = 0 sin 2 π x + ln e {\\displaystyle \\sin 2\\pi x+\\ln e} sin 2πx + ln e Spacing in simple math formulae Using &nbsp; to prevent line break is not needed; the {{ math }} template will prevent line breaks anyway; you can use <br /> if you need an explicit line break inside a formula. Markup Renders as It follows that {{math|''x'' < sup >2 </ sup > &ge; 0}} for real {{mvar|x}}. It follows that x2 0 for real x. Complicated formulae See Help:Displaying a formula for how to use <math>. A formula displayed on a line by itself should probably be indented by using the colon (:) character. Markup Renders as : <math> \\sum _{n=0 }^ \\infty \\frac {x ^n }{n! }</math> n = 0 x n n ! {\\displaystyle \\sum _{n=0}^{\\infty }{\\frac {x^{n}}{n!}}} Links and URLs Main page: Help:Link Free links In Wikipedia and some other wikis , free links are used in wikitext markup to produce internal links between pages, as opposed to the concept of CamelCase for the same purpose, which was used in the early days of Wikipedia see CamelCase and Wikipedia . In Wikipedia's markup language , you create free links by putting double square brackets around text designating the title of the page you want to link to. Thus, [[Texas]] will be rendered as Texas . Optionally, you can use a vertical bar (|) to customize the link title. For example, typing [[Texas|Lone Star State]] will produce Lone Star State , a link that is displayed as \"Lone Star State\" but in fact links to Texas . Link to another wiki article Internally, the first letter of the target page is automatically capitalized and spaces are represented as underscores (typing an underscore in the link has the same effect as typing a space, but is not recommended). Thus the link hereafter is to the Web address en.wikipedia.org/wiki/Public_transport, which is the Wikipedia article with the name \"Public transport\". See also Canonicalization . A red link is a page that doesn't exist yet; it can be created by clicking on the link. A link to its own page will appear only as bold text. Markup Renders as London has [[public transport]]. London has public transport . Link to this article: \"[[Help:Wikitext]]\" will appear only as bold text. Link to this article: \" Help:Wikitext \" will appear only as bold text. Renamed link Same target, different name. The target (\"piped\") text must be placed first, then the text to be displayed second. What you type What it looks like New York also has [[public transport|public transportation]]. New York also has public transportation . Automatically rename links Simply typing the pipe character | after a link will automatically rename the link in certain circumstances. The next time you open the edit box you will see the expanded piped link. When previewing your edits, you will not see the expanded form until you press Save and Edit again. The same applies to links to sections within the same page . See Pipe trick for details. Description What you type What it looks like Automatically hide stuff in parentheses [[kingdom (biology)|]] kingdom Automatically hide the comma and following text [[Seattle, Washington|]] Seattle Automatically hide namespace [[Wikipedia:Village pump|]] Village pump Or both [[Wikipedia:Manual of Style (headings)|]] Manual of Style But this doesn't work for section links [[Wikipedia:Manual of Style#Links|]] [[Wikipedia:Manual of Style#Links|]] Blend link Endings are blended into the link. Exception: a trailing apostrophe (') and any characters following the apostrophe are not blended. Preferred style is to use this instead of a piped link, if possible. Blending can be suppressed by using the <nowiki /> tag, which may be desirable in some instances. Description What you type What it looks like Blending active San Francisco also has [[public transport]]ation. Examples include [[bus]]es, [[taxicab]]s, and [[tram]]s. San Francisco also has public transportation . Examples include buses , taxicabs , and trams . A [[micro-]]second A micro-second Blending suppressed A [[micro-]]<nowiki />second. A micro- second Link to a section of a page The part after the hash sign (#) must match a section heading on the page. Matches must be exact in terms of spelling, case, and punctuation. Links to non-existent sections are not broken; they are treated as links to the beginning of the page. Include \"| link title\" to create a stylish ( piped ) link title. If sections have the same title, add a number to link to any but the first. #Example section 3 goes to the third section named \"Example section\". You can use the pipe and retype the section title to display the text without the # symbol. What you type What it looks like [[Wikipedia:Manual of Style#Italics]] is a link to a section within another page. Wikipedia:Manual of Style#Italics is a link to a section within another page. [[#Links and URLs]] is a link to another section on the current page. [[#Links and URLs|Links and URLs]] is a link to the same section without showing the # symbol. #Links and URLs is a link to another section on the current page. Links and URLs is a link to the same section without showing the # symbol. [[Wikipedia:Manual of Style#Italics|Italics]] is a piped link to a section within another page. Italics is a piped link to a section within another page. Create a page link To create a new page: Create a link to it on some other (related) page. Save that page. Click on the link you just made. The new page will open for editing. For more information, see starting an article and check out Wikipedia's naming conventions . Please do not create a new article without linking to it from at least one other article. Description What you type What it looks like Links to pages that don’t exist yet look red. The article about [[cardboard sandwiches]] doesn't exist yet. The article about cardboard sandwiches doesn't exist yet. Redirects Main page: Help:Redirect Redirect one article title to another by placing a directive like the one shown to the right on the first line of the article (such as at a page titled \" US \"). It is possible to redirect to a section. For example, a redirect to United States#History will redirect to the History section of the United States page, if it exists. Description What you type Redirect to an article #REDIRECT [[United States]] Redirect to a section #REDIRECT [[United States#History]] Link to another namespace The full page name should be included in double square brackets. What you type What it looks like See the [[Wikipedia:Manual of Style]]. See the Wikipedia:Manual of Style . Link to the same article in another language (interlanguage links) Main pages: Help:Interlanguage links and Wikipedia:Complete list of language wikis available After the launch of Wikidata , interlanguage links are now added through it. Links in articles should exist only in special cases, for example when an article in one language has two articles in another language. To link to a corresponding page in another language, use the form: [[language code:Foreign title]]. It is recommended interlanguage links be placed at the very end of the article. Interlanguage links are not visible within the formatted article, but instead appear as language links on the sidebar (to the left) under the menu section \"languages\". NOTE: To create an inline link (a clickable link within the text) to any foreign language article, see Help:Interlanguage links#Inline interlanguage links and consider the usage notes. Description What you type Link from English article \"Plankton\" to the Spanish article \"Plancton\" . \"es\" is the language code for \"español\" (the Spanish language ). [[es:Plancton]] Other examples: French ( fr for français), German ( de for Deutsch), Russian ( ru), and simple English ( simple). [[fr:Plancton]] [[de:Plankton]] [[ru:Планктон]] [[simple:Plankton]] Interwiki link Interwiki links link to any page on other wikis. Interwikimedia links link to other Wikimedia wikis. Note that interwikimedia links use the internal link style, with double square brackets. See MetaWikiPedia:Interwiki_map for the list of shortcuts; if the site you want to link to is not on the list, use an external link . See also Wikimedia sister projects . Description What you type What it looks like Linking to a page on another wiki in English. All of these forms lead to the URL http://en.wiktionary.org/wiki/hello . Simple link. Without prefix. Named link. [[Wiktionary:hello]] [[Wiktionary:hello|]] [[Wiktionary:hello|Wiktionary definition of \"hello\"]] Wiktionary:hello hello Wiktionary definition of \"hello\" Linking to a page on another wiki in another language. All of these forms lead to the URL http://fr.wiktionary.org/wiki/bonjour . Simple link. Without prefix. Named link. [[Wiktionary:fr:bonjour]] [[Wiktionary:fr:bonjour|]] [[Wiktionary:fr:bonjour|bonjour]] Wiktionary:fr:bonjour fr:bonjour bonjour Categories To put an article in a category , place a link like [[Category:Example]] into the article. As with interlanguage links, placing these links at the end of the article is recommended. To link to a category page without putting the article into the category, use a colon prefix (\":Category\") in the link. Description What you type What it looks like Categorize an article. [[Category:Character sets]] Link to a category. [[:Category:Character sets]] Category:Character sets Without prefix. [[:Category:Character sets|]] Character sets External links Single square brackets indicate an external link. Note the use of a space (not a pipe |) to separate the URL from the link text in a named link. Square brackets may be used as normal punctuation when not linking to anything [like this]. A URL must begin with a supported URI scheme : http:// and https:// will be supported by all browsers; irc://, ircs://, ftp://, news://, mailto:, and gopher:// will require a plugin or an external application. IPv6 addresses in URLs are currently not supported. A URL containing certain characters will display and link incorrectly unless those characters are percent encoded . For example, a space must be replaced by %20. Encoding can be achieved by: Use the link button on the enhanced editing toolbar to encode the link; this tool will add the bracket markup and the linked text, which may not always be desirable. Or manually encode the URL by replacing these characters: space \" ' , ; < > ? [ ] %20 %22 %27 %2c %3b %3c %3e %3f %5b %5d Or use the {{urlencode:}} magic word. See Help:Magic words in the MediaWiki documentation for more details. See Wikipedia:External links for style issues, and Category:External link file type templates for indicating the file type of an external link with an icon. Description What you type What it looks like Named link with an external link icon [http://www.wikipedia.org Wikipedia] Wikipedia Unnamed link (Used only within article body for footnotes) [http://www.wikipedia.org] [1] Bare URL (Bad style) use <nowiki></nowiki> to keep this bad style from showing http://www.wikipedia.org http://www.wikipedia.org Link without arrow (Not often used) <span class=\"plainlinks\">[http://www.wikipedia.org Wikipedia]</span> Wikipedia Automatic links Main page: Help:Magic links Magic links are automatic links for certain unique identifiers that require no markup. They can be used for ISBN numbers, RFC numbers, and PMID numbers. Book sources Link to books using their ISBN , which creates a link to Special:BookSources . This is preferred to linking to a specific online bookstore, because it gives the reader a choice of vendors. However, if one bookstore or online service provides additional free information, such as table of contents or excerpts from the text, then a link to that source will aid the user and is recommended. ISBN links do not need any extra markup, provided you use one of the indicated formats. To create a link to Special:BookSources using alternative text (e.g. the book's title), use the internal link style with the appropriate namespace. What you type What it looks like {{ISBN|022628705X}} ISBN 022628705X {{ISBN|0-22-628705-X}} ISBN 0-22-628705-X Link to a book using [[Special:BookSources/0670037818|alternative text, such as its title]] Link to a book using alternative text, such as its title RFC number Link to an Internet Engineering Task Force Request for Comments (RFC) . What you type What it looks like Text mentioning an RFC number anywhere, e.g. RFC 4321. Text mentioning an RFC number anywhere, e.g. RFC 4321 . Miscellaneous \"As of\" template The As of template generates phrases like \"As of April 2009\" or \"as of April 2009\", and categorize information that will need updating. For an explanation of the parameters see the {{ As of }} documentation. What you type What it looks like {{As of|2009|4|df=us}} As of April 2009 [update] {{As of|2009|4|df=us|lc=y}} as of April 2009 [update] Media link To include links to non image uploads such as sounds, use a \"media\" link. For images, see next section . Some uploaded sounds are listed at Commons:Sound . What you type What it looks like [[media:Classical guitar scale.ogg|Sound]] Sound Links directly into edit mode These create links that directly go to the edit or view source tab. For example, to create links to the edit tab for this page, either of the following works: Description What you type What it looks like Using the {{ fullurl }} template [{{fullurl:Help:Wiki markup|action=edit}} edit] edit Using the {{ Edit }} template {{edit}} edit Links partially italicized Linking to a page with a title containing words that are usually italicized, such as the Hindenburg disaster article. What you type What it looks like [[Hindenburg disaster|''Hindenburg'' disaster]] Hindenburg disaster Pronunciation aids It is often desirable to provide an aid to pronunciation for a word. The IPAc-en and Respell templates can be of assistance. What you type What it looks like '''Konjac''' {{IPAc-en|lang|pron|ˈ|k|oʊ|n|j|æ|k}} Konjac English: / ˈ k oʊ n j æ k/ '''Konjac''' ({{IPAc-en|lang|pron|ˈ|k|oʊ|n|j|æ|k}} {{respell|KOHN|yak}}) Konjac ( English: / ˈ k oʊ n j æ k/ KOHN-yak ) ''Konjac'' is pronounced {{IPAc-en|ˈ|k|oʊ|n|j|æ|k}} in English. Konjac is pronounced / ˈ k oʊ n j æ k/ in English. Refer to Wikipedia:Manual of Style (pronunciation) for more information. Musical notation Main page: Help:Score Musical notation is added by using the < score >...</score> extension tag. For example: Markup Renders as <score>\\relative c' { fis d fis a d f e d c cis d e a g f ees }</score> Images Main pages: Help:Visual file markup and Wikipedia:Images Only images that have been uploaded to Wikipedia or Wikimedia Commons can be used. To upload images, use the Commons upload wizard for photos you have taken, and the Wikipedia upload page if there may be copyright issues. You can find the uploaded image on the image list . See the Wikipedia's image use policy for the policy used on Wikipedia. For further help on images, including some more versatile abilities, see the picture tutorial and extended image syntax . What you type What it looks like Notes The image name, the word thumb then the caption : [[File:wiki.png|thumb|Wikipedia logo]] The image name, the word thumb then the caption : Wikipedia logo The thumb tag automatically allows the image to be enlarged and positions it (floats) automatically to the right of the page. An enlarge icon is placed in the lower right corner. See note below about adding an alt tag This is the basic markup for most images A picture: [[File:wiki.png]] A picture: The picture name alone places the image in the text, or on the next line if there is insufficient space. Embedding the image in the text is only possible for very small images. Embedding the image will affect the vertical formatting of text. With alternative text: [[File:wiki.png|alt=Puzzle globe logo]] With alternative text: Alternative text, used when the image is unavailable or when the image is loaded in a text-only browser, or when spoken aloud, is strongly encouraged. See Alternative text for images for help on choosing it. With link: [[File:wiki.png|link=Wikipedia]] With link: The link directs to the Wikipedia page, Wikipedia , instead of the image file page. Forced to the centre of the page using the ''frame '' tag (attribute), a ''centre '' tag and a caption: [[File:wiki.png|frame|centre|alt=Puzzle globe|Wikipedia logo]] Forced to the centre of the page using the frame tag (attribute), a centre tag and a caption: Wikipedia logo The frame tag automatically floats the image right. The frame tag is only of use with very small images or ones using the px tag The attributes left, center or centre override this, and places the image to the left or the centre of the page. The last parameter is the caption that appears below the image. Forced to the left side of the page using the ''thumb '' attribute, the ''left '' attribute and a caption: [[File:wiki.png|thumb|left|alt=Puzzle globe|Wikipedia logo]] Forced to the left side of the page using the thumb attribute, the left attribute and a caption: Wikipedia logo The thumb tag automatically floats the image right. An enlarge icon is placed in the lower right corner. The attributes left, center or centre override this, and places the image to the left or the centre of the page. Forced to the right side of the page ''without '' a caption: [[File:wiki.png|right|Wikipedia encyclopedia]] Forced to the right side of the page without a caption: Captions are only displayed when the thumb or frame attributes are present The picture tutorial explains more options. A picture resized to 50 pixels... [[File:wiki.png|50 px|Wikipedia encyclopedia]] A picture resized to 50 pixels... The picture tutorial explains more options. This should be used very sparingly, thumb images are always of the same width. There is an upright attribute that can be used to display tall images. These tags are optimised for both laptop and mobile phone screens. Linking directly to the description page of an image: [[:File:wiki.png]] Linking directly to the description page of an image: File:wiki.png Clicking on an image displayed normally on a page also leads to the description page. Linking directly to an image without displaying it: [[Media:wiki.png|Image of jigsaw globe]] Linking directly to an image without displaying it: Image of jigsaw globe To include links to images shown as links instead of drawn on the page, use a \"media\" link. Example: < div style = \"display: inline; width: 220px; float: right;\" > [[File:wiki.png|50 px|Wikipedia encyclopedia]][[File:wiki.png|50 px]] </ div > Example: Using the span or div elements to separate images from text (note that this may allow images to cover text). Example: {| align=right |- | [[File:wiki.png|50 px]] |- | [[File:wiki.png|50 px]] |- | [[File:wiki.png|50 px]] |} Example: Using wiki markup to make a table in which to place a vertical column of images (this helps edit links match headers, especially in Firefox browsers). Tables Main page: Help:Table There are two ways to build tables: In special wiki-markup (see Help:Table ). Using HTML elements: <table>, <tr>, <td> or <th>. See also When tables are appropriate . Columns Main page: Help:Columns Use {{ colbegin }} and {{ colend }} to produce columns. References and citing sources Main pages: Wikipedia:Citing sources and Help:Footnotes See also: APA style , Chicago style , Harvard style , and MLA style Making a reference citing a printed or online source can be accomplished by using the <ref>...</ref> tags. Inside these tags details about the reference are added. Details about the citation can be provided using a structure provided by various templates; the table below lists some typical citation components. What it's for What you type To create the reference <ref name=\"name for reference\">Use a closing tag</ref> To cite a book {{ cite book }} To cite a web source {{ cite web }} Book ISBN |isbn=0-4397-0818-4 (ISBN of the book) Web URL |url=http://www.wikipedia.org Title |title=title of source Author |author=authors, use commas for multiple First name |first=first name Last name |last=last name Location |location=location of publisher Publisher |publisher=who published the source Date |date=2007-09-21 (date of source) Year |year=year of source Accessed date |accessdate=2008-12-25 (only if url= is included) A complete reference tag <ref name=\"WikiMarkup\"> {{cite web |url=http://en.wikipedia.org/w/index.php?title=Help:Wiki_markup |title=Help:Wiki markup |publisher=Wikimedia Foundation}} </ref> Referencing this again <ref name=\"WikiMarkup\" /> Citation needed {{ Citation needed |{{ subst:DATE }}}} Templates and transcluding pages Main page: Wikipedia:Transclusion See also: Help:Template § Noinclude, includeonly, and onlyinclude Examples for templates: {{pad|...}}, {{math|...}}, {{as of|...}}, {{edit}} Templates are segments of wiki markup that are meant to be copied automatically (\"transcluded\") into a page. They are specified by putting the template's name in {{double braces}}. Most templates are pages in the Template namespace , but it is possible to transclude mainspace pages (articles) by using {{:colon and double braces}}. There are three pairs of tags that can be used in wikitext to control how transclusion affects parts of a template or article. They determine whether or not wikitext renders, either in its own article, which we will call \"here\", or in another article where it is transcluded, which we will call \"there\". <noinclude>: the content will not be rendered there. These tags have no effect here. <includeonly>: the content will render only there, and will not render here (like invisible ink made visible by means of transclusion). <onlyinclude>: the content will render here and will render there, but it will only render there what is between these tags. There can be several such section \" elements \". Also, they can be nested. All possible renderings are achievable. For example, to render there one or more sections of the page here use <onlyinclude> tags. To append text there, wrap the addition in <includeonly> tags before, within, or after the section. To omit portions of the section, nest <noinclude> tags within it. If a page is transcluded without transclusion markup, it may cause an unintentional categorization . Any page transcluding it will contain the same category as the original page. Wrap the category markup with <noinclude> tags to prevent incorrect categorization. Some templates take parameters, as well, which you separate with the pipe character |. What you type What it looks like {{Transclusion demo}} This text comes from the page named Template:Transclusion demo . It has been transcluded into this page. {{Help:Transclusion demo}} This transclusion demo is a little bit of text from the page Help:Transclusion demo to be included into any file. This template takes two parameters, and creates underlined text with a hover box for many modern browsers supporting CSS: {{H:title|This is the hover text| Hover your mouse over this text}} Go to this page to see the H:title template itself: {{tl|H:title}} This template takes two parameters, and creates underlined text with a hover box for many modern browsers supporting CSS: Hover your mouse over this text Go to this page to see the H:title template itself: {{ H:title }} Talk and project pages These are likely to be helpful on talk and project pages . Signing comments The tilde character (~) is used when signing a comment on a talk page. Your username provides a link to your user page . Description What you type What it looks like You should sign your comments by appending four tildes to the comment, which adds your user name plus date/time. ~~~~ Username ( talk ) 06:56, 26 December 2020 (UTC) Adding three tildes will add just your user name. ~~~ Username ( talk ) Adding five tildes gives the date/time alone. ~~~~~ 06:56, 26 December 2020 (UTC) Linking to old revisions of pages, diffs, and specific history pages The external link function is mainly used for these. Open an old revision or diff, and copy the URL from the address bar, pasting it where you want it. What you type What it looks like [//en.wikipedia.org/w/index.php?title=Help:Wiki_markup&diff=330350877&oldid=330349143 Diff between revisions 330349143 and 330350877] Diff between revisions 330349143 and 330350877 You can also use an internal diff link . Unlike the template {{ diff }}, this kind of link can even be used in edit summaries. What you type What it looks like [[Special:Diff/330349143/330350877|Diff between revisions 330349143 and 330350877]] Diff between revisions 330349143 and 330350877 If the diff intended to be shown is between an immediately previous revision, the first parameter can be dropped. What you type What it looks like [[Special:Diff/330350877|Diff between revisions 330349143 and 330350877]] Diff between revisions 330349143 and 330350877 For an old revision, you can also use a permalink . Though here only the main text is guaranteed to be retained (images and templates will be shown as they are today, not as they were at the time). What you type What it looks like [[Special:Permalink/330350877|Revision 330350877]] Revision 330350877 What links here, and recent changes linked The following markup can be used. For example, for the article Beetroot : What you type What it looks like [[Special:WhatLinksHere/Beetroot]] Special:WhatLinksHere/Beetroot [[Special:RecentChangesLinked/Beetroot]] Special:RecentChangesLinked/Beetroot User edits Link to a user's contributions page . Description What you type What it looks like Username (registered users). [[Special:Contributions/UserName]] Special:Contributions/UserName IPv4 address (unregistered users). [[Special:Contributions/192.0.2.0]] Special:Contributions/192.0.2.0 IPv6 address (unregistered users). [[Special:Contributions/2001:0db8:0000:0000:0000:ff00:0042:8329]] Special:Contributions/2001:0db8:0000:0000:0000:ff00:0042:8329 Coloring and highlighting text Using the {{ Color }} and {{ Font color }} templates: What you type What it looks like I will change the color in {{color|blue|the middle part of}} this sentence. I will change the color in the middle part of this sentence. This is how to {{Font color||yellow|highlight part of a sentence}}. This is how to highlight part of a sentence. Example text The {{ xt }} family of templates can be used on help pages and user pages to highlight example text. These do not work in mainspace; that is, in articles. What you type What you get This is an {{xt|A correct example}} for comparison {{tick}} This is an A correct example for comparison Y this is an {{!xt|An incorrect example}} for example {{cross}} this is an An incorrect example for example N this is an {{mxt|In monospace}} for comparison this is an In monospace for comparison this is an {{!mxt|In monospace}} for comparison this is an In monospace for comparison this is an {{bxt|in bold}} for comparison this is an In bold for comparison this is an {{!bxt|In bold}} for comparison this is an In bold for comparison Show deleted or inserted text Further information: Wikipedia:Talk page guidelines When editing your own previous remarks in talk pages, it is sometimes appropriate to mark up deleted or inserted content: It is best to indicate deleted content using the strike-through markup <s>...</s>. It is best to indicate inserted content using the underline markup <u>...</u>. When editing regular Wikipedia articles, just make your changes, and do not mark them up in any special way. However, when the article itself discusses deleted or inserted content, such as an amendment to a statute: It is best to indicate deleted content using the strike-through markup <del>...</del>. It is best to indicate inserted content using the underline markup <ins>...</ins>. Note: <s></s> and <u></u> (speced in HTML 3 & 4) are considerably more popular than <del></del> and <ins></ins> (speced in HTML 5) on Wikipedia. What you type What it looks like You can <del>strike out deleted material</del> and <ins>underline new material</ins>. You can strike out deleted material and underline new material. Alternative markup: You can <s>strike out deleted material</s> and <u>underline new material</u>. You can strike out deleted material and underline new material. Strike through This is also possible with the {{ strike }} template. What you type What you get This is {{strike|a misplaced bit of text}} for comparison This is a misplaced bit of text for comparison Limiting formatting / escaping wiki markup A few different kinds of formatting will tell the wiki to display things as you typed them what you see is what you get! What you type What it looks like '''&lt;nowiki&gt; tag:''' <nowiki> The <nowiki> tag ignores [[wiki]] ''markup''. It reformats text by removing newlines and multiple spaces. It still interprets characters specified by &name;: &rarr; </nowiki> <nowiki> tag: The <nowiki> tag ignores [[wiki]] ''markup''. It reformats text by removing newlines and multiple spaces. It still interprets characters specified by &name;: '''&lt;pre&gt; tag:''' <pre>The <pre> tag ignores [[wiki]] ''markup'' as does the <nowiki> tag. Additionally, <pre> displays in a mono-spaced font, and does not reformat text spaces. It still interprets special characters: &rarr; </pre> <pre> tag: The <pre> tag ignores [[wiki]] ''markup'' as does the <nowiki> tag. Additionally, <pre> displays in a mono-spaced font, and does not reformat text spaces. It still interprets special characters: '''[Text without a URL]:''' Single square brackets holding [text without a HTTP URL] are preserved, but single square brackets containing a URL are treated as being an external [http://example.com/ Web link]. [Text without a URL]: Single square brackets holding [text without a HTTP URL] are preserved, but single square brackets containing a URL are treated as being an external Web link . '''Leading space: ''' Leading spaces are another way to preserve formatting. Putting a space at the beginning of each line stops the text from being reformatted. It still interprets [[wiki]] ''markup '' and special characters: &amp;rarr; Leading space: Leading spaces are another way to preserve formatting. Putting a space at the beginning of each line stops the text from being reformatted. It still interprets wiki markup and special characters: Nowiki \"WP:NOWIKI\" redirects here. For the essay about the name \"Wiki\", see Wikipedia:Don't abbreviate \"Wikipedia\" as \"Wiki\"! Shortcuts H:NOWIKI WP:NOWIKI In order for the software to interpret wiki markup, its parser first scans the page. When it sees its nowiki tags <nowiki>...</nowiki> ( escapes all contained wiki markup), and <nowiki /> (escapes the interpretations it is designed to \"break\"), it escapes its wikicode, so editors can document its markup using its markup. Article editors can normalize the font of characters trailing [[...]]outside a wikilink, which would otherwise adhere to the wikilink font. They can also add line-spacing in the wikitext. Template editors: tag <nowiki> works only on its source page, not the target; also {{#tag:nowiki | content}}, although it wraps that content in nowiki tags, it also does a pre-save transform on that content, which is entirely at odds with the intended purpose of nowiki for templates, subst, signatures, and the pipe-trick. The two kinds of nowiki operate in different ways to target content, but they both remove meaning (subtract rendering) of wiki markup, then disappear into the background font. Nowiki does nothing toward rendering, but it can add newlines to wikitext (for readability), just like the HTML comment (the preferred method) can. Unlike wiki markup, nowiki does not remove the meaning of character entities, either HTML or MediaWiki special characters . There is only one meaning for what <nowiki>...</nowiki> contains, so it needs few examples; but the singular <nowiki /> tag \"contains\" many linkage structures, where it is expected between bracketing-pair characters or in the keyword area. So this section has many examples and few mis-examples. For example, only at the beginning of a line (bol of wikitext, bol in a transclusion, or beginning of a table cell), do *, #, ; or : mean something. Markup Renders as # Ordered list Ordered list <nowiki /># Ordered list # Ordered list A [[micro-]]second. A micro-second . A [[micro-]]<nowiki />second. A micro- second. a<nowiki> b</nowiki> a b '<nowiki />'Italics' markup'<nowiki />' ''Italics' markup'' <nowiki>[[Example]]</nowiki> [[Example]] <nowiki><!-- revealed --></nowiki> <!-- revealed --> The rest of the section consists of simple, live examples showing how a single nowiki tag escapes entire linkage structures, beyond [[ wikilink ]] and {{ template }}: [[ fullpagename | label ]] {{ pagename | parameter }} [[fullpagename | {{ pagename }} ]] {{ pagename | [[ fullpagename ]] }} {{ pagename | {{ pagename }} }} Unless you use the two \"balanced\" nowiki tags, troubleshooting strip marker errors and template parameter-handling inconsistencies is a risk. Also, a rendering error may arise when two [[...]] square brackets are on the same line, or two {{...}} curly brackets are in the same section, but only when the two have the nowiki markup placed inconsistently. Displaying wikilinks (These are all live examples.) [[ wp:pagename | page name ]] [<nowiki />[ wp:pagename | page name ]] [[<nowiki /> wp:pagename | page name ]] [[ wp:pagename <nowiki />| page name ]] [[ wp:pagename | page name ]<nowiki />] page name [[ wp:pagename | page name ]] [[ wp:pagename | page name ]] [[ wp:pagename | page name ]] [[wp:pagename | page name ]] For nested structures, escaping an inner structure escapes its outer structure too. [[ wp: {{ 1x | pagename }} ]] [[ wp: {<nowiki />{ 1x | pagename }} ]] [[ wp: {{<nowiki /> 1x | pagename }} ]] [[ wp: {{ 1x <nowiki />| pagename }} ]] wp: pagename [[ wp: {{ 1x | pagename }} ]] [[ wp: {{ 1x | pagename }} ]] [[ wp: {{ 1x | pagename }} ]] For two, first pipes, two nowiki tags are required: [[ wp: pagename | {{ 1x | label }} ]] [[ wp: pagename <nowiki />| {{ 1x <nowiki />| label }} ]] <nowiki>[[ wp: pagename | {{ 1x | label }} ]] </nowiki> label [[ wp: pagename | {{ 1x | label }} ]] [[ wp: pagename | {{ 1x | label }} ]] Displaying template calls See also: Template:tl For templates, put nowiki before the first pipe. If a parameter has a wikilink, put it in that, an inmost position. {<nowiki />{ val | u=&gt; [[ms]] | 49082 }} {{<nowiki /> val | u=&gt; [[ms]] | 49082 }} {{ val <nowiki />| u=&gt; [[ms]] | 49082 }} {{ val | u= > [[ms]] | 49082 }<nowiki />} {{ val | u= > [[ ms ]<nowiki />] | 49082 }} {{ val | u=> ms | 49082 }} {{ val | u= > ms | 49082 }} {{ val | u=> ms | 49082 }} {{ val | u=> ms | 49082 }} {{ val | u= > [[ ms ]] | 49082 }} Y Displaying magic words Further information: Help:Magic words and Help:Parser function For input parameters, {{{1}}}, {{{2}}}, just write them out, unless they have a default (which goes behind their pipe): {{<nowiki />{1|default}}} {{{1|default}}} For a parser function nowiki goes between bracketing-pair characters, or anywhere before the : colon. {{ #ifeq: inYes | inYes | outYes | outNo }} {<nowiki />{ #ifeq: inYes | inYes | outYes | outNo }} {{<nowiki /> #ifeq: inYes | inYes | outYes | outNo }} {{ #ifeq<nowiki />: inYes | inYes | outYes | outNo }} {{ #ifeq: inYes | inYes | outYes | outNo }<nowiki />} outYes {{ #ifeq: inYes | inYes | outYes | outNo }} {{ #ifeq: inYes | inYes | outYes | outNo }} {{ #ifeq: inYes | inYes | outYes | outNo }} {{ #ifeq: inYes | inYes | outYes | outNo }} Behavioral switches expect the tag anywhere: 1. __HIDDENCAT__ 2. __HIDDENCAT<nowiki />__ 1. 2. __HIDDENCAT__ Displaying tags <tags> do not display; they are just markup. If you want them to, insert <nowiki /> after an < opening angle bracket; it goes only in the very front. Opening tags and closing tags must be treated separately. <span style=color:blue> Blue </span> <<nowiki />span style=color:blue> Blue <<nowiki />/span> <section end=la<nowiki />bel /> Blue <span style=color:blue> Blue </span> bel /> N Use template {{ tag }} instead of nowiki tags to display parser tags: Character entities, nowiki cannot escape. To escape HTML or special character entities, replace & with &amp;. For example, &amp;lt; &lt; To display a nowiki tag, you can (1) use {{ tag }}, (2) replace the < left angle bracket with its HTML character entity, or (3) nest nowiki tags in each other: {{ tag | nowiki }} <code>&lt; nowiki>...&lt;/ nowiki ></code> <code><<nowiki />nowiki>...<<nowiki />/ nowiki ></code> <nowiki>...</ nowiki > < nowiki>...</ nowiki > < nowiki>...</ nowiki > {{ tag | nowiki | s }} <code>&lt; nowiki /></code> <code><<nowiki /> nowiki /></code> <code><nowiki>< nowiki /></nowiki></code> <nowiki /> < nowiki /> < nowiki /> < nowiki /> Nowiki tags do not otherwise nest, so it is the second and fourth that displays: 1<nowiki>2<nowiki>3</nowiki>4</nowiki> <nowiki>{{!}}<nowiki></nowiki>{{!}}</nowiki> 12<nowiki>34</nowiki> second and fourth {{!}}<nowiki>|</nowiki> These simply scan from left to right. The paired tags cannot overlap, because the very first pair-match nullifies any intervening tags inside. Unbalanced tags always display. Nowiki tags do not display table markup, use <pre>...</pre>. Pre Shortcut WP:PRE <pre> is a parser tag that emulates the HTML <pre> tag. It defines preformatted text that is displayed in a fixed-width font and is enclosed in a dashed box. HTML and wiki markups are escaped and spaces and line breaks are preserved, but HTML entities are parsed. <pre> examples Markup Renders as <pre><!--Comment--> [[ wiki]] markup &amp; </pre> <!--Comment--> [[wiki]] markup &amp; <pre> formatted text does not wrap, thus text may extend past the browser window: Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. To resolve this, <pre> may use CSS styling to add wrapping or a horizontal scrollbar: Wrapping: <pre style=\"white-space:-moz-pre-wrap; white-space:-pre-wrap; white-space:-o-pre-wrap; white-space:pre-wrap; word-wrap:break-word;\"> Scroll bar: <pre style=\"overflow:auto; width:auto;\"> As <pre> is a parser tag, it escapes wikitext and HTML tags. This can be prevented with the use of <includeonly></includeonly> within the <pre>, making it act more like its HTML equivalent: <pre> with <includeonly></includeonly> example Markup Renders as <pre<includeonly></includeonly>> <!--Comment--> [[ wiki]] markup &amp; </pre> wiki markup & Invisible HTML <pre> tags can also be inserted by preceding text with a space character, like: wiki markup & Alternatively, consider using {{ pre2 }} template or < syntaxhighlight lang=\"text\">...</syntaxhighlight>. Invisible text (comments) See also: Help:Hidden text It's uncommon but on occasion acceptable for notes to other editors to add a hidden comment within the text of an article. These comments are visible only when editing or viewing the source of a page. Most comments should go on the appropriate Talk page . The format is to surround the hidden text with \" <!--\" and \" -->\" and may cover several lines, e.g.: <!-- An example of hidden comments This won't be visible except in \"edit\" mode. --> Another way to include a comment in the wiki markup uses the {{ Void }} template, which can be abbreviated as {{ ^ }}. This template \"expands\" to the empty string, generating no HTML output; it is visible only to people editing the wiki source. Thus {{ ^ |A lengthy comment here}} operates similarly to the comment <!-- A lengthy comment here -->. The main difference is that the template version can be nested, while attempting to nest HTML comments produces odd results. Variables See also: Help:Magic_words § Variables Code Effect Notes {{CURRENTWEEK}} 52 {{CURRENTDOW}} 6 Monday = 1, Tuesday = 2, etc., but Sunday = 0 {{CURRENTMONTH}} 12 {{CURRENTMONTHNAME}} December {{CURRENTMONTHNAMEGEN}} December {{CURRENTDAY}} 26 {{CURRENTDAYNAME}} Saturday {{CURRENTYEAR}} 2020 {{CURRENTTIME}} 06:56 {{NUMBEROFARTICLES}} 6,215,108 {{NUMBEROFPAGES}} 52,207,317 {{NUMBEROFUSERS}} 40,586,435 {{PAGENAME}} Wikitext {{NAMESPACE}} Help {{REVISIONID}} - {{REVISIONUSER}} Cedar101 {{localurl:pagename}} /wiki/Pagename {{localurl:Wikipedia:Sandbox|action=edit}} /w/index.php?title=Wikipedia:Sandbox&action=edit {{fullurl:pagename}} //en.wikipedia.org/wiki/Pagename {{fullurl:pagename|query_string}} //en.wikipedia.org/w/index.php?title=Pagename&query_string {{SERVER}} //en.wikipedia.org {{ns:1}} Talk {{ns:index}} e.g. {{ns:1}} full name of namespace {{SITENAME}} Wikipedia {{NUMBEROFARTICLES}} is the number of pages in the main namespace that contain a link and are not a redirect. This includes full articles, stubs containing a link, and disambiguation pages. {{CURRENTMONTHNAMEGEN}} is the genitive (possessive) grammatical form of the month name, as used in some languages but not in English; {{CURRENTMONTHNAME}} is the nominative (subject) form, as usually seen in English. In languages where it makes a difference, you can use constructs like {{grammar:case|word}} to convert a word from the nominative case to some other case. For example, {{grammar:genitive|{{CURRENTMONTHNAME}}}} means the same as {{CURRENTMONTHNAMEGEN}}. HTML Main page: Help:HTML in wikitext Many HTML tags can be used in wiki markup. You can check your HTML by using markup validation . Common templates hide v t e Quick Templates show Image [[File: | thumb | upright | right | alt= | caption ]] show Cite Web <ref> {{ cite web |url = |title = |author = |date = |work = |publisher = |accessdate = }} </ref> show Cite Journal <ref> {{ cite journal |last1 = |first1 = |last2 = |first2 = |year = |title = |journal = |volume = |issue = |pages = |publisher = |doi = |url = |accessdate = }} </ref> show Cite Book (Short) <ref> {{ cite book |last = |first = |authorlink = |title = |publisher = |series = |year = |doi = |isbn = }} </ref> show Cite Book (Extended) <ref> {{ cite book | last = | first = | authorlink = | coauthors = | editor = | title = | trans_title = | url = | accessdate = | edition = | series = | volume = | date = | year = | publisher = | location = | isbn = | doi = | page = | pages = | chapter = }} </ref> show Metric Conversions Single Input: {{ convert |original_value |original_unit |conversion_unit |abbr = on }} Range of Values: {{ convert |orig_val1 |range |orig_val2 |original_unit |conversion_unit |abbr = on }} EXAMPLES: {{ convert |60 |and |170 |kg |lb |abbr = on }} {{ convert |18 |° C |° F }} {{ convert |3.21 |kg |lb }} show Variables Code Effect {{CURRENTWEEK}} 52 {{CURRENTDOW}} 6 {{CURRENTMONTH}} 12 {{CURRENTMONTHNAME}} December {{CURRENTMONTHNAMEGEN}} December {{CURRENTDAY}} 26 {{CURRENTDAYNAME}} Saturday {{CURRENTYEAR}} 2020 {{CURRENTTIME}} 06:56 {{NUMBEROFARTICLES}} 6,215,108 {{NUMBEROFPAGES}} 52,207,317 {{NUMBEROFUSERS}} 40,586,435 {{PAGENAME}} Wikitext {{NAMESPACE}} Help {{REVISIONID}} - {{REVISIONUSER}} Cedar101 {{localurl:pagename}} /wiki/Pagename {{localurl:Wikipedia:Sandbox|action=edit}} /w/index.php?title=Wikipedia:Sandbox&action=edit {{fullurl:pagename}} //en.wikipedia.org/wiki/Pagename {{fullurl:pagename|query_string}} //en.wikipedia.org/w/index.php?title=Pagename&query_string {{SERVER}} //en.wikipedia.org {{ns:index}} e.g. '{{ns:1}}' fullname of namespace e.g 'Talk' {{SITENAME}} Wikipedia show Recalling Named Reference <ref name= \"NAMEOFREF\" /> show Quote {{ quote | text =| sign = }} show Blockquote < blockquote > < p >QUOTED PARAGRAPH </ p > < p >NAME, SOURCE, REFERENCE </ p > </ blockquote > show About (This page is about USE1. For other uses, see About (disambiguation).) {{ About |USE1 }} (This page is about USE1. For other uses, see PAGE2.) {{ About |USE1 ||PAGE2 }} (This page is about USE1. For USE2, see PAGE2.) {{ About |USE1 |USE2 |PAGE2 }} (This page is about USE1. For USE2, see PAGE2. For USE3, see PAGE3. For USE4, see PAGE4. For USE5, see PAGE5.) {{ About |USE1 |USE2 |PAGE2 |USE3 |PAGE3 |USE4 |PAGE4 |USE5 |PAGE5 }} show Table (Borderless) { | |- ! scope=\"col\" width=\" width : 20 em ; \" |COLUMN1 ! scope=\"col\" width=\" width : 20 em ; \" |COLUMN2 |- |ROW1 |ROW1/COL2 |- |ROW2 |ROW2/COL2 |- |} show Table Style 1 { | border=\"1\" cellpadding=\"2\" |---- ! scope=\"col\" width=\" width : 20 em ; \" |COLUMN1 ! scope=\"col\" width=\" width : 20 em ; \" |COLUMN2 |- |ROW1 |ROW1/COL2 |- |ROW2 |ROW2/COL2 |---- |} show Table Style 2 (Wikitable) { | class=\"wikitable\" style=\" text-align : left ; \" |- ! style=\" width : 20 em ; \" |COLUMN1 ! style=\" width : 20 em ; \" |COLUMN2 |- |ROW1 |ROW1/COL2 |- |ROW2 |ROW2/COL2 |- |} show Collapsible Table, Default: Collapsed { | class=\"wikitable collapsible collapsed\" style=\" text-align : left ; margin : 0 px ; \" |- ! style=\" width : 20 em ; \" |COLUMN1 ! style=\" width : 20 em ; \" |COLUMN2 |- |ROW1 |ROW1/COL2 |- |ROW2 |ROW2/COL2 |- |} show Columns {{ col - begin |width = 100 % }} {{ col - break |width = }} {{ col - end }} show Interwiki Wiki Shortcut Wikicommons [[commons:]] Wikipedia [[w:]] Wiktionary [[wikt:]] Wikibooks [[b:]] Wikisource [[s:]] Wikispecies [[species:]] Metawiki [[m:]] Mediawiki [[mw:]] show Vandalism Response Templates * {{subst:uw-vandalism1|PageName}} ~~~~ (unintentional vandalism/test) * {{subst:uw-delete1|PageName}} ~~~~ (unintentional removal of content) * {{subst:uw-vandalism2|PageName}} ~~~~ (suitable for intentional nonsense or disruption) * {{subst:uw-delete2|PageName}} ~~~~ (variant for removal of content) * {{subst:uw-vandalism3|PageName}} ~~~~ (\"please stop\" for use after level 2 warning) * {{subst:uw-delete3|PageName}} ~~~~ (please stop removing content) * {{subst:uw-vandalism4|PageName}} ~~~~ (last warning for vandalism) * {{subst:uw-delete4|PageName}} ~~~~ (last warning for removing content) * {{subst:uw-vandalism4im|PageName}} ~~~~ (only warning; for severe or grotesque vandalism only) * {{subst:uw-delete4im|PageName}} ~~~~ (only warning; for many blankings in a short period of time) show Page Citation {{ rp |page = }} Notes ^ The version of LaTeX used is a subset of AMS-LaTeX markup; see Help:Displaying a formula for details. See also Help desk See the 'Coding wiki markup' section of the Help navigation navbox below for additional links. Wikipedia:User page design center/Style Help:Magic links : magic links are automatic links for certain unique identifiers that require no markup. Wikipedia:Extended image syntax : advanced visual file markup . Help:A quick guide to templates : an introduction to templates . Help:Substitution : substitution is an alternative way of including templates than transclusion Help:Score : how to render musical scores. Help:Displaying a formula : displaying mathematical formulae. Editing Wikitext at Wikibooks Parsoid - MediaWiki application that allows for converting back and forth between wikitext and HTML. {{ Syntaxhighlight }} show Wikipedia help pages Visit the Teahouse or the Help desk for an interactive Q & A forum. FAQs (?) Reference desks (?) Noticeboards (?) Cheatsheet (?) Directories (?) About Wikipedia (?) Administration Purpose Principles Policies and guidelines What Wikipedia is not Disclaimer ( parental advice ) Making requests Who writes Wikipedia? Help for readers (?) FAQ Books Copyright Glossary Mobile access Navigation Other languages Searching Students Viewing media Contributing to Wikipedia (?) Advice for young editors Avoiding common mistakes Etiquette Simplified Manual of Style Simplified rule-set \"Ignore all rules\" \"The rules are principles\" Style-tips Tip of the day Your first article ( article wizard ) Getting started (?) Why create an account? Introductions by topic The Wikipedia Adventure Graphics tutorials Picture tutorial IRC (live chat) tutorial VisualEditor user guide Dos and don'ts (?) Accessibility Biographies Biographies (living) Categorization Consensus Discussions Disambiguation Images Leads Links Lists References Tables Titles (of articles) How-to pages and information pages (?) Appealing blocks Article deletion Categories Citations/references Referencing for beginners Citation Style 1 Cite errors References and page numbers Convert Diff Editing Minor edit toolbar edit conflict Find sources Files Footnotes Image deletion Infoboxes Linking ( link color ) Logging in Merging Page name Renaming pages Redirect Passwords Email confirmation Reverting Simple vandalism cleanup Talk pages ( archiving ) User contributions Coding (?) Wiki markup Barcharts Calculations Characters Columns Hidden text HTML Lists Magic words Music symbols Sections Sounds Tables Templates Transclusion URL Visual files Directories (?) Abbreviations Contents (Encyclopedia proper) Departments Editor's index Essays FAQs Glossary Guidelines Manual of Style Policies Tasks Tips Tools Missing Manual Ask for help on your talk page (?) show v t e Wikipedia technical help Get personal technical help at the Teahouse , Help desk , Village pump (technical) , talk pages or IRC . General technical help Browser notes Bypass cache Keyboard shortcuts Troubleshooting Editing CharInsert Edit conflict Edit toolbar Reverting How to create a page IRC Tutorial Mobile access Multilingual support Page history Page information Page name Help Printing Software notices Editnotice Special Characters Entering User access levels VisualEditor User guide Special page -related Special page help Edit filter Emailing users Logging in Reset passwords Logs Moving a page Fixing cut-and-paste moves Notifications/Echo FAQ Page Curation Page import Pending changes Random pages Recent changes Related changes Searching Linksearch Tags User contributions Watchlist What links here Wikitext Wikitext Cheatsheet Columns Line-break handling Lists Magic words For beginners Conditional expressions Switch parser function Time function Redirects Sections and TOCs Tables Introduction Basics Advanced table formatting Collapsing Conditional tables Sorting Using colours Links and diffs Links Interlanguage Interwiki Permanent Diffs Simplest diff guide Simple diff and link guide Complete diff and link guide Colon trick Link color Magic links Pipe trick URLs Media files: images, videos and sounds Media help Files Creation and usage Moving files to Commons Images Introduction to images Picture tutorial Preparing images for upload Uploading images Options to hide an image Extended image syntax SVG help Gallery tag Graphics tutorials Basic bitmap image editing How to improve image quality Graphics Lab resources Sound file markup Visual file markup Other graphics Family trees Graphs and charts How to create Barcharts To scale charts Math formulas Math symbols LaTeX symbols Rendering math Musical scores Musical symbols Timeline EasyTimeline syntax WikiHiero syntax Templates and Lua modules Templates Advanced template coding Template documentation Template index Template limits Template sandbox and test cases Citation templates Lua help Lua project Resources To do Substitution Purge Job queue Transclusion Labeled section Guide to Scribbling Data structure Namespaces Main/Article Category Draft File File description page Help Portal Project/Wikipedia Talk Archiving Template User User page design MediaWiki Bug reports and feature requests System message TimedMediaHandler extension Module Special HTML and CSS Cascading Style Sheets HTML in wikitext Catalogue of CSS classes Common.js and common.css User CSS for monospaced coding font Classes in Ambox Classes in microformats Markup validation Span tags Useful styles Customisation and tools Preferences Gadgets Skins Citation tools Cleaning up vandalism tools Customizing watchlists Hide pages IRC Scripts User scripts Guide Techniques User style Tools Alternative browsing Browser tools Editing tools Navigation shortcuts Optimum tool set Wikimedia Cloud Services Beta Features at MediaWiki Automated editing AfC helper script AutoWikiBrowser Bots Creating HotCat Huggle Navigation popups RedWarn Twinkle WPCleaner Inactive igloo STiki See also: Category:Wikipedia how-to Category:Wikipedia information pages Further navigation at: Help pages Administrators Accessibility Accounts Bots Referencing Citation metadata Templates User scripts show v t e Toolbox Templates Welcome {{ subst:Welcome }} {{ subst:Welcomeh }} {{ subst:Welcome-anon }} {{ subst:W-graphical-anon }} {{ subst:Welcome-anon-unconstructive }} {{ subst:Welcome-anon-npov }} {{ subst:welcome-t }} {{ subst:thanks }} Vandalism {{ subst:uw-vandalism1 }} {{ subst:uw-vandalism2 }} {{ subst:uw-vandalism3 }} {{ subst:uw-vandalism4 }} {{ subst:uw-vandalism4im }} Content removal {{ subst:uw-delete1 }} {{ subst:uw-delete2 }} {{ subst:uw-delete3 }} {{ subst:uw-delete4 }} {{ subst:uw-delete4im }} Check {{ subst:Copyvio |url=source}} {{ Db |...}} {{ Di-no license }} {{ Di-no source }} Dispute {{ Citation needed }} {{ Controversial }} {{ Disputed }} {{ Fringe theories }} {{ POV }} {{ Unreferenced section }} {{ Advert }} {{ Multiple issues }} Delete {{ subst:afd }} {{ subst:cfd }} {{ ffd }} {{ mfd }} {{ subst:rfd }} {{ subst:tfd }} {{ subst:proposed deletion }} Community Barnstars Community portal Current discussions Request directory Essays Departments Noticeboards Peer review RC patrol Tools Village pumps WikiProjects Protocols Policies Guidelines Manual of Style Main Did you know In the news Picture of the day Selected anniversaries Today's featured article Stats Statistics Site map External HTML to Wiki Converter for Tables Wikipedia:Directories and indexes Retrieved from \" https://en.wikipedia.org/w/index.php?title=Help:Wikitext&oldid=995627336 \" Categories : Wikipedia how-to Wikipedia editor help Wikipedia text help Wikipedia article elements help Hidden categories: Help pages with short description Wikipedia semi-protected project pages Pages using RFC magic links Navigation menu Personal tools Eskabore777 Alerts (0) Notice (1) Talk Sandbox Preferences Beta Watchlist Contributions Log out Namespaces Help page Talk Variants Views Read View source View history Watch More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Wikidata item Print/export Download as PDF Printable version In other projects MediaWiki Meta-Wiki Wikiversity Wikivoyage Languages Alemannisch العربية Azərbaycanca تۆرکجه বাংলা Башҡортса Беларуская भोजपुरी Català Чӑвашла Čeština Davvisámegiella Deutsch Dolnoserbski Ελληνικά Esperanto فارسی Français ગુજરાતી 한국어 Hornjoserbsce Hrvatski Bahasa Indonesia Italiano עברית Қазақша Lëtzebuergesch Malti Bahasa Melayu မြန်မာဘာသာ Nederlands Oʻzbekcha/ўзбекча ਪੰਜਾਬੀ Pälzisch پښتو Polski Română Русский Shqip Simple English سنڌي Slovenčina Suomi Татарча/tatarça ၽႃႇသႃႇတႆး ไทย Türkçe Удмурт Українська اردو Tiếng Việt 中文 43 more Edit links This page was last edited on 22 December 2020, at 01:38 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License ; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement Enable previews ",
                "urlTerms": [
                    "wiki",
                    "wikitext"
                ],
                "titleTerms": [
                    "wikitext",
                    "wikipedia"
                ]
            }
        },
        {
            "timestamp": 1608972296275,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "en.wikipedia.org/wiki/Help:Wikitext"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "en.wikipedia.org/wiki/Help:Wikitext",
                "fullUrl": "https://en.wikipedia.org/wiki/Help:Wikitext",
                "createdAt": "2020-12-26T08:44:56.264Z"
            }
        },
        {
            "timestamp": 1608972296286,
            "collection": "visits",
            "objectPk": [
                1608972296281,
                "en.wikipedia.org/wiki/Help:Wikitext"
            ],
            "operation": "create",
            "object": {
                "url": "en.wikipedia.org/wiki/Help:Wikitext",
                "time": 1608972296281
            }
        },
        {
            "timestamp": 1608972296294,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Help:Wikitext/#1608972295624",
            "operation": "create",
            "object": {
                "pageTitle": "Help:Wikitext - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Help:Wikitext",
                "body": "Description lists\r\n\r\nShortcut\r\n\r\n    H:DL\r\n\r\nTo list terms and definitions, start a new line with a semicolon (;) followed by the term. Then, type a colon (:) followed by a definition. The format can also be used for other purposes, such as make and models of vehicles, etc.\r\n\r\nDescription lists (formerly definition lists, and a.k.a. association lists) consist of group names corresponding to values. Group names (terms) are in bold. Values (definitions) are indented. Each group must include one or more definitions. For a single or first value, the : can be placed on the same line after ; – but subsequent values must be placed on separate lines.\r\n\r\nDo not use a semicolon (;) simply to bold a line without defining a value using a colon (:). This usage renders invalid HTML5 and creates issues with screen readers.",
                "comment": "",
                "selector": {
                    "quote": "Description lists\r\n\r\nShortcut\r\n\r\n    H:DL\r\n\r\nTo list terms and definitions, start a new line with a semicolon (;) followed by the term. Then, type a colon (:) followed by a definition. The format can also be used for other purposes, such as make and models of vehicles, etc.\r\n\r\nDescription lists (formerly definition lists, and a.k.a. association lists) consist of group names corresponding to values. Group names (terms) are in bold. Values (definitions) are indented. Each group must include one or more definitions. For a single or first value, the : can be placed on the same line after ; – but subsequent values must be placed on separate lines.\r\n\r\nDo not use a semicolon (;) simply to bold a line without defining a value using a colon (:). This usage renders invalid HTML5 and creates issues with screen readers.",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/h4[6]/span[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[26]/span[1]",
                                "endOffset": 165
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 13652,
                                "end": 14453
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Description lists\n\n\nShortcutH:DL\nTo list terms and definitions, start a new line with a semicolon (;) followed by the term. Then, type a colon (:) followed by a definition. The format can also be used for other purposes, such as make and models of vehicles, etc.\nDescription lists (formerly definition lists, and a.k.a. association lists) consist of group names corresponding to values. Group names (terms) are in bold. Values (definitions) are indented. Each group must include one or more definitions. For a single or first value, the : can be placed on the same line after ; – but subsequent values must be placed on separate lines.\nDo not use a semicolon (;) simply to bold a line without defining a value using a colon (:). This usage renders invalid HTML5 and creates issues with screen readers.",
                                "prefix": "ub-item\nSub-item 2\nItem5\n\n\n\n\n\n\n\n",
                                "suffix": "\n\n\n\n\nMarkup\nRenders as \n\n\n; Term"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T08:44:55.624Z",
                "lastEdited": "2020-12-26T08:44:55.624Z",
                "url": "https://en.wikipedia.org/wiki/Help:Wikitext/#1608972295624"
            }
        },
        {
            "timestamp": 1608972311759,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Help:Wikitext/#1608972311739",
            "operation": "create",
            "object": {
                "pageTitle": "Help:Wikitext - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Help:Wikitext",
                "body": "; Term : Definition1\r\n\r\n\t\r\n\r\nTerm\r\n    Definition1\r\n\r\n; Term\r\n: Definition1\r\n: Definition2\r\n: Definition3\r\n: Definition4\r\n\r\n\t\r\n\r\nTerm\r\n    Definition1\r\n    Definition2\r\n    Definition3\r\n    Definition4\r\n\r\n\t\r\n\r\nHTML equivalent: <dl> <dt>...</dt>, <dd>...</dd> </dl>",
                "comment": "",
                "selector": {
                    "quote": "; Term : Definition1\r\n\r\n\t\r\n\r\nTerm\r\n    Definition1\r\n\r\n; Term\r\n: Definition1\r\n: Definition2\r\n: Definition3\r\n: Definition4\r\n\r\n\t\r\n\r\nTerm\r\n    Definition1\r\n    Definition2\r\n    Definition3\r\n    Definition4\r\n\r\n\t\r\n\r\nHTML equivalent: <dl> <dt>...</dt>, <dd>...</dd> </dl>",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/table[14]/tbody[1]/tr[2]/td[1]/pre[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/p[27]/code[4]",
                                "endOffset": 5
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 14479,
                                "end": 14708
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "; Term : Definition1\n\n\n\n\n\nTerm\nDefinition1\n \n\n\n; Term\n: Definition1\n: Definition2\n: Definition3\n: Definition4\n\n\n\n\n\nTerm\nDefinition1\nDefinition2\nDefinition3\nDefinition4\n\n\n\n\n\n\n\nHTML equivalent: <dl> <dt>...</dt>, <dd>...</dd> </dl>",
                                "prefix": "aders.\n\n\n\n\nMarkup\nRenders as \n\n\n",
                                "suffix": "\nTemplates: {{defn}}\n\nRetaining "
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T08:45:11.739Z",
                "lastEdited": "2020-12-26T08:45:11.739Z",
                "url": "https://en.wikipedia.org/wiki/Help:Wikitext/#1608972311739"
            }
        },
        {
            "timestamp": 1608972420495,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Help:Wikitext/#1608972420456",
            "operation": "create",
            "object": {
                "pageTitle": "Help:Wikitext - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Help:Wikitext",
                "body": "Retaining newlines and spaces\r\nShortcut\r\n\r\n    H:POEM\r\n\r\nThe MediaWiki software suppresses single newlines and converts lines starting with a space to preformatted text in a dashed box. HTML suppresses multiple spaces. It is often desirable to retain these elements for poems, lyrics, mottoes, oaths and the like. The Poem extension adds HTML-like <poem>...</poem> tags to maintain newlines and spaces. These tags may be used inside other tags such as <blockquote>...</blockquote>; the template {{poemquote}} provides a convenient shorthand. CSS styles may be applied to this tag, e.g.: <poem style=\"margin-left: 2em;\">.\r\nMarkup \tRenders as\r\n\r\n<poem>\r\nIn Xanadu did Kubla Khan\r\n  A stately pleasure-dome decree:\r\nWhere Alph, the sacred river, ran\r\n  Through caverns measureless to man\r\nDown to a sunless sea.\r\n\r\nSo twice five miles of fertile ground\r\n  With walls and towers were girdled round:\r\nAnd there were gardens bright with sinuous rills,\r\n  Where blossomed many an incense-bearing tree;\r\nAnd here were forests ancient as the hills,\r\n  Enfolding sunny spots of greenery.\r\n</poem>\r\n\r\n\t\r\n\r\nIn Xanadu did Kubla Khan\r\n  A stately pleasure-dome decree:\r\nWhere Alph, the sacred river, ran\r\n  Through caverns measureless to man\r\nDown to a sunless sea.\r\n\r\nSo twice five miles of fertile ground\r\n  With walls and towers were girdled round:\r\nAnd there were gardens bright with sinuous rills,\r\n  Where blossomed many an incense-bearing tree;\r\nAnd here were forests ancient as the hills,\r\n  Enfolding sunny spots of greenery. ",
                "comment": "",
                "selector": {
                    "quote": "Retaining newlines and spaces\r\nShortcut\r\n\r\n    H:POEM\r\n\r\nThe MediaWiki software suppresses single newlines and converts lines starting with a space to preformatted text in a dashed box. HTML suppresses multiple spaces. It is often desirable to retain these elements for poems, lyrics, mottoes, oaths and the like. The Poem extension adds HTML-like <poem>...</poem> tags to maintain newlines and spaces. These tags may be used inside other tags such as <blockquote>...</blockquote>; the template {{poemquote}} provides a convenient shorthand. CSS styles may be applied to this tag, e.g.: <poem style=\"margin-left: 2em;\">.\r\nMarkup \tRenders as\r\n\r\n<poem>\r\nIn Xanadu did Kubla Khan\r\n  A stately pleasure-dome decree:\r\nWhere Alph, the sacred river, ran\r\n  Through caverns measureless to man\r\nDown to a sunless sea.\r\n\r\nSo twice five miles of fertile ground\r\n  With walls and towers were girdled round:\r\nAnd there were gardens bright with sinuous rills,\r\n  Where blossomed many an incense-bearing tree;\r\nAnd here were forests ancient as the hills,\r\n  Enfolding sunny spots of greenery.\r\n</poem>\r\n\r\n\t\r\n\r\nIn Xanadu did Kubla Khan\r\n  A stately pleasure-dome decree:\r\nWhere Alph, the sacred river, ran\r\n  Through caverns measureless to man\r\nDown to a sunless sea.\r\n\r\nSo twice five miles of fertile ground\r\n  With walls and towers were girdled round:\r\nAnd there were gardens bright with sinuous rills,\r\n  Where blossomed many an incense-bearing tree;\r\nAnd here were forests ancient as the hills,\r\n  Enfolding sunny spots of greenery. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/h3[8]/span[1]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/table[15]/tbody[1]/tr[2]/td[2]/div[1]/div[1]/p[1]",
                                "endOffset": 415
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 14730,
                                "end": 16212
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Retaining newlines and spaces\nShortcutH:POEM\nThe MediaWiki software suppresses single newlines and converts lines starting with a space to preformatted text in a dashed box. HTML suppresses multiple spaces. It is often desirable to retain these elements for poems, lyrics, mottoes, oaths and the like. The Poem extension adds HTML-like <poem>...</poem> tags to maintain newlines and spaces. These tags may be used inside other tags such as <blockquote>...</blockquote>; the template {{poemquote}} provides a convenient shorthand. CSS styles may be applied to this tag, e.g.: <poem style=\"margin-left: 2em;\">.\n\n\n\n\nMarkup\nRenders as \n\n\n<poem>\nIn Xanadu did Kubla Khan\n  A stately pleasure-dome decree:\nWhere Alph, the sacred river, ran\n  Through caverns measureless to man\nDown to a sunless sea.\n\nSo twice five miles of fertile ground\n  With walls and towers were girdled round:\nAnd there were gardens bright with sinuous rills,\n  Where blossomed many an incense-bearing tree;\nAnd here were forests ancient as the hills,\n  Enfolding sunny spots of greenery.\n</poem>\n\n\n\nIn Xanadu did Kubla Khan\n  A stately pleasure-dome decree:\nWhere Alph, the sacred river, ran\n  Through caverns measureless to man\nDown to a sunless sea.\n\nSo twice five miles of fertile ground\n  With walls and towers were girdled round:\nAnd there were gardens bright with sinuous rills,\n  Where blossomed many an incense-bearing tree;\nAnd here were forests ancient as the hills,\n  Enfolding sunny spots of greenery.\n",
                                "prefix": "/dd> </dl>\nTemplates: {{defn}}\n\n",
                                "suffix": "\n\n\n\n\n\n\n\n\nPoems and their transla"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T08:47:00.456Z",
                "lastEdited": "2020-12-26T08:47:00.456Z",
                "url": "https://en.wikipedia.org/wiki/Help:Wikitext/#1608972420456"
            }
        },
        {
            "timestamp": 1608972511119,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Help:Wikitext/#1608972511094",
            "operation": "create",
            "object": {
                "pageTitle": "Help:Wikitext - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Help:Wikitext",
                "body": "Poems and their translation can be presented side by side, and the language can be indicated with lang=\"xx\". Following the last side-by-side block, {{Clear|left}} must be used to cancel \"float:left;\" and to re-establish normal flow. Note that this method does not require a table and its columns to achieve the side-by-side presentation.\r\n\r\nMarkup\r\n\r\n<poem lang=\"fr\" style=\"float:left;\">Frère Jacques, frère Jacques,\r\nDormez-vous? Dormez-vous?\r\nSonnez les matines! Sonnez les matines!\r\nDing, dang, dong. Ding, dang, dong.</poem>\r\n<poem style=\"margin-left:2em; float:left;\">Are you sleeping? Are you sleeping?\r\nBrother John, Brother John,\r\nMorning bells are ringing! Morning bells are ringing!\r\nDing, dang, dong. Ding, dang, dong.</poem>{{Clear|left}}",
                "comment": "",
                "selector": {
                    "quote": "Poems and their translation can be presented side by side, and the language can be indicated with lang=\"xx\". Following the last side-by-side block, {{Clear|left}} must be used to cancel \"float:left;\" and to re-establish normal flow. Note that this method does not require a table and its columns to achieve the side-by-side presentation.\r\n\r\nMarkup\r\n\r\n<poem lang=\"fr\" style=\"float:left;\">Frère Jacques, frère Jacques,\r\nDormez-vous? Dormez-vous?\r\nSonnez les matines! Sonnez les matines!\r\nDing, dang, dong. Ding, dang, dong.</poem>\r\n<poem style=\"margin-left:2em; float:left;\">Are you sleeping? Are you sleeping?\r\nBrother John, Brother John,\r\nMorning bells are ringing! Morning bells are ringing!\r\nDing, dang, dong. Ding, dang, dong.</poem>{{Clear|left}}",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[30]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/div[15]/pre[1]",
                                "endOffset": 392
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 16221,
                                "end": 16959
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Poems and their translation can be presented side by side, and the language can be indicated with lang=\"xx\". Following the last side-by-side block, {{Clear|left}} must be used to cancel \"float:left;\" and to re-establish normal flow. Note that this method does not require a table and its columns to achieve the side-by-side presentation.\nMarkup\n\n<poem lang=\"fr\" style=\"float:left;\">Frère Jacques, frère Jacques,\nDormez-vous? Dormez-vous?\nSonnez les matines! Sonnez les matines!\nDing, dang, dong. Ding, dang, dong.</poem>\n<poem style=\"margin-left:2em; float:left;\">Are you sleeping? Are you sleeping?\nBrother John, Brother John,\nMorning bells are ringing! Morning bells are ringing!\nDing, dang, dong. Ding, dang, dong.</poem>{{Clear|left}}",
                                "prefix": "nny spots of greenery.\n\n\n\n\n\n\n\n\n\n",
                                "suffix": "\n\nRenders as\n\n\nFrère Jacques, fr"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T08:48:31.094Z",
                "lastEdited": "2020-12-26T08:49:45.569Z",
                "url": "https://en.wikipedia.org/wiki/Help:Wikitext/#1608972511094"
            }
        },
        {
            "timestamp": 1608972585603,
            "collection": "annotations",
            "objectPk": "https://en.wikipedia.org/wiki/Help:Wikitext/#1608972511094",
            "operation": "update",
            "object": {
                "pageTitle": "Help:Wikitext - Wikipedia",
                "pageUrl": "en.wikipedia.org/wiki/Help:Wikitext",
                "body": "Poems and their translation can be presented side by side, and the language can be indicated with lang=\"xx\". Following the last side-by-side block, {{Clear|left}} must be used to cancel \"float:left;\" and to re-establish normal flow. Note that this method does not require a table and its columns to achieve the side-by-side presentation.\r\n\r\nMarkup\r\n\r\n<poem lang=\"fr\" style=\"float:left;\">Frère Jacques, frère Jacques,\r\nDormez-vous? Dormez-vous?\r\nSonnez les matines! Sonnez les matines!\r\nDing, dang, dong. Ding, dang, dong.</poem>\r\n<poem style=\"margin-left:2em; float:left;\">Are you sleeping? Are you sleeping?\r\nBrother John, Brother John,\r\nMorning bells are ringing! Morning bells are ringing!\r\nDing, dang, dong. Ding, dang, dong.</poem>{{Clear|left}}",
                "comment": "",
                "selector": {
                    "quote": "Poems and their translation can be presented side by side, and the language can be indicated with lang=\"xx\". Following the last side-by-side block, {{Clear|left}} must be used to cancel \"float:left;\" and to re-establish normal flow. Note that this method does not require a table and its columns to achieve the side-by-side presentation.\r\n\r\nMarkup\r\n\r\n<poem lang=\"fr\" style=\"float:left;\">Frère Jacques, frère Jacques,\r\nDormez-vous? Dormez-vous?\r\nSonnez les matines! Sonnez les matines!\r\nDing, dang, dong. Ding, dang, dong.</poem>\r\n<poem style=\"margin-left:2em; float:left;\">Are you sleeping? Are you sleeping?\r\nBrother John, Brother John,\r\nMorning bells are ringing! Morning bells are ringing!\r\nDing, dang, dong. Ding, dang, dong.</poem>{{Clear|left}}",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[3]/div[3]/div[5]/div[1]/p[30]",
                                "startOffset": 0,
                                "endContainer": "/div[3]/div[3]/div[5]/div[1]/div[15]/pre[1]",
                                "endOffset": 392
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 16221,
                                "end": 16959
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Poems and their translation can be presented side by side, and the language can be indicated with lang=\"xx\". Following the last side-by-side block, {{Clear|left}} must be used to cancel \"float:left;\" and to re-establish normal flow. Note that this method does not require a table and its columns to achieve the side-by-side presentation.\nMarkup\n\n<poem lang=\"fr\" style=\"float:left;\">Frère Jacques, frère Jacques,\nDormez-vous? Dormez-vous?\nSonnez les matines! Sonnez les matines!\nDing, dang, dong. Ding, dang, dong.</poem>\n<poem style=\"margin-left:2em; float:left;\">Are you sleeping? Are you sleeping?\nBrother John, Brother John,\nMorning bells are ringing! Morning bells are ringing!\nDing, dang, dong. Ding, dang, dong.</poem>{{Clear|left}}",
                                "prefix": "nny spots of greenery.\n\n\n\n\n\n\n\n\n\n",
                                "suffix": "\n\nRenders as\n\n\nFrère Jacques, fr"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T08:48:31.094Z",
                "lastEdited": "2020-12-26T08:49:45.569Z",
                "url": "https://en.wikipedia.org/wiki/Help:Wikitext/#1608972511094"
            }
        },
        {
            "timestamp": 1608972585644,
            "collection": "tags",
            "objectPk": [
                "html",
                "https://en.wikipedia.org/wiki/Help:Wikitext/#1608972511094"
            ],
            "operation": "create",
            "object": {
                "url": "https://en.wikipedia.org/wiki/Help:Wikitext/#1608972511094",
                "name": "html"
            }
        },
        {
            "timestamp": 1608972585663,
            "collection": "tags",
            "objectPk": [
                "programming",
                "https://en.wikipedia.org/wiki/Help:Wikitext/#1608972511094"
            ],
            "operation": "create",
            "object": {
                "url": "https://en.wikipedia.org/wiki/Help:Wikitext/#1608972511094",
                "name": "programming"
            }
        },
        {
            "timestamp": 1608972585676,
            "collection": "tags",
            "objectPk": [
                "wikipedia",
                "https://en.wikipedia.org/wiki/Help:Wikitext/#1608972511094"
            ],
            "operation": "create",
            "object": {
                "url": "https://en.wikipedia.org/wiki/Help:Wikitext/#1608972511094",
                "name": "wikipedia"
            }
        },
        {
            "timestamp": 1608972585690,
            "collection": "tags",
            "objectPk": [
                "template",
                "https://en.wikipedia.org/wiki/Help:Wikitext/#1608972511094"
            ],
            "operation": "create",
            "object": {
                "url": "https://en.wikipedia.org/wiki/Help:Wikitext/#1608972511094",
                "name": "template"
            }
        },
        {
            "timestamp": 1608983329364,
            "collection": "favIcons",
            "objectPk": "tutorialspoint.com",
            "operation": "create",
            "object": {
                "hostname": "tutorialspoint.com",
                "favIcon": "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABEFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wUmlnaHRzPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvcmlnaHRzLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wUmlnaHRzOk1hcmtlZD0iRmFsc2UiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NjlFRjRDRkEyMkFCMTFFNDhGQTc4RkYyNTY3NTVDM0QiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NjlFRjRDRjkyMkFCMTFFNDhGQTc4RkYyNTY3NTVDM0QiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTMyBXaW5kb3dzIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OUNGRkMyMDNGNjE1MTFFMzg5OEE5Mjg0MjY2Q0I2RDEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5k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"
            }
        },
        {
            "timestamp": 1608983329397,
            "collection": "pages",
            "objectPk": "tutorialspoint.com/yaml/yaml_scalars_and_tags.htm",
            "operation": "create",
            "object": {
                "url": "tutorialspoint.com/yaml/yaml_scalars_and_tags.htm",
                "fullUrl": "https://www.tutorialspoint.com/yaml/yaml_scalars_and_tags.htm",
                "domain": "tutorialspoint.com",
                "hostname": "tutorialspoint.com",
                "fullTitle": "YAML - Scalars and Tags - Tutorialspoint",
                "text": " × Home Jobs Tools Coding Ground Current Affairs UPSC Notes Online Tutors Whiteboard Net Meeting Tutorix Login Packages Categories Academic Tutorials Big Data & Analytics Computer Programming Computer Science Databases DevOps Digital Marketing Engineering Tutorials Exams Syllabus Famous Monuments GATE Exams Tutorials Latest Technologies Machine Learning Mainframe Development Management Tutorials Mathematics Tutorials Microsoft Technologies Misc tutorials Mobile Development Java Technologies Python Technologies SAP Tutorials Programming Scripts Selected Reading Software Quality Soft Skills Telecom Tutorials UPSC IAS Exams Web Development Sports Tutorials XML Technologies Multi-Language Interview Questions × Custom Search Sort by: Relevance Relevance Date Library Videos Q/A eBooks Login Library Videos eBooks YAML Tutorial YAML - Home YAML Introduction YAML Basics YAML Indentation and Separation YAML Comments YAML Collections and Structures YAML Scalars and Tags YAML Full Length Example YAML Processes YAML Information Models YAML Syntax Characters YAML Syntax Primitives YAML Character Streams YAML Node Properties YAML Block Scalar Header YAML Flow Styles YAML Block Styles YAML Sequence Styles YAML Flow Mappings YAML Block Sequences YAML Failsafe Schema YAML JSON Schema YAML Useful Resources YAML - Quick Guide YAML - Useful Resources YAML - Discussion Selected Reading UPSC IAS Exams Notes Developer's Best Practices Questions and Answers Effective Resume Writing HR Interview Questions Computer Glossary Who is Who YAML - Scalars and Tags Advertisements Previous Page Next Page Scalars in YAML are written in block format using a literal type which is denoted as(|). It denotes line breaks count. In YAML, scalars are written in folded style (>) where each line denotes a folded space which ends with an empty line or more indented line. New lines are preserved in literals are shown below ASCII Art --- | \\//||\\/|| // || ||__ The folded newlines are preserved for more indented lines and blank lines as shown below > Sammy Sosa completed another fine season with great stats . 63 Home Runs 0.288 Batting Average What a year ! YAML flow scalars include plain styles and quoted styles. The double quoted style includes various escape sequences. Flow scalars can include multiple lines; line breaks are always folded in this structure. plain: This unquoted scalar spans many lines. quoted: \"So does this quoted scalar.\\n\" In YAML, untagged nodes are specified with a specific type of the application. The examples of tags specification generally use seq, map and str types for YAML tag repository. The tags are represented as examples which are mentioned as below Integer tags These tags include integer values in them. They are also called as numeric tags. canonical: 12345 decimal: +12,345 sexagecimal: 3:25:45 octal: 014 hexadecimal: 0xC Floating point numbers These tags include decimal and exponential values. They are also called as exponential tags. canonical: 1.23015e+3 exponential: 12.3015e+02 sexagecimal: 20:30.15 fixed: 1,230.15 negative infinity: -.inf not a number: .NaN Miscellaneous Tags It includes a variety of integer, floating and string values embedded in them. Hence it is called miscellaneous tags. null: ~ true: y false: n string: '12345' Previous Page Print Page Next Page Advertisements Print Add Notes Bookmark this page Report Error Suggestions Save Close Dashboard Logout About us Refund Policy Terms of use Privacy Policy FAQ's Contact © Copyright 2020. All Rights Reserved. ",
                "urlTerms": [
                    "yaml",
                    "scalars",
                    "tags",
                    "htm"
                ],
                "titleTerms": [
                    "yaml",
                    "scalars",
                    "tags",
                    "tutorialspoint"
                ]
            }
        },
        {
            "timestamp": 1608983329431,
            "collection": "pageListEntries",
            "objectPk": [
                20201014,
                "tutorialspoint.com/yaml/yaml_scalars_and_tags.htm"
            ],
            "operation": "create",
            "object": {
                "listId": 20201014,
                "pageUrl": "tutorialspoint.com/yaml/yaml_scalars_and_tags.htm",
                "fullUrl": "https://www.tutorialspoint.com/yaml/yaml_scalars_and_tags.htm",
                "createdAt": "2020-12-26T11:48:49.419Z"
            }
        },
        {
            "timestamp": 1608983329443,
            "collection": "visits",
            "objectPk": [
                1608983329439,
                "tutorialspoint.com/yaml/yaml_scalars_and_tags.htm"
            ],
            "operation": "create",
            "object": {
                "url": "tutorialspoint.com/yaml/yaml_scalars_and_tags.htm",
                "time": 1608983329439
            }
        },
        {
            "timestamp": 1608983329452,
            "collection": "annotations",
            "objectPk": "https://www.tutorialspoint.com/yaml/yaml_scalars_and_tags.htm/#1608983329208",
            "operation": "create",
            "object": {
                "pageTitle": "YAML - Scalars and Tags - Tutorialspoint",
                "pageUrl": "tutorialspoint.com/yaml/yaml_scalars_and_tags.htm",
                "body": "Scalars in YAML are written in block format using a literal type which is denoted as(|). It denotes line breaks count. In YAML, scalars are written in folded style (>) where each line denotes a folded space which ends with an empty line or more indented line.",
                "comment": "",
                "selector": {
                    "quote": "Scalars in YAML are written in block format using a literal type which is denoted as(|). It denotes line breaks count. In YAML, scalars are written in folded style (>) where each line denotes a folded space which ends with an empty line or more indented line.",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[1]/div[1]/div[2]/p[1]",
                                "startOffset": 0,
                                "endContainer": "/div[1]/div[1]/div[2]/p[1]",
                                "endOffset": 259
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 2594,
                                "end": 2853
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Scalars in YAML are written in block format using a literal type which is denoted as(|). It denotes line breaks count. In YAML, scalars are written in folded style (>) where each line denotes a folded space which ends with an empty line or more indented line.",
                                "prefix": " Previous Page\n\n\nNext Page  \n\n\n\n",
                                "suffix": "\nNew lines are preserved in lite"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T11:48:49.208Z",
                "lastEdited": "2020-12-26T11:48:49.208Z",
                "url": "https://www.tutorialspoint.com/yaml/yaml_scalars_and_tags.htm/#1608983329208"
            }
        },
        {
            "timestamp": 1608985735927,
            "collection": "pages",
            "objectPk": "yaml.org/spec/1.2/spec.html",
            "operation": "update",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "fullUrl": "https://yaml.org/spec/1.2/spec.html#id2708649",
                "domain": "yaml.org",
                "hostname": "yaml.org",
                "fullTitle": "YAML Ain’t Markup Language (YAML™) Version 1.2",
                "text": " YAML Ain’t Markup Language ( YAML ) Version 1.2 3rd Edition, Patched at 2009-10-01 Oren Ben-Kiki < oren@ben-kiki.org > Clark Evans < cce@clarkevans.com > Ingy döt Net < ingy@ingy.net > Latest (patched) version: HTML: http://yaml.org/spec/1.2/spec.html PDF: http://yaml.org/spec/1.2/spec.pdf PS: http://yaml.org/spec/1.2/spec.ps Errata: http://yaml.org/spec/1.2/errata.html Previous (original) version: http://yaml.org/spec/1.2/2009-07-21/spec.html Copyright © 2001-2009 Oren Ben-Kiki, Clark Evans, Ingy döt Net This document may be freely copied, provided it is not modified. Status of this Document This document reflects the third version of YAML data serialization language. The content of the specification was arrived at by consensus of its authors and through user feedback on the yaml-core mailing list. We encourage implementers to please update their software with support for this version. The primary objective of this revision is to bring YAML into compliance with JSON as an official subset. YAML 1.2 is compatible with 1.1 for most practical applications - this is a minor revision. An expected source of incompatibility with prior versions of YAML, especially the syck implementation, is the change in implicit typing rules. We have removed unique implicit typing rules and have updated these rules to align them with JSON's productions. In this version of YAML, boolean values may be serialized as “ true” or “ false”; the empty scalar as “ null”. Unquoted numeric values are a superset of JSON's numeric production. Other changes in the specification were the removal of the Unicode line breaks and production bug fixes. We also define 3 built-in implicit typing rule sets: untyped, strict JSON, and a more flexible YAML rule set that extends JSON typing. The difference between late 1.0 drafts which syck 0.55 implements and the 1.1 revision of this specification is much more extensive. We fixed usability issues with the tagging syntax. In particular, the single exclamation was re-defined for private types and a simple prefixing mechanism was introduced. This revision also fixed many production edge cases and introduced a type repository. Therefore, there are several incompatibilities between syck and this revision as well. The list of known errors in this specification is available at http://yaml.org/spec/1.2/errata.html . Please report errors in this document to the yaml-core mailing list. This revision contains fixes for all errors known as of 2009-10-01. We wish to thank implementers who have tirelessly tracked earlier versions of this specification, and our fabulous user community whose feedback has both validated and clarified our direction. Abstract YAML (rhymes with “ camel”) is a human-friendly, cross language, Unicode based data serialization language designed around the common native data types of agile programming languages. It is broadly useful for programming needs ranging from configuration files to Internet messaging to object persistence to data auditing. Together with the Unicode standard for characters , this specification provides all the information necessary to understand YAML Version 1.2 and to create programs that process YAML information. Table of Contents 1. Introduction 1.1. Goals 1.2. Prior Art 1.3. Relation to JSON 1.4. Relation to XML 1.5. Terminology 2. Preview 2.1. Collections 2.2. Structures 2.3. Scalars 2.4. Tags 2.5. Full Length Example 3. Processing YAML Information 3.1. Processes 3.1.1. Dump 3.1.2. Load 3.2. Information Models 3.2.1. Representation Graph 3.2.1.1. Nodes 3.2.1.2. Tags 3.2.1.3. Node Comparison 3.2.2. Serialization Tree 3.2.2.1. Keys Order 3.2.2.2. Anchors and Aliases 3.2.3. Presentation Stream 3.2.3.1. Node Styles 3.2.3.2. Scalar Formats 3.2.3.3. Comments 3.2.3.4. Directives 3.3. Loading Failure Points 3.3.1. Well-Formed Streams and Identified Aliases 3.3.2. Resolved Tags 3.3.3. Recognized and Valid Tags 3.3.4. Available Tags 4. Syntax Conventions 4.1. Production Parameters 4.2. Production Naming Conventions 5. Characters 5.1. Character Set 5.2. Character Encodings 5.3. Indicator Characters 5.4. Line Break Characters 5.5. White Space Characters 5.6. Miscellaneous Characters 5.7. Escaped Characters 6. Basic Structures 6.1. Indentation Spaces 6.2. Separation Spaces 6.3. Line Prefixes 6.4. Empty Lines 6.5. Line Folding 6.6. Comments 6.7. Separation Lines 6.8. Directives 6.8.1. “ YAML” Directives 6.8.2. “ TAG” Directives 6.8.2.1. Tag Handles 6.8.2.2. Tag Prefixes 6.9. Node Properties 6.9.1. Node Tags 6.9.2. Node Anchors 7. Flow Styles 7.1. Alias Nodes 7.2. Empty Nodes 7.3. Flow Scalar Styles 7.3.1. Double-Quoted Style 7.3.2. Single-Quoted Style 7.3.3. Plain Style 7.4. Flow Collection Styles 7.4.1. Flow Sequences 7.4.2. Flow Mappings 7.5. Flow Nodes 8. Block Styles 8.1. Block Scalar Styles 8.1.1. Block Scalar Headers 8.1.1.1. Block Indentation Indicator 8.1.1.2. Block Chomping Indicator 8.1.2. Literal Style 8.1.3. Folded Style 8.2. Block Collection Styles 8.2.1. Block Sequences 8.2.2. Block Mappings 8.2.3. Block Nodes 9. YAML Character Stream 9.1. Documents 9.1.1. Document Prefix 9.1.2. Document Markers 9.1.3. Bare Documents 9.1.4. Explicit Documents 9.1.5. Directives Documents 9.2. Streams 10. Recommended Schemas 10.1. Failsafe Schema 10.1.1. Tags 10.1.1.1. Generic Mapping 10.1.1.2. Generic Sequence 10.1.1.3. Generic String 10.1.2. Tag Resolution 10.2. JSON Schema 10.2.1. Tags 10.2.1.1. Null 10.2.1.2. Boolean 10.2.1.3. Integer 10.2.1.4. Floating Point 10.2.2. Tag Resolution 10.3. Core Schema 10.3.1. Tags 10.3.2. Tag Resolution 10.4. Other Schemas Index Chapter 1. Introduction “ YAML Ain’t Markup Language” (abbreviated YAML) is a data serialization language designed to be human-friendly and work well with modern programming languages for common everyday tasks. This specification is both an introduction to the YAML language and the concepts supporting it, and also a complete specification of the information needed to develop applications for processing YAML. Open, interoperable and readily understandable tools have advanced computing immensely. YAML was designed from the start to be useful and friendly to people working with data. It uses Unicode printable characters, some of which provide structural information and the rest containing the data itself. YAML achieves a unique cleanness by minimizing the amount of structural characters and allowing the data to show itself in a natural and meaningful way. For example, indentation may be used for structure, colons separate key: value pairs , and dashes are used to create “ bullet” lists . There are myriad flavors of data structures , but they can all be adequately represented with three basic primitives: mappings (hashes/dictionaries), sequences (arrays/lists) and scalars (strings/numbers). YAML leverages these primitives, and adds a simple typing system and aliasing mechanism to form a complete language for serializing any native data structure . While most programming languages can use YAML for data serialization, YAML excels in working with those languages that are fundamentally built around the three basic primitives. These include the new wave of agile languages such as Perl, Python, PHP, Ruby, and Javascript. There are hundreds of different languages for programming, but only a handful of languages for storing and transferring data. Even though its potential is virtually boundless, YAML was specifically created to work well for common use cases such as: configuration files, log files, interprocess messaging, cross-language data sharing, object persistence, and debugging of complex data structures. When data is easy to view and understand, programming becomes a simpler task. 1.1. Goals The design goals for YAML are, in decreasing priority: YAML is easily readable by humans. YAML data is portable between programming languages. YAML matches the native data structures of agile languages. YAML has a consistent model to support generic tools. YAML supports one-pass processing. YAML is expressive and extensible. YAML is easy to implement and use. 1.2. Prior Art YAML’s initial direction was set by the data serialization and markup language discussions among SML-DEV members . Later on, it directly incorporated experience from Ingy döt Net’s Perl module Data::Denter . Since then, YAML has matured through ideas and support from its user community. YAML integrates and builds upon concepts described by C , Java , Perl , Python , Ruby , RFC0822 (MAIL), RFC1866 (HTML), RFC2045 (MIME), RFC2396 (URI), XML , SAX , SOAP , and JSON . The syntax of YAML was motivated by Internet Mail (RFC0822) and remains partially compatible with that standard. Further, borrowing from MIME (RFC2045), YAML’s top-level production is a stream of independent documents , ideal for message-based distributed processing systems. YAML’s indentation -based scoping is similar to Python’s (without the ambiguities caused by tabs ). Indented blocks facilitate easy inspection of the data’s structure. YAML’s literal style leverages this by enabling formatted text to be cleanly mixed within an indented structure without troublesome escaping . YAML also allows the use of traditional indicator -based scoping similar to JSON’s and Perl’s. Such flow content can be freely nested inside indented blocks . YAML’s double-quoted style uses familiar C-style escape sequences . This enables ASCII encoding of non- printable or 8-bit (ISO 8859-1) characters such as “ \\x3B” . Non- printable 16-bit Unicode and 32-bit (ISO/IEC 10646) characters are supported with escape sequences such as “ \\u003B” and “ \\U0000003B” . Motivated by HTML’s end-of-line normalization, YAML’s line folding employs an intuitive method of handling line breaks . A single line break is folded into a single space , while empty lines are interpreted as line break characters. This technique allows for paragraphs to be word-wrapped without affecting the canonical form of the scalar content . YAML’s core type system is based on the requirements of agile languages such as Perl, Python, and Ruby. YAML directly supports both collections ( mappings , sequences ) and scalars . Support for these common types enables programmers to use their language’s native data structures for YAML manipulation, instead of requiring a special document object model (DOM). Like XML’s SOAP, YAML supports serializing a graph of native data structures through an aliasing mechanism. Also like SOAP, YAML provides for application -defined types . This allows YAML to represent rich data structures required for modern distributed computing. YAML provides globally unique type names using a namespace mechanism inspired by Java’s DNS-based package naming convention and XML’s URI-based namespaces. In addition, YAML allows for private types specific to a single application . YAML was designed to support incremental interfaces that include both input (“ getNextEvent()”) and output (“ sendNextEvent()”) one-pass interfaces. Together, these enable YAML to support the processing of large documents (e.g. transaction logs) or continuous streams (e.g. feeds from a production machine). 1.3. Relation to JSON Both JSON and YAML aim to be human readable data interchange formats. However, JSON and YAML have different priorities. JSON’s foremost design goal is simplicity and universality. Thus, JSON is trivial to generate and parse, at the cost of reduced human readability. It also uses a lowest common denominator information model, ensuring any JSON data can be easily processed by every modern programming environment. In contrast, YAML’s foremost design goals are human readability and support for serializing arbitrary native data structures . Thus, YAML allows for extremely readable files, but is more complex to generate and parse. In addition, YAML ventures beyond the lowest common denominator data types, requiring more complex processing when crossing between different programming environments. YAML can therefore be viewed as a natural superset of JSON, offering improved human readability and a more complete information model. This is also the case in practice; every JSON file is also a valid YAML file. This makes it easy to migrate from JSON to YAML if/when the additional features are required. JSON's RFC4627 requires that mappings keys merely “ SHOULD” be unique , while YAML insists they “ MUST” be. Technically, YAML therefore complies with the JSON spec, choosing to treat duplicates as an error. In practice, since JSON is silent on the semantics of such duplicates, the only portable JSON files are those with unique keys, which are therefore valid YAML files. It may be useful to define a intermediate format between YAML and JSON. Such a format would be trivial to parse (but not very human readable), like JSON. At the same time, it would allow for serializing arbitrary native data structures , like YAML. Such a format might also serve as YAML’s \"canonical format\". Defining such a “ YSON” format (YSON is a Serialized Object Notation) can be done either by enhancing the JSON specification or by restricting the YAML specification. Such a definition is beyond the scope of this specification. 1.4. Relation to XML Newcomers to YAML often search for its correlation to the eXtensible Markup Language (XML). Although the two languages may actually compete in several application domains, there is no direct correlation between them. YAML is primarily a data serialization language. XML was designed to be backwards compatible with the Standard Generalized Markup Language (SGML), which was designed to support structured documentation. XML therefore had many design constraints placed on it that YAML does not share. XML is a pioneer in many domains, YAML is the result of lessons learned from XML and other technologies. It should be mentioned that there are ongoing efforts to define standard XML/YAML mappings. This generally requires that a subset of each language be used. For more information on using both XML and YAML, please visit http://yaml.org/xml . 1.5. Terminology This specification uses key words based on RFC2119 to indicate requirement level. In particular, the following words are used to describe the actions of a YAML processor : May The word may, or the adjective optional, mean that conforming YAML processors are permitted to, but need not behave as described. Should The word should, or the adjective recommended, mean that there could be reasons for a YAML processor to deviate from the behavior described, but that such deviation could hurt interoperability and should therefore be advertised with appropriate notice. Must The word must, or the term required or shall, mean that the behavior described is an absolute requirement of the specification. The rest of this document is arranged as follows. Chapter 2 provides a short preview of the main YAML features. Chapter 3 describes the YAML information model, and the processes for converting from and to this model and the YAML text format. The bulk of the document, chapters 4 through 9 , formally define this text format. Finally, chapter 10 recommends basic YAML schemas. Chapter 2. Preview This section provides a quick glimpse into the expressive power of YAML. It is not expected that the first-time reader grok all of the examples. Rather, these selections are used as motivation for the remainder of the specification. 2.1. Collections YAML’s block collections use indentation for scope and begin each entry on its own line. Block sequences indicate each entry with a dash and space ( “ - ” ). Mappings use a colon and space ( “ : ” ) to mark each key: value pair . Comments begin with an octothorpe (also called a “ hash”, “ sharp”, “ pound”, or “ number sign” - “ #” ). Example 2.1. Sequence of Scalars (ball players) - Mark McGwire - Sammy Sosa - Ken Griffey Example 2.2. Mapping Scalars to Scalars (player statistics) hr: 65 # Home runs avg: 0.278 # Batting average rbi: 147 # Runs Batted In Example 2.3. Mapping Scalars to Sequences (ball clubs in each league) american: - Boston Red Sox - Detroit Tigers - New York Yankees national: - New York Mets - Chicago Cubs - Atlanta Braves Example 2.4. Sequence of Mappings (players’ statistics) - name: Mark McGwire hr: 65 avg: 0.278 - name: Sammy Sosa hr: 63 avg: 0.288 YAML also has flow styles , using explicit indicators rather than indentation to denote scope. The flow sequence is written as a comma separated list within square brackets . In a similar manner, the flow mapping uses curly braces . Example 2.5. Sequence of Sequences - [name , hr, avg ] - [Mark McGwire, 65, 0.278] - [Sammy Sosa , 63, 0.288] Example 2.6. Mapping of Mappings Mark McGwire: {hr: 65, avg: 0.278} Sammy Sosa: { hr: 63, avg: 0.288 } 2.2. Structures YAML uses three dashes ( “ ---” ) to separate directives from document content . This also serves to signal the start of a document if no directives are present. Three dots ( “ ...” ) indicate the end of a document without starting a new one, for use in communication channels. Example 2.7. Two Documents in a Stream (each with a leading comment) # Ranking of 1998 home runs --- - Mark McGwire - Sammy Sosa - Ken Griffey # Team ranking --- - Chicago Cubs - St Louis Cardinals Example 2.8. Play by Play Feed from a Game --- time: 20:03:20 player: Sammy Sosa action: strike (miss) ... --- time: 20:03:47 player: Sammy Sosa action: grand slam ... Repeated nodes (objects) are first identified by an anchor (marked with the ampersand - “ &” ), and are then aliased (referenced with an asterisk - “ *” ) thereafter. Example 2.9. Single Document with Two Comments --- hr: # 1998 hr ranking - Mark McGwire - Sammy Sosa rbi: # 1998 rbi ranking - Sammy Sosa - Ken Griffey Example 2.10. Node for “ Sammy Sosa” appears twice in this document --- hr: - Mark McGwire # Following node labeled SS - &SS Sammy Sosa rbi: - *SS # Subsequent occurrence - Ken Griffey A question mark and space ( “ ? ” ) indicate a complex mapping key . Within a block collection , key: value pairs can start immediately following the dash , colon , or question mark . Example 2.11. Mapping between Sequences ? - Detroit Tigers - Chicago cubs : - 2001-07-23 ? [ New York Yankees, Atlanta Braves ] : [ 2001-07-02, 2001-08-12, 2001-08-14 ] Example 2.12. Compact Nested Mapping --- # Products purchased - item : Super Hoop quantity: 1 - item : Basketball quantity: 4 - item : Big Shoes quantity: 1 2.3. Scalars Scalar content can be written in block notation, using a literal style (indicated by “ |” ) where all line breaks are significant. Alternatively, they can be written with the folded style (denoted by “ >” ) where each line break is folded to a space unless it ends an empty or a more-indented line. Example 2.13. In literals, newlines are preserved # ASCII Art --- | \\//||\\/|| // || ||__ Example 2.14. In the folded scalars, newlines become spaces --- > Mark McGwire's year was crippled by a knee injury. Example 2.15. Folded newlines are preserved for \"more indented\" and blank lines > Sammy Sosa completed another fine season with great stats. 63 Home Runs 0.288 Batting Average What a year! Example 2.16. Indentation determines scope name: Mark McGwire accomplishment: > Mark set a major league home run record in 1998. stats: | 65 Home Runs 0.278 Batting Average YAML’s flow scalars include the plain style (most examples thus far) and two quoted styles. The double-quoted style provides escape sequences . The single-quoted style is useful when escaping is not needed. All flow scalars can span multiple lines; line breaks are always folded . Example 2.17. Quoted Scalars unicode: \"Sosa did fine.\\u263A\" control: \"\\b1998\\t1999\\t2000\\n\" hex esc: \"\\x0d\\x0a is \\r\\n\" single: '\"Howdy!\" he cried.' quoted: ' # Not a ''comment''.' tie-fighter: '|\\-*-/|' Example 2.18. Multi-line Flow Scalars plain: This unquoted scalar spans many lines. quoted: \"So does this quoted scalar.\\n\" 2.4. Tags In YAML, untagged nodes are given a type depending on the application . The examples in this specification generally use the seq , map and str types from the fail safe schema . A few examples also use the int , float , and null types from the JSON schema . The repository includes additional types such as binary , omap , set and others. Example 2.19. Integers canonical: 12345 decimal: +12345 octal: 0o14 hexadecimal: 0xC Example 2.20. Floating Point canonical: 1.23015e+3 exponential: 12.3015e+02 fixed: 1230.15 negative infinity: -.inf not a number: .NaN Example 2.21. Miscellaneous null: booleans: [ true, false ] string: '012345' Example 2.22. Timestamps canonical: 2001-12-15T02:59:43.1Z iso8601: 2001-12-14t21:59:43.10-05:00 spaced: 2001-12-14 21:59:43.10 -5 date: 2002-12-14 Explicit typing is denoted with a tag using the exclamation point ( “ !” ) symbol. Global tags are URIs and may be specified in a tag shorthand notation using a handle . Application -specific local tags may also be used. Example 2.23. Various Explicit Tags --- not-date: !!str 2002-04-28 picture: !!binary | R0lGODlhDAAMAIQAAP//9/X 17unp5WZmZgAAAOfn515eXv Pz7Y6OjuDg4J+fn5OTk6enp 56enmleECcgggoBADs= application specific tag: !something | The semantics of the tag above may be different for different documents. Example 2.24. Global Tags %TAG ! tag:clarkevans.com,2002: --- !shape # Use the ! handle for presenting # tag:clarkevans.com,2002:circle - !circle center: &ORIGIN {x: 73, y: 129} radius: 7 - !line start: *ORIGIN finish: { x: 89, y: 102 } - !label start: *ORIGIN color: 0xFFEEBB text: Pretty vector drawing. Example 2.25. Unordered Sets # Sets are represented as a # Mapping where each key is # associated with a null value --- !!set ? Mark McGwire ? Sammy Sosa ? Ken Griff Example 2.26. Ordered Mappings # Ordered maps are represented as # A sequence of mappings, with # each mapping having one key --- !!omap - Mark McGwire: 65 - Sammy Sosa: 63 - Ken Griffy: 58 2.5. Full Length Example Below are two full-length examples of YAML. On the left is a sample invoice; on the right is a sample log file. Example 2.27. Invoice --- !<tag:clarkevans.com,2002:invoice> invoice: 34843 date : 2001-01-23 bill-to: &id001 given : Chris family : Dumars address: lines: | 458 Walkman Dr. Suite #292 city : Royal Oak state : MI postal : 48046 ship-to: *id001 product: - sku : BL394D quantity : 4 description : Basketball price : 450.00 - sku : BL4438H quantity : 1 description : Super Hoop price : 2392.00 tax : 251.42 total: 4443.52 comments: Late afternoon is best. Backup contact is Nancy Billsmer @ 338-4338. Example 2.28. Log File --- Time: 2001-11-23 15:01:42 -5 User: ed Warning: This is an error message for the log file --- Time: 2001-11-23 15:02:31 -5 User: ed Warning: A slightly different error message. --- Date: 2001-11-23 15:03:17 -5 User: ed Fatal: Unknown variable \"bar\" Stack: - file: TopClass.py line: 23 code: | x = MoreObject(\"345\\n\") - file: MoreClass.py line: 58 code: |- foo = bar Chapter 3. Processing YAML Information YAML is both a text format and a method for presenting any native data structure in this format. Therefore, this specification defines two concepts: a class of data objects called YAML representations , and a syntax for presenting YAML representations as a series of characters, called a YAML stream . A YAML processor is a tool for converting information between these complementary views. It is assumed that a YAML processor does its work on behalf of another module, called an application. This chapter describes the information structures a YAML processor must provide to or obtain from the application. YAML information is used in two ways: for machine processing, and for human consumption. The challenge of reconciling these two perspectives is best done in three distinct translation stages: representation , serialization , and presentation . Representation addresses how YAML views native data structures to achieve portability between programming environments. Serialization concerns itself with turning a YAML representation into a serial form, that is, a form with sequential access constraints. Presentation deals with the formatting of a YAML serialization as a series of characters in a human-friendly manner. 3.1. Processes Translating between native data structures and a character stream is done in several logically distinct stages, each with a well defined input and output data model, as shown in the following diagram: Figure 3.1. Processing Overview A YAML processor need not expose the serialization or representation stages. It may translate directly between native data structures and a character stream ( dump and load in the diagram above). However, such a direct translation should take place so that the native data structures are constructed only from information available in the representation . In particular, mapping key order , comments , and tag handles should not be referenced during composition . 3.1.1. Dump Dumping native data structures to a character stream is done using the following three stages: Representing Native Data Structures YAML represents any native data structure using three node kinds : sequence - an ordered series of entries; mapping - an unordered association of unique keys to values ; and scalar - any datum with opaque structure presentable as a series of Unicode characters. Combined, these primitives generate directed graph structures. These primitives were chosen because they are both powerful and familiar: the sequence corresponds to a Perl array and a Python list, the mapping corresponds to a Perl hash table and a Python dictionary. The scalar represents strings, integers, dates, and other atomic data types. Each YAML node requires, in addition to its kind and content , a tag specifying its data type. Type specifiers are either global URIs, or are local in scope to a single application . For example, an integer is represented in YAML with a scalar plus the global tag “ tag:yaml.org,2002:int”. Similarly, an invoice object, particular to a given organization, could be represented as a mapping together with the local tag “ !invoice”. This simple model can represent any data structure independent of programming language. Serializing the Representation Graph For sequential access mediums, such as an event callback API, a YAML representation must be serialized to an ordered tree. Since in a YAML representation , mapping keys are unordered and nodes may be referenced more than once (have more than one incoming “ arrow”), the serialization process is required to impose an ordering on the mapping keys and to replace the second and subsequent references to a given node with place holders called aliases . YAML does not specify how these serialization details are chosen. It is up to the YAML processor to come up with human-friendly key order and anchor names, possibly with the help of the application . The result of this process, a YAML serialization tree , can then be traversed to produce a series of event calls for one-pass processing of YAML data. Presenting the Serialization Tree The final output process is presenting the YAML serializations as a character stream in a human-friendly manner. To maximize human readability, YAML offers a rich set of stylistic options which go far beyond the minimal functional needs of simple data storage. Therefore the YAML processor is required to introduce various presentation details when creating the stream , such as the choice of node styles , how to format scalar content , the amount of indentation , which tag handles to use, the node tags to leave unspecified , the set of directives to provide and possibly even what comments to add. While some of this can be done with the help of the application , in general this process should be guided by the preferences of the user. 3.1.2. Load Loading native data structures from a character stream is done using the following three stages: Parsing the Presentation Stream Parsing is the inverse process of presentation , it takes a stream of characters and produces a series of events. Parsing discards all the details introduced in the presentation process, reporting only the serialization events. Parsing can fail due to ill-formed input. Composing the Representation Graph Composing takes a series of serialization events and produces a representation graph . Composing discards all the details introduced in the serialization process, producing only the representation graph . Composing can fail due to any of several reasons, detailed below . Constructing Native Data Structures The final input process is constructing native data structures from the YAML representation . Construction must be based only on the information available in the representation , and not on additional serialization or presentation details such as comments , directives , mapping key order , node styles , scalar content format , indentation levels etc. Construction can fail due to the unavailability of the required native data types . 3.2. Information Models This section specifies the formal details of the results of the above processes. To maximize data portability between programming languages and implementations, users of YAML should be mindful of the distinction between serialization or presentation properties and those which are part of the YAML representation . Thus, while imposing a order on mapping keys is necessary for flattening YAML representations to a sequential access medium, this serialization detail must not be used to convey application level information. In a similar manner, while indentation technique and a choice of a node style are needed for the human readability, these presentation details are neither part of the YAML serialization nor the YAML representation . By carefully separating properties needed for serialization and presentation , YAML representations of application information will be consistent and portable between various programming environments. The following diagram summarizes the three information models. Full arrows denote composition, hollow arrows denote inheritance, “ 1” and “ *” denote “ one” and “ many” relationships. A single “ +” denotes serialization details, a double “ ++” denotes presentation details. Figure 3.2. Information Models 3.2.1. Representation Graph YAML’s representation of native data structure is a rooted, connected, directed graph of tagged nodes . By “ directed graph” we mean a set of nodes and directed edges (“ arrows”), where each edge connects one node to another (see a formal definition ). All the nodes must be reachable from the root node via such edges. Note that the YAML graph may include cycles, and a node may have more than one incoming edge. Nodes that are defined in terms of other nodes are collections ; nodes that are independent of any other nodes are scalars . YAML supports two kinds of collection nodes : sequences and mappings . Mapping nodes are somewhat tricky because their keys are unordered and must be unique . Figure 3.3. Representation Model 3.2.1.1. Nodes A YAML node represents a single native data structure . Such nodes have content of one of three kinds: scalar, sequence, or mapping. In addition, each node has a tag which serves to restrict the set of possible values the content can have. Scalar The content of a scalar node is an opaque datum that can be presented as a series of zero or more Unicode characters. Sequence The content of a sequence node is an ordered series of zero or more nodes. In particular, a sequence may contain the same node more than once. It could even contain itself (directly or indirectly). Mapping The content of a mapping node is an unordered set of key: value node pairs, with the restriction that each of the keys is unique . YAML places no further restrictions on the nodes. In particular, keys may be arbitrary nodes, the same node may be used as the value of several key: value pairs, and a mapping could even contain itself as a key or a value (directly or indirectly). When appropriate, it is convenient to consider sequences and mappings together, as collections. In this view, sequences are treated as mappings with integer keys starting at zero. Having a unified collections view for sequences and mappings is helpful both for theoretical analysis and for creating practical YAML tools and APIs. This strategy is also used by the Javascript programming language. 3.2.1.2. Tags YAML represents type information of native data structures with a simple identifier, called a tag. Global tags are URIs and hence globally unique across all applications . The “ tag:” URI scheme is recommended for all global YAML tags. In contrast, local tags are specific to a single application . Local tags start with “ !”, are not URIs and are not expected to be globally unique. YAML provides a “ TAG” directive to make tag notation less verbose; it also offers easy migration from local to global tags. To ensure this, local tags are restricted to the URI character set and use URI character escaping . YAML does not mandate any special relationship between different tags that begin with the same substring. Tags ending with URI fragments (containing “ #”) are no exception; tags that share the same base URI but differ in their fragment part are considered to be different, independent tags. By convention, fragments are used to identify different “ variants” of a tag, while “ /” is used to define nested tag “ namespace” hierarchies. However, this is merely a convention, and each tag may employ its own rules. For example, Perl tags may use “ ::” to express namespace hierarchies, Java tags may use “ .”, etc. YAML tags are used to associate meta information with each node . In particular, each tag must specify the expected node kind ( scalar , sequence , or mapping ). Scalar tags must also provide a mechanism for converting formatted content to a canonical form for supporting equality testing. Furthermore, a tag may provide additional information such as the set of allowed content values for validation, a mechanism for tag resolution , or any other data that is applicable to all of the tag’s nodes . 3.2.1.3. Node Comparison Since YAML mappings require key uniqueness, representations must include a mechanism for testing the equality of nodes . This is non-trivial since YAML allows various ways to format scalar content . For example, the integer eleven can be written as “ 0o13” (octal) or “ 0xB” (hexadecimal). If both notations are used as keys in the same mapping , only a YAML processor which recognizes integer formats would correctly flag the duplicate key as an error. Canonical Form YAML supports the need for scalar equality by requiring that every scalar tag must specify a mechanism for producing the canonical form of any formatted content . This form is a Unicode character string which also presents the same content , and can be used for equality testing. While this requirement is stronger than a well defined equality operator, it has other uses, such as the production of digital signatures. Equality Two nodes must have the same tag and content to be equal. Since each tag applies to exactly one kind , this implies that the two nodes must have the same kind to be equal. Two scalars are equal only when their tags and canonical forms are equal character-by-character. Equality of collections is defined recursively. Two sequences are equal only when they have the same tag and length, and each node in one sequence is equal to the corresponding node in the other sequence . Two mappings are equal only when they have the same tag and an equal set of keys , and each key in this set is associated with equal values in both mappings . Different URI schemes may define different rules for testing the equality of URIs. Since a YAML processor cannot be reasonably expected to be aware of them all, it must resort to a simple character-by-character comparison of tags to ensure consistency. This also happens to be the comparison method defined by the “ tag:” URI scheme. Tags in a YAML stream must therefore be presented in a canonical way so that such comparison would yield the correct results. Identity Two nodes are identical only when they represent the same native data structure . Typically, this corresponds to a single memory address. Identity should not be confused with equality; two equal nodes need not have the same identity. A YAML processor may treat equal scalars as if they were identical. In contrast, the separate identity of two distinct but equal collections must be preserved. 3.2.2. Serialization Tree To express a YAML representation using a serial API, it is necessary to impose an order on mapping keys and employ alias nodes to indicate a subsequent occurrence of a previously encountered node . The result of this process is a serialization tree, where each node has an ordered set of children. This tree can be traversed for a serial event-based API. Construction of native data structures from the serial interface should not use key order or anchor names for the preservation of application data. Figure 3.4. Serialization Model 3.2.2.1. Keys Order In the representation model, mapping keys do not have an order. To serialize a mapping , it is necessary to impose an ordering on its keys . This order is a serialization detail and should not be used when composing the representation graph (and hence for the preservation of application data). In every case where node order is significant, a sequence must be used. For example, an ordered mapping can be represented as a sequence of mappings , where each mapping is a single key: value pair . YAML provides convenient compact notation for this case. 3.2.2.2. Anchors and Aliases In the representation graph , a node may appear in more than one collection . When serializing such data, the first occurrence of the node is identified by an anchor. Each subsequent occurrence is serialized as an alias node which refers back to this anchor. Otherwise, anchor names are a serialization detail and are discarded once composing is completed. When composing a representation graph from serialized events, an alias node refers to the most recent node in the serialization having the specified anchor. Therefore, anchors need not be unique within a serialization . In addition, an anchor need not have an alias node referring to it. It is therefore possible to provide an anchor for all nodes in serialization . 3.2.3. Presentation Stream A YAML presentation is a stream of Unicode characters making use of of styles , scalar content formats , comments , directives and other presentation details to present a YAML serialization in a human readable way. Although a YAML processor may provide these details when parsing , they should not be reflected in the resulting serialization . YAML allows several serialization trees to be contained in the same YAML character stream, as a series of documents separated by markers . Documents appearing in the same stream are independent; that is, a node must not appear in more than one serialization tree or representation graph . Figure 3.5. Presentation Model 3.2.3.1. Node Styles Each node is presented in some style, depending on its kind . The node style is a presentation detail and is not reflected in the serialization tree or representation graph . There are two groups of styles. Block styles use indentation to denote structure; In contrast, flow styles styles rely on explicit indicators . YAML provides a rich set of scalar styles. Block scalar styles include the literal style and the folded style . Flow scalar styles include the plain style and two quoted styles, the single-quoted style and the double-quoted style . These styles offer a range of trade-offs between expressive power and readability. Normally, block sequences and mappings begin on the next line. In some cases, YAML also allows nested block collections to start in-line for a more compact notation . In addition, YAML provides a compact notation for flow mappings with a single key: value pair , nested inside a flow sequence . These allow for a natural “ ordered mapping” notation. Figure 3.6. Kind/Style Combinations 3.2.3.2. Scalar Formats YAML allows scalars to be presented in several formats. For example, the integer “ 11” might also be written as “ 0xB”. Tags must specify a mechanism for converting the formatted content to a canonical form for use in equality testing. Like node style , the format is a presentation detail and is not reflected in the serialization tree and representation graph . 3.2.3.3. Comments Comments are a presentation detail and must not have any effect on the serialization tree or representation graph . In particular, comments are not associated with a particular node . The usual purpose of a comment is to communicate between the human maintainers of a file. A typical example is comments in a configuration file. Comments must not appear inside scalars , but may be interleaved with such scalars inside collections . 3.2.3.4. Directives Each document may be associated with a set of directives . A directive has a name and an optional sequence of parameters. Directives are instructions to the YAML processor , and like all other presentation details are not reflected in the YAML serialization tree or representation graph . This version of YAML defines a two directives, “ YAML” and “ TAG” . All other directives are reserved for future versions of YAML. 3.3. Loading Failure Points The process of loading native data structures from a YAML stream has several potential failure points. The character stream may be ill-formed , aliases may be unidentified , unspecified tags may be unresolvable , tags may be unrecognized , the content may be invalid , and a native type may be unavailable . Each of these failures results with an incomplete loading. A partial representation need not resolve the tag of each node , and the canonical form of formatted scalar content need not be available. This weaker representation is useful for cases of incomplete knowledge of the types used in the document . In contrast, a complete representation specifies the tag of each node , and provides the canonical form of formatted scalar content , allowing for equality testing. A complete representation is required in order to construct native data structures . Figure 3.7. Loading Failure Points 3.3.1. Well-Formed Streams and Identified Aliases A well-formed character stream must match the BNF productions specified in the following chapters. Successful loading also requires that each alias shall refer to a previous node identified by the anchor . A YAML processor should reject ill-formed streams and unidentified aliases. A YAML processor may recover from syntax errors, possibly by ignoring certain parts of the input, but it must provide a mechanism for reporting such errors. 3.3.2. Resolved Tags Typically, most tags are not explicitly specified in the character stream . During parsing , nodes lacking an explicit tag are given a non-specific tag: “ !” for non- plain scalars , and “ ?” for all other nodes . Composing a complete representation requires each such non-specific tag to be resolved to a specific tag, be it a global tag or a local tag . Resolving the tag of a node must only depend on the following three parameters: (1) the non-specific tag of the node , (2) the path leading from the root to the node , and (3) the content (and hence the kind ) of the node . When a node has more than one occurrence (using aliases ), tag resolution must depend only on the path to the first ( anchored ) occurrence of the node . Note that resolution must not consider presentation details such as comments , indentation and node style . Also, resolution must not consider the content of any other node , except for the content of the key nodes directly along the path leading from the root to the resolved node . Finally, resolution must not consider the content of a sibling node in a collection , or the content of the value node associated with a key node being resolved. These rules ensure that tag resolution can be performed as soon as a node is first encountered in the stream , typically before its content is parsed . Also, tag resolution only requires referring to a relatively small number of previously parsed nodes . Thus, in most cases, tag resolution in one-pass processors is both possible and practical. YAML processors should resolve nodes having the “ !” non-specific tag as “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map” or “ tag:yaml.org,2002:str” depending on their kind . This tag resolution convention allows the author of a YAML character stream to effectively “ disable” the tag resolution process. By explicitly specifying a “ !” non-specific tag property , the node would then be resolved to a “ vanilla” sequence , mapping , or string, according to its kind . Application specific tag resolution rules should be restricted to resolving the “ ?” non-specific tag, most commonly to resolving plain scalars . These may be matched against a set of regular expressions to provide automatic resolution of integers, floats, timestamps, and similar types. An application may also match the content of mapping nodes against sets of expected keys to automatically resolve points, complex numbers, and similar types. Resolved sequence node types such as the “ ordered mapping” are also possible. That said, tag resolution is specific to the application . YAML processors should therefore provide a mechanism allowing the application to override and expand these default tag resolution rules. If a document contains unresolved tags, the YAML processor is unable to compose a complete representation graph. In such a case, the YAML processor may compose a partial representation , based on each node’s kind and allowing for non-specific tags. 3.3.3. Recognized and Valid Tags To be valid, a node must have a tag which is recognized by the YAML processor and its content must satisfy the constraints imposed by this tag . If a document contains a scalar node with an unrecognized tag or invalid content, only a partial representation may be composed . In contrast, a YAML processor can always compose a complete representation for an unrecognized or an invalid collection , since collection equality does not depend upon knowledge of the collection’s data type. However, such a complete representation cannot be used to construct a native data structure . 3.3.4. Available Tags In a given processing environment, there need not be an available native type corresponding to a given tag . If a node’s tag is unavailable, a YAML processor will not be able to construct a native data structure for it. In this case, a complete representation may still be composed , and an application may wish to use this representation directly. Chapter 4. Syntax Conventions The following chapters formally define the syntax of YAML character streams , using parameterized BNF productions. Each BNF production is both named and numbered for easy reference. Whenever possible, basic structures are specified before the more complex structures using them in a “ bottom up” fashion. The order of alternatives inside a production is significant. Subsequent alternatives are only considered when previous ones fails. See for example the b-break production. In addition, production matching is expected to be greedy. Optional ( ?), zero-or-more ( *) and one-or-more ( +) patterns are always expected to match as much of the input as possible. The productions are accompanied by examples, which are given side-by-side next to equivalent YAML text in an explanatory format. This format uses only flow collections , double-quoted scalars , and explicit tags for each node . A reference implementation using the productions is available as the YamlReference Haskell package. This reference implementation is also available as an interactive web application at http://dev.yaml.org/ypaste . 4.1. Production Parameters YAML’s syntax is designed for maximal human readability. This requires parsing to depend on the surrounding text. For notational compactness, this dependency is expressed using parameterized BNF productions. This context sensitivity is the cause of most of the complexity of the YAML syntax definition. It is further complicated by struggling with the human tendency to look ahead when interpreting text. These complications are of course the source of most of YAML’s power to present data in a very human readable way. Productions use any of the following parameters: Indentation: n or m Many productions use an explicit indentation level parameter. This is less elegant than Python’s “ indent” and “ undent” conceptual tokens. However it is required to formally express YAML’s indentation rules. Context: c This parameter allows productions to tweak their behavior according to their surrounding. YAML supports two groups of contexts, distinguishing between block styles and flow styles . In block styles , indentation is used to delineate structure. To capture human perception of indentation the rules require special treatment of the “ -” character, used in block sequences . Hence in some cases productions need to behave differently inside block sequences ( block-in context) and outside them ( block-out context). In flow styles , explicit indicators are used to delineate structure. These styles can be viewed as the natural extension of JSON to cover tagged , single-quoted and plain scalars . Since the latter have no delineating indicators , they are subject to some restrictions to avoid ambiguities. These restrictions depend on where they appear: as implicit keys directly inside a block mapping ( block-key); as implicit keys inside a flow mapping ( flow-key); as values inside a flow collection ( flow-in); or as values outside one ( flow-out). (Block) Chomping: t Block scalars offer three possible mechanisms for chomping any trailing line breaks : strip , clip and keep . Unlike the previous parameters, this only controls interpretation; the line breaks are valid in all cases. 4.2. Production Naming Conventions To make it easier to follow production combinations, production names use a Hungarian-style naming convention. Each production is given a prefix based on the type of characters it begins and ends with. e- A production matching no characters. c- A production starting and ending with a special character. b- A production matching a single line break . nb- A production starting and ending with a non- break character. s- A production starting and ending with a white space character. ns- A production starting and ending with a non- space character. l- A production matching complete line(s). X - Y - A production starting with an X - character and ending with a Y - character, where X - and Y - are any of the above prefixes. X +, X - Y + A production as above, with the additional property that the matched content indentation level is greater than the specified n parameter. Chapter 5. Characters 5.1. Character Set To ensure readability, YAML streams use only the printable subset of the Unicode character set. The allowed character range explicitly excludes the C0 control block #x0-#x1F (except for TAB #x9, LF #xA, and CR #xD which are allowed), DEL #x7F, the C1 control block #x80-#x9F (except for NEL #x85 which is allowed), the surrogate block #xD800-#xDFFF, #xFFFE, and #xFFFF. On input, a YAML processor must accept all Unicode characters except those explicitly excluded above. On output, a YAML processor must only produce acceptable characters. Any excluded characters must be presented using escape sequences. In addition, any allowed characters known to be non-printable should also be escaped . This isn’t mandatory since a full implementation would require extensive character property tables. [1] c-printable ::= #x9 | #xA | #xD | [#x20-#x7E] /* 8 bit */ | #x85 | [#xA0-#xD7FF] | [#xE000-#xFFFD] /* 16 bit */ | [#x10000-#x10FFFF] /* 32 bit */ To ensure JSON compatibility , YAML processors must allow all non-control characters inside quoted scalars . To ensure readability, non-printable characters should be escaped on output, even inside such scalars . Note that JSON quoted scalars cannot span multiple lines or contain tabs , but YAML quoted scalars can. [2] nb-json ::= #x9 | [#x20-#x10FFFF] 5.2. Character Encodings All characters mentioned in this specification are Unicode code points. Each such code point is written as one or more bytes depending on the character encoding used. Note that in UTF-16, characters above #xFFFF are written as four bytes, using a surrogate pair. The character encoding is a presentation detail and must not be used to convey content information. On input, a YAML processor must support the UTF-8 and UTF-16 character encodings. For JSON compatibility , the UTF-32 encodings must also be supported. If a character stream begins with a byte order mark, the character encoding will be taken to be as as indicated by the byte order mark. Otherwise, the stream must begin with an ASCII character. This allows the encoding to be deduced by the pattern of null ( #x00) characters. To make it easier to concatenate streams , byte order marks may appear at the start of any document . However all documents in the same stream must use the same character encoding. To allow for JSON compatibility , byte order marks are also allowed inside quoted scalars . For readability, such content byte order marks should be escaped on output. The encoding can therefore be deduced by matching the first few bytes of the stream with the following table rows (in order): Byte0 Byte1 Byte2 Byte3 Encoding Explicit BOM #x00 #x00 #xFE #xFF UTF-32BE ASCII first character #x00 #x00 #x00 any UTF-32BE Explicit BOM #xFF #xFE #x00 #x00 UTF-32LE ASCII first character any #x00 #x00 #x00 UTF-32LE Explicit BOM #xFE #xFF UTF-16BE ASCII first character #x00 any UTF-16BE Explicit BOM #xFF #xFE UTF-16LE ASCII first character any #x00 UTF-16LE Explicit BOM #xEF #xBB #xBF UTF-8 Default UTF-8 The recommended output encoding is UTF-8. If another encoding is used, it is recommended that an explicit byte order mark be used, even if the first stream character is ASCII. For more information about the byte order mark and the Unicode character encoding schemes see the Unicode FAQ . [3] c-byte-order-mark ::= #xFEFF In the examples, byte order mark characters are displayed as “ ”. Example 5.1. Byte Order Mark # Comment only. Legend: c-byte-order-mark # This stream contains no # documents, only comments. Example 5.2. Invalid Byte Order Mark - Invalid use of BOM - Inside a document. ERROR: A BOM must not appear inside a document. 5.3. Indicator Characters Indicators are characters that have special semantics. [4] c-sequence-entry ::= “ -” A “ -” ( #x2D, hyphen) denotes a block sequence entry. [5] c-mapping-key ::= “ ?” A “ ?” ( #x3F, question mark) denotes a mapping key . [6] c-mapping-value ::= “ :” A “ :” ( #x3A, colon) denotes a mapping value . Example 5.3. Block Structure Indicators sequence : - one - two mapping : ? sky : blue sea : green Legend: c-sequence-entry c-mapping-key c-mapping-value %YAML 1.2 --- !!map { ? !!str \"sequence\" : !!seq [ !!str \"one\", !!str \"two\" ], ? !!str \"mapping\" : !!map { ? !!str \"sky\" : !!str \"blue\", ? !!str \"sea\" : !!str \"green\", }, } [7] c-collect-entry ::= “ ,” A “ ,” ( #x2C, comma) ends a flow collection entry. [8] c-sequence-start ::= “ [” A “ [” ( #x5B, left bracket) starts a flow sequence . [9] c-sequence-end ::= “ ]” A “ ]” ( #x5D, right bracket) ends a flow sequence . [10] c-mapping-start ::= “ {” A “ {” ( #x7B, left brace) starts a flow mapping . [11] c-mapping-end ::= “ }” A “ }” ( #x7D, right brace) ends a flow mapping . Example 5.4. Flow Collection Indicators sequence: [ one , two , ] mapping: { sky: blue , sea: green } Legend: c-sequence-start c-sequence-end c-mapping-start c-mapping-end c-collect-entry %YAML 1.2 --- !!map { ? !!str \"sequence\" : !!seq [ !!str \"one\", !!str \"two\" ], ? !!str \"mapping\" : !!map { ? !!str \"sky\" : !!str \"blue\", ? !!str \"sea\" : !!str \"green\", }, } [12] c-comment ::= “ #” An “ #” ( #x23, octothorpe, hash, sharp, pound, number sign) denotes a comment . Example 5.5. Comment Indicator # Comment only. Legend: c-comment # This stream contains no # documents, only comments. [13] c-anchor ::= “ &” An “ &” ( #x26, ampersand) denotes a node’s anchor property . [14] c-alias ::= “ *” An “ *” ( #x2A, asterisk) denotes an alias node . [15] c-tag ::= “ !” The “ !” ( #x21, exclamation) is heavily overloaded for specifying node tags . It is used to denote tag handles used in tag directives and tag properties ; to denote local tags ; and as the non-specific tag for non- plain scalars . Example 5.6. Node Property Indicators anchored: !local &anchor value alias: *anchor Legend: c-tag c-anchor c-alias %YAML 1.2 --- !!map { ? !!str \"anchored\" : !local &A1 \"value\", ? !!str \"alias\" : *A1, } [16] c-literal ::= “ |” A “ |” ( 7C, vertical bar) denotes a literal block scalar . [17] c-folded ::= “ >” A “ >” ( #x3E, greater than) denotes a folded block scalar . Example 5.7. Block Scalar Indicators literal: | some text folded: > some text Legend: c-literal c-folded %YAML 1.2 --- !!map { ? !!str \"literal\" : !!str \"some\\ntext\\n\", ? !!str \"folded\" : !!str \"some text\\n\", } [18] c-single-quote ::= “ '” An “ '” ( #x27, apostrophe, single quote) surrounds a single-quoted flow scalar . [19] c-double-quote ::= “ \"” A “ \"” ( #x22, double quote) surrounds a double-quoted flow scalar . Example 5.8. Quoted Scalar Indicators single: 'text ' double: \"text \" Legend: c-single-quote c-double-quote %YAML 1.2 --- !!map { ? !!str \"single\" : !!str \"text\", ? !!str \"double\" : !!str \"text\", } [20] c-directive ::= “ %” A “ %” ( #x25, percent) denotes a directive line. Example 5.9. Directive Indicator %YAML 1.2 --- text Legend: c-directive %YAML 1.2 --- !!str \"text\" [21] c-reserved ::= “ @” | “ `” The “ @” ( #x40, at) and “ `” ( #x60, grave accent) are reserved for future use. Example 5.10. Invalid use of Reserved Indicators commercial-at: @text grave-accent: `text ERROR: Reserved indicators can't start a plain scalar. Any indicator character: [22] c-indicator ::= “ -” | “ ?” | “ :” | “ ,” | “ [” | “ ]” | “ {” | “ }” | “ #” | “ &” | “ *” | “ !” | “ |” | “ >” | “ '” | “ \"” | “ %” | “ @” | “ `” The “ [” , “ ]” , “ {” , “ }” and “ ,” indicators denote structure in flow collections . They are therefore forbidden in some cases, to avoid ambiguity in several constructs. This is handled on a case-by-case basis by the relevant productions. [23] c-flow-indicator ::= “ ,” | “ [” | “ ]” | “ {” | “ }” 5.4. Line Break Characters YAML recognizes the following ASCII line break characters. [24] b-line-feed ::= #xA /* LF */ [25] b-carriage-return ::= #xD /* CR */ [26] b-char ::= b-line-feed | b-carriage-return All other characters, including the form feed ( #x0C), are considered to be non-break characters. Note that these include the non-ASCII line breaks: next line ( #x85), line separator ( #x2028) and paragraph separator ( #x2029). YAML version 1.1 did support the above non-ASCII line break characters; however, JSON does not. Hence, to ensure JSON compatibility , YAML treats them as non-break characters as of version 1.2. In theory this would cause incompatibility with version 1.1 ; in practice these characters were rarely (if ever) used. YAML 1.2 processors parsing a version 1.1 document should therefore treat these line breaks as non-break characters, with an appropriate warning. [27] nb-char ::= c-printable - b-char - c-byte-order-mark Line breaks are interpreted differently by different systems, and have several widely used formats. [28] b-break ::= ( b-carriage-return b-line-feed ) /* DOS, Windows */ | b-carriage-return /* MacOS upto 9.x */ | b-line-feed /* UNIX, MacOS X */ Line breaks inside scalar content must be normalized by the YAML processor . Each such line break must be parsed into a single line feed character. The original line break format is a presentation detail and must not be used to convey content information. [29] b-as-line-feed ::= b-break Outside scalar content , YAML allows any line break to be used to terminate lines. [30] b-non-content ::= b-break On output, a YAML processor is free to emit line breaks using whatever convention is most appropriate. In the examples, line breaks are sometimes displayed using the “ ” glyph for clarity. Example 5.11. Line Break Characters | Line break (no glyph) Line break (glyphed) Legend: b-break %YAML 1.2 --- !!str \"line break (no glyph)\\n\\ line break (glyphed)\\n\" 5.5. White Space Characters YAML recognizes two white space characters: space and tab. [31] s-space ::= #x20 /* SP */ [32] s-tab ::= #x9 /* TAB */ [33] s-white ::= s-space | s-tab The rest of the ( printable ) non- break characters are considered to be non-space characters. [34] ns-char ::= nb-char - s-white In the examples, tab characters are displayed as the glyph “ ”. Space characters are sometimes displayed as the glyph “ ·” for clarity. Example 5.12. Tabs and Spaces # Tabs and spaces quoted: ·\"Quoted \" block: | ··void main() { ·· printf(\"Hello, world!\\n\"); ··} Legend: s-space s-tab %YAML 1.2 --- !!map { ? !!str \"quoted\" : \"Quoted \\t\", ? !!str \"block\" : \"void main() {\\n\\ \\tprintf(\\\"Hello, world!\\\\n\\\");\\n\\ }\\n\", } 5.6. Miscellaneous Characters The YAML syntax productions make use of the following additional character classes: A decimal digit for numbers: [35] ns-dec-digit ::= [#x30-#x39] /* 0-9 */ A hexadecimal digit for escape sequences : [36] ns-hex-digit ::= ns-dec-digit | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */ ASCII letter (alphabetic) characters: [37] ns-ascii-letter ::= [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */ Word (alphanumeric) characters for identifiers: [38] ns-word-char ::= ns-dec-digit | ns-ascii-letter | “ -” URI characters for tags , as specified in RFC2396 , with the addition of the “ [” and “ ]” for presenting IPv6 addresses as proposed in RFC2732 . By convention, any URI characters other than the allowed printable ASCII characters are first encoded in UTF-8, and then each byte is escaped using the “ %” character. The YAML processor must not expand such escaped characters. Tag characters must be preserved and compared exactly as presented in the YAML stream , without any processing. [39] ns-uri-char ::= “ %” ns-hex-digit ns-hex-digit | ns-word-char | “ #” | “ ;” | “ /” | “ ?” | “ :” | “ @” | “ &” | “ =” | “ +” | “ $” | “ ,” | “ _” | “ .” | “ !” | “ ~” | “ *” | “ '” | “ (” | “ )” | “ [” | “ ]” The “ !” character is used to indicate the end of a named tag handle ; hence its use in tag shorthands is restricted. In addition, such shorthands must not contain the “ [” , “ ]” , “ {” , “ }” and “ ,” characters. These characters would cause ambiguity with flow collection structures. [40] ns-tag-char ::= ns-uri-char - “ !” - c-flow-indicator 5.7. Escaped Characters All non- printable characters must be escaped. YAML escape sequences use the “ \\” notation common to most modern computer languages. Each escape sequence must be parsed into the appropriate Unicode character. The original escape sequence is a presentation detail and must not be used to convey content information. Note that escape sequences are only interpreted in double-quoted scalars . In all other scalar styles , the “ \\” character has no special meaning and non- printable characters are not available. [41] c-escape ::= “ \\” YAML escape sequences are a superset of C’s escape sequences: [42] ns-esc-null ::= “ 0” Escaped ASCII null ( #x0) character. [43] ns-esc-bell ::= “ a” Escaped ASCII bell ( #x7) character. [44] ns-esc-backspace ::= “ b” Escaped ASCII backspace ( #x8) character. [45] ns-esc-horizontal-tab ::= “ t” | #x9 Escaped ASCII horizontal tab ( #x9) character. This is useful at the start or the end of a line to force a leading or trailing tab to become part of the content . [46] ns-esc-line-feed ::= “ n” Escaped ASCII line feed ( #xA) character. [47] ns-esc-vertical-tab ::= “ v” Escaped ASCII vertical tab ( #xB) character. [48] ns-esc-form-feed ::= “ f” Escaped ASCII form feed ( #xC) character. [49] ns-esc-carriage-return ::= “ r” Escaped ASCII carriage return ( #xD) character. [50] ns-esc-escape ::= “ e” Escaped ASCII escape ( #x1B) character. [51] ns-esc-space ::= #x20 Escaped ASCII space ( #x20) character. This is useful at the start or the end of a line to force a leading or trailing space to become part of the content . [52] ns-esc-double-quote ::= “ \"” Escaped ASCII double quote ( #x22). [53] ns-esc-slash ::= “ /” Escaped ASCII slash ( #x2F), for JSON compatibility . [54] ns-esc-backslash ::= “ \\” Escaped ASCII back slash ( #x5C). [55] ns-esc-next-line ::= “ N” Escaped Unicode next line ( #x85) character. [56] ns-esc-non-breaking-space ::= “ _” Escaped Unicode non-breaking space ( #xA0) character. [57] ns-esc-line-separator ::= “ L” Escaped Unicode line separator ( #x2028) character. [58] ns-esc-paragraph-separator ::= “ P” Escaped Unicode paragraph separator ( #x2029) character. [59] ns-esc-8-bit ::= “ x” ( ns-hex-digit × 2 ) Escaped 8-bit Unicode character. [60] ns-esc-16-bit ::= “ u” ( ns-hex-digit × 4 ) Escaped 16-bit Unicode character. [61] ns-esc-32-bit ::= “ U” ( ns-hex-digit × 8 ) Escaped 32-bit Unicode character. Any escaped character: [62] c-ns-esc-char ::= “ \\” ( ns-esc-null | ns-esc-bell | ns-esc-backspace | ns-esc-horizontal-tab | ns-esc-line-feed | ns-esc-vertical-tab | ns-esc-form-feed | ns-esc-carriage-return | ns-esc-escape | ns-esc-space | ns-esc-double-quote | ns-esc-slash | ns-esc-backslash | ns-esc-next-line | ns-esc-non-breaking-space | ns-esc-line-separator | ns-esc-paragraph-separator | ns-esc-8-bit | ns-esc-16-bit | ns-esc-32-bit ) Example 5.13. Escaped Characters \"Fun with \\\\ \\\" \\a \\b \\e \\f \\ \\n \\r \\t \\v \\0 \\ \\ \\_ \\N \\L \\P \\ \\x41 \\u0041 \\U00000041\" Legend: c-ns-esc-char %YAML 1.2 --- \"Fun with \\x5C \\x22 \\x07 \\x08 \\x1B \\x0C \\x0A \\x0D \\x09 \\x0B \\x00 \\x20 \\xA0 \\x85 \\u2028 \\u2029 A A A\" Example 5.14. Invalid Escaped Characters Bad escapes: \"\\ c \\x q-\" ERROR: - c is an invalid escaped character. - q and - are invalid hex digits. Chapter 6. Basic Structures 6.1. Indentation Spaces In YAML block styles , structure is determined by indentation. In general, indentation is defined as a zero or more space characters at the start of a line. To maintain portability, tab characters must not be used in indentation, since different systems treat tabs differently. Note that most modern editors may be configured so that pressing the tab key results in the insertion of an appropriate number of spaces . The amount of indentation is a presentation detail and must not be used to convey content information. [63] s-indent(n) ::= s-space × n A block style construct is terminated when encountering a line which is less indented than the construct. The productions use the notation “ s-indent(<n)” and “ s-indent( n)” to express this. [64] s-indent(<n) ::= s-space × m /* Where m < n */ [65] s-indent( n) ::= s-space × m /* Where m n */ Each node must be indented further than its parent node . All sibling nodes must use the exact same indentation level. However the content of each sibling node may be further indented independently. Example 6.1. Indentation Spaces ··# Leading comment line spaces are ···# neither content nor indentation. ···· Not indented: ·By one space: | ····By four ···· ··spaces ·Flow style: [ # Leading spaces ·· ·By two, # in flow style ··Also by two, # are neither ·· Still by two # content nor ·· ··] # indentation. Legend: s-indent(n) Content Neither content nor indentation %YAML 1.2 - - - !!map { ? !!str \"Not indented\" : !!map { ? !!str \"By one space\" : !!str \"By four\\n spaces\\n\", ? !!str \"Flow style\" : !!seq [ !!str \"By two\", !!str \"Also by two\", !!str \"Still by two\", ] } } The “ -” , “ ?” and “ :” characters used to denote block collection entries are perceived by people to be part of the indentation. This is handled on a case-by-case basis by the relevant productions. Example 6.2. Indentation Indicators ?·a : · - b ·· - ·· - c ····· -·d Legend: Total Indentation s-indent(n) Indicator as indentation %YAML 1.2 --- !!map { ? !!str \"a\" : !!seq [ !!str \"b\", !!seq [ !!str \"c\", !!str \"d\" ] ], } 6.2. Separation Spaces Outside indentation and scalar content , YAML uses white space characters for separation between tokens within a line. Note that such white space may safely include tab characters. Separation spaces are a presentation detail and must not be used to convey content information. [66] s-separate-in-line ::= s-white + | /* Start of line */ Example 6.3. Separation Spaces - ·foo: ·bar - - ·baz - baz Legend: s-separate-in-line %YAML 1.2 --- !!seq [ !!map { ? !!str \"foo\" : !!str \"bar\", }, !!seq [ !!str \"baz\", !!str \"baz\" ], ] 6.3. Line Prefixes Inside scalar content , each line begins with a non- content line prefix. This prefix always includes the indentation . For flow scalar styles it additionally includes all leading white space , which may contain tab characters. Line prefixes are a presentation detail and must not be used to convey content information. [67] s-line-prefix(n,c) ::= c = block-out s-block-line-prefix(n) c = block-in s-block-line-prefix(n) c = flow-out s-flow-line-prefix(n) c = flow-in s-flow-line-prefix(n) [68] s-block-line-prefix(n) ::= s-indent(n) [69] s-flow-line-prefix(n) ::= s-indent(n) s-separate-in-line ? Example 6.4. Line Prefixes plain: text ··lines quoted: \"text ·· lines\" block: | ··text ··· lines Legend: s-flow-line-prefix(n) s-block-line-prefix(n) s-indent(n) %YAML 1.2 --- !!map { ? !!str \"plain\" : !!str \"text lines\", ? !!str \"quoted\" : !!str \"text lines\", ? !!str \"block\" : !!str \"text\\n· lines\\n\", } 6.4. Empty Lines An empty line line consists of the non- content prefix followed by a line break . [70] l-empty(n,c) ::= ( s-line-prefix(n,c) | s-indent(<n) ) b-as-line-feed The semantics of empty lines depend on the scalar style they appear in. This is handled on a case-by-case basis by the relevant productions. Example 6.5. Empty Lines Folding: \"Empty line ··· as a line feed\" Chomping: | Clipped empty lines · Legend: l-empty(n,c) %YAML 1.2 --- !!map { ? !!str \"Folding\" : !!str \"Empty line\\nas a line feed\", ? !!str \"Chomping\" : !!str \"Clipped empty lines\\n\", } 6.5. Line Folding Line folding allows long lines to be broken for readability, while retaining the semantics of the original long line. If a line break is followed by an empty line , it is trimmed; the first line break is discarded and the rest are retained as content . [71] b-l-trimmed(n,c) ::= b-non-content l-empty(n,c) + Otherwise (the following line is not empty ), the line break is converted to a single space ( #x20). [72] b-as-space ::= b-break A folded non- empty line may end with either of the above line breaks . [73] b-l-folded(n,c) ::= b-l-trimmed(n,c) | b-as-space Example 6.6. Line Folding >- trimmed ·· · as space %YAML 1.2 --- !!str \"trimmed\\n\\n\\nas space\" Legend: b-l-trimmed(n,c) b-as-space The above rules are common to both the folded block style and the scalar flow styles . Folding does distinguish between these cases in the following way: Block Folding In the folded block style , the final line break and trailing empty lines are subject to chomping , and are never folded. In addition, folding does not apply to line breaks surrounding text lines that contain leading white space . Note that such a more-indented line may consist only of such leading white space . The combined effect of the block line folding rules is that each “ paragraph” is interpreted as a line, empty lines are interpreted as a line feed, and the formatting of more-indented lines is preserved. Example 6.7. Block Folding > ··foo · · ·· ·bar ··baz %YAML 1.2 --- !!str \"foo \\n\\n\\t bar\\n\\nbaz\\n\" Legend: b-l-folded(n,c) Non-content spaces Content spaces Flow Folding Folding in flow styles provides more relaxed semantics. Flow styles typically depend on explicit indicators rather than indentation to convey structure. Hence spaces preceding or following the text in a line are a presentation detail and must not be used to convey content information. Once all such spaces have been discarded, all line breaks are folded, without exception. The combined effect of the flow line folding rules is that each “ paragraph” is interpreted as a line, empty lines are interpreted as line feeds, and text can be freely more-indented without affecting the content information. [74] s-flow-folded(n) ::= s-separate-in-line ? b-l-folded(n,flow-in) s-flow-line-prefix(n) Example 6.8. Flow Folding \" ··foo · · ·· ·bar ··baz \" %YAML 1.2 --- !!str \" foo\\nbar\\nbaz \" Legend: s-flow-folded(n) Non-content spaces 6.6. Comments An explicit comment is marked by a “ #” indicator. Comments are a presentation detail and must not be used to convey content information. Comments must be separated from other tokens by white space characters. To ensure JSON compatibility , YAML processors must allow for the omission of the final comment line break of the input stream . However, as this confuses many tools, YAML processors should terminate the stream with an explicit line break on output. [75] c-nb-comment-text ::= “ #” nb-char * [76] b-comment ::= b-non-content | /* End of file */ [77] s-b-comment ::= ( s-separate-in-line c-nb-comment-text ? )? b-comment Example 6.9. Separated Comment key: ···· # Comment value eof Legend: c-nb-comment-text b-comment s-b-comment %YAML 1.2 --- !!map { ? !!str \"key\" : !!str \"value\", } Outside scalar content , comments may appear on a line of their own, independent of the indentation level. Note that outside scalar content , a line containing only white space characters is taken to be a comment line. [78] l-comment ::= s-separate-in-line c-nb-comment-text ? b-comment Example 6.10. Comment Lines ·· # Comment ··· # This stream contains no # documents, only comments. Legend: s-b-comment l-comment In most cases, when a line may end with a comment, YAML allows it to be followed by additional comment lines. The only exception is a comment ending a block scalar header . [79] s-l-comments ::= ( s-b-comment | /* Start of line */ ) l-comment * Example 6.11. Multi-Line Comments key: ····# Comment ········# lines value %YAML 1.2 --- !!map { ? !!str \"key\" : !!str \"value\", } Legend: s-b-comment l-comment s-l-comments 6.7. Separation Lines Implicit keys are restricted to a single line. In all other cases, YAML allows tokens to be separated by multi-line (possibly empty) comments . Note that structures following multi-line comment separation must be properly indented , even though there is no such restriction on the separation comment lines themselves. [80] s-separate(n,c) ::= c = block-out s-separate-lines(n) c = block-in s-separate-lines(n) c = flow-out s-separate-lines(n) c = flow-in s-separate-lines(n) c = block-key s-separate-in-line c = flow-key s-separate-in-line [81] s-separate-lines(n) ::= ( s-l-comments s-flow-line-prefix(n) ) | s-separate-in-line Example 6.12. Separation Spaces { ·first: ·Sammy, ·last: ·Sosa ·}: # Statistics: ··hr: ··# Home runs ·····65 ··avg: ·# Average ···0.278 Legend: s-separate-in-line s-separate-lines(n) s-indent(n) %YAML 1.2 --- !!map { ? !!map { ? !!str \"first\" : !!str \"Sammy\", ? !!str \"last\" : !!str \"Sosa\", } : !!map { ? !!str \"hr\" : !!int \"65\", ? !!str \"avg\" : !!float \"0.278\", }, } 6.8. Directives Directives are instructions to the YAML processor . This specification defines two directives, “ YAML” and “ TAG” , and reserves all other directives for future use. There is no way to define private directives. This is intentional. Directives are a presentation detail and must not be used to convey content information. [82] l-directive ::= “ %” ( ns-yaml-directive | ns-tag-directive | ns-reserved-directive ) s-l-comments Each directive is specified on a separate non- indented line starting with the “ %” indicator, followed by the directive name and a list of parameters. The semantics of these parameters depends on the specific directive. A YAML processor should ignore unknown directives with an appropriate warning. [83] ns-reserved-directive ::= ns-directive-name ( s-separate-in-line ns-directive-parameter )* [84] ns-directive-name ::= ns-char + [85] ns-directive-parameter ::= ns-char + Example 6.13. Reserved Directives % FOO bar baz # Should be ignored # with a warning. --- \"foo\" %YAML 1.2 --- !!str \"foo\" Legend: ns-reserved-directive ns-directive-name ns-directive-parameter 6.8.1. “ YAML” Directives The “ YAML” directive specifies the version of YAML the document conforms to. This specification defines version “ 1.2”, including recommendations for YAML 1.1 processing. A version 1.2 YAML processor must accept documents with an explicit “ %YAML 1.2” directive, as well as documents lacking a “ YAML” directive. Such documents are assumed to conform to the 1.2 version specification. Documents with a “ YAML” directive specifying a higher minor version (e.g. “ %YAML 1.3”) should be processed with an appropriate warning. Documents with a “ YAML” directive specifying a higher major version (e.g. “ %YAML 2.0”) should be rejected with an appropriate error message. A version 1.2 YAML processor must also accept documents with an explicit “ %YAML 1.1” directive. Note that version 1.2 is mostly a superset of version 1.1, defined for the purpose of ensuring JSON compatibility. Hence a version 1.2 processor should process version 1.1 documents as if they were version 1.2, giving a warning on points of incompatibility (handling of non-ASCII line breaks , as described above ). [86] ns-yaml-directive ::= “ Y” “ A” “ M” “ L” s-separate-in-line ns-yaml-version [87] ns-yaml-version ::= ns-dec-digit + “ .” ns-dec-digit + Example 6.14. “ YAML” directive % YAML 1.3 # Attempt parsing # with a warning --- \"foo\" %YAML 1.2 --- !!str \"foo\" Legend: ns-yaml-directive ns-yaml-version It is an error to specify more than one “ YAML” directive for the same document, even if both occurrences give the same version number. Example 6.15. Invalid Repeated YAML directive %YAML 1.2 % YAML 1.1 foo ERROR: The YAML directive must only be given at most once per document. 6.8.2. “ TAG” Directives The “ TAG” directive establishes a tag shorthand notation for specifying node tags . Each “ TAG” directive associates a handle with a prefix . This allows for compact and readable tag notation. [88] ns-tag-directive ::= “ T” “ A” “ G” s-separate-in-line c-tag-handle s-separate-in-line ns-tag-prefix Example 6.16. “ TAG” directive % TAG !yaml! tag:yaml.org,2002: --- !yaml!str \"foo\" %YAML 1.2 --- !!str \"foo\" Legend: ns-tag-directive c-tag-handle ns-tag-prefix It is an error to specify more than one “ TAG” directive for the same handle in the same document, even if both occurrences give the same prefix . Example 6.17. Invalid Repeated TAG directive %TAG ! !foo %TAG ! !foo bar ERROR: The TAG directive must only be given at most once per handle in the same document. 6.8.2.1. Tag Handles The tag handle exactly matches the prefix of the affected tag shorthand . There are three tag handle variants: [89] c-tag-handle ::= c-named-tag-handle | c-secondary-tag-handle | c-primary-tag-handle Primary Handle The primary tag handle is a single “ !” character. This allows using the most compact possible notation for a single “ primary” name space. By default, the prefix associated with this handle is “ !” . Thus, by default, shorthands using this handle are interpreted as local tags . It is possible to override the default behavior by providing an explicit “ TAG” directive, associating a different prefix for this handle. This provides smooth migration from using local tags to using global tags , by the simple addition of a single “ TAG” directive. [90] c-primary-tag-handle ::= “ !” Example 6.18. Primary Tag Handle # Private !foo \"bar\" ... # Global %TAG ! tag:example.com,2000:app/ --- !foo \"bar\" %YAML 1.2 --- !<!foo> \"bar\" ... --- !<tag:example.com,2000:app/foo> \"bar\" Legend: c-primary-tag-handle Secondary Handle The secondary tag handle is written as “ !!”. This allows using a compact notation for a single “ secondary” name space. By default, the prefix associated with this handle is “ tag:yaml.org,2002:”. This prefix is used by the YAML tag repository . It is possible to override this default behavior by providing an explicit “ TAG” directive associating a different prefix for this handle. [91] c-secondary-tag-handle ::= “ !” “ !” Example 6.19. Secondary Tag Handle %TAG !! tag:example.com,2000:app/ --- !!int 1 - 3 # Interval, not integer Legend: c-secondary-tag-handle %YAML 1.2 --- !<tag:example.com,2000:app/int> \"1 - 3\" Named Handles A named tag handle surrounds a non-empty name with “ !” characters. A handle name must not be used in a tag shorthand unless an explicit “ TAG” directive has associated some prefix with it. The name of the handle is a presentation detail and must not be used to convey content information. In particular, the YAML processor need not preserve the handle name once parsing is completed. [92] c-named-tag-handle ::= “ !” ns-word-char + “ !” Example 6.20. Tag Handles %TAG !e! tag:example.com,2000:app/ --- !e!foo \"bar\" Legend: c-named-tag-handle %YAML 1.2 --- !<tag:example.com,2000:app/foo> \"bar\" 6.8.2.2. Tag Prefixes There are two tag prefix variants: [93] ns-tag-prefix ::= c-ns-local-tag-prefix | ns-global-tag-prefix Local Tag Prefix If the prefix begins with a “ !” character, shorthands using the handle are expanded to a local tag . Note that such a tag is intentionally not a valid URI, and its semantics are specific to the application . In particular, two documents in the same stream may assign different semantics to the same local tag . [94] c-ns-local-tag-prefix ::= “ !” ns-uri-char * Example 6.21. Local Tag Prefix %TAG !m! !my- --- # Bulb here !m!light fluorescent ... %TAG !m! !my- --- # Color here !m!light green Legend: c-ns-local-tag-prefix %YAML 1.2 --- !<!my-light> \"fluorescent\" ... %YAML 1.2 --- !<!my-light> \"green\" Global Tag Prefix If the prefix begins with a character other than “ !” , it must to be a valid URI prefix, and should contain at least the scheme and the authority. Shorthands using the associated handle are expanded to globally unique URI tags, and their semantics is consistent across applications . In particular, every documents in every stream must assign the same semantics to the same global tag . [95] ns-global-tag-prefix ::= ns-tag-char ns-uri-char * Example 6.22. Global Tag Prefix %TAG !e! tag:example.com,2000:app/ --- - !e!foo \"bar\" Legend: ns-global-tag-prefix %YAML 1.2 --- !<tag:example.com,2000:app/foo> \"bar\" 6.9. Node Properties Each node may have two optional properties, anchor and tag , in addition to its content . Node properties may be specified in any order before the node’s content . Either or both may be omitted. [96] c-ns-properties(n,c) ::= ( c-ns-tag-property ( s-separate(n,c) c-ns-anchor-property )? ) | ( c-ns-anchor-property ( s-separate(n,c) c-ns-tag-property )? ) Example 6.23. Node Properties !!str &a1 \"foo\": !!str bar &a2 baz : *a1 Legend: c-ns-properties(n,c) c-ns-anchor-property c-ns-tag-property %YAML 1.2 --- !!map { ? &B1 !!str \"foo\" : !!str \"bar\", ? !!str \"baz\" : *B1, } 6.9.1. Node Tags The tag property identifies the type of the native data structure presented by the node . A tag is denoted by the “ !” indicator. [97] c-ns-tag-property ::= c-verbatim-tag | c-ns-shorthand-tag | c-non-specific-tag Verbatim Tags A tag may be written verbatim by surrounding it with the “ <” and “ >” characters. In this case, the YAML processor must deliver the verbatim tag as-is to the application . In particular, verbatim tags are not subject to tag resolution . A verbatim tag must either begin with a “ !” (a local tag ) or be a valid URI (a global tag ). [98] c-verbatim-tag ::= “ !” “ <” ns-uri-char + “ >” Example 6.24. Verbatim Tags !<tag:yaml.org,2002:str> foo : !<!bar> baz Legend: c-verbatim-tag %YAML 1.2 --- !!map { ? !<tag:yaml.org,2002:str> \"foo\" : !<!bar> \"baz\", } Example 6.25. Invalid Verbatim Tags - !< !> foo - !< $:?> bar ERROR: - Verbatim tags aren't resolved, so ! is invalid. - The $:? tag is neither a global URI tag nor a local tag starting with “ !”. Tag Shorthands A tag shorthand consists of a valid tag handle followed by a non-empty suffix. The tag handle must be associated with a prefix , either by default or by using a “ TAG” directive . The resulting parsed tag is the concatenation of the prefix and the suffix, and must either begin with “ !” (a local tag ) or be a valid URI (a global tag ). The choice of tag handle is a presentation detail and must not be used to convey content information. In particular, the tag handle may be discarded once parsing is completed. The suffix must not contain any “ !” character. This would cause the tag shorthand to be interpreted as having a named tag handle . In addition, the suffix must not contain the “ [” , “ ]” , “ {” , “ }” and “ ,” characters. These characters would cause ambiguity with flow collection structures. If the suffix needs to specify any of the above restricted characters, they must be escaped using the “ %” character. This behavior is consistent with the URI character escaping rules (specifically, section 2.3 of RFC2396 ). [99] c-ns-shorthand-tag ::= c-tag-handle ns-tag-char + Example 6.26. Tag Shorthands %TAG !e! tag:example.com,2000:app/ --- - !local foo - !!str bar - !e!tag%21 baz Legend: c-ns-shorthand-tag %YAML 1.2 --- !!seq [ !<!local> \"foo\", !<tag:yaml.org,2002:str> \"bar\", !<tag:example.com,2000:app/tag!> \"baz\" ] Example 6.27. Invalid Tag Shorthands %TAG !e! tag:example,2000:app/ --- - !e! foo - !h!bar baz ERROR: - The !o! handle has no suffix. - The !h! handle wasn't declared. Non-Specific Tags If a node has no tag property, it is assigned a non-specific tag that needs to be resolved to a specific one. This non-specific tag is “ !” for non- plain scalars and “ ?” for all other nodes . This is the only case where the node style has any effect on the content information. It is possible for the tag property to be explicitly set to the “ !” non-specific tag . By convention , this “ disables” tag resolution , forcing the node to be interpreted as “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map”, or “ tag:yaml.org,2002:str”, according to its kind . There is no way to explicitly specify the “ ?” non-specific tag. This is intentional. [100] c-non-specific-tag ::= “ !” Example 6.28. Non-Specific Tags # Assuming conventional resolution: - \"12\" - 12 - ! 12 Legend: c-non-specific-tag %YAML 1.2 --- !!seq [ !<tag:yaml.org,2002:str> \"12\", !<tag:yaml.org,2002:int> \"12\", !<tag:yaml.org,2002:str> \"12\", ] 6.9.2. Node Anchors An anchor is denoted by the “ &” indicator. It marks a node for future reference. An alias node can then be used to indicate additional inclusions of the anchored node . An anchored node need not be referenced by any alias nodes ; in particular, it is valid for all nodes to be anchored. [101] c-ns-anchor-property ::= “ &” ns-anchor-name Note that as a serialization detail , the anchor name is preserved in the serialization tree . However, it is not reflected in the representation graph and must not be used to convey content information. In particular, the YAML processor need not preserve the anchor name once the representation is composed . Anchor names must not contain the “ [” , “ ]” , “ {” , “ }” and “ ,” characters. These characters would cause ambiguity with flow collection structures. [102] ns-anchor-char ::= ns-char - c-flow-indicator [103] ns-anchor-name ::= ns-anchor-char + Example 6.29. Node Anchors First occurrence: & anchor Value Second occurrence: * anchor Legend: c-ns-anchor-property ns-anchor-name %YAML 1.2 --- !!map { ? !!str \"First occurrence\" : &A !!str \"Value\", ? !!str \"Second occurrence\" : *A, } Chapter 7. Flow Styles YAML’s flow styles can be thought of as the natural extension of JSON to cover folding long content lines for readability, tagging nodes to control construction of native data structures , and using anchors and aliases to reuse constructed object instances. 7.1. Alias Nodes Subsequent occurrences of a previously serialized node are presented as alias nodes. The first occurrence of the node must be marked by an anchor to allow subsequent occurrences to be presented as alias nodes. An alias node is denoted by the “ *” indicator. The alias refers to the most recent preceding node having the same anchor . It is an error for an alias node to use an anchor that does not previously occur in the document . It is not an error to specify an anchor that is not used by any alias node. Note that an alias node must not specify any properties or content , as these were already specified at the first occurrence of the node . [104] c-ns-alias-node ::= “ *” ns-anchor-name Example 7.1. Alias Nodes First occurrence: & anchor Foo Second occurrence: * anchor Override anchor: & anchor Bar Reuse anchor: * anchor Legend: c-ns-alias-node ns-anchor-name %YAML 1.2 --- !!map { ? !!str \"First occurrence\" : &A !!str \"Foo\", ? !!str \"Override anchor\" : &B !!str \"Bar\", ? !!str \"Second occurrence\" : *A, ? !!str \"Reuse anchor\" : *B, } 7.2. Empty Nodes YAML allows the node content to be omitted in many cases. Nodes with empty content are interpreted as if they were plain scalars with an empty value. Such nodes are commonly resolved to a “ null” value. [105] e-scalar ::= /* Empty */ In the examples, empty scalars are sometimes displayed as the glyph “ °” for clarity. Note that this glyph corresponds to a position in the characters stream rather than to an actual character. Example 7.2. Empty Content { foo : !!str °, !!str ° : bar, } Legend: e-scalar %YAML 1.2 --- !!map { ? !!str \"foo\" : !!str \"\", ? !!str \"\" : !!str \"bar\", } Both the node’s properties and node content are optional. This allows for a completely empty node. Completely empty nodes are only valid when following some explicit indication for their existence. [106] e-node ::= e-scalar Example 7.3. Completely Empty Flow Nodes { ? foo : °, °: bar, } Legend: e-node %YAML 1.2 --- !!map { ? !!str \"foo\" : !!null \"\", ? !!null \"\" : !!str \"bar\", } 7.3. Flow Scalar Styles YAML provides three flow scalar styles: double-quoted , single-quoted and plain (unquoted). Each provides a different trade-off between readability and expressive power. The scalar style is a presentation detail and must not be used to convey content information, with the exception that plain scalars are distinguished for the purpose of tag resolution . 7.3.1. Double-Quoted Style The double-quoted style is specified by surrounding “ \"” indicators. This is the only style capable of expressing arbitrary strings, by using “ \\” escape sequences . This comes at the cost of having to escape the “ \\” and “ \"” characters. [107] nb-double-char ::= c-ns-esc-char | ( nb-json - “ \\” - “ \"” ) [108] ns-double-char ::= nb-double-char - s-white Double-quoted scalars are restricted to a single line when contained inside an implicit key . [109] c-double-quoted(n,c) ::= “ \"” nb-double-text(n,c) “ \"” [110] nb-double-text(n,c) ::= c = flow-out nb-double-multi-line(n) c = flow-in nb-double-multi-line(n) c = block-key nb-double-one-line c = flow-key nb-double-one-line [111] nb-double-one-line ::= nb-double-char * Example 7.4. Double Quoted Implicit Keys \" implicit block key\" : [ \" implicit flow key\" : value, ] Legend: nb-double-one-line c-double-quoted(n,c) %YAML 1.2 --- !!map { ? !!str \"implicit block key\" : !!seq [ !!map { ? !!str \"implicit flow key\" : !!str \"value\", } ] } In a multi-line double-quoted scalar, line breaks are are subject to flow line folding , which discards any trailing white space characters. It is also possible to escape the line break character. In this case, the line break is excluded from the content , and the trailing white space characters are preserved. Combined with the ability to escape white space characters, this allows double-quoted lines to be broken at arbitrary positions. [112] s-double-escaped(n) ::= s-white * “ \\” b-non-content l-empty(n,flow-in) * s-flow-line-prefix(n) [113] s-double-break(n) ::= s-double-escaped(n) | s-flow-folded(n) Example 7.5. Double Quoted Line Breaks \"folded · to a space, · to a line feed, or · \\ ·\\· non-content\" %YAML 1.2 --- !!str \"folded to a space,\\n\\ to a line feed, \\ or \\t \\tnon-content\" Legend: s-flow-folded(n) s-double-escaped(n) All leading and trailing white space characters are excluded from the content . Each continuation line must therefore contain at least one non- space character. Empty lines, if any, are consumed as part of the line folding . [114] nb-ns-double-in-line ::= ( s-white * ns-double-char )* [115] s-double-next-line(n) ::= s-double-break(n) ( ns-double-char nb-ns-double-in-line ( s-double-next-line(n) | s-white * ) )? [116] nb-double-multi-line(n) ::= nb-ns-double-in-line ( s-double-next-line(n) | s-white * ) Example 7.6. Double Quoted Lines \" ·1st non-empty · 2nd non-empty · 3rd non-empty·\" %YAML 1.2 --- !!str \" 1st non-empty\\n\\ 2nd non-empty \\ 3rd non-empty \" Legend: nb-ns-double-in-line s-double-next-line(n) 7.3.2. Single-Quoted Style The single-quoted style is specified by surrounding “ '” indicators. Therefore, within a single-quoted scalar, such characters need to be repeated. This is the only form of escaping performed in single-quoted scalars. In particular, the “ \\” and “ \"” characters may be freely used. This restricts single-quoted scalars to printable characters. In addition, it is only possible to break a long single-quoted line where a space character is surrounded by non- spaces . [117] c-quoted-quote ::= “ '” “ '” [118] nb-single-char ::= c-quoted-quote | ( nb-json - “ '” ) [119] ns-single-char ::= nb-single-char - s-white Example 7.7. Single Quoted Characters 'here ''s to \"quotes\"' Legend: c-quoted-quote %YAML 1.2 --- !!str \"here's to \\\"quotes\\\"\" Single-quoted scalars are restricted to a single line when contained inside a implicit key . [120] c-single-quoted(n,c) ::= “ '” nb-single-text(n,c) “ '” [121] nb-single-text(n,c) ::= c = flow-out nb-single-multi-line(n) c = flow-in nb-single-multi-line(n) c = block-key nb-single-one-line c = flow-key nb-single-one-line [122] nb-single-one-line ::= nb-single-char * Example 7.8. Single Quoted Implicit Keys ' implicit block key' : [ ' implicit flow key' : value, ] Legend: nb-single-one-line c-single-quoted(n,c) %YAML 1.2 --- !!map { ? !!str \"implicit block key\" : !!seq [ !!map { ? !!str \"implicit flow key\" : !!str \"value\", } ] } All leading and trailing white space characters are excluded from the content . Each continuation line must therefore contain at least one non- space character. Empty lines, if any, are consumed as part of the line folding . [123] nb-ns-single-in-line ::= ( s-white * ns-single-char )* [124] s-single-next-line(n) ::= s-flow-folded(n) ( ns-single-char nb-ns-single-in-line ( s-single-next-line(n) | s-white * ) )? [125] nb-single-multi-line(n) ::= nb-ns-single-in-line ( s-single-next-line(n) | s-white * ) Example 7.9. Single Quoted Lines ' ·1st non-empty · 2nd non-empty · 3rd non-empty·' %YAML 1.2 --- !!str \" 1st non-empty\\n\\ 2nd non-empty \\ 3rd non-empty \" Legend: nb-ns-single-in-line(n) s-single-next-line(n) 7.3.3. Plain Style The plain (unquoted) style has no identifying indicators and provides no form of escaping. It is therefore the most readable, most limited and most context sensitive style . In addition to a restricted character set, a plain scalar must not be empty, or contain leading or trailing white space characters. It is only possible to break a long plain line where a space character is surrounded by non- spaces . Plain scalars must not begin with most indicators , as this would cause ambiguity with other YAML constructs. However, the “ :” , “ ?” and “ -” indicators may be used as the first character if followed by a non- space “ safe” character, as this causes no ambiguity. [126] ns-plain-first(c) ::= ( ns-char - c-indicator ) | ( ( “ ?” | “ :” | “ -” ) /* Followed by an ns-plain-safe(c) ) */ ) Plain scalars must never contain the “ : ” and “ #” character combinations. Such combinations would cause ambiguity with mapping key: value pairs and comments . In addition, inside flow collections , or when used as implicit keys , plain scalars must not contain the “ [” , “ ]” , “ {” , “ }” and “ ,” characters. These characters would cause ambiguity with flow collection structures. [127] ns-plain-safe(c) ::= c = flow-out ns-plain-safe-out c = flow-in ns-plain-safe-in c = block-key ns-plain-safe-out c = flow-key ns-plain-safe-in [128] ns-plain-safe-out ::= ns-char [129] ns-plain-safe-in ::= ns-char - c-flow-indicator [130] ns-plain-char(c) ::= ( ns-plain-safe(c) - “ :” - “ #” ) | ( /* An ns-char preceding */ “ #” ) | ( “ :” /* Followed by an ns-plain-safe(c) */ ) Example 7.10. Plain Characters # Outside flow collection: - : :vector - \" : - ()\" - Up , up, and away! - -123 - http ://example.com/foo #bar # Inside flow collection: - [ : :vector, \" : - ()\", \"Up , up and away!\", -123, http ://example.com/foo #bar ] %YAML 1.2 --- !!seq [ !!str \"::vector\", !!str \": - ()\", !!str \"Up, up, and away!\", !!int \"-123\", !!str \"http://example.com/foo#bar\", !!seq [ !!str \"::vector\", !!str \": - ()\", !!str \"Up, up, and away!\", !!int \"-123\", !!str \"http://example.com/foo#bar\", ], ] Legend: ns-plain-first(c) Not ns-plain-first(c) ns-plain-char(c) Not ns-plain-char(c) Plain scalars are further restricted to a single line when contained inside an implicit key . [131] ns-plain(n,c) ::= c = flow-out ns-plain-multi-line(n,c) c = flow-in ns-plain-multi-line(n,c) c = block-key ns-plain-one-line(c) c = flow-key ns-plain-one-line(c) [132] nb-ns-plain-in-line(c) ::= ( s-white * ns-plain-char(c) )* [133] ns-plain-one-line(c) ::= ns-plain-first(c) nb-ns-plain-in-line(c) Example 7.11. Plain Implicit Keys implicit block key : [ implicit flow key : value, ] Legend: ns-plain-one-line(c) %YAML 1.2 --- !!map { ? !!str \"implicit block key\" : !!seq [ !!map { ? !!str \"implicit flow key\" : !!str \"value\", } ] } All leading and trailing white space characters are excluded from the content . Each continuation line must therefore contain at least one non- space character. Empty lines, if any, are consumed as part of the line folding . [134] s-ns-plain-next-line(n,c) ::= s-flow-folded(n) ns-plain-char(c) nb-ns-plain-in-line(c) [135] ns-plain-multi-line(n,c) ::= ns-plain-one-line(c) s-ns-plain-next-line(n,c) * Example 7.12. Plain Lines 1st non-empty · 2nd non-empty · 3rd non-empty %YAML 1.2 --- !!str \"1st non-empty\\n\\ 2nd non-empty \\ 3rd non-empty\" Legend: nb-ns-plain-in-line(c) s-ns-plain-next-line(n,c) 7.4. Flow Collection Styles A flow collection may be nested within a block collection ( flow-out context ), nested within another flow collection ( flow-in context ), or be a part of an implicit key ( flow-key context or block-key context ). Flow collection entries are terminated by the “ ,” indicator. The final “ ,” may be omitted. This does not cause ambiguity because flow collection entries can never be completely empty . [136] in-flow(c) ::= c = flow-out flow-in c = flow-in flow-in c = block-key flow-key c = flow-key flow-key 7.4.1. Flow Sequences Flow sequence content is denoted by surrounding “ [” and “ ]” characters. [137] c-flow-sequence(n,c) ::= “ [” s-separate(n,c) ? ns-s-flow-seq-entries(n, in-flow(c) ) ? “ ]” Sequence entries are separated by a “ ,” character. [138] ns-s-flow-seq-entries(n,c) ::= ns-flow-seq-entry(n,c) s-separate(n,c) ? ( “ ,” s-separate(n,c) ? ns-s-flow-seq-entries(n,c) ? )? Example 7.13. Flow Sequence - [ one, two, ] - [ three , four ] Legend: c-sequence-start c-sequence-end ns-flow-seq-entry(n,c) %YAML 1.2 --- !!seq [ !!seq [ !!str \"one\", !!str \"two\", ], !!seq [ !!str \"three\", !!str \"four\", ], ] Any flow node may be used as a flow sequence entry. In addition, YAML provides a compact notation for the case where a flow sequence entry is a mapping with a single key: value pair . [139] ns-flow-seq-entry(n,c) ::= ns-flow-pair(n,c) | ns-flow-node(n,c) Example 7.14. Flow Sequence Entries [ \"double quoted\", 'single quoted', plain text, [ nested ], single: pair, ] Legend: ns-flow-node(n,c) ns-flow-pair(n,c) %YAML 1.2 --- !!seq [ !!str \"double quoted\", !!str \"single quoted\", !!str \"plain text\", !!seq [ !!str \"nested\", ], !!map { ? !!str \"single\" : !!str \"pair\", }, ] 7.4.2. Flow Mappings Flow mappings are denoted by surrounding “ {” and “ }” characters. [140] c-flow-mapping(n,c) ::= “ {” s-separate(n,c) ? ns-s-flow-map-entries(n, in-flow(c) ) ? “ }” Mapping entries are separated by a “ ,” character. [141] ns-s-flow-map-entries(n,c) ::= ns-flow-map-entry(n,c) s-separate(n,c) ? ( “ ,” s-separate(n,c) ? ns-s-flow-map-entries(n,c) ? )? Example 7.15. Flow Mappings - { one : two , three: four , } - { five: six, seven : eight } Legend: c-mapping-start c-mapping-end ns-flow-map-entry(n,c) %YAML 1.2 --- !!seq [ !!map { ? !!str \"one\" : !!str \"two\", ? !!str \"three\" : !!str \"four\", }, !!map { ? !!str \"five\" : !!str \"six\", ? !!str \"seven\" : !!str \"eight\", }, ] If the optional “ ?” mapping key indicator is specified, the rest of the entry may be completely empty . [142] ns-flow-map-entry(n,c) ::= ( “ ?” s-separate(n,c) ns-flow-map-explicit-entry(n,c) ) | ns-flow-map-implicit-entry(n,c) [143] ns-flow-map-explicit-entry(n,c) ::= ns-flow-map-implicit-entry(n,c) | ( e-node /* Key */ e-node /* Value */ ) Example 7.16. Flow Mapping Entries { ? explicit: entry, implicit: entry, ? ° ° } Legend: ns-flow-map-explicit-entry(n,c) ns-flow-map-implicit-entry(n,c) e-node %YAML 1.2 --- !!map { ? !!str \"explicit\" : !!str \"entry\", ? !!str \"implicit\" : !!str \"entry\", ? !!null \"\" : !!null \"\", } Normally, YAML insists the “ :” mapping value indicator be separated from the value by white space . A benefit of this restriction is that the “ :” character can be used inside plain scalars , as long as it is not followed by white space . This allows for unquoted URLs and timestamps. It is also a potential source for confusion as “ a:1” is a plain scalar and not a key: value pair . Note that the value may be completely empty since its existence is indicated by the “ :”. [144] ns-flow-map-implicit-entry(n,c) ::= ns-flow-map-yaml-key-entry(n,c) | c-ns-flow-map-empty-key-entry(n,c) | c-ns-flow-map-json-key-entry(n,c) [145] ns-flow-map-yaml-key-entry(n,c) ::= ns-flow-yaml-node(n,c) ( ( s-separate(n,c) ? c-ns-flow-map-separate-value(n,c) ) | e-node ) [146] c-ns-flow-map-empty-key-entry(n,c) ::= e-node /* Key */ c-ns-flow-map-separate-value(n,c) [147] c-ns-flow-map-separate-value(n,c) ::= “ :” /* Not followed by an ns-plain-safe(c) */ ( ( s-separate(n,c) ns-flow-node(n,c) ) | e-node /* Value */ ) Example 7.17. Flow Mapping Separate Values { unquoted· :·\"separate\", http://foo.com, omitted value : °, ° :·omitted key, } Legend: ns-flow-yaml-node(n,c) e-node c-ns-flow-map-separate-value(n,c) %YAML 1.2 --- !!map { ? !!str \"unquoted\" : !!str \"separate\", ? !!str \"http://foo.com\" : !!null \"\", ? !!str \"omitted value\" : !!null \"\", ? !!null \"\" : !!str \"omitted key\", } To ensure JSON compatibility , if a key inside a flow mapping is JSON-like , YAML allows the following value to be specified adjacent to the “ :”. This causes no ambiguity, as all JSON-like keys are surrounded by indicators . However, as this greatly reduces readability, YAML processors should separate the value from the “ :” on output, even in this case. [148] c-ns-flow-map-json-key-entry(n,c) ::= c-flow-json-node(n,c) ( ( s-separate(n,c) ? c-ns-flow-map-adjacent-value(n,c) ) | e-node ) [149] c-ns-flow-map-adjacent-value(n,c) ::= “ :” ( ( s-separate(n,c) ? ns-flow-node(n,c) ) | e-node ) /* Value */ Example 7.18. Flow Mapping Adjacent Values { \"adjacent\": value, \"readable\": ·value, \"empty\": ° } Legend: c-flow-json-node(n,c) e-node c-ns-flow-map-adjacent-value(n,c) %YAML 1.2 --- !!map { ? !!str \"adjacent\" : !!str \"value\", ? !!str \"readable\" : !!str \"value\", ? !!str \"empty\" : !!null \"\", } A more compact notation is usable inside flow sequences , if the mapping contains a single key: value pair. This notation does not require the surrounding “ {” and “ }” characters. Note that it is not possible to specify any node properties for the mapping in this case. Example 7.19. Single Pair Flow Mappings [ foo: bar ] Legend: ns-flow-pair(n,c) %YAML 1.2 --- !!seq [ !!map { ? !!str \"foo\" : !!str \"bar\" } ] If the “ ?” indicator is explicitly specified, parsing is unambiguous, and the syntax is identical to the general case. [150] ns-flow-pair(n,c) ::= ( “ ?” s-separate(n,c) ns-flow-map-explicit-entry(n,c) ) | ns-flow-pair-entry(n,c) Example 7.20. Single Pair Explicit Entry [ ? foo bar : baz ] Legend: ns-flow-map-explicit-entry(n,c) %YAML 1.2 --- !!seq [ !!map { ? !!str \"foo bar\" : !!str \"baz\", }, ] If the “ ?” indicator is omitted, parsing needs to see past the implicit key to recognize it as such. To limit the amount of lookahead required, the “ :” indicator must appear at most 1024 Unicode characters beyond the start of the key . In addition, the key is restricted to a single line. Note that YAML allows arbitrary nodes to be used as keys . In particular, a key may be a sequence or a mapping . Thus, without the above restrictions, practical one-pass parsing would have been impossible to implement. [151] ns-flow-pair-entry(n,c) ::= ns-flow-pair-yaml-key-entry(n,c) | c-ns-flow-map-empty-key-entry(n,c) | c-ns-flow-pair-json-key-entry(n,c) [152] ns-flow-pair-yaml-key-entry(n,c) ::= ns-s-implicit-yaml-key(flow-key) c-ns-flow-map-separate-value(n,c) [153] c-ns-flow-pair-json-key-entry(n,c) ::= c-s-implicit-json-key(flow-key) c-ns-flow-map-adjacent-value(n,c) [154] ns-s-implicit-yaml-key(c) ::= ns-flow-yaml-node(n/a,c) s-separate-in-line ? /* At most 1024 characters altogether */ [155] c-s-implicit-json-key(c) ::= c-flow-json-node(n/a,c) s-separate-in-line ? /* At most 1024 characters altogether */ Example 7.21. Single Pair Implicit Entries - [ YAML· : separate ] - [ ° : empty key entry ] - [ {JSON: like} :adjacent ] Legend: ns-s-implicit-yaml-key c-s-implicit-json-key e-node Value %YAML 1.2 --- !!seq [ !!seq [ !!map { ? !!str \"YAML\" : !!str \"separate\" }, ], !!seq [ !!map { ? !!null \"\" : !!str \"empty key entry\" }, ], !!seq [ !!map { ? !!map { ? !!str \"JSON\" : !!str \"like\" } : \"adjacent\", }, ], ] Example 7.22. Invalid Implicit Keys [ foo bar: invalid, \"foo ...>1K characters...bar\": invalid ] ERROR: - The foo bar key spans multiple lines - The foo...bar key is too long 7.5. Flow Nodes JSON-like flow styles all have explicit start and end indicators . The only flow style that does not have this property is the plain scalar . Note that none of the “ JSON-like” styles is actually acceptable by JSON. Even the double-quoted style is a superset of the JSON string format. [156] ns-flow-yaml-content(n,c) ::= ns-plain(n,c) [157] c-flow-json-content(n,c) ::= c-flow-sequence(n,c) | c-flow-mapping(n,c) | c-single-quoted(n,c) | c-double-quoted(n,c) [158] ns-flow-content(n,c) ::= ns-flow-yaml-content(n,c) | c-flow-json-content(n,c) Example 7.23. Flow Content - [ a, b ] - { a: b } - \"a\" - 'b' - c Legend: c-flow-json-content(n,c) ns-flow-yaml-content(n,c) %YAML 1.2 --- !!seq [ !!seq [ !!str \"a\", !!str \"b\" ], !!map { ? !!str \"a\" : !!str \"b\" }, !!str \"a\", !!str \"b\", !!str \"c\", ] A complete flow node also has optional node properties , except for alias nodes which refer to the anchored node properties . [159] ns-flow-yaml-node(n,c) ::= c-ns-alias-node | ns-flow-yaml-content(n,c) | ( c-ns-properties(n,c) ( ( s-separate(n,c) ns-flow-yaml-content(n,c) ) | e-scalar ) ) [160] c-flow-json-node(n,c) ::= ( c-ns-properties(n,c) s-separate(n,c) )? c-flow-json-content(n,c) [161] ns-flow-node(n,c) ::= c-ns-alias-node | ns-flow-content(n,c) | ( c-ns-properties(n,c) ( ( s-separate(n,c) ns-flow-content(n,c) ) | e-scalar ) ) Example 7.24. Flow Nodes - !!str \"a\" - 'b' - &anchor \"c\" - *anchor - !!str° Legend: c-flow-json-node(n,c) ns-flow-yaml-node(n,c) %YAML 1.2 --- !!seq [ !!str \"a\", !!str \"b\", &A !!str \"c\", *A, !!str \"\", ] Chapter 8. Block Styles YAML’s block styles employ indentation rather than indicators to denote structure. This results in a more human readable (though less compact) notation. 8.1. Block Scalar Styles YAML provides two block scalar styles, literal and folded . Each provides a different trade-off between readability and expressive power. 8.1.1. Block Scalar Headers Block scalars are controlled by a few indicators given in a header preceding the content itself. This header is followed by a non-content line break with an optional comment . This is the only case where a comment must not be followed by additional comment lines. [162] c-b-block-header(m,t) ::= ( ( c-indentation-indicator(m) c-chomping-indicator(t) ) | ( c-chomping-indicator(t) c-indentation-indicator(m) ) ) s-b-comment Example 8.1. Block Scalar Header - | # Empty header literal - > 1 # Indentation indicator ·folded - |+ # Chomping indicator keep - > 1- # Both indicators ·strip %YAML 1.2 --- !!seq [ !!str \"literal\\n\", !!str \"·folded\\n\", !!str \"keep\\n\\n\", !!str \"·strip\", ] Legend: c-b-block-header(m,t) 8.1.1.1. Block Indentation Indicator Typically, the indentation level of a block scalar is detected from its first non- empty line. It is an error for any of the leading empty lines to contain more spaces than the first non- empty line . Detection fails when the first non- empty line contains leading content space characters. Content may safely start with a tab or a “ #” character. When detection would fail, YAML requires that the indentation level for the content be given using an explicit indentation indicator. This level is specified as the integer number of the additional indentation spaces used for the content , relative to its parent node . It is always valid to specify an indentation indicator for a block scalar node, though a YAML processor should only emit an explicit indentation indicator for cases where detection will fail. [163] c-indentation-indicator(m) ::= ns-dec-digit m = ns-dec-digit - #x30 /* Empty */ m = auto-detect() Example 8.2. Block Indentation Indicator - |° ·detected - > ° · ·· ··# detected - |1 ··explicit - > ° · ·detected %YAML 1.2 --- !!seq [ !!str \"detected\\n\", !!str \"\\n\\n# detected\\n\", !!str \"·explicit\\n\", !!str \"\\t·detected\\n\", ] Legend: c-indentation-indicator(m) s-indent(n) Example 8.3. Invalid Block Scalar Indentation Indicators - |· · ·text - > ··text ·text - |2 ·text ERROR: - A leading all-space line must not have too many spaces. - A following text line must not be less indented. - The text is less indented than the indicated level. 8.1.1.2. Block Chomping Indicator Chomping controls how final line breaks and trailing empty lines are interpreted. YAML provides three chomping methods: Strip Stripping is specified by the “ -” chomping indicator. In this case, the final line break and any trailing empty lines are excluded from the scalar’s content . Clip Clipping is the default behavior used if no explicit chomping indicator is specified. In this case, the final line break character is preserved in the scalar’s content . However, any trailing empty lines are excluded from the scalar’s content . Keep Keeping is specified by the “ +” chomping indicator. In this case, the final line break and any trailing empty lines are considered to be part of the scalar’s content . These additional lines are not subject to folding . The chomping method used is a presentation detail and must not be used to convey content information. [164] c-chomping-indicator(t) ::= “ -” t = strip “ +” t = keep /* Empty */ t = clip The interpretation of the final line break of a block scalar is controlled by the chomping indicator specified in the block scalar header . [165] b-chomped-last(t) ::= t = strip b-non-content | /* End of file */ t = clip b-as-line-feed | /* End of file */ t = keep b-as-line-feed | /* End of file */ Example 8.4. Chomping Final Line Break strip: |- text clip: | text keep: |+ text Legend: b-non-content b-as-line-feed %YAML 1.2 --- !!map { ? !!str \"strip\" : !!str \"text\", ? !!str \"clip\" : !!str \"text\\n\", ? !!str \"keep\" : !!str \"text\\n\", } The interpretation of the trailing empty lines following a block scalar is also controlled by the chomping indicator specified in the block scalar header . [166] l-chomped-empty(n,t) ::= t = strip l-strip-empty(n) t = clip l-strip-empty(n) t = keep l-keep-empty(n) [167] l-strip-empty(n) ::= ( s-indent( n) b-non-content )* l-trail-comments(n) ? [168] l-keep-empty(n) ::= l-empty(n,block-in) * l-trail-comments(n) ? Explicit comment lines may follow the trailing empty lines . To prevent ambiguity, the first such comment line must be less indented than the block scalar content . Additional comment lines, if any, are not so restricted. This is the only case where the indentation of comment lines is constrained. [169] l-trail-comments(n) ::= s-indent(<n) c-nb-comment-text b-comment l-comment * Example 8.5. Chomping Trailing Lines # Strip # Comments: strip: |- # text ·· ·# Clip ··# comments: clip: | # text · ·# Keep ··# comments: keep: |+ # text ·# Trail ··# comments. %YAML 1.2 --- !!map { ? !!str \"strip\" : !!str \"# text\", ? !!str \"clip\" : !!str \"# text\\n\", ? !!str \"keep\" : !!str \"# text\\n\", } Legend: l-strip-empty(n) l-keep-empty(n) l-trail-comments(n) If a block scalar consists only of empty lines , then these lines are considered as trailing lines and hence are affected by chomping. Example 8.6. Empty Scalar Chomping strip: >- clip: > keep: |+ Legend: l-strip-empty(n) l-keep-empty(n) %YAML 1.2 --- !!map { ? !!str \"strip\" : !!str \"\", ? !!str \"clip\" : !!str \"\", ? !!str \"keep\" : !!str \"\\n\", } 8.1.2. Literal Style The literal style is denoted by the “ |” indicator. It is the simplest, most restricted, and most readable scalar style . [170] c-l+literal(n) ::= “ |” c-b-block-header(m,t) l-literal-content(n+m,t) Example 8.7. Literal Scalar | ·literal · text Legend: c-l+literal(n) %YAML 1.2 --- !!str \"literal\\n\\ttext\\n\" Inside literal scalars, all ( indented ) characters are considered to be content , including white space characters. Note that all line break characters are normalized . In addition, empty lines are not folded , though final line breaks and trailing empty lines are chomped . There is no way to escape characters inside literal scalars. This restricts them to printable characters. In addition, there is no way to break a long literal line. [171] l-nb-literal-text(n) ::= l-empty(n,block-in) * s-indent(n) nb-char + [172] b-nb-literal-next(n) ::= b-as-line-feed l-nb-literal-text(n) [173] l-literal-content(n,t) ::= ( l-nb-literal-text(n) b-nb-literal-next(n) * b-chomped-last(t) )? l-chomped-empty(n,t) Example 8.8. Literal Content |· ·· ··literal ··· ·· ··text ·# Comment %YAML 1.2 --- !!str \"\\n\\nliteral\\n·\\n\\ntext\\n\" Legend: l-nb-literal-text(n) b-nb-literal-next(n) b-chomped-last(t) l-chomped-empty(n,t) 8.1.3. Folded Style The folded style is denoted by the “ >” indicator. It is similar to the literal style ; however, folded scalars are subject to line folding . [174] c-l+folded(n) ::= “ >” c-b-block-header(m,t) l-folded-content(n+m,t) Example 8.9. Folded Scalar > ·folded ·text %YAML 1.2 --- !!str \"folded text\\n\" Legend: c-l+folded(n) Folding allows long lines to be broken anywhere a single space character separates two non- space characters. [175] s-nb-folded-text(n) ::= s-indent(n) ns-char nb-char * [176] l-nb-folded-lines(n) ::= s-nb-folded-text(n) ( b-l-folded(n,block-in) s-nb-folded-text(n) )* Example 8.10. Folded Lines > ·folded ·line ·next ·line * bullet * list * lines ·last ·line # Comment %YAML 1.2 --- !!str \"\\n\\ folded line\\n\\ next line\\n\\ \\ * bullet\\n \\n\\ \\ * list\\n\\ \\ * lines\\n\\ \\n\\ last line\\n\" Legend: s-nb-folded-text(n) l-nb-folded-lines(n) (The following three examples duplicate this example, each highlighting different productions.) Lines starting with white space characters ( more-indented lines) are not folded . [177] s-nb-spaced-text(n) ::= s-indent(n) s-white nb-char * [178] b-l-spaced(n) ::= b-as-line-feed l-empty(n,block-in) * [179] l-nb-spaced-lines(n) ::= s-nb-spaced-text(n) ( b-l-spaced(n) s-nb-spaced-text(n) )* Example 8.11. More Indented Lines > folded line next line ···* bullet ···* list ···* lines last line # Comment %YAML 1.2 --- !!str \"\\n\\ folded line\\n\\ next line\\n\\ \\ * bullet\\n \\n\\ \\ * list\\n\\ \\ * lines\\n\\ \\n\\ last line\\n\" Legend: s-nb-spaced-text(n) l-nb-spaced-lines(n) Line breaks and empty lines separating folded and more-indented lines are also not folded . [180] l-nb-same-lines(n) ::= l-empty(n,block-in) * ( l-nb-folded-lines(n) | l-nb-spaced-lines(n) ) [181] l-nb-diff-lines(n) ::= l-nb-same-lines(n) ( b-as-line-feed l-nb-same-lines(n) )* Example 8.12. Empty Separation Lines > folded line next line * bullet * list * line last line # Comment %YAML 1.2 --- !!str \"\\n\\ folded line\\n\\ next line\\n\\ \\ * bullet\\n \\n\\ \\ * list\\n\\ \\ * lines\\n\\ \\n\\ last line\\n\" Legend: b-as-line-feed (separation) l-empty(n,c) The final line break , and trailing empty lines if any, are subject to chomping and are never folded . [182] l-folded-content(n,t) ::= ( l-nb-diff-lines(n) b-chomped-last(t) )? l-chomped-empty(n,t) Example 8.13. Final Empty Lines > folded line next line * bullet * list * line last line # Comment %YAML 1.2 --- !!str \"\\n\\ folded line\\n\\ next line\\n\\ \\ * bullet\\n \\n\\ \\ * list\\n\\ \\ * lines\\n\\ \\n\\ last line\\n\" Legend: b-chomped-last(t) l-chomped-empty(n,t) 8.2. Block Collection Styles For readability, block collections styles are not denoted by any indicator . Instead, YAML uses a lookahead method, where a block collection is distinguished from a plain scalar only when a key: value pair or a sequence entry is seen. 8.2.1. Block Sequences A block sequence is simply a series of nodes , each denoted by a leading “ -” indicator. The “ -” indicator must be separated from the node by white space . This allows “ -” to be used as the first character in a plain scalar if followed by a non-space character (e.g. “ -1”). [183] l+block-sequence(n) ::= ( s-indent(n+m) c-l-block-seq-entry(n+m) )+ /* For some fixed auto-detected m > 0 */ [184] c-l-block-seq-entry(n) ::= “ -” /* Not followed by an ns-char */ s-l+block-indented(n,block-in) Example 8.14. Block Sequence block sequence: ·· - one - two : three Legend: c-l-block-seq-entry(n) auto-detected s-indent(n) %YAML 1.2 --- !!map { ? !!str \"block sequence\" : !!seq [ !!str \"one\", !!map { ? !!str \"two\" : !!str \"three\" }, ], } The entry node may be either completely empty , be a nested block node , or use a compact in-line notation. The compact notation may be used when the entry is itself a nested block collection . In this case, both the “ -” indicator and the following spaces are considered to be part of the indentation of the nested collection . Note that it is not possible to specify node properties for such a collection . [185] s-l+block-indented(n,c) ::= ( s-indent(m) ( ns-l-compact-sequence(n+1+m) | ns-l-compact-mapping(n+1+m) ) ) | s-l+block-node(n,c) | ( e-node s-l-comments ) [186] ns-l-compact-sequence(n) ::= c-l-block-seq-entry(n) ( s-indent(n) c-l-block-seq-entry(n) )* Example 8.15. Block Sequence Entry Types - ° # Empty - | block node - ·- one # Compact ··- two # sequence - one: two # Compact mapping Legend: Empty s-l+block-node(n,c) ns-l-compact-sequence(n) ns-l-compact-mapping(n) %YAML 1.2 --- !!seq [ !!null \"\", !!str \"block node\\n\", !!seq [ !!str \"one\" !!str \"two\", ], !!map { ? !!str \"one\" : !!str \"two\", }, ] 8.2.2. Block Mappings A Block mapping is a series of entries, each presenting a key: value pair . [187] l+block-mapping(n) ::= ( s-indent(n+m) ns-l-block-map-entry(n+m) )+ /* For some fixed auto-detected m > 0 */ Example 8.16. Block Mappings block mapping: · key: value Legend: ns-l-block-map-entry(n) auto-detected s-indent(n) %YAML 1.2 --- !!map { ? !!str \"block mapping\" : !!map { ? !!str \"key\" : !!str \"value\", }, } If the “ ?” indicator is specified, the optional value node must be specified on a separate line, denoted by the “ :” indicator. Note that YAML allows here the same compact in-line notation described above for block sequence entries. [188] ns-l-block-map-entry(n) ::= c-l-block-map-explicit-entry(n) | ns-l-block-map-implicit-entry(n) [189] c-l-block-map-explicit-entry(n) ::= c-l-block-map-explicit-key(n) ( l-block-map-explicit-value(n) | e-node ) [190] c-l-block-map-explicit-key(n) ::= “ ?” s-l+block-indented(n,block-out) [191] l-block-map-explicit-value(n) ::= s-indent(n) “ :” s-l+block-indented(n,block-out) Example 8.17. Explicit Block Mapping Entries ? explicit key # Empty value ° ? | block key :·- one # Explicit compact ··- two # block value Legend: c-l-block-map-explicit-key(n) l-block-map-explicit-value(n) e-node %YAML 1.2 --- !!map { ? !!str \"explicit key\" : !!str \"\", ? !!str \"block key\\n\" : !!seq [ !!str \"one\", !!str \"two\", ], } If the “ ?” indicator is omitted, parsing needs to see past the implicit key , in the same way as in the single key: value pair flow mapping . Hence, such keys are subject to the same restrictions; they are limited to a single line and must not span more than 1024 Unicode characters. [192] ns-l-block-map-implicit-entry(n) ::= ( ns-s-block-map-implicit-key | e-node ) c-l-block-map-implicit-value(n) [193] ns-s-block-map-implicit-key ::= c-s-implicit-json-key(block-key) | ns-s-implicit-yaml-key(block-key) In this case, the value may be specified on the same line as the implicit key . Note however that in block mappings the value must never be adjacent to the “ :”, as this greatly reduces readability and is not required for JSON compatibility (unlike the case in flow mappings ). There is no compact notation for in-line values . Also, while both the implicit key and the value following it may be empty, the “ :” indicator is mandatory. This prevents a potential ambiguity with multi-line plain scalars . [194] c-l-block-map-implicit-value(n) ::= “ :” ( s-l+block-node(n,block-out) | ( e-node s-l-comments ) ) Example 8.18. Implicit Block Mapping Entries plain key : in-line value ° :° # Both empty \"quoted key\" : - entry Legend: ns-s-block-map-implicit-key c-l-block-map-implicit-value(n) %YAML 1.2 --- !!map { ? !!str \"plain key\" : !!str \"in-line value\", ? !!null \"\" : !!null \"\", ? !!str \"quoted key\" : !!seq [ !!str \"entry\" ], } A compact in-line notation is also available. This compact notation may be nested inside block sequences and explicit block mapping entries. Note that it is not possible to specify node properties for such a nested mapping. [195] ns-l-compact-mapping(n) ::= ns-l-block-map-entry(n) ( s-indent(n) ns-l-block-map-entry(n) )* Example 8.19. Compact Block Mappings - sun: yellow - ? earth: blue : moon: white Legend: ns-l-compact-mapping(n) %YAML 1.2 --- !!seq [ !!map { !!str \"sun\" : !!str \"yellow\", }, !!map { ? !!map { ? !!str \"earth\" : !!str \"blue\" }, : !!map { ? !!str \"moon\" : !!str \"white\" }, } ] 8.2.3. Block Nodes YAML allows flow nodes to be embedded inside block collections (but not vice-versa). Flow nodes must be indented by at least one more space than the parent block collection . Note that flow nodes may begin on a following line. It is at this point that parsing needs to distinguish between a plain scalar and an implicit key starting a nested block mapping . [196] s-l+block-node(n,c) ::= s-l+block-in-block(n,c) | s-l+flow-in-block(n) [197] s-l+flow-in-block(n) ::= s-separate(n+1,flow-out) ns-flow-node(n+1,flow-out) s-l-comments Example 8.20. Block Node Types - ··\"flow in block\" -· > Block scalar -· !!map # Block collection foo : bar Legend: s-l+flow-in-block(n) s-l+block-in-block(n,c) %YAML 1.2 --- !!seq [ !!str \"flow in block\", !!str \"Block scalar\\n\", !!map { ? !!str \"foo\" : !!str \"bar\", }, ] The block node’s properties may span across several lines. In this case, they must be indented by at least one more space than the block collection , regardless of the indentation of the block collection entries. [198] s-l+block-in-block(n,c) ::= s-l+block-scalar(n,c) | s-l+block-collection(n,c) [199] s-l+block-scalar(n,c) ::= s-separate(n+1,c) ( c-ns-properties(n+1,c) s-separate(n+1,c) )? ( c-l+literal(n) | c-l+folded(n) ) Example 8.21. Block Scalar Nodes literal: |2 ··value folded: ···!foo ··>1 ·value Legend: c-l+literal(n) c-l+folded(n) %YAML 1.2 --- !!map { ? !!str \"literal\" : !!str \"value\", ? !!str \"folded\" : !<!foo> \"value\", } Since people perceive the “ -” indicator as indentation , nested block sequences may be indented by one less space to compensate, except, of course, if nested inside another block sequence ( block-out context vs. block-in context ). [200] s-l+block-collection(n,c) ::= ( s-separate(n+1,c) c-ns-properties(n+1,c) )? s-l-comments ( l+block-sequence( seq-spaces(n,c) ) | l+block-mapping(n) ) [201] seq-spaces(n,c) ::= c = block-out n-1 c = block-in n Example 8.22. Block Collection Nodes sequence: !!seq - entry - !!seq - nested mapping: !!map foo: bar Legend: l+block-sequence(n) l+block-mapping(n) s-l+block-collection(n,c) %YAML 1.2 --- !!map { ? !!str \"sequence\" : !!seq [ !!str \"entry\", !!seq [ !!str \"nested\" ], ], ? !!str \"mapping\" : !!map { ? !!str \"foo\" : !!str \"bar\", }, } Chapter 9. YAML Character Stream 9.1. Documents A YAML character stream may contain several documents. Each document is completely independent from the rest. 9.1.1. Document Prefix A document may be preceded by a prefix specifying the character encoding , and optional comment lines. Note that all documents in a stream must use the same character encoding . However it is valid to re-specify the encoding using a byte order mark for each document in the stream. This makes it easier to concatenate streams. The existence of the optional prefix does not necessarily indicate the existence of an actual document . [202] l-document-prefix ::= c-byte-order-mark ? l-comment * Example 9.1. Document Prefix # Comment # lines Document Legend: l-document-prefix %YAML 1.2 --- !!str \"Document\" 9.1.2. Document Markers Using directives creates a potential ambiguity. It is valid to have a “ %” character at the start of a line (e.g. as the first character of the second line of a plain scalar ). How, then, to distinguish between an actual directive and a content line that happens to start with a “ %” character? The solution is the use of two special marker lines to control the processing of directives , one at the start of a document and one at the end. At the start of a document , lines beginning with a “ %” character are assumed to be directives . The (possibly empty) list of directives is terminated by a directives end marker line. Lines following this marker can safely use “ %” as the first character. At the end of a document , a document end marker line is used to signal the parser to begin scanning for directives again. The existence of this optional document suffix does not necessarily indicate the existence of an actual following document . Obviously, the actual content lines are therefore forbidden to begin with either of these markers. [203] c-directives-end ::= “ -” “ -” “ -” [204] c-document-end ::= “ .” “ .” “ .” [205] l-document-suffix ::= c-document-end s-l-comments [206] c-forbidden ::= /* Start of line */ ( c-directives-end | c-document-end ) ( b-char | s-white | /* End of file */ ) Example 9.2. Document Markers %YAML 1.2 --- Document ... # Suffix %YAML 1.2 --- !!str \"Document\" Legend: c-directives-end c-document-end l-document-suffix 9.1.3. Bare Documents A bare document does not begin with any directives or marker lines. Such documents are very “ clean” as they contain nothing other than the content . In this case, the first non-comment line may not start with a “ %” first character. Document nodes are indented as if they have a parent indented at -1 spaces . Since a node must be more indented than its parent node , this allows the document’s node to be indented at zero or more spaces . [207] l-bare-document ::= s-l+block-node(-1,block-in) /* Excluding c-forbidden content */ Example 9.3. Bare Documents Bare document ... # No document ... | %!PS-Adobe-2.0 # Not the first line %YAML 1.2 --- !!str \"Bare document\" %YAML 1.2 --- !!str \"%!PS-Adobe-2.0\\n\" Legend: l-bare-document 9.1.4. Explicit Documents An explicit document begins with an explicit directives end marker line but no directives . Since the existence of the document is indicated by this marker , the document itself may be completely empty . [208] l-explicit-document ::= c-directives-end ( l-bare-document | ( e-node s-l-comments ) ) Example 9.4. Explicit Documents --- { matches % : 20 } ... --- # Empty ... Legend: l-explicit-document %YAML 1.2 --- !!map { !!str \"matches %\": !!int \"20\" } ... %YAML 1.2 --- !!null \"\" 9.1.5. Directives Documents A directives document begins with some directives followed by an explicit directives end marker line. [209] l-directive-document ::= l-directive + l-explicit-document Example 9.5. Directives Documents %YAML 1.2 --- | %!PS-Adobe-2.0 ... %YAML1.2 --- # Empty ... Legend: l-explicit-document %YAML 1.2 --- !!str \"%!PS-Adobe-2.0\\n\" ... %YAML 1.2 --- !!null \"\" 9.2. Streams A YAML stream consists of zero or more documents . Subsequent documents require some sort of separation marker line. If a document is not terminated by a document end marker line, then the following document must begin with a directives end marker line. The stream format is intentionally “ sloppy” to better support common use cases, such as stream concatenation. [210] l-any-document ::= l-directive-document | l-explicit-document | l-bare-document [211] l-yaml-stream ::= l-document-prefix * l-any-document ? ( l-document-suffix + l-document-prefix * l-any-document ? | l-document-prefix * l-explicit-document ? )* Example 9.6. Stream Document --- # Empty ... %YAML 1.2 --- matches %: 20 Legend: l-any-document l-document-suffix l-explicit-document %YAML 1.2 --- !!str \"Document\" ... %YAML 1.2 --- !!null \"\" ... %YAML 1.2 --- !!map { !!str \"matches %\": !!int \"20\" } A sequence of bytes is a well-formed stream if, taken as a whole, it complies with the above l-yaml-stream production. Some common use case that can take advantage of the YAML stream structure are: Appending to Streams Allowing multiple documents in a single stream makes YAML suitable for log files and similar applications . Note that each document is independent of the rest, allowing for heterogeneous log file entries. Concatenating Streams Concatenating two YAML streams requires both to use the same character encoding . In addition, it is necessary to separate the last document of the first stream and the first document of the second stream. This is easily ensured by inserting a document end marker between the two streams. Note that this is safe regardless of the content of either stream. In particular, either or both may be empty, and the first stream may or may not already contain such a marker. Communication Streams The document end marker allows signaling the end of a document without closing the stream or starting the next document . This allows the receiver to complete processing a document without having to wait for the next one to arrive. The sender may also transmit \"keep-alive\" messages in the form of comment lines or repeated document end markers without signalling the start of the next document . Chapter 10. Recommended Schemas A YAML schema is a combination of a set of tags and a mechanism for resolving non-specific tags . 10.1. Failsafe Schema The failsafe schema is guaranteed to work with any YAML document . It is therefore the recommended schema for generic YAML tools. A YAML processor should therefore support this schema , at least as an option. 10.1.1. Tags 10.1.1.1. Generic Mapping URI: tag:yaml.org,2002:map Kind: Mapping . Definition: Represents an associative container, where each key is unique in the association and mapped to exactly one value . YAML places no restrictions on the type of keys ; in particular, they are not restricted to being scalars . Example bindings to native types include Perl’s hash, Python’s dictionary, and Java’s Hashtable. Example 10.1. !!map Examples Block style: !!map Clark : Evans Ingy : döt Net Oren : Ben-Kiki Flow style: !!map { Clark: Evans, Ingy: döt Net, Oren: Ben-Kiki } 10.1.1.2. Generic Sequence URI: tag:yaml.org,2002:seq Kind: Sequence . Definition: Represents a collection indexed by sequential integers starting with zero. Example bindings to native types include Perl’s array, Python’s list or tuple, and Java’s array or Vector. Example 10.2. !!seq Examples Block style: !!seq - Clark Evans - Ingy döt Net - Oren Ben-Kiki Flow style: !!seq [ Clark Evans, Ingy döt Net, Oren Ben-Kiki ] 10.1.1.3. Generic String URI: tag:yaml.org,2002:str Kind: Scalar . Definition: Represents a Unicode string, a sequence of zero or more Unicode characters. This type is usually bound to the native language’s string type, or, for languages lacking one (such as C), to a character array. Canonical Form: The obvious. Example 10.3. !!str Examples Block style: !!str |- String: just a theory. Flow style: !!str \"String: just a theory.\" 10.1.2. Tag Resolution All nodes with the “ !” non-specific tag are resolved , by the standard convention , to “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map”, or “ tag:yaml.org,2002:str”, according to their kind . All nodes with the “ ?” non-specific tag are left unresolved . This constrains the application to deal with a partial representation . 10.2. JSON Schema The JSON schema is the lowest common denominator of most modern computer languages, and allows parsing JSON files. A YAML processor should therefore support this schema , at least as an option. It is also strongly recommended that other schemas should be based on it. 10.2.1. Tags The JSON schema uses the following tags in addition to those defined by the failsafe schema: 10.2.1.1. Null URI: tag:yaml.org,2002:null Kind: Scalar . Definition: Represents the lack of a value. This is typically bound to a native null-like value (e.g., undef in Perl, None in Python). Note that a null is different from an empty string. Also, a mapping entry with some key and a null value is valid, and different from not having that key in the mapping . Canonical Form: null. Example 10.4. !!null Examples !!null null: value for null key key with null value: !!null null 10.2.1.2. Boolean URI: tag:yaml.org,2002:bool Kind: Scalar . Definition: Represents a true/false value. In languages without a native Boolean type (such as C), is usually bound to a native integer type, using one for true and zero for false. Canonical Form: Either true or false. Example 10.5. !!bool Examples YAML is a superset of JSON: !!bool true Pluto is a planet: !!bool false 10.2.1.3. Integer URI: tag:yaml.org,2002:int Kind: Scalar . Definition: Represents arbitrary sized finite mathematical integers. Scalars of this type should be bound to a native integer data type, if possible. Some languages (such as Perl) provide only a “ number” type that allows for both integer and floating-point values. A YAML processor may use such a type for integers, as long as they round-trip properly. In some languages (such as C), an integer may overflow the native type’s storage capability. A YAML processor may reject such a value as an error, truncate it with a warning, or find some other manner to round-trip it. In general, integers representable using 32 binary digits should safely round-trip through most systems. Canonical Form: Decimal integer notation, with a leading “ -” character for negative values, matching the regular expression 0 | -? [1-9] [0-9]* Example 10.6. !!int Examples negative: !!int -12 zero: !!int 0 positive: !!int 34 10.2.1.4. Floating Point URI: tag:yaml.org,2002:float Kind: Scalar . Definition: Represents an approximation to real numbers, including three special values (positive and negative infinity, and “ not a number”). Some languages (such as Perl) provide only a “ number” type that allows for both integer and floating-point values. A YAML processor may use such a type for floating-point numbers, as long as they round-trip properly. Not all floating-point values can be stored exactly in any given native type. Hence a float value may change by “ a small amount” when round-tripped. The supported range and accuracy depends on the implementation, though 32 bit IEEE floats should be safe. Since YAML does not specify a particular accuracy, using floating-point mapping keys requires great care and is not recommended. Canonical Form: Either 0, .inf, -.inf, .nan, or scientific notation matching the regular expression -? [1-9] ( \\. [0-9]* [1-9] )? ( e [-+] [1-9] [0-9]* )?. Example 10.7. !!float Examples negative: !!float -1 zero: !!float 0 positive: !!float 2.3e4 infinity: !!float .inf not a number: !!float .nan 10.2.2. Tag Resolution The JSON schema tag resolution is an extension of the failsafe schema tag resolution . All nodes with the “ !” non-specific tag are resolved , by the standard convention , to “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map”, or “ tag:yaml.org,2002:str”, according to their kind . Collections with the “ ?” non-specific tag (that is, untagged collections ) are resolved to “ tag:yaml.org,2002:seq” or “ tag:yaml.org,2002:map” according to their kind . Scalars with the “ ?” non-specific tag (that is, plain scalars ) are matched with a list of regular expressions (first match wins, e.g. 0 is resolved as !!int). In principle, JSON files should not contain any scalars that do not match at least one of these. Hence the YAML processor should consider them to be an error. Regular expression Resolved to tag null tag:yaml.org,2002:null true | false tag:yaml.org,2002:bool -? ( 0 | [1-9] [0-9]* ) tag:yaml.org,2002:int -? ( 0 | [1-9] [0-9]* ) ( \\. [0-9]* )? ( [eE] [-+]? [0-9]+ )? tag:yaml.org,2002:float * Error Example 10.8. JSON Tag Resolution A null: null Booleans: [ true, false ] Integers: [ 0, -0, 3, -19 ] Floats: [ 0., -0.0, 12e03, -2E+05 ] Invalid: [ True, Null, 0o7, 0x3A, +12.3 ] %YAML 1.2 --- !!map { !!str \"A null\" : !!null \"null\", !!str \"Booleans: !!seq [ !!bool \"true\", !!bool \"false\" ], !!str \"Integers\": !!seq [ !!int \"0\", !!int \"-0\", !!int \"3\", !!int \"-19\" ], !!str \"Floats\": !!seq [ !!float \"0.\", !!float \"-0.0\", !!float \"12e03\", !!float \"-2E+05\" ], !!str \"Invalid\": !!seq [ # Rejected by the schema True, Null, 0o7, 0x3A, +12.3, ], } ... 10.3. Core Schema The Core schema is an extension of the JSON schema , allowing for more human-readable presentation of the same types. This is the recommended default schema that YAML processor should use unless instructed otherwise. It is also strongly recommended that other schemas should be based on it. 10.3.1. Tags The core schema uses the same tags as the JSON schema . 10.3.2. Tag Resolution The core schema tag resolution is an extension of the JSON schema tag resolution . All nodes with the “ !” non-specific tag are resolved , by the standard convention , to “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map”, or “ tag:yaml.org,2002:str”, according to their kind . Collections with the “ ?” non-specific tag (that is, untagged collections ) are resolved to “ tag:yaml.org,2002:seq” or “ tag:yaml.org,2002:map” according to their kind . Scalars with the “ ?” non-specific tag (that is, plain scalars ) are matched with an extended list of regular expressions. However, in this case, if none of the regular expressions matches, the scalar is resolved to tag:yaml.org,2002:str (that is, considered to be a string). Regular expression Resolved to tag null | Null | NULL | ~ tag:yaml.org,2002:null /* Empty */ tag:yaml.org,2002:null true | True | TRUE | false | False | FALSE tag:yaml.org,2002:bool [-+]? [0-9]+ tag:yaml.org,2002:int (Base 10) 0o [0-7]+ tag:yaml.org,2002:int (Base 8) 0x [0-9a-fA-F]+ tag:yaml.org,2002:int (Base 16) [-+]? ( \\. [0-9]+ | [0-9]+ ( \\. [0-9]* )? ) ( [eE] [-+]? [0-9]+ )? tag:yaml.org,2002:float (Number) [-+]? ( \\.inf | \\.Inf | \\.INF ) tag:yaml.org,2002:float (Infinity) \\.nan | \\.NaN | \\.NAN tag:yaml.org,2002:float (Not a number) * tag:yaml.org,2002:str (Default) Example 10.9. Core Tag Resolution A null: null Also a null: # Empty Not a null: \"\" Booleans: [ true, True, false, FALSE ] Integers: [ 0, 0o7, 0x3A, -19 ] Floats: [ 0., -0.0, .5, +12e03, -2E+05 ] Also floats: [ .inf, -.Inf, +.INF, .NAN ] %YAML 1.2 --- !!map { !!str \"A null\" : !!null \"null\", !!str \"Also a null\" : !!null \"\", !!str \"Not a null\" : !!str \"\", !!str \"Booleans: !!seq [ !!bool \"true\", !!bool \"True\", !!bool \"false\", !!bool \"FALSE\", ], !!str \"Integers\": !!seq [ !!int \"0\", !!int \"0o7\", !!int \"0x3A\", !!int \"-19\", ], !!str \"Floats\": !!seq [ !!float \"0.\", !!float \"-0.0\", !!float \".5\", !!float \"+12e03\", !!float \"-2E+05\" ], !!str \"Also floats\": !!seq [ !!float \".inf\", !!float \"-.Inf\", !!float \"+.INF\", !!float \".NAN\", ], } ... 10.4. Other Schemas None of the above recommended schemas preclude the use of arbitrary explicit tags . Hence YAML processors for a particular programming language typically provide some form of local tags that map directly to the language’s native data structures (e.g., !ruby/object:Set). While such local tags are useful for ad-hoc applications , they do not suffice for stable, interoperable cross- application or cross-platform data exchange. Interoperable schemas make use of global tags (URIs) that represent the same data across different programming languages. In addition, an interoperable schema may provide additional tag resolution rules. Such rules may provide additional regular expressions, as well as consider the path to the node . This allows interoperable schemas to use untagged nodes . It is strongly recommended that such schemas be based on the core schema defined above. In addition, it is strongly recommended that such schemas make as much use as possible of the the YAML tag repository at http://yaml.org/type/ . This repository provides recommended global tags for increasing the portability of YAML documents between different applications . The tag repository is intentionally left out of the scope of this specification. This allows it to evolve to better support YAML applications . Hence, developers are encouraged to submit new “ universal” types to the repository. The yaml-core mailing list at http://lists.sourceforge.net/lists/listinfo/yaml-core is the preferred method for such submissions, as well as raising any questions regarding this draft. Index Indicators ! tag indicator, Tags , Indicator Characters , Node Tags ! local tag, Tags , Tag Handles , Tag Prefixes , Node Tags ! non-specific tag, Resolved Tags , Node Tags , Tag Resolution , Tag Resolution , Tag Resolution ! primary tag handle, Tag Handles !! secondary tag handle, Tag Handles !…! named handle, Tag Handles , Node Tags \" double-quoted style, Indicator Characters , Double-Quoted Style # comment, Collections , Indicator Characters , Comments , Plain Style , Block Indentation Indicator % directive, Indicator Characters , Directives , Document Markers , Bare Documents % escaping in URI, Tags , Miscellaneous Characters , Node Tags & anchor, Structures , Indicator Characters , Node Anchors ' reserved indicator, Indicator Characters ' single-quoted style, Indicator Characters , Single-Quoted Style * alias, Structures , Indicator Characters , Alias Nodes + keep chomping, Block Chomping Indicator , end flow entry, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Collection Styles , Flow Sequences , Flow Mappings - block sequence entry, Introduction , Collections , Structures , Production Parameters , Indicator Characters , Indentation Spaces , Plain Style , Block Collection Styles , Block Sequences , Block Nodes - strip chomping, Block Chomping Indicator : mapping value, Introduction , Collections , Structures , Indicator Characters , Indentation Spaces , Plain Style , Flow Mappings , Block Mappings <…> verbatim tag, Node Tags > folded style, Scalars , Indicator Characters , Folded Style ? mapping key, Structures , Indicator Characters , Indentation Spaces , Plain Style , Flow Mappings , Block Mappings ? non-specific tag, Resolved Tags , Node Tags , Tag Resolution , Tag Resolution , Tag Resolution @ reserved indicator, Indicator Characters [ start flow sequence, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Sequences \\ escaping in double-quoted scalars, Escaped Characters , Double-Quoted Style ] end flow sequence, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Sequences { start flow mapping, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Mappings | literal style, Scalars , Indicator Characters , Literal Style } end flow mapping, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Mappings prefix, Document Prefix A alias, Introduction , Prior Art , Structures , Dump , Serialization Tree , Anchors and Aliases , Loading Failure Points , Well-Formed Streams and Identified Aliases , Resolved Tags , Indicator Characters , Node Anchors , Flow Styles , Alias Nodes , Flow Nodes identified, Structures , Anchors and Aliases , Well-Formed Streams and Identified Aliases unidentified, Loading Failure Points , Well-Formed Streams and Identified Aliases anchor, Structures , Dump , Serialization Tree , Anchors and Aliases , Well-Formed Streams and Identified Aliases , Resolved Tags , Indicator Characters , Node Properties , Flow Styles , Alias Nodes , Flow Nodes application, Introduction , Prior Art , Tags , Processing YAML Information , Dump , Information Models , Tags , Serialization Tree , Keys Order , Resolved Tags , Available Tags , Tag Prefixes , Node Tags , Streams , Tag Resolution , Other Schemas B block scalar header, Comments , Block Scalar Headers , Block Chomping Indicator byte order mark, Character Encodings , Document Prefix C character encoding, Character Encodings , Document Prefix , Streams in URI, Miscellaneous Characters chomping, Production Parameters , Line Folding , Block Chomping Indicator , Literal Style , Folded Style clip, Production Parameters , Block Chomping Indicator keep, Production Parameters , Block Chomping Indicator strip, Production Parameters , Block Chomping Indicator collection, Prior Art , Representation Graph , Nodes , Node Comparison , Anchors and Aliases , Node Styles , Comments , Resolved Tags , Recognized and Valid Tags , Tag Resolution , Tag Resolution comment, Collections , Processes , Dump , Load , Presentation Stream , Comments , Resolved Tags , Indicator Characters , Comments , Separation Lines , Plain Style , Block Scalar Headers , Block Chomping Indicator , Document Prefix , Streams compose, Processes , Load , Keys Order , Anchors and Aliases , Resolved Tags , Recognized and Valid Tags , Available Tags , Node Anchors construct, Processes , Load , Serialization Tree , Loading Failure Points , Recognized and Valid Tags , Available Tags , Flow Styles , Generic Mapping , Generic Sequence , Generic String , Null , Boolean , Integer content, Structures , Dump , Nodes , Tags , Node Comparison , Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Character Encodings , Line Break Characters , Escaped Characters , Indentation Spaces , Separation Spaces , Line Prefixes , Empty Lines , Line Folding , Comments , Directives , Tag Handles , Node Properties , Node Tags , Node Anchors , Alias Nodes , Empty Nodes , Flow Scalar Styles , Double-Quoted Style , Single-Quoted Style , Plain Style , Block Scalar Headers , Block Indentation Indicator , Block Chomping Indicator , Literal Style , Document Markers , Bare Documents valid, Recognized and Valid Tags context, Production Parameters , Plain Style block-in, Production Parameters , Block Nodes block-key, Production Parameters , Flow Collection Styles block-out, Production Parameters , Block Nodes flow-in, Production Parameters , Flow Collection Styles flow-key, Production Parameters , Flow Collection Styles flow-out, Production Parameters , Flow Collection Styles D directive, Structures , Dump , Load , Presentation Stream , Directives , Indicator Characters , Directives , Document Markers , Bare Documents , Explicit Documents , Directives Documents reserved, Directives , Directives TAG, Tags , Directives , Indicator Characters , Directives , “TAG” Directives , Node Tags YAML, Directives , Directives , “YAML” Directives document, Prior Art , Structures , Presentation Stream , Directives , Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Character Encodings , Line Break Characters , “YAML” Directives , Tag Prefixes , Alias Nodes , Documents , Document Prefix , Document Markers , Explicit Documents , Streams , Failsafe Schema , Other Schemas bare, Bare Documents directives, Directives Documents explicit, Explicit Documents suffix, Document Markers dump, Processes , Dump E empty line, Prior Art , Scalars , Empty Lines , Line Folding , Block Indentation Indicator , Block Chomping Indicator , Literal Style , Folded Style equality, Relation to JSON , Dump , Representation Graph , Nodes , Tags , Node Comparison , Scalar Formats , Loading Failure Points , Recognized and Valid Tags escaping in double-quoted scalars, Prior Art , Scalars , Character Set , Character Encodings , Miscellaneous Characters , Escaped Characters , Double-Quoted Style in single-quoted scalars, Single-Quoted Style in URIs, Miscellaneous Characters non-content line break, Double-Quoted Style I identity, Node Comparison indicator, Introduction , Prior Art , Collections , Node Styles , Production Parameters , Indicator Characters , Line Folding , Plain Style , Flow Mappings , Flow Nodes , Block Styles , Block Scalar Headers , Block Collection Styles indentation, Block Indentation Indicator reserved, Indicator Characters information model, Information Models invalid content, Loading Failure Points , Recognized and Valid Tags J JSON compatibility, Character Set , Character Encodings , Line Break Characters , Escaped Characters , Comments , “YAML” Directives , Flow Mappings , Block Mappings JSON-like, Flow Mappings , Flow Nodes K key, Relation to JSON , Structures , Dump , Information Models , Representation Graph , Nodes , Node Comparison , Serialization Tree , Keys Order , Resolved Tags , Indicator Characters , Flow Mappings , Block Mappings , Generic Mapping , Null , Floating Point implicit, Separation Lines , Double-Quoted Style , Single-Quoted Style , Plain Style , Flow Collection Styles , Flow Mappings , Block Mappings , Block Nodes order, Processes , Dump , Load , Information Models , Serialization Tree , Keys Order key: value pair, Introduction , Collections , Structures , Nodes , Keys Order , Node Styles , Plain Style , Flow Mappings , Block Collection Styles , Block Mappings kind, Dump , Representation Graph , Nodes , Tags , Node Comparison , Node Styles , Resolved Tags , Node Tags , Tag Resolution , Tag Resolution , Tag Resolution L line break, Prior Art , Scalars , Production Parameters , Production Naming Conventions , Line Break Characters , White Space Characters , Empty Lines , Line Folding , Comments , Double-Quoted Style , Block Scalar Headers , Block Chomping Indicator , Literal Style , Folded Style non-ASCII, Line Break Characters , “YAML” Directives normalization, Line Break Characters , Literal Style line folding, Prior Art , Scalars , Line Folding , Flow Styles , Double-Quoted Style , Single-Quoted Style , Plain Style , Block Chomping Indicator , Folded Style block, Line Folding , Folded Style flow, Line Folding , Double-Quoted Style line prefix, Line Prefixes , Empty Lines load, Processes , Load , Loading Failure Points failure point, Load , Loading Failure Points M mapping, Introduction , Prior Art , Relation to JSON , Collections , Structures , Dump , Representation Graph , Nodes , Tags , Node Comparison , Keys Order , Resolved Tags , Plain Style , Flow Sequences , Flow Mappings , Generic Mapping , Null marker, Presentation Stream , Document Markers , Bare Documents , Explicit Documents , Streams directives end, Structures , Document Markers , Explicit Documents , Directives Documents , Streams document end, Structures , Document Markers , Streams more-indented, Scalars , Line Folding , Folded Style N native data structure, Introduction , Goals , Prior Art , Relation to JSON , Processing YAML Information , Processes , Dump , Load , Representation Graph , Nodes , Tags , Node Comparison , Serialization Tree , Loading Failure Points , Recognized and Valid Tags , Available Tags , Node Tags , Flow Styles , Generic Mapping , Generic Sequence , Generic String , Null , Boolean , Integer , Floating Point , Other Schemas need not, Terminology node, Structures , Dump , Representation Graph , Nodes , Tags , Node Comparison , Serialization Tree , Keys Order , Anchors and Aliases , Presentation Stream , Node Styles , Comments , Loading Failure Points , Well-Formed Streams and Identified Aliases , Resolved Tags , Recognized and Valid Tags , Syntax Conventions , Indentation Spaces , Node Properties , Node Tags , Node Anchors , Alias Nodes , Empty Nodes , Flow Mappings , Flow Nodes , Block Indentation Indicator , Block Sequences , Bare Documents , Tag Resolution , Tag Resolution , Tag Resolution , Other Schemas completely empty, Empty Nodes , Flow Collection Styles , Flow Mappings , Block Sequences , Explicit Documents property, Node Properties , Alias Nodes , Empty Nodes , Flow Mappings , Flow Nodes , Block Sequences , Block Mappings , Block Nodes root, Representation Graph , Resolved Tags P parse, Load , Presentation Stream , Resolved Tags , Production Parameters , Line Break Characters , Escaped Characters , Tag Handles , Node Tags , Flow Mappings , Block Mappings , Block Nodes , Document Markers , JSON Schema present, Processing YAML Information , Dump , Load , Nodes , Node Comparison , Presentation Stream , Scalar Formats , Character Set , Miscellaneous Characters , Node Tags , Alias Nodes , Block Mappings , Core Schema presentation, Processing YAML Information , Information Models , Presentation Stream , Production Parameters detail, Dump , Load , Information Models , Presentation Stream , Node Styles , Scalar Formats , Comments , Directives , Resolved Tags , Character Encodings , Line Break Characters , Escaped Characters , Indentation Spaces , Separation Spaces , Line Prefixes , Line Folding , Comments , Directives , Tag Handles , Node Tags , Flow Scalar Styles , Block Chomping Indicator printable character, Introduction , Prior Art , Character Set , White Space Characters , Escaped Characters , Single-Quoted Style , Literal Style processor, Terminology , Processing YAML Information , Dump , Node Comparison , Presentation Stream , Directives , Well-Formed Streams and Identified Aliases , Resolved Tags , Recognized and Valid Tags , Available Tags , Character Set , Character Encodings , Line Break Characters , Miscellaneous Characters , Comments , Directives , “YAML” Directives , Tag Handles , Node Tags , Node Anchors , Flow Mappings , Block Indentation Indicator , Failsafe Schema , JSON Schema , Integer , Floating Point , Tag Resolution , Core Schema , Other Schemas R represent, Introduction , Prior Art , Dump , Tags , Node Comparison , Keys Order , Generic Mapping , Generic Sequence , Generic String , Null , Boolean , Integer , Floating Point , Other Schemas representation, Processing YAML Information , Processes , Dump , Load , Information Models , Representation Graph , Nodes , Node Comparison , Serialization Tree , Keys Order , Anchors and Aliases , Presentation Stream , Node Styles , Scalar Formats , Comments , Directives , Available Tags , Node Anchors complete, Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Available Tags partial, Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Tag Resolution required, Terminology S scalar, Introduction , Prior Art , Scalars , Dump , Representation Graph , Nodes , Tags , Node Comparison , Scalar Formats , Comments , Recognized and Valid Tags , Line Break Characters , Separation Spaces , Line Prefixes , Comments , Empty Nodes , Block Chomping Indicator , Generic Mapping , Generic String , Null , Boolean , Integer , Floating Point , Tag Resolution , Tag Resolution canonical form, Prior Art , Tags , Node Comparison , Scalar Formats , Loading Failure Points content format, Dump , Load , Tags , Node Comparison , Presentation Stream , Scalar Formats , Loading Failure Points schema, Recommended Schemas , Failsafe Schema , JSON Schema , Tags , Core Schema , Tags , Other Schemas core, Core Schema , Tag Resolution , Other Schemas failsafe, Tags , Failsafe Schema , Tags , Tag Resolution JSON, Tags , JSON Schema , Tag Resolution , Core Schema , Tags , Tag Resolution sequence, Introduction , Prior Art , Dump , Representation Graph , Nodes , Tags , Node Comparison , Keys Order , Resolved Tags , Flow Mappings , Generic Sequence serialization, Processing YAML Information , Processes , Dump , Load , Information Models , Serialization Tree , Anchors and Aliases , Presentation Stream , Node Styles , Scalar Formats , Comments , Directives , Node Anchors detail, Dump , Load , Information Models , Keys Order , Anchors and Aliases , Node Anchors serialize, Introduction , Prior Art , Relation to JSON , Dump , Load , Keys Order , Anchors and Aliases , Alias Nodes shall, Terminology space, Prior Art , Scalars , White Space Characters , Indentation Spaces , Line Folding , Single-Quoted Style , Plain Style , Block Indentation Indicator , Folded Style , Block Sequences , Block Nodes , Bare Documents indentation, Introduction , Prior Art , Collections , Dump , Load , Information Models , Node Styles , Resolved Tags , Production Parameters , Production Naming Conventions , Indentation Spaces , Separation Spaces , Line Prefixes , Line Folding , Comments , Separation Lines , Directives , Block Styles , Block Indentation Indicator , Block Chomping Indicator , Literal Style , Block Sequences , Block Nodes , Bare Documents separation, Separation Spaces , Comments , Flow Mappings , Block Sequences white, Production Naming Conventions , White Space Characters , Separation Spaces , Line Prefixes , Line Folding , Comments , Double-Quoted Style , Single-Quoted Style , Plain Style , Flow Mappings , Literal Style , Folded Style , Block Sequences stream, Prior Art , Processing YAML Information , Processes , Dump , Load , Presentation Stream , Loading Failure Points , Well-Formed Streams and Identified Aliases , Resolved Tags , Syntax Conventions , Character Set , Character Encodings , Miscellaneous Characters , Comments , Tag Prefixes , Empty Nodes , Documents , Streams ill-formed, Load , Loading Failure Points , Well-Formed Streams and Identified Aliases well-formed, Well-Formed Streams and Identified Aliases , Streams style, Dump , Load , Information Models , Presentation Stream , Node Styles , Scalar Formats , Resolved Tags , Node Tags , Double-Quoted Style , Plain Style block, Prior Art , Scalars , Node Styles , Production Parameters , Indentation Spaces , Block Styles , Block Sequences collection, Collections , Structures , Indentation Spaces , Flow Collection Styles , Block Collection Styles , Block Sequences , Block Nodes folded, Scalars , Node Styles , Indicator Characters , Line Folding , Block Scalar Styles , Literal Style , Folded Style literal, Prior Art , Scalars , Node Styles , Indicator Characters , Block Scalar Styles , Literal Style , Folded Style mapping, Node Styles , Production Parameters , Block Mappings , Block Nodes scalar, Node Styles , Block Scalar Styles , Block Scalar Headers , Block Indentation Indicator , Block Chomping Indicator sequence, Collections , Node Styles , Production Parameters , Indicator Characters , Block Sequences , Block Mappings , Block Nodes compact block collection, Node Styles , Block Sequences , Block Mappings flow, Prior Art , Collections , Scalars , Node Styles , Production Parameters , Line Folding , Flow Styles , Flow Sequences , Flow Nodes , Block Nodes collection, Syntax Conventions , Production Parameters , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Collection Styles double-quoted, Prior Art , Scalars , Node Styles , Syntax Conventions , Character Set , Character Encodings , Indicator Characters , Escaped Characters , Flow Scalar Styles , Double-Quoted Style , Flow Nodes mapping, Collections , Node Styles , Production Parameters , Indicator Characters , Flow Mappings , Block Mappings plain, Scalars , Node Styles , Resolved Tags , Production Parameters , Indicator Characters , Node Tags , Empty Nodes , Flow Scalar Styles , Plain Style , Flow Mappings , Flow Nodes , Block Collection Styles , Block Sequences , Block Mappings , Block Nodes , Document Markers , Tag Resolution , Tag Resolution scalar, Scalars , Node Styles , Line Prefixes , Line Folding , Flow Scalar Styles sequence, Collections , Node Styles , Indicator Characters , Flow Sequences , Flow Mappings single-quoted, Node Styles , Production Parameters , Indicator Characters , Flow Scalar Styles , Single-Quoted Style scalar, Node Styles , Escaped Characters , Empty Lines , Flow Scalar Styles , Literal Style single key:value pair mapping, Keys Order , Node Styles , Flow Sequences , Flow Mappings , Block Mappings T tab, Prior Art , Character Set , White Space Characters , Indentation Spaces , Separation Spaces , Line Prefixes , Block Indentation Indicator tag, Prior Art , Tags , Dump , Representation Graph , Nodes , Tags , Node Comparison , Scalar Formats , Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Available Tags , Syntax Conventions , Production Parameters , Indicator Characters , Miscellaneous Characters , “TAG” Directives , Tag Prefixes , Node Properties , Node Tags , Flow Styles , Recommended Schemas , Tags , Tags , Other Schemas available, Available Tags global, Prior Art , Tags , Dump , Tags , Resolved Tags , Tag Handles , Tag Prefixes , Node Tags , Other Schemas handle, Tags , Processes , Dump , Indicator Characters , “TAG” Directives , Tag Handles , Tag Prefixes , Node Tags named, Miscellaneous Characters , Tag Handles , Node Tags primary, Tag Handles secondary, Tag Handles local, Prior Art , Tags , Dump , Tags , Resolved Tags , Indicator Characters , Tag Handles , Tag Prefixes , Node Tags , Other Schemas non-specific, Tags , Dump , Loading Failure Points , Resolved Tags , Indicator Characters , Node Tags , Recommended Schemas , Tag Resolution , Tag Resolution , Other Schemas prefix, “TAG” Directives , Tag Prefixes , Node Tags property, Resolved Tags , Indicator Characters , Node Tags recognized, Recognized and Valid Tags repository, Tags , Tag Handles , Other Schemas bool, Boolean float, Tags , Floating Point int, Tags , Integer map, Tags , Generic Mapping null, Tags , Empty Nodes , Null seq, Tags , Generic Sequence str, Tags , Generic String resolution, Tags , Loading Failure Points , Resolved Tags , Node Tags , Flow Scalar Styles , Recommended Schemas , Tag Resolution , Tag Resolution , Tag Resolution , Other Schemas convention, Resolved Tags , Node Tags , Tag Resolution , Tag Resolution , Tag Resolution shorthand, Tags , Miscellaneous Characters , “TAG” Directives , Tag Handles , Tag Prefixes , Node Tags specific, Resolved Tags , Node Tags unavailable, Load , Loading Failure Points , Available Tags unrecognized, Loading Failure Points , Recognized and Valid Tags unresolved, Loading Failure Points , Resolved Tags verbatim, Node Tags trimming, Line Folding V value, Dump , Nodes , Node Comparison , Resolved Tags , Indicator Characters , Flow Mappings , Block Mappings , Generic Mapping , Null Y YAML 1.1 processing, Line Break Characters , “YAML” Directives ",
                "urlTerms": [
                    "spec",
                    "html"
                ],
                "titleTerms": [
                    "yaml",
                    "markup",
                    "language",
                    "yaml™",
                    "version"
                ]
            }
        },
        {
            "timestamp": 1608985736062,
            "collection": "visits",
            "objectPk": [
                1608985736056,
                "yaml.org/spec/1.2/spec.html"
            ],
            "operation": "create",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "time": 1608985736056
            }
        },
        {
            "timestamp": 1608985736074,
            "collection": "annotations",
            "objectPk": "https://yaml.org/spec/1.2/spec.html#id2761292/#1608985734268",
            "operation": "create",
            "object": {
                "pageTitle": "YAML Ain’t Markup Language (YAML™) Version 1.2",
                "pageUrl": "yaml.org/spec/1.2/spec.html",
                "body": "Processing YAML Information\r\n\r\nYAML is both a text format and a method for presenting any native data structure in this format. Therefore, this specification defines two concepts: a class of data objects called YAML representations, and a syntax for presenting YAML representations as a series of characters, called a YAML stream. A YAML processor is a tool for converting information between these complementary views. It is assumed that a YAML processor does its work on behalf of another module, called an application. This chapter describes the information structures a YAML processor must provide to or obtain from the application.\r\n\r\nYAML information is used in two ways: for machine processing, and for human consumption. The challenge of reconciling these two perspectives is best done in three distinct translation stages: representation, serialization, and presentation. Representation addresses how YAML views native data structures to achieve portability between programming environments. Serialization concerns itself with turning a YAML representation into a serial form, that is, a form with sequential access constraints. Presentation deals with the formatting of a YAML serialization as a series of characters in a human-friendly manner. ",
                "comment": "",
                "selector": {
                    "quote": "Processing YAML Information\r\n\r\nYAML is both a text format and a method for presenting any native data structure in this format. Therefore, this specification defines two concepts: a class of data objects called YAML representations, and a syntax for presenting YAML representations as a series of characters, called a YAML stream. A YAML processor is a tool for converting information between these complementary views. It is assumed that a YAML processor does its work on behalf of another module, called an application. This chapter describes the information structures a YAML processor must provide to or obtain from the application.\r\n\r\nYAML information is used in two ways: for machine processing, and for human consumption. The challenge of reconciling these two perspectives is best done in three distinct translation stages: representation, serialization, and presentation. Representation addresses how YAML views native data structures to achieve portability between programming environments. Serialization concerns itself with turning a YAML representation into a serial form, that is, a form with sequential access constraints. Presentation deals with the formatting of a YAML serialization as a series of characters in a human-friendly manner. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[1]/div[5]/div[1]/div[1]/div[1]/h2[1]",
                                "startOffset": 11,
                                "endContainer": "/div[1]/div[5]/p[2]",
                                "endOffset": 680
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 42919,
                                "end": 44354
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Processing YAML Information\n            \n          \n        \n        \n      YAML is both a text format and a method for presenting any native data structure in this format. Therefore,\n      this specification defines two concepts: a class of data objects called\n      YAML representations, and a\n      syntax for presenting YAML representations as a series of\n      characters, called a YAML stream. A\n      YAML processor is a tool for\n      converting information between these complementary views. It is assumed\n      that a YAML processor does its work on behalf of another module, called\n      an application. This chapter\n      describes the information structures a YAML processor must provide to or\n      obtain from the application.\n    \n        \n      YAML information is used in two ways: for machine processing, and for\n      human consumption. The challenge of reconciling these two perspectives is\n      best done in three distinct translation stages: representation, serialization, and presentation. Representation addresses how YAML\n      views native data\n      structures to achieve portability between programming\n      environments. Serialization\n      concerns itself with turning a YAML representation into a serial form,\n      that is, a form with sequential access constraints. Presentation deals with the formatting\n      of a YAML serialization as a\n      series of characters in a human-friendly manner.\n    ",
                                "prefix": "      \n              Chapter 3. ",
                                "suffix": "\n        \n          \n           "
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T12:28:54.269Z",
                "lastEdited": "2020-12-26T12:28:54.269Z",
                "url": "https://yaml.org/spec/1.2/spec.html#id2761292/#1608985734268"
            }
        },
        {
            "timestamp": 1608987372543,
            "collection": "pages",
            "objectPk": "yaml.org/spec/1.2/spec.html",
            "operation": "update",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "fullUrl": "https://yaml.org/spec/1.2/spec.html#id2708649",
                "domain": "yaml.org",
                "hostname": "yaml.org",
                "fullTitle": "YAML Ain’t Markup Language (YAML™) Version 1.2",
                "text": " YAML Ain’t Markup Language ( YAML ) Version 1.2 3rd Edition, Patched at 2009-10-01 Oren Ben-Kiki < oren@ben-kiki.org > Clark Evans < cce@clarkevans.com > Ingy döt Net < ingy@ingy.net > Latest (patched) version: HTML: http://yaml.org/spec/1.2/spec.html PDF: http://yaml.org/spec/1.2/spec.pdf PS: http://yaml.org/spec/1.2/spec.ps Errata: http://yaml.org/spec/1.2/errata.html Previous (original) version: http://yaml.org/spec/1.2/2009-07-21/spec.html Copyright © 2001-2009 Oren Ben-Kiki, Clark Evans, Ingy döt Net This document may be freely copied, provided it is not modified. Status of this Document This document reflects the third version of YAML data serialization language. The content of the specification was arrived at by consensus of its authors and through user feedback on the yaml-core mailing list. We encourage implementers to please update their software with support for this version. The primary objective of this revision is to bring YAML into compliance with JSON as an official subset. YAML 1.2 is compatible with 1.1 for most practical applications - this is a minor revision. An expected source of incompatibility with prior versions of YAML, especially the syck implementation, is the change in implicit typing rules. We have removed unique implicit typing rules and have updated these rules to align them with JSON's productions. In this version of YAML, boolean values may be serialized as “ true” or “ false”; the empty scalar as “ null”. Unquoted numeric values are a superset of JSON's numeric production. Other changes in the specification were the removal of the Unicode line breaks and production bug fixes. We also define 3 built-in implicit typing rule sets: untyped, strict JSON, and a more flexible YAML rule set that extends JSON typing. The difference between late 1.0 drafts which syck 0.55 implements and the 1.1 revision of this specification is much more extensive. We fixed usability issues with the tagging syntax. In particular, the single exclamation was re-defined for private types and a simple prefixing mechanism was introduced. This revision also fixed many production edge cases and introduced a type repository. Therefore, there are several incompatibilities between syck and this revision as well. The list of known errors in this specification is available at http://yaml.org/spec/1.2/errata.html . Please report errors in this document to the yaml-core mailing list. This revision contains fixes for all errors known as of 2009-10-01. We wish to thank implementers who have tirelessly tracked earlier versions of this specification, and our fabulous user community whose feedback has both validated and clarified our direction. Abstract YAML (rhymes with “ camel”) is a human-friendly, cross language, Unicode based data serialization language designed around the common native data types of agile programming languages. It is broadly useful for programming needs ranging from configuration files to Internet messaging to object persistence to data auditing. Together with the Unicode standard for characters , this specification provides all the information necessary to understand YAML Version 1.2 and to create programs that process YAML information. Table of Contents 1. Introduction 1.1. Goals 1.2. Prior Art 1.3. Relation to JSON 1.4. Relation to XML 1.5. Terminology 2. Preview 2.1. Collections 2.2. Structures 2.3. Scalars 2.4. Tags 2.5. Full Length Example 3. Processing YAML Information 3.1. Processes 3.1.1. Dump 3.1.2. Load 3.2. Information Models 3.2.1. Representation Graph 3.2.1.1. Nodes 3.2.1.2. Tags 3.2.1.3. Node Comparison 3.2.2. Serialization Tree 3.2.2.1. Keys Order 3.2.2.2. Anchors and Aliases 3.2.3. Presentation Stream 3.2.3.1. Node Styles 3.2.3.2. Scalar Formats 3.2.3.3. Comments 3.2.3.4. Directives 3.3. Loading Failure Points 3.3.1. Well-Formed Streams and Identified Aliases 3.3.2. Resolved Tags 3.3.3. Recognized and Valid Tags 3.3.4. Available Tags 4. Syntax Conventions 4.1. Production Parameters 4.2. Production Naming Conventions 5. Characters 5.1. Character Set 5.2. Character Encodings 5.3. Indicator Characters 5.4. Line Break Characters 5.5. White Space Characters 5.6. Miscellaneous Characters 5.7. Escaped Characters 6. Basic Structures 6.1. Indentation Spaces 6.2. Separation Spaces 6.3. Line Prefixes 6.4. Empty Lines 6.5. Line Folding 6.6. Comments 6.7. Separation Lines 6.8. Directives 6.8.1. “ YAML” Directives 6.8.2. “ TAG” Directives 6.8.2.1. Tag Handles 6.8.2.2. Tag Prefixes 6.9. Node Properties 6.9.1. Node Tags 6.9.2. Node Anchors 7. Flow Styles 7.1. Alias Nodes 7.2. Empty Nodes 7.3. Flow Scalar Styles 7.3.1. Double-Quoted Style 7.3.2. Single-Quoted Style 7.3.3. Plain Style 7.4. Flow Collection Styles 7.4.1. Flow Sequences 7.4.2. Flow Mappings 7.5. Flow Nodes 8. Block Styles 8.1. Block Scalar Styles 8.1.1. Block Scalar Headers 8.1.1.1. Block Indentation Indicator 8.1.1.2. Block Chomping Indicator 8.1.2. Literal Style 8.1.3. Folded Style 8.2. Block Collection Styles 8.2.1. Block Sequences 8.2.2. Block Mappings 8.2.3. Block Nodes 9. YAML Character Stream 9.1. Documents 9.1.1. Document Prefix 9.1.2. Document Markers 9.1.3. Bare Documents 9.1.4. Explicit Documents 9.1.5. Directives Documents 9.2. Streams 10. Recommended Schemas 10.1. Failsafe Schema 10.1.1. Tags 10.1.1.1. Generic Mapping 10.1.1.2. Generic Sequence 10.1.1.3. Generic String 10.1.2. Tag Resolution 10.2. JSON Schema 10.2.1. Tags 10.2.1.1. Null 10.2.1.2. Boolean 10.2.1.3. Integer 10.2.1.4. Floating Point 10.2.2. Tag Resolution 10.3. Core Schema 10.3.1. Tags 10.3.2. Tag Resolution 10.4. Other Schemas Index Chapter 1. Introduction “ YAML Ain’t Markup Language” (abbreviated YAML) is a data serialization language designed to be human-friendly and work well with modern programming languages for common everyday tasks. This specification is both an introduction to the YAML language and the concepts supporting it, and also a complete specification of the information needed to develop applications for processing YAML. Open, interoperable and readily understandable tools have advanced computing immensely. YAML was designed from the start to be useful and friendly to people working with data. It uses Unicode printable characters, some of which provide structural information and the rest containing the data itself. YAML achieves a unique cleanness by minimizing the amount of structural characters and allowing the data to show itself in a natural and meaningful way. For example, indentation may be used for structure, colons separate key: value pairs , and dashes are used to create “ bullet” lists . There are myriad flavors of data structures , but they can all be adequately represented with three basic primitives: mappings (hashes/dictionaries), sequences (arrays/lists) and scalars (strings/numbers). YAML leverages these primitives, and adds a simple typing system and aliasing mechanism to form a complete language for serializing any native data structure . While most programming languages can use YAML for data serialization, YAML excels in working with those languages that are fundamentally built around the three basic primitives. These include the new wave of agile languages such as Perl, Python, PHP, Ruby, and Javascript. There are hundreds of different languages for programming, but only a handful of languages for storing and transferring data. Even though its potential is virtually boundless, YAML was specifically created to work well for common use cases such as: configuration files, log files, interprocess messaging, cross-language data sharing, object persistence, and debugging of complex data structures. When data is easy to view and understand, programming becomes a simpler task. 1.1. Goals The design goals for YAML are, in decreasing priority: YAML is easily readable by humans. YAML data is portable between programming languages. YAML matches the native data structures of agile languages. YAML has a consistent model to support generic tools. YAML supports one-pass processing. YAML is expressive and extensible. YAML is easy to implement and use. 1.2. Prior Art YAML’s initial direction was set by the data serialization and markup language discussions among SML-DEV members . Later on, it directly incorporated experience from Ingy döt Net’s Perl module Data::Denter . Since then, YAML has matured through ideas and support from its user community. YAML integrates and builds upon concepts described by C , Java , Perl , Python , Ruby , RFC0822 (MAIL), RFC1866 (HTML), RFC2045 (MIME), RFC2396 (URI), XML , SAX , SOAP , and JSON . The syntax of YAML was motivated by Internet Mail (RFC0822) and remains partially compatible with that standard. Further, borrowing from MIME (RFC2045), YAML’s top-level production is a stream of independent documents , ideal for message-based distributed processing systems. YAML’s indentation -based scoping is similar to Python’s (without the ambiguities caused by tabs ). Indented blocks facilitate easy inspection of the data’s structure. YAML’s literal style leverages this by enabling formatted text to be cleanly mixed within an indented structure without troublesome escaping . YAML also allows the use of traditional indicator -based scoping similar to JSON’s and Perl’s. Such flow content can be freely nested inside indented blocks . YAML’s double-quoted style uses familiar C-style escape sequences . This enables ASCII encoding of non- printable or 8-bit (ISO 8859-1) characters such as “ \\x3B” . Non- printable 16-bit Unicode and 32-bit (ISO/IEC 10646) characters are supported with escape sequences such as “ \\u003B” and “ \\U0000003B” . Motivated by HTML’s end-of-line normalization, YAML’s line folding employs an intuitive method of handling line breaks . A single line break is folded into a single space , while empty lines are interpreted as line break characters. This technique allows for paragraphs to be word-wrapped without affecting the canonical form of the scalar content . YAML’s core type system is based on the requirements of agile languages such as Perl, Python, and Ruby. YAML directly supports both collections ( mappings , sequences ) and scalars . Support for these common types enables programmers to use their language’s native data structures for YAML manipulation, instead of requiring a special document object model (DOM). Like XML’s SOAP, YAML supports serializing a graph of native data structures through an aliasing mechanism. Also like SOAP, YAML provides for application -defined types . This allows YAML to represent rich data structures required for modern distributed computing. YAML provides globally unique type names using a namespace mechanism inspired by Java’s DNS-based package naming convention and XML’s URI-based namespaces. In addition, YAML allows for private types specific to a single application . YAML was designed to support incremental interfaces that include both input (“ getNextEvent()”) and output (“ sendNextEvent()”) one-pass interfaces. Together, these enable YAML to support the processing of large documents (e.g. transaction logs) or continuous streams (e.g. feeds from a production machine). 1.3. Relation to JSON Both JSON and YAML aim to be human readable data interchange formats. However, JSON and YAML have different priorities. JSON’s foremost design goal is simplicity and universality. Thus, JSON is trivial to generate and parse, at the cost of reduced human readability. It also uses a lowest common denominator information model, ensuring any JSON data can be easily processed by every modern programming environment. In contrast, YAML’s foremost design goals are human readability and support for serializing arbitrary native data structures . Thus, YAML allows for extremely readable files, but is more complex to generate and parse. In addition, YAML ventures beyond the lowest common denominator data types, requiring more complex processing when crossing between different programming environments. YAML can therefore be viewed as a natural superset of JSON, offering improved human readability and a more complete information model. This is also the case in practice; every JSON file is also a valid YAML file. This makes it easy to migrate from JSON to YAML if/when the additional features are required. JSON's RFC4627 requires that mappings keys merely “ SHOULD” be unique , while YAML insists they “ MUST” be. Technically, YAML therefore complies with the JSON spec, choosing to treat duplicates as an error. In practice, since JSON is silent on the semantics of such duplicates, the only portable JSON files are those with unique keys, which are therefore valid YAML files. It may be useful to define a intermediate format between YAML and JSON. Such a format would be trivial to parse (but not very human readable), like JSON. At the same time, it would allow for serializing arbitrary native data structures , like YAML. Such a format might also serve as YAML’s \"canonical format\". Defining such a “ YSON” format (YSON is a Serialized Object Notation) can be done either by enhancing the JSON specification or by restricting the YAML specification. Such a definition is beyond the scope of this specification. 1.4. Relation to XML Newcomers to YAML often search for its correlation to the eXtensible Markup Language (XML). Although the two languages may actually compete in several application domains, there is no direct correlation between them. YAML is primarily a data serialization language. XML was designed to be backwards compatible with the Standard Generalized Markup Language (SGML), which was designed to support structured documentation. XML therefore had many design constraints placed on it that YAML does not share. XML is a pioneer in many domains, YAML is the result of lessons learned from XML and other technologies. It should be mentioned that there are ongoing efforts to define standard XML/YAML mappings. This generally requires that a subset of each language be used. For more information on using both XML and YAML, please visit http://yaml.org/xml . 1.5. Terminology This specification uses key words based on RFC2119 to indicate requirement level. In particular, the following words are used to describe the actions of a YAML processor : May The word may, or the adjective optional, mean that conforming YAML processors are permitted to, but need not behave as described. Should The word should, or the adjective recommended, mean that there could be reasons for a YAML processor to deviate from the behavior described, but that such deviation could hurt interoperability and should therefore be advertised with appropriate notice. Must The word must, or the term required or shall, mean that the behavior described is an absolute requirement of the specification. The rest of this document is arranged as follows. Chapter 2 provides a short preview of the main YAML features. Chapter 3 describes the YAML information model, and the processes for converting from and to this model and the YAML text format. The bulk of the document, chapters 4 through 9 , formally define this text format. Finally, chapter 10 recommends basic YAML schemas. Chapter 2. Preview This section provides a quick glimpse into the expressive power of YAML. It is not expected that the first-time reader grok all of the examples. Rather, these selections are used as motivation for the remainder of the specification. 2.1. Collections YAML’s block collections use indentation for scope and begin each entry on its own line. Block sequences indicate each entry with a dash and space ( “ - ” ). Mappings use a colon and space ( “ : ” ) to mark each key: value pair . Comments begin with an octothorpe (also called a “ hash”, “ sharp”, “ pound”, or “ number sign” - “ #” ). Example 2.1. Sequence of Scalars (ball players) - Mark McGwire - Sammy Sosa - Ken Griffey Example 2.2. Mapping Scalars to Scalars (player statistics) hr: 65 # Home runs avg: 0.278 # Batting average rbi: 147 # Runs Batted In Example 2.3. Mapping Scalars to Sequences (ball clubs in each league) american: - Boston Red Sox - Detroit Tigers - New York Yankees national: - New York Mets - Chicago Cubs - Atlanta Braves Example 2.4. Sequence of Mappings (players’ statistics) - name: Mark McGwire hr: 65 avg: 0.278 - name: Sammy Sosa hr: 63 avg: 0.288 YAML also has flow styles , using explicit indicators rather than indentation to denote scope. The flow sequence is written as a comma separated list within square brackets . In a similar manner, the flow mapping uses curly braces . Example 2.5. Sequence of Sequences - [name , hr, avg ] - [Mark McGwire, 65, 0.278] - [Sammy Sosa , 63, 0.288] Example 2.6. Mapping of Mappings Mark McGwire: {hr: 65, avg: 0.278} Sammy Sosa: { hr: 63, avg: 0.288 } 2.2. Structures YAML uses three dashes ( “ ---” ) to separate directives from document content . This also serves to signal the start of a document if no directives are present. Three dots ( “ ...” ) indicate the end of a document without starting a new one, for use in communication channels. Example 2.7. Two Documents in a Stream (each with a leading comment) # Ranking of 1998 home runs --- - Mark McGwire - Sammy Sosa - Ken Griffey # Team ranking --- - Chicago Cubs - St Louis Cardinals Example 2.8. Play by Play Feed from a Game --- time: 20:03:20 player: Sammy Sosa action: strike (miss) ... --- time: 20:03:47 player: Sammy Sosa action: grand slam ... Repeated nodes (objects) are first identified by an anchor (marked with the ampersand - “ &” ), and are then aliased (referenced with an asterisk - “ *” ) thereafter. Example 2.9. Single Document with Two Comments --- hr: # 1998 hr ranking - Mark McGwire - Sammy Sosa rbi: # 1998 rbi ranking - Sammy Sosa - Ken Griffey Example 2.10. Node for “ Sammy Sosa” appears twice in this document --- hr: - Mark McGwire # Following node labeled SS - &SS Sammy Sosa rbi: - *SS # Subsequent occurrence - Ken Griffey A question mark and space ( “ ? ” ) indicate a complex mapping key . Within a block collection , key: value pairs can start immediately following the dash , colon , or question mark . Example 2.11. Mapping between Sequences ? - Detroit Tigers - Chicago cubs : - 2001-07-23 ? [ New York Yankees, Atlanta Braves ] : [ 2001-07-02, 2001-08-12, 2001-08-14 ] Example 2.12. Compact Nested Mapping --- # Products purchased - item : Super Hoop quantity: 1 - item : Basketball quantity: 4 - item : Big Shoes quantity: 1 2.3. Scalars Scalar content can be written in block notation, using a literal style (indicated by “ |” ) where all line breaks are significant. Alternatively, they can be written with the folded style (denoted by “ >” ) where each line break is folded to a space unless it ends an empty or a more-indented line. Example 2.13. In literals, newlines are preserved # ASCII Art --- | \\//||\\/|| // || ||__ Example 2.14. In the folded scalars, newlines become spaces --- > Mark McGwire's year was crippled by a knee injury. Example 2.15. Folded newlines are preserved for \"more indented\" and blank lines > Sammy Sosa completed another fine season with great stats. 63 Home Runs 0.288 Batting Average What a year! Example 2.16. Indentation determines scope name: Mark McGwire accomplishment: > Mark set a major league home run record in 1998. stats: | 65 Home Runs 0.278 Batting Average YAML’s flow scalars include the plain style (most examples thus far) and two quoted styles. The double-quoted style provides escape sequences . The single-quoted style is useful when escaping is not needed. All flow scalars can span multiple lines; line breaks are always folded . Example 2.17. Quoted Scalars unicode: \"Sosa did fine.\\u263A\" control: \"\\b1998\\t1999\\t2000\\n\" hex esc: \"\\x0d\\x0a is \\r\\n\" single: '\"Howdy!\" he cried.' quoted: ' # Not a ''comment''.' tie-fighter: '|\\-*-/|' Example 2.18. Multi-line Flow Scalars plain: This unquoted scalar spans many lines. quoted: \"So does this quoted scalar.\\n\" 2.4. Tags In YAML, untagged nodes are given a type depending on the application . The examples in this specification generally use the seq , map and str types from the fail safe schema . A few examples also use the int , float , and null types from the JSON schema . The repository includes additional types such as binary , omap , set and others. Example 2.19. Integers canonical: 12345 decimal: +12345 octal: 0o14 hexadecimal: 0xC Example 2.20. Floating Point canonical: 1.23015e+3 exponential: 12.3015e+02 fixed: 1230.15 negative infinity: -.inf not a number: .NaN Example 2.21. Miscellaneous null: booleans: [ true, false ] string: '012345' Example 2.22. Timestamps canonical: 2001-12-15T02:59:43.1Z iso8601: 2001-12-14t21:59:43.10-05:00 spaced: 2001-12-14 21:59:43.10 -5 date: 2002-12-14 Explicit typing is denoted with a tag using the exclamation point ( “ !” ) symbol. Global tags are URIs and may be specified in a tag shorthand notation using a handle . Application -specific local tags may also be used. Example 2.23. Various Explicit Tags --- not-date: !!str 2002-04-28 picture: !!binary | R0lGODlhDAAMAIQAAP//9/X 17unp5WZmZgAAAOfn515eXv Pz7Y6OjuDg4J+fn5OTk6enp 56enmleECcgggoBADs= application specific tag: !something | The semantics of the tag above may be different for different documents. Example 2.24. Global Tags %TAG ! tag:clarkevans.com,2002: --- !shape # Use the ! handle for presenting # tag:clarkevans.com,2002:circle - !circle center: &ORIGIN {x: 73, y: 129} radius: 7 - !line start: *ORIGIN finish: { x: 89, y: 102 } - !label start: *ORIGIN color: 0xFFEEBB text: Pretty vector drawing. Example 2.25. Unordered Sets # Sets are represented as a # Mapping where each key is # associated with a null value --- !!set ? Mark McGwire ? Sammy Sosa ? Ken Griff Example 2.26. Ordered Mappings # Ordered maps are represented as # A sequence of mappings, with # each mapping having one key --- !!omap - Mark McGwire: 65 - Sammy Sosa: 63 - Ken Griffy: 58 2.5. Full Length Example Below are two full-length examples of YAML. On the left is a sample invoice; on the right is a sample log file. Example 2.27. Invoice --- !<tag:clarkevans.com,2002:invoice> invoice: 34843 date : 2001-01-23 bill-to: &id001 given : Chris family : Dumars address: lines: | 458 Walkman Dr. Suite #292 city : Royal Oak state : MI postal : 48046 ship-to: *id001 product: - sku : BL394D quantity : 4 description : Basketball price : 450.00 - sku : BL4438H quantity : 1 description : Super Hoop price : 2392.00 tax : 251.42 total: 4443.52 comments: Late afternoon is best. Backup contact is Nancy Billsmer @ 338-4338. Example 2.28. Log File --- Time: 2001-11-23 15:01:42 -5 User: ed Warning: This is an error message for the log file --- Time: 2001-11-23 15:02:31 -5 User: ed Warning: A slightly different error message. --- Date: 2001-11-23 15:03:17 -5 User: ed Fatal: Unknown variable \"bar\" Stack: - file: TopClass.py line: 23 code: | x = MoreObject(\"345\\n\") - file: MoreClass.py line: 58 code: |- foo = bar Chapter 3. Processing YAML Information YAML is both a text format and a method for presenting any native data structure in this format. Therefore, this specification defines two concepts: a class of data objects called YAML representations , and a syntax for presenting YAML representations as a series of characters, called a YAML stream . A YAML processor is a tool for converting information between these complementary views. It is assumed that a YAML processor does its work on behalf of another module, called an application. This chapter describes the information structures a YAML processor must provide to or obtain from the application. YAML information is used in two ways: for machine processing, and for human consumption. The challenge of reconciling these two perspectives is best done in three distinct translation stages: representation , serialization , and presentation . Representation addresses how YAML views native data structures to achieve portability between programming environments. Serialization concerns itself with turning a YAML representation into a serial form, that is, a form with sequential access constraints. Presentation deals with the formatting of a YAML serialization as a series of characters in a human-friendly manner. 3.1. Processes Translating between native data structures and a character stream is done in several logically distinct stages, each with a well defined input and output data model, as shown in the following diagram: Figure 3.1. Processing Overview A YAML processor need not expose the serialization or representation stages. It may translate directly between native data structures and a character stream ( dump and load in the diagram above). However, such a direct translation should take place so that the native data structures are constructed only from information available in the representation . In particular, mapping key order , comments , and tag handles should not be referenced during composition . 3.1.1. Dump Dumping native data structures to a character stream is done using the following three stages: Representing Native Data Structures YAML represents any native data structure using three node kinds : sequence - an ordered series of entries; mapping - an unordered association of unique keys to values ; and scalar - any datum with opaque structure presentable as a series of Unicode characters. Combined, these primitives generate directed graph structures. These primitives were chosen because they are both powerful and familiar: the sequence corresponds to a Perl array and a Python list, the mapping corresponds to a Perl hash table and a Python dictionary. The scalar represents strings, integers, dates, and other atomic data types. Each YAML node requires, in addition to its kind and content , a tag specifying its data type. Type specifiers are either global URIs, or are local in scope to a single application . For example, an integer is represented in YAML with a scalar plus the global tag “ tag:yaml.org,2002:int”. Similarly, an invoice object, particular to a given organization, could be represented as a mapping together with the local tag “ !invoice”. This simple model can represent any data structure independent of programming language. Serializing the Representation Graph For sequential access mediums, such as an event callback API, a YAML representation must be serialized to an ordered tree. Since in a YAML representation , mapping keys are unordered and nodes may be referenced more than once (have more than one incoming “ arrow”), the serialization process is required to impose an ordering on the mapping keys and to replace the second and subsequent references to a given node with place holders called aliases . YAML does not specify how these serialization details are chosen. It is up to the YAML processor to come up with human-friendly key order and anchor names, possibly with the help of the application . The result of this process, a YAML serialization tree , can then be traversed to produce a series of event calls for one-pass processing of YAML data. Presenting the Serialization Tree The final output process is presenting the YAML serializations as a character stream in a human-friendly manner. To maximize human readability, YAML offers a rich set of stylistic options which go far beyond the minimal functional needs of simple data storage. Therefore the YAML processor is required to introduce various presentation details when creating the stream , such as the choice of node styles , how to format scalar content , the amount of indentation , which tag handles to use, the node tags to leave unspecified , the set of directives to provide and possibly even what comments to add. While some of this can be done with the help of the application , in general this process should be guided by the preferences of the user. 3.1.2. Load Loading native data structures from a character stream is done using the following three stages: Parsing the Presentation Stream Parsing is the inverse process of presentation , it takes a stream of characters and produces a series of events. Parsing discards all the details introduced in the presentation process, reporting only the serialization events. Parsing can fail due to ill-formed input. Composing the Representation Graph Composing takes a series of serialization events and produces a representation graph . Composing discards all the details introduced in the serialization process, producing only the representation graph . Composing can fail due to any of several reasons, detailed below . Constructing Native Data Structures The final input process is constructing native data structures from the YAML representation . Construction must be based only on the information available in the representation , and not on additional serialization or presentation details such as comments , directives , mapping key order , node styles , scalar content format , indentation levels etc. Construction can fail due to the unavailability of the required native data types . 3.2. Information Models This section specifies the formal details of the results of the above processes. To maximize data portability between programming languages and implementations, users of YAML should be mindful of the distinction between serialization or presentation properties and those which are part of the YAML representation . Thus, while imposing a order on mapping keys is necessary for flattening YAML representations to a sequential access medium, this serialization detail must not be used to convey application level information. In a similar manner, while indentation technique and a choice of a node style are needed for the human readability, these presentation details are neither part of the YAML serialization nor the YAML representation . By carefully separating properties needed for serialization and presentation , YAML representations of application information will be consistent and portable between various programming environments. The following diagram summarizes the three information models. Full arrows denote composition, hollow arrows denote inheritance, “ 1” and “ *” denote “ one” and “ many” relationships. A single “ +” denotes serialization details, a double “ ++” denotes presentation details. Figure 3.2. Information Models 3.2.1. Representation Graph YAML’s representation of native data structure is a rooted, connected, directed graph of tagged nodes . By “ directed graph” we mean a set of nodes and directed edges (“ arrows”), where each edge connects one node to another (see a formal definition ). All the nodes must be reachable from the root node via such edges. Note that the YAML graph may include cycles, and a node may have more than one incoming edge. Nodes that are defined in terms of other nodes are collections ; nodes that are independent of any other nodes are scalars . YAML supports two kinds of collection nodes : sequences and mappings . Mapping nodes are somewhat tricky because their keys are unordered and must be unique . Figure 3.3. Representation Model 3.2.1.1. Nodes A YAML node represents a single native data structure . Such nodes have content of one of three kinds: scalar, sequence, or mapping. In addition, each node has a tag which serves to restrict the set of possible values the content can have. Scalar The content of a scalar node is an opaque datum that can be presented as a series of zero or more Unicode characters. Sequence The content of a sequence node is an ordered series of zero or more nodes. In particular, a sequence may contain the same node more than once. It could even contain itself (directly or indirectly). Mapping The content of a mapping node is an unordered set of key: value node pairs, with the restriction that each of the keys is unique . YAML places no further restrictions on the nodes. In particular, keys may be arbitrary nodes, the same node may be used as the value of several key: value pairs, and a mapping could even contain itself as a key or a value (directly or indirectly). When appropriate, it is convenient to consider sequences and mappings together, as collections. In this view, sequences are treated as mappings with integer keys starting at zero. Having a unified collections view for sequences and mappings is helpful both for theoretical analysis and for creating practical YAML tools and APIs. This strategy is also used by the Javascript programming language. 3.2.1.2. Tags YAML represents type information of native data structures with a simple identifier, called a tag. Global tags are URIs and hence globally unique across all applications . The “ tag:” URI scheme is recommended for all global YAML tags. In contrast, local tags are specific to a single application . Local tags start with “ !”, are not URIs and are not expected to be globally unique. YAML provides a “ TAG” directive to make tag notation less verbose; it also offers easy migration from local to global tags. To ensure this, local tags are restricted to the URI character set and use URI character escaping . YAML does not mandate any special relationship between different tags that begin with the same substring. Tags ending with URI fragments (containing “ #”) are no exception; tags that share the same base URI but differ in their fragment part are considered to be different, independent tags. By convention, fragments are used to identify different “ variants” of a tag, while “ /” is used to define nested tag “ namespace” hierarchies. However, this is merely a convention, and each tag may employ its own rules. For example, Perl tags may use “ ::” to express namespace hierarchies, Java tags may use “ .”, etc. YAML tags are used to associate meta information with each node . In particular, each tag must specify the expected node kind ( scalar , sequence , or mapping ). Scalar tags must also provide a mechanism for converting formatted content to a canonical form for supporting equality testing. Furthermore, a tag may provide additional information such as the set of allowed content values for validation, a mechanism for tag resolution , or any other data that is applicable to all of the tag’s nodes . 3.2.1.3. Node Comparison Since YAML mappings require key uniqueness, representations must include a mechanism for testing the equality of nodes . This is non-trivial since YAML allows various ways to format scalar content . For example, the integer eleven can be written as “ 0o13” (octal) or “ 0xB” (hexadecimal). If both notations are used as keys in the same mapping , only a YAML processor which recognizes integer formats would correctly flag the duplicate key as an error. Canonical Form YAML supports the need for scalar equality by requiring that every scalar tag must specify a mechanism for producing the canonical form of any formatted content . This form is a Unicode character string which also presents the same content , and can be used for equality testing. While this requirement is stronger than a well defined equality operator, it has other uses, such as the production of digital signatures. Equality Two nodes must have the same tag and content to be equal. Since each tag applies to exactly one kind , this implies that the two nodes must have the same kind to be equal. Two scalars are equal only when their tags and canonical forms are equal character-by-character. Equality of collections is defined recursively. Two sequences are equal only when they have the same tag and length, and each node in one sequence is equal to the corresponding node in the other sequence . Two mappings are equal only when they have the same tag and an equal set of keys , and each key in this set is associated with equal values in both mappings . Different URI schemes may define different rules for testing the equality of URIs. Since a YAML processor cannot be reasonably expected to be aware of them all, it must resort to a simple character-by-character comparison of tags to ensure consistency. This also happens to be the comparison method defined by the “ tag:” URI scheme. Tags in a YAML stream must therefore be presented in a canonical way so that such comparison would yield the correct results. Identity Two nodes are identical only when they represent the same native data structure . Typically, this corresponds to a single memory address. Identity should not be confused with equality; two equal nodes need not have the same identity. A YAML processor may treat equal scalars as if they were identical. In contrast, the separate identity of two distinct but equal collections must be preserved. 3.2.2. Serialization Tree To express a YAML representation using a serial API, it is necessary to impose an order on mapping keys and employ alias nodes to indicate a subsequent occurrence of a previously encountered node . The result of this process is a serialization tree, where each node has an ordered set of children. This tree can be traversed for a serial event-based API. Construction of native data structures from the serial interface should not use key order or anchor names for the preservation of application data. Figure 3.4. Serialization Model 3.2.2.1. Keys Order In the representation model, mapping keys do not have an order. To serialize a mapping , it is necessary to impose an ordering on its keys . This order is a serialization detail and should not be used when composing the representation graph (and hence for the preservation of application data). In every case where node order is significant, a sequence must be used. For example, an ordered mapping can be represented as a sequence of mappings , where each mapping is a single key: value pair . YAML provides convenient compact notation for this case. 3.2.2.2. Anchors and Aliases In the representation graph , a node may appear in more than one collection . When serializing such data, the first occurrence of the node is identified by an anchor. Each subsequent occurrence is serialized as an alias node which refers back to this anchor. Otherwise, anchor names are a serialization detail and are discarded once composing is completed. When composing a representation graph from serialized events, an alias node refers to the most recent node in the serialization having the specified anchor. Therefore, anchors need not be unique within a serialization . In addition, an anchor need not have an alias node referring to it. It is therefore possible to provide an anchor for all nodes in serialization . 3.2.3. Presentation Stream A YAML presentation is a stream of Unicode characters making use of of styles , scalar content formats , comments , directives and other presentation details to present a YAML serialization in a human readable way. Although a YAML processor may provide these details when parsing , they should not be reflected in the resulting serialization . YAML allows several serialization trees to be contained in the same YAML character stream, as a series of documents separated by markers . Documents appearing in the same stream are independent; that is, a node must not appear in more than one serialization tree or representation graph . Figure 3.5. Presentation Model 3.2.3.1. Node Styles Each node is presented in some style, depending on its kind . The node style is a presentation detail and is not reflected in the serialization tree or representation graph . There are two groups of styles. Block styles use indentation to denote structure; In contrast, flow styles styles rely on explicit indicators . YAML provides a rich set of scalar styles. Block scalar styles include the literal style and the folded style . Flow scalar styles include the plain style and two quoted styles, the single-quoted style and the double-quoted style . These styles offer a range of trade-offs between expressive power and readability. Normally, block sequences and mappings begin on the next line. In some cases, YAML also allows nested block collections to start in-line for a more compact notation . In addition, YAML provides a compact notation for flow mappings with a single key: value pair , nested inside a flow sequence . These allow for a natural “ ordered mapping” notation. Figure 3.6. Kind/Style Combinations 3.2.3.2. Scalar Formats YAML allows scalars to be presented in several formats. For example, the integer “ 11” might also be written as “ 0xB”. Tags must specify a mechanism for converting the formatted content to a canonical form for use in equality testing. Like node style , the format is a presentation detail and is not reflected in the serialization tree and representation graph . 3.2.3.3. Comments Comments are a presentation detail and must not have any effect on the serialization tree or representation graph . In particular, comments are not associated with a particular node . The usual purpose of a comment is to communicate between the human maintainers of a file. A typical example is comments in a configuration file. Comments must not appear inside scalars , but may be interleaved with such scalars inside collections . 3.2.3.4. Directives Each document may be associated with a set of directives . A directive has a name and an optional sequence of parameters. Directives are instructions to the YAML processor , and like all other presentation details are not reflected in the YAML serialization tree or representation graph . This version of YAML defines a two directives, “ YAML” and “ TAG” . All other directives are reserved for future versions of YAML. 3.3. Loading Failure Points The process of loading native data structures from a YAML stream has several potential failure points. The character stream may be ill-formed , aliases may be unidentified , unspecified tags may be unresolvable , tags may be unrecognized , the content may be invalid , and a native type may be unavailable . Each of these failures results with an incomplete loading. A partial representation need not resolve the tag of each node , and the canonical form of formatted scalar content need not be available. This weaker representation is useful for cases of incomplete knowledge of the types used in the document . In contrast, a complete representation specifies the tag of each node , and provides the canonical form of formatted scalar content , allowing for equality testing. A complete representation is required in order to construct native data structures . Figure 3.7. Loading Failure Points 3.3.1. Well-Formed Streams and Identified Aliases A well-formed character stream must match the BNF productions specified in the following chapters. Successful loading also requires that each alias shall refer to a previous node identified by the anchor . A YAML processor should reject ill-formed streams and unidentified aliases. A YAML processor may recover from syntax errors, possibly by ignoring certain parts of the input, but it must provide a mechanism for reporting such errors. 3.3.2. Resolved Tags Typically, most tags are not explicitly specified in the character stream . During parsing , nodes lacking an explicit tag are given a non-specific tag: “ !” for non- plain scalars , and “ ?” for all other nodes . Composing a complete representation requires each such non-specific tag to be resolved to a specific tag, be it a global tag or a local tag . Resolving the tag of a node must only depend on the following three parameters: (1) the non-specific tag of the node , (2) the path leading from the root to the node , and (3) the content (and hence the kind ) of the node . When a node has more than one occurrence (using aliases ), tag resolution must depend only on the path to the first ( anchored ) occurrence of the node . Note that resolution must not consider presentation details such as comments , indentation and node style . Also, resolution must not consider the content of any other node , except for the content of the key nodes directly along the path leading from the root to the resolved node . Finally, resolution must not consider the content of a sibling node in a collection , or the content of the value node associated with a key node being resolved. These rules ensure that tag resolution can be performed as soon as a node is first encountered in the stream , typically before its content is parsed . Also, tag resolution only requires referring to a relatively small number of previously parsed nodes . Thus, in most cases, tag resolution in one-pass processors is both possible and practical. YAML processors should resolve nodes having the “ !” non-specific tag as “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map” or “ tag:yaml.org,2002:str” depending on their kind . This tag resolution convention allows the author of a YAML character stream to effectively “ disable” the tag resolution process. By explicitly specifying a “ !” non-specific tag property , the node would then be resolved to a “ vanilla” sequence , mapping , or string, according to its kind . Application specific tag resolution rules should be restricted to resolving the “ ?” non-specific tag, most commonly to resolving plain scalars . These may be matched against a set of regular expressions to provide automatic resolution of integers, floats, timestamps, and similar types. An application may also match the content of mapping nodes against sets of expected keys to automatically resolve points, complex numbers, and similar types. Resolved sequence node types such as the “ ordered mapping” are also possible. That said, tag resolution is specific to the application . YAML processors should therefore provide a mechanism allowing the application to override and expand these default tag resolution rules. If a document contains unresolved tags, the YAML processor is unable to compose a complete representation graph. In such a case, the YAML processor may compose a partial representation , based on each node’s kind and allowing for non-specific tags. 3.3.3. Recognized and Valid Tags To be valid, a node must have a tag which is recognized by the YAML processor and its content must satisfy the constraints imposed by this tag . If a document contains a scalar node with an unrecognized tag or invalid content, only a partial representation may be composed . In contrast, a YAML processor can always compose a complete representation for an unrecognized or an invalid collection , since collection equality does not depend upon knowledge of the collection’s data type. However, such a complete representation cannot be used to construct a native data structure . 3.3.4. Available Tags In a given processing environment, there need not be an available native type corresponding to a given tag . If a node’s tag is unavailable, a YAML processor will not be able to construct a native data structure for it. In this case, a complete representation may still be composed , and an application may wish to use this representation directly. Chapter 4. Syntax Conventions The following chapters formally define the syntax of YAML character streams , using parameterized BNF productions. Each BNF production is both named and numbered for easy reference. Whenever possible, basic structures are specified before the more complex structures using them in a “ bottom up” fashion. The order of alternatives inside a production is significant. Subsequent alternatives are only considered when previous ones fails. See for example the b-break production. In addition, production matching is expected to be greedy. Optional ( ?), zero-or-more ( *) and one-or-more ( +) patterns are always expected to match as much of the input as possible. The productions are accompanied by examples, which are given side-by-side next to equivalent YAML text in an explanatory format. This format uses only flow collections , double-quoted scalars , and explicit tags for each node . A reference implementation using the productions is available as the YamlReference Haskell package. This reference implementation is also available as an interactive web application at http://dev.yaml.org/ypaste . 4.1. Production Parameters YAML’s syntax is designed for maximal human readability. This requires parsing to depend on the surrounding text. For notational compactness, this dependency is expressed using parameterized BNF productions. This context sensitivity is the cause of most of the complexity of the YAML syntax definition. It is further complicated by struggling with the human tendency to look ahead when interpreting text. These complications are of course the source of most of YAML’s power to present data in a very human readable way. Productions use any of the following parameters: Indentation: n or m Many productions use an explicit indentation level parameter. This is less elegant than Python’s “ indent” and “ undent” conceptual tokens. However it is required to formally express YAML’s indentation rules. Context: c This parameter allows productions to tweak their behavior according to their surrounding. YAML supports two groups of contexts, distinguishing between block styles and flow styles . In block styles , indentation is used to delineate structure. To capture human perception of indentation the rules require special treatment of the “ -” character, used in block sequences . Hence in some cases productions need to behave differently inside block sequences ( block-in context) and outside them ( block-out context). In flow styles , explicit indicators are used to delineate structure. These styles can be viewed as the natural extension of JSON to cover tagged , single-quoted and plain scalars . Since the latter have no delineating indicators , they are subject to some restrictions to avoid ambiguities. These restrictions depend on where they appear: as implicit keys directly inside a block mapping ( block-key); as implicit keys inside a flow mapping ( flow-key); as values inside a flow collection ( flow-in); or as values outside one ( flow-out). (Block) Chomping: t Block scalars offer three possible mechanisms for chomping any trailing line breaks : strip , clip and keep . Unlike the previous parameters, this only controls interpretation; the line breaks are valid in all cases. 4.2. Production Naming Conventions To make it easier to follow production combinations, production names use a Hungarian-style naming convention. Each production is given a prefix based on the type of characters it begins and ends with. e- A production matching no characters. c- A production starting and ending with a special character. b- A production matching a single line break . nb- A production starting and ending with a non- break character. s- A production starting and ending with a white space character. ns- A production starting and ending with a non- space character. l- A production matching complete line(s). X - Y - A production starting with an X - character and ending with a Y - character, where X - and Y - are any of the above prefixes. X +, X - Y + A production as above, with the additional property that the matched content indentation level is greater than the specified n parameter. Chapter 5. Characters 5.1. Character Set To ensure readability, YAML streams use only the printable subset of the Unicode character set. The allowed character range explicitly excludes the C0 control block #x0-#x1F (except for TAB #x9, LF #xA, and CR #xD which are allowed), DEL #x7F, the C1 control block #x80-#x9F (except for NEL #x85 which is allowed), the surrogate block #xD800-#xDFFF, #xFFFE, and #xFFFF. On input, a YAML processor must accept all Unicode characters except those explicitly excluded above. On output, a YAML processor must only produce acceptable characters. Any excluded characters must be presented using escape sequences. In addition, any allowed characters known to be non-printable should also be escaped . This isn’t mandatory since a full implementation would require extensive character property tables. [1] c-printable ::= #x9 | #xA | #xD | [#x20-#x7E] /* 8 bit */ | #x85 | [#xA0-#xD7FF] | [#xE000-#xFFFD] /* 16 bit */ | [#x10000-#x10FFFF] /* 32 bit */ To ensure JSON compatibility , YAML processors must allow all non-control characters inside quoted scalars . To ensure readability, non-printable characters should be escaped on output, even inside such scalars . Note that JSON quoted scalars cannot span multiple lines or contain tabs , but YAML quoted scalars can. [2] nb-json ::= #x9 | [#x20-#x10FFFF] 5.2. Character Encodings All characters mentioned in this specification are Unicode code points. Each such code point is written as one or more bytes depending on the character encoding used. Note that in UTF-16, characters above #xFFFF are written as four bytes, using a surrogate pair. The character encoding is a presentation detail and must not be used to convey content information. On input, a YAML processor must support the UTF-8 and UTF-16 character encodings. For JSON compatibility , the UTF-32 encodings must also be supported. If a character stream begins with a byte order mark, the character encoding will be taken to be as as indicated by the byte order mark. Otherwise, the stream must begin with an ASCII character. This allows the encoding to be deduced by the pattern of null ( #x00) characters. To make it easier to concatenate streams , byte order marks may appear at the start of any document . However all documents in the same stream must use the same character encoding. To allow for JSON compatibility , byte order marks are also allowed inside quoted scalars . For readability, such content byte order marks should be escaped on output. The encoding can therefore be deduced by matching the first few bytes of the stream with the following table rows (in order): Byte0 Byte1 Byte2 Byte3 Encoding Explicit BOM #x00 #x00 #xFE #xFF UTF-32BE ASCII first character #x00 #x00 #x00 any UTF-32BE Explicit BOM #xFF #xFE #x00 #x00 UTF-32LE ASCII first character any #x00 #x00 #x00 UTF-32LE Explicit BOM #xFE #xFF UTF-16BE ASCII first character #x00 any UTF-16BE Explicit BOM #xFF #xFE UTF-16LE ASCII first character any #x00 UTF-16LE Explicit BOM #xEF #xBB #xBF UTF-8 Default UTF-8 The recommended output encoding is UTF-8. If another encoding is used, it is recommended that an explicit byte order mark be used, even if the first stream character is ASCII. For more information about the byte order mark and the Unicode character encoding schemes see the Unicode FAQ . [3] c-byte-order-mark ::= #xFEFF In the examples, byte order mark characters are displayed as “ ”. Example 5.1. Byte Order Mark # Comment only. Legend: c-byte-order-mark # This stream contains no # documents, only comments. Example 5.2. Invalid Byte Order Mark - Invalid use of BOM - Inside a document. ERROR: A BOM must not appear inside a document. 5.3. Indicator Characters Indicators are characters that have special semantics. [4] c-sequence-entry ::= “ -” A “ -” ( #x2D, hyphen) denotes a block sequence entry. [5] c-mapping-key ::= “ ?” A “ ?” ( #x3F, question mark) denotes a mapping key . [6] c-mapping-value ::= “ :” A “ :” ( #x3A, colon) denotes a mapping value . Example 5.3. Block Structure Indicators sequence : - one - two mapping : ? sky : blue sea : green Legend: c-sequence-entry c-mapping-key c-mapping-value %YAML 1.2 --- !!map { ? !!str \"sequence\" : !!seq [ !!str \"one\", !!str \"two\" ], ? !!str \"mapping\" : !!map { ? !!str \"sky\" : !!str \"blue\", ? !!str \"sea\" : !!str \"green\", }, } [7] c-collect-entry ::= “ ,” A “ ,” ( #x2C, comma) ends a flow collection entry. [8] c-sequence-start ::= “ [” A “ [” ( #x5B, left bracket) starts a flow sequence . [9] c-sequence-end ::= “ ]” A “ ]” ( #x5D, right bracket) ends a flow sequence . [10] c-mapping-start ::= “ {” A “ {” ( #x7B, left brace) starts a flow mapping . [11] c-mapping-end ::= “ }” A “ }” ( #x7D, right brace) ends a flow mapping . Example 5.4. Flow Collection Indicators sequence: [ one , two , ] mapping: { sky: blue , sea: green } Legend: c-sequence-start c-sequence-end c-mapping-start c-mapping-end c-collect-entry %YAML 1.2 --- !!map { ? !!str \"sequence\" : !!seq [ !!str \"one\", !!str \"two\" ], ? !!str \"mapping\" : !!map { ? !!str \"sky\" : !!str \"blue\", ? !!str \"sea\" : !!str \"green\", }, } [12] c-comment ::= “ #” An “ #” ( #x23, octothorpe, hash, sharp, pound, number sign) denotes a comment . Example 5.5. Comment Indicator # Comment only. Legend: c-comment # This stream contains no # documents, only comments. [13] c-anchor ::= “ &” An “ &” ( #x26, ampersand) denotes a node’s anchor property . [14] c-alias ::= “ *” An “ *” ( #x2A, asterisk) denotes an alias node . [15] c-tag ::= “ !” The “ !” ( #x21, exclamation) is heavily overloaded for specifying node tags . It is used to denote tag handles used in tag directives and tag properties ; to denote local tags ; and as the non-specific tag for non- plain scalars . Example 5.6. Node Property Indicators anchored: !local &anchor value alias: *anchor Legend: c-tag c-anchor c-alias %YAML 1.2 --- !!map { ? !!str \"anchored\" : !local &A1 \"value\", ? !!str \"alias\" : *A1, } [16] c-literal ::= “ |” A “ |” ( 7C, vertical bar) denotes a literal block scalar . [17] c-folded ::= “ >” A “ >” ( #x3E, greater than) denotes a folded block scalar . Example 5.7. Block Scalar Indicators literal: | some text folded: > some text Legend: c-literal c-folded %YAML 1.2 --- !!map { ? !!str \"literal\" : !!str \"some\\ntext\\n\", ? !!str \"folded\" : !!str \"some text\\n\", } [18] c-single-quote ::= “ '” An “ '” ( #x27, apostrophe, single quote) surrounds a single-quoted flow scalar . [19] c-double-quote ::= “ \"” A “ \"” ( #x22, double quote) surrounds a double-quoted flow scalar . Example 5.8. Quoted Scalar Indicators single: 'text ' double: \"text \" Legend: c-single-quote c-double-quote %YAML 1.2 --- !!map { ? !!str \"single\" : !!str \"text\", ? !!str \"double\" : !!str \"text\", } [20] c-directive ::= “ %” A “ %” ( #x25, percent) denotes a directive line. Example 5.9. Directive Indicator %YAML 1.2 --- text Legend: c-directive %YAML 1.2 --- !!str \"text\" [21] c-reserved ::= “ @” | “ `” The “ @” ( #x40, at) and “ `” ( #x60, grave accent) are reserved for future use. Example 5.10. Invalid use of Reserved Indicators commercial-at: @text grave-accent: `text ERROR: Reserved indicators can't start a plain scalar. Any indicator character: [22] c-indicator ::= “ -” | “ ?” | “ :” | “ ,” | “ [” | “ ]” | “ {” | “ }” | “ #” | “ &” | “ *” | “ !” | “ |” | “ >” | “ '” | “ \"” | “ %” | “ @” | “ `” The “ [” , “ ]” , “ {” , “ }” and “ ,” indicators denote structure in flow collections . They are therefore forbidden in some cases, to avoid ambiguity in several constructs. This is handled on a case-by-case basis by the relevant productions. [23] c-flow-indicator ::= “ ,” | “ [” | “ ]” | “ {” | “ }” 5.4. Line Break Characters YAML recognizes the following ASCII line break characters. [24] b-line-feed ::= #xA /* LF */ [25] b-carriage-return ::= #xD /* CR */ [26] b-char ::= b-line-feed | b-carriage-return All other characters, including the form feed ( #x0C), are considered to be non-break characters. Note that these include the non-ASCII line breaks: next line ( #x85), line separator ( #x2028) and paragraph separator ( #x2029). YAML version 1.1 did support the above non-ASCII line break characters; however, JSON does not. Hence, to ensure JSON compatibility , YAML treats them as non-break characters as of version 1.2. In theory this would cause incompatibility with version 1.1 ; in practice these characters were rarely (if ever) used. YAML 1.2 processors parsing a version 1.1 document should therefore treat these line breaks as non-break characters, with an appropriate warning. [27] nb-char ::= c-printable - b-char - c-byte-order-mark Line breaks are interpreted differently by different systems, and have several widely used formats. [28] b-break ::= ( b-carriage-return b-line-feed ) /* DOS, Windows */ | b-carriage-return /* MacOS upto 9.x */ | b-line-feed /* UNIX, MacOS X */ Line breaks inside scalar content must be normalized by the YAML processor . Each such line break must be parsed into a single line feed character. The original line break format is a presentation detail and must not be used to convey content information. [29] b-as-line-feed ::= b-break Outside scalar content , YAML allows any line break to be used to terminate lines. [30] b-non-content ::= b-break On output, a YAML processor is free to emit line breaks using whatever convention is most appropriate. In the examples, line breaks are sometimes displayed using the “ ” glyph for clarity. Example 5.11. Line Break Characters | Line break (no glyph) Line break (glyphed) Legend: b-break %YAML 1.2 --- !!str \"line break (no glyph)\\n\\ line break (glyphed)\\n\" 5.5. White Space Characters YAML recognizes two white space characters: space and tab. [31] s-space ::= #x20 /* SP */ [32] s-tab ::= #x9 /* TAB */ [33] s-white ::= s-space | s-tab The rest of the ( printable ) non- break characters are considered to be non-space characters. [34] ns-char ::= nb-char - s-white In the examples, tab characters are displayed as the glyph “ ”. Space characters are sometimes displayed as the glyph “ ·” for clarity. Example 5.12. Tabs and Spaces # Tabs and spaces quoted: ·\"Quoted \" block: | ··void main() { ·· printf(\"Hello, world!\\n\"); ··} Legend: s-space s-tab %YAML 1.2 --- !!map { ? !!str \"quoted\" : \"Quoted \\t\", ? !!str \"block\" : \"void main() {\\n\\ \\tprintf(\\\"Hello, world!\\\\n\\\");\\n\\ }\\n\", } 5.6. Miscellaneous Characters The YAML syntax productions make use of the following additional character classes: A decimal digit for numbers: [35] ns-dec-digit ::= [#x30-#x39] /* 0-9 */ A hexadecimal digit for escape sequences : [36] ns-hex-digit ::= ns-dec-digit | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */ ASCII letter (alphabetic) characters: [37] ns-ascii-letter ::= [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */ Word (alphanumeric) characters for identifiers: [38] ns-word-char ::= ns-dec-digit | ns-ascii-letter | “ -” URI characters for tags , as specified in RFC2396 , with the addition of the “ [” and “ ]” for presenting IPv6 addresses as proposed in RFC2732 . By convention, any URI characters other than the allowed printable ASCII characters are first encoded in UTF-8, and then each byte is escaped using the “ %” character. The YAML processor must not expand such escaped characters. Tag characters must be preserved and compared exactly as presented in the YAML stream , without any processing. [39] ns-uri-char ::= “ %” ns-hex-digit ns-hex-digit | ns-word-char | “ #” | “ ;” | “ /” | “ ?” | “ :” | “ @” | “ &” | “ =” | “ +” | “ $” | “ ,” | “ _” | “ .” | “ !” | “ ~” | “ *” | “ '” | “ (” | “ )” | “ [” | “ ]” The “ !” character is used to indicate the end of a named tag handle ; hence its use in tag shorthands is restricted. In addition, such shorthands must not contain the “ [” , “ ]” , “ {” , “ }” and “ ,” characters. These characters would cause ambiguity with flow collection structures. [40] ns-tag-char ::= ns-uri-char - “ !” - c-flow-indicator 5.7. Escaped Characters All non- printable characters must be escaped. YAML escape sequences use the “ \\” notation common to most modern computer languages. Each escape sequence must be parsed into the appropriate Unicode character. The original escape sequence is a presentation detail and must not be used to convey content information. Note that escape sequences are only interpreted in double-quoted scalars . In all other scalar styles , the “ \\” character has no special meaning and non- printable characters are not available. [41] c-escape ::= “ \\” YAML escape sequences are a superset of C’s escape sequences: [42] ns-esc-null ::= “ 0” Escaped ASCII null ( #x0) character. [43] ns-esc-bell ::= “ a” Escaped ASCII bell ( #x7) character. [44] ns-esc-backspace ::= “ b” Escaped ASCII backspace ( #x8) character. [45] ns-esc-horizontal-tab ::= “ t” | #x9 Escaped ASCII horizontal tab ( #x9) character. This is useful at the start or the end of a line to force a leading or trailing tab to become part of the content . [46] ns-esc-line-feed ::= “ n” Escaped ASCII line feed ( #xA) character. [47] ns-esc-vertical-tab ::= “ v” Escaped ASCII vertical tab ( #xB) character. [48] ns-esc-form-feed ::= “ f” Escaped ASCII form feed ( #xC) character. [49] ns-esc-carriage-return ::= “ r” Escaped ASCII carriage return ( #xD) character. [50] ns-esc-escape ::= “ e” Escaped ASCII escape ( #x1B) character. [51] ns-esc-space ::= #x20 Escaped ASCII space ( #x20) character. This is useful at the start or the end of a line to force a leading or trailing space to become part of the content . [52] ns-esc-double-quote ::= “ \"” Escaped ASCII double quote ( #x22). [53] ns-esc-slash ::= “ /” Escaped ASCII slash ( #x2F), for JSON compatibility . [54] ns-esc-backslash ::= “ \\” Escaped ASCII back slash ( #x5C). [55] ns-esc-next-line ::= “ N” Escaped Unicode next line ( #x85) character. [56] ns-esc-non-breaking-space ::= “ _” Escaped Unicode non-breaking space ( #xA0) character. [57] ns-esc-line-separator ::= “ L” Escaped Unicode line separator ( #x2028) character. [58] ns-esc-paragraph-separator ::= “ P” Escaped Unicode paragraph separator ( #x2029) character. [59] ns-esc-8-bit ::= “ x” ( ns-hex-digit × 2 ) Escaped 8-bit Unicode character. [60] ns-esc-16-bit ::= “ u” ( ns-hex-digit × 4 ) Escaped 16-bit Unicode character. [61] ns-esc-32-bit ::= “ U” ( ns-hex-digit × 8 ) Escaped 32-bit Unicode character. Any escaped character: [62] c-ns-esc-char ::= “ \\” ( ns-esc-null | ns-esc-bell | ns-esc-backspace | ns-esc-horizontal-tab | ns-esc-line-feed | ns-esc-vertical-tab | ns-esc-form-feed | ns-esc-carriage-return | ns-esc-escape | ns-esc-space | ns-esc-double-quote | ns-esc-slash | ns-esc-backslash | ns-esc-next-line | ns-esc-non-breaking-space | ns-esc-line-separator | ns-esc-paragraph-separator | ns-esc-8-bit | ns-esc-16-bit | ns-esc-32-bit ) Example 5.13. Escaped Characters \"Fun with \\\\ \\\" \\a \\b \\e \\f \\ \\n \\r \\t \\v \\0 \\ \\ \\_ \\N \\L \\P \\ \\x41 \\u0041 \\U00000041\" Legend: c-ns-esc-char %YAML 1.2 --- \"Fun with \\x5C \\x22 \\x07 \\x08 \\x1B \\x0C \\x0A \\x0D \\x09 \\x0B \\x00 \\x20 \\xA0 \\x85 \\u2028 \\u2029 A A A\" Example 5.14. Invalid Escaped Characters Bad escapes: \"\\ c \\x q-\" ERROR: - c is an invalid escaped character. - q and - are invalid hex digits. Chapter 6. Basic Structures 6.1. Indentation Spaces In YAML block styles , structure is determined by indentation. In general, indentation is defined as a zero or more space characters at the start of a line. To maintain portability, tab characters must not be used in indentation, since different systems treat tabs differently. Note that most modern editors may be configured so that pressing the tab key results in the insertion of an appropriate number of spaces . The amount of indentation is a presentation detail and must not be used to convey content information. [63] s-indent(n) ::= s-space × n A block style construct is terminated when encountering a line which is less indented than the construct. The productions use the notation “ s-indent(<n)” and “ s-indent( n)” to express this. [64] s-indent(<n) ::= s-space × m /* Where m < n */ [65] s-indent( n) ::= s-space × m /* Where m n */ Each node must be indented further than its parent node . All sibling nodes must use the exact same indentation level. However the content of each sibling node may be further indented independently. Example 6.1. Indentation Spaces ··# Leading comment line spaces are ···# neither content nor indentation. ···· Not indented: ·By one space: | ····By four ···· ··spaces ·Flow style: [ # Leading spaces ·· ·By two, # in flow style ··Also by two, # are neither ·· Still by two # content nor ·· ··] # indentation. Legend: s-indent(n) Content Neither content nor indentation %YAML 1.2 - - - !!map { ? !!str \"Not indented\" : !!map { ? !!str \"By one space\" : !!str \"By four\\n spaces\\n\", ? !!str \"Flow style\" : !!seq [ !!str \"By two\", !!str \"Also by two\", !!str \"Still by two\", ] } } The “ -” , “ ?” and “ :” characters used to denote block collection entries are perceived by people to be part of the indentation. This is handled on a case-by-case basis by the relevant productions. Example 6.2. Indentation Indicators ?·a : · - b ·· - ·· - c ····· -·d Legend: Total Indentation s-indent(n) Indicator as indentation %YAML 1.2 --- !!map { ? !!str \"a\" : !!seq [ !!str \"b\", !!seq [ !!str \"c\", !!str \"d\" ] ], } 6.2. Separation Spaces Outside indentation and scalar content , YAML uses white space characters for separation between tokens within a line. Note that such white space may safely include tab characters. Separation spaces are a presentation detail and must not be used to convey content information. [66] s-separate-in-line ::= s-white + | /* Start of line */ Example 6.3. Separation Spaces - ·foo: ·bar - - ·baz - baz Legend: s-separate-in-line %YAML 1.2 --- !!seq [ !!map { ? !!str \"foo\" : !!str \"bar\", }, !!seq [ !!str \"baz\", !!str \"baz\" ], ] 6.3. Line Prefixes Inside scalar content , each line begins with a non- content line prefix. This prefix always includes the indentation . For flow scalar styles it additionally includes all leading white space , which may contain tab characters. Line prefixes are a presentation detail and must not be used to convey content information. [67] s-line-prefix(n,c) ::= c = block-out s-block-line-prefix(n) c = block-in s-block-line-prefix(n) c = flow-out s-flow-line-prefix(n) c = flow-in s-flow-line-prefix(n) [68] s-block-line-prefix(n) ::= s-indent(n) [69] s-flow-line-prefix(n) ::= s-indent(n) s-separate-in-line ? Example 6.4. Line Prefixes plain: text ··lines quoted: \"text ·· lines\" block: | ··text ··· lines Legend: s-flow-line-prefix(n) s-block-line-prefix(n) s-indent(n) %YAML 1.2 --- !!map { ? !!str \"plain\" : !!str \"text lines\", ? !!str \"quoted\" : !!str \"text lines\", ? !!str \"block\" : !!str \"text\\n· lines\\n\", } 6.4. Empty Lines An empty line line consists of the non- content prefix followed by a line break . [70] l-empty(n,c) ::= ( s-line-prefix(n,c) | s-indent(<n) ) b-as-line-feed The semantics of empty lines depend on the scalar style they appear in. This is handled on a case-by-case basis by the relevant productions. Example 6.5. Empty Lines Folding: \"Empty line ··· as a line feed\" Chomping: | Clipped empty lines · Legend: l-empty(n,c) %YAML 1.2 --- !!map { ? !!str \"Folding\" : !!str \"Empty line\\nas a line feed\", ? !!str \"Chomping\" : !!str \"Clipped empty lines\\n\", } 6.5. Line Folding Line folding allows long lines to be broken for readability, while retaining the semantics of the original long line. If a line break is followed by an empty line , it is trimmed; the first line break is discarded and the rest are retained as content . [71] b-l-trimmed(n,c) ::= b-non-content l-empty(n,c) + Otherwise (the following line is not empty ), the line break is converted to a single space ( #x20). [72] b-as-space ::= b-break A folded non- empty line may end with either of the above line breaks . [73] b-l-folded(n,c) ::= b-l-trimmed(n,c) | b-as-space Example 6.6. Line Folding >- trimmed ·· · as space %YAML 1.2 --- !!str \"trimmed\\n\\n\\nas space\" Legend: b-l-trimmed(n,c) b-as-space The above rules are common to both the folded block style and the scalar flow styles . Folding does distinguish between these cases in the following way: Block Folding In the folded block style , the final line break and trailing empty lines are subject to chomping , and are never folded. In addition, folding does not apply to line breaks surrounding text lines that contain leading white space . Note that such a more-indented line may consist only of such leading white space . The combined effect of the block line folding rules is that each “ paragraph” is interpreted as a line, empty lines are interpreted as a line feed, and the formatting of more-indented lines is preserved. Example 6.7. Block Folding > ··foo · · ·· ·bar ··baz %YAML 1.2 --- !!str \"foo \\n\\n\\t bar\\n\\nbaz\\n\" Legend: b-l-folded(n,c) Non-content spaces Content spaces Flow Folding Folding in flow styles provides more relaxed semantics. Flow styles typically depend on explicit indicators rather than indentation to convey structure. Hence spaces preceding or following the text in a line are a presentation detail and must not be used to convey content information. Once all such spaces have been discarded, all line breaks are folded, without exception. The combined effect of the flow line folding rules is that each “ paragraph” is interpreted as a line, empty lines are interpreted as line feeds, and text can be freely more-indented without affecting the content information. [74] s-flow-folded(n) ::= s-separate-in-line ? b-l-folded(n,flow-in) s-flow-line-prefix(n) Example 6.8. Flow Folding \" ··foo · · ·· ·bar ··baz \" %YAML 1.2 --- !!str \" foo\\nbar\\nbaz \" Legend: s-flow-folded(n) Non-content spaces 6.6. Comments An explicit comment is marked by a “ #” indicator. Comments are a presentation detail and must not be used to convey content information. Comments must be separated from other tokens by white space characters. To ensure JSON compatibility , YAML processors must allow for the omission of the final comment line break of the input stream . However, as this confuses many tools, YAML processors should terminate the stream with an explicit line break on output. [75] c-nb-comment-text ::= “ #” nb-char * [76] b-comment ::= b-non-content | /* End of file */ [77] s-b-comment ::= ( s-separate-in-line c-nb-comment-text ? )? b-comment Example 6.9. Separated Comment key: ···· # Comment value eof Legend: c-nb-comment-text b-comment s-b-comment %YAML 1.2 --- !!map { ? !!str \"key\" : !!str \"value\", } Outside scalar content , comments may appear on a line of their own, independent of the indentation level. Note that outside scalar content , a line containing only white space characters is taken to be a comment line. [78] l-comment ::= s-separate-in-line c-nb-comment-text ? b-comment Example 6.10. Comment Lines ·· # Comment ··· # This stream contains no # documents, only comments. Legend: s-b-comment l-comment In most cases, when a line may end with a comment, YAML allows it to be followed by additional comment lines. The only exception is a comment ending a block scalar header . [79] s-l-comments ::= ( s-b-comment | /* Start of line */ ) l-comment * Example 6.11. Multi-Line Comments key: ····# Comment ········# lines value %YAML 1.2 --- !!map { ? !!str \"key\" : !!str \"value\", } Legend: s-b-comment l-comment s-l-comments 6.7. Separation Lines Implicit keys are restricted to a single line. In all other cases, YAML allows tokens to be separated by multi-line (possibly empty) comments . Note that structures following multi-line comment separation must be properly indented , even though there is no such restriction on the separation comment lines themselves. [80] s-separate(n,c) ::= c = block-out s-separate-lines(n) c = block-in s-separate-lines(n) c = flow-out s-separate-lines(n) c = flow-in s-separate-lines(n) c = block-key s-separate-in-line c = flow-key s-separate-in-line [81] s-separate-lines(n) ::= ( s-l-comments s-flow-line-prefix(n) ) | s-separate-in-line Example 6.12. Separation Spaces { ·first: ·Sammy, ·last: ·Sosa ·}: # Statistics: ··hr: ··# Home runs ·····65 ··avg: ·# Average ···0.278 Legend: s-separate-in-line s-separate-lines(n) s-indent(n) %YAML 1.2 --- !!map { ? !!map { ? !!str \"first\" : !!str \"Sammy\", ? !!str \"last\" : !!str \"Sosa\", } : !!map { ? !!str \"hr\" : !!int \"65\", ? !!str \"avg\" : !!float \"0.278\", }, } 6.8. Directives Directives are instructions to the YAML processor . This specification defines two directives, “ YAML” and “ TAG” , and reserves all other directives for future use. There is no way to define private directives. This is intentional. Directives are a presentation detail and must not be used to convey content information. [82] l-directive ::= “ %” ( ns-yaml-directive | ns-tag-directive | ns-reserved-directive ) s-l-comments Each directive is specified on a separate non- indented line starting with the “ %” indicator, followed by the directive name and a list of parameters. The semantics of these parameters depends on the specific directive. A YAML processor should ignore unknown directives with an appropriate warning. [83] ns-reserved-directive ::= ns-directive-name ( s-separate-in-line ns-directive-parameter )* [84] ns-directive-name ::= ns-char + [85] ns-directive-parameter ::= ns-char + Example 6.13. Reserved Directives % FOO bar baz # Should be ignored # with a warning. --- \"foo\" %YAML 1.2 --- !!str \"foo\" Legend: ns-reserved-directive ns-directive-name ns-directive-parameter 6.8.1. “ YAML” Directives The “ YAML” directive specifies the version of YAML the document conforms to. This specification defines version “ 1.2”, including recommendations for YAML 1.1 processing. A version 1.2 YAML processor must accept documents with an explicit “ %YAML 1.2” directive, as well as documents lacking a “ YAML” directive. Such documents are assumed to conform to the 1.2 version specification. Documents with a “ YAML” directive specifying a higher minor version (e.g. “ %YAML 1.3”) should be processed with an appropriate warning. Documents with a “ YAML” directive specifying a higher major version (e.g. “ %YAML 2.0”) should be rejected with an appropriate error message. A version 1.2 YAML processor must also accept documents with an explicit “ %YAML 1.1” directive. Note that version 1.2 is mostly a superset of version 1.1, defined for the purpose of ensuring JSON compatibility. Hence a version 1.2 processor should process version 1.1 documents as if they were version 1.2, giving a warning on points of incompatibility (handling of non-ASCII line breaks , as described above ). [86] ns-yaml-directive ::= “ Y” “ A” “ M” “ L” s-separate-in-line ns-yaml-version [87] ns-yaml-version ::= ns-dec-digit + “ .” ns-dec-digit + Example 6.14. “ YAML” directive % YAML 1.3 # Attempt parsing # with a warning --- \"foo\" %YAML 1.2 --- !!str \"foo\" Legend: ns-yaml-directive ns-yaml-version It is an error to specify more than one “ YAML” directive for the same document, even if both occurrences give the same version number. Example 6.15. Invalid Repeated YAML directive %YAML 1.2 % YAML 1.1 foo ERROR: The YAML directive must only be given at most once per document. 6.8.2. “ TAG” Directives The “ TAG” directive establishes a tag shorthand notation for specifying node tags . Each “ TAG” directive associates a handle with a prefix . This allows for compact and readable tag notation. [88] ns-tag-directive ::= “ T” “ A” “ G” s-separate-in-line c-tag-handle s-separate-in-line ns-tag-prefix Example 6.16. “ TAG” directive % TAG !yaml! tag:yaml.org,2002: --- !yaml!str \"foo\" %YAML 1.2 --- !!str \"foo\" Legend: ns-tag-directive c-tag-handle ns-tag-prefix It is an error to specify more than one “ TAG” directive for the same handle in the same document, even if both occurrences give the same prefix . Example 6.17. Invalid Repeated TAG directive %TAG ! !foo %TAG ! !foo bar ERROR: The TAG directive must only be given at most once per handle in the same document. 6.8.2.1. Tag Handles The tag handle exactly matches the prefix of the affected tag shorthand . There are three tag handle variants: [89] c-tag-handle ::= c-named-tag-handle | c-secondary-tag-handle | c-primary-tag-handle Primary Handle The primary tag handle is a single “ !” character. This allows using the most compact possible notation for a single “ primary” name space. By default, the prefix associated with this handle is “ !” . Thus, by default, shorthands using this handle are interpreted as local tags . It is possible to override the default behavior by providing an explicit “ TAG” directive, associating a different prefix for this handle. This provides smooth migration from using local tags to using global tags , by the simple addition of a single “ TAG” directive. [90] c-primary-tag-handle ::= “ !” Example 6.18. Primary Tag Handle # Private !foo \"bar\" ... # Global %TAG ! tag:example.com,2000:app/ --- !foo \"bar\" %YAML 1.2 --- !<!foo> \"bar\" ... --- !<tag:example.com,2000:app/foo> \"bar\" Legend: c-primary-tag-handle Secondary Handle The secondary tag handle is written as “ !!”. This allows using a compact notation for a single “ secondary” name space. By default, the prefix associated with this handle is “ tag:yaml.org,2002:”. This prefix is used by the YAML tag repository . It is possible to override this default behavior by providing an explicit “ TAG” directive associating a different prefix for this handle. [91] c-secondary-tag-handle ::= “ !” “ !” Example 6.19. Secondary Tag Handle %TAG !! tag:example.com,2000:app/ --- !!int 1 - 3 # Interval, not integer Legend: c-secondary-tag-handle %YAML 1.2 --- !<tag:example.com,2000:app/int> \"1 - 3\" Named Handles A named tag handle surrounds a non-empty name with “ !” characters. A handle name must not be used in a tag shorthand unless an explicit “ TAG” directive has associated some prefix with it. The name of the handle is a presentation detail and must not be used to convey content information. In particular, the YAML processor need not preserve the handle name once parsing is completed. [92] c-named-tag-handle ::= “ !” ns-word-char + “ !” Example 6.20. Tag Handles %TAG !e! tag:example.com,2000:app/ --- !e!foo \"bar\" Legend: c-named-tag-handle %YAML 1.2 --- !<tag:example.com,2000:app/foo> \"bar\" 6.8.2.2. Tag Prefixes There are two tag prefix variants: [93] ns-tag-prefix ::= c-ns-local-tag-prefix | ns-global-tag-prefix Local Tag Prefix If the prefix begins with a “ !” character, shorthands using the handle are expanded to a local tag . Note that such a tag is intentionally not a valid URI, and its semantics are specific to the application . In particular, two documents in the same stream may assign different semantics to the same local tag . [94] c-ns-local-tag-prefix ::= “ !” ns-uri-char * Example 6.21. Local Tag Prefix %TAG !m! !my- --- # Bulb here !m!light fluorescent ... %TAG !m! !my- --- # Color here !m!light green Legend: c-ns-local-tag-prefix %YAML 1.2 --- !<!my-light> \"fluorescent\" ... %YAML 1.2 --- !<!my-light> \"green\" Global Tag Prefix If the prefix begins with a character other than “ !” , it must to be a valid URI prefix, and should contain at least the scheme and the authority. Shorthands using the associated handle are expanded to globally unique URI tags, and their semantics is consistent across applications . In particular, every documents in every stream must assign the same semantics to the same global tag . [95] ns-global-tag-prefix ::= ns-tag-char ns-uri-char * Example 6.22. Global Tag Prefix %TAG !e! tag:example.com,2000:app/ --- - !e!foo \"bar\" Legend: ns-global-tag-prefix %YAML 1.2 --- !<tag:example.com,2000:app/foo> \"bar\" 6.9. Node Properties Each node may have two optional properties, anchor and tag , in addition to its content . Node properties may be specified in any order before the node’s content . Either or both may be omitted. [96] c-ns-properties(n,c) ::= ( c-ns-tag-property ( s-separate(n,c) c-ns-anchor-property )? ) | ( c-ns-anchor-property ( s-separate(n,c) c-ns-tag-property )? ) Example 6.23. Node Properties !!str &a1 \"foo\": !!str bar &a2 baz : *a1 Legend: c-ns-properties(n,c) c-ns-anchor-property c-ns-tag-property %YAML 1.2 --- !!map { ? &B1 !!str \"foo\" : !!str \"bar\", ? !!str \"baz\" : *B1, } 6.9.1. Node Tags The tag property identifies the type of the native data structure presented by the node . A tag is denoted by the “ !” indicator. [97] c-ns-tag-property ::= c-verbatim-tag | c-ns-shorthand-tag | c-non-specific-tag Verbatim Tags A tag may be written verbatim by surrounding it with the “ <” and “ >” characters. In this case, the YAML processor must deliver the verbatim tag as-is to the application . In particular, verbatim tags are not subject to tag resolution . A verbatim tag must either begin with a “ !” (a local tag ) or be a valid URI (a global tag ). [98] c-verbatim-tag ::= “ !” “ <” ns-uri-char + “ >” Example 6.24. Verbatim Tags !<tag:yaml.org,2002:str> foo : !<!bar> baz Legend: c-verbatim-tag %YAML 1.2 --- !!map { ? !<tag:yaml.org,2002:str> \"foo\" : !<!bar> \"baz\", } Example 6.25. Invalid Verbatim Tags - !< !> foo - !< $:?> bar ERROR: - Verbatim tags aren't resolved, so ! is invalid. - The $:? tag is neither a global URI tag nor a local tag starting with “ !”. Tag Shorthands A tag shorthand consists of a valid tag handle followed by a non-empty suffix. The tag handle must be associated with a prefix , either by default or by using a “ TAG” directive . The resulting parsed tag is the concatenation of the prefix and the suffix, and must either begin with “ !” (a local tag ) or be a valid URI (a global tag ). The choice of tag handle is a presentation detail and must not be used to convey content information. In particular, the tag handle may be discarded once parsing is completed. The suffix must not contain any “ !” character. This would cause the tag shorthand to be interpreted as having a named tag handle . In addition, the suffix must not contain the “ [” , “ ]” , “ {” , “ }” and “ ,” characters. These characters would cause ambiguity with flow collection structures. If the suffix needs to specify any of the above restricted characters, they must be escaped using the “ %” character. This behavior is consistent with the URI character escaping rules (specifically, section 2.3 of RFC2396 ). [99] c-ns-shorthand-tag ::= c-tag-handle ns-tag-char + Example 6.26. Tag Shorthands %TAG !e! tag:example.com,2000:app/ --- - !local foo - !!str bar - !e!tag%21 baz Legend: c-ns-shorthand-tag %YAML 1.2 --- !!seq [ !<!local> \"foo\", !<tag:yaml.org,2002:str> \"bar\", !<tag:example.com,2000:app/tag!> \"baz\" ] Example 6.27. Invalid Tag Shorthands %TAG !e! tag:example,2000:app/ --- - !e! foo - !h!bar baz ERROR: - The !o! handle has no suffix. - The !h! handle wasn't declared. Non-Specific Tags If a node has no tag property, it is assigned a non-specific tag that needs to be resolved to a specific one. This non-specific tag is “ !” for non- plain scalars and “ ?” for all other nodes . This is the only case where the node style has any effect on the content information. It is possible for the tag property to be explicitly set to the “ !” non-specific tag . By convention , this “ disables” tag resolution , forcing the node to be interpreted as “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map”, or “ tag:yaml.org,2002:str”, according to its kind . There is no way to explicitly specify the “ ?” non-specific tag. This is intentional. [100] c-non-specific-tag ::= “ !” Example 6.28. Non-Specific Tags # Assuming conventional resolution: - \"12\" - 12 - ! 12 Legend: c-non-specific-tag %YAML 1.2 --- !!seq [ !<tag:yaml.org,2002:str> \"12\", !<tag:yaml.org,2002:int> \"12\", !<tag:yaml.org,2002:str> \"12\", ] 6.9.2. Node Anchors An anchor is denoted by the “ &” indicator. It marks a node for future reference. An alias node can then be used to indicate additional inclusions of the anchored node . An anchored node need not be referenced by any alias nodes ; in particular, it is valid for all nodes to be anchored. [101] c-ns-anchor-property ::= “ &” ns-anchor-name Note that as a serialization detail , the anchor name is preserved in the serialization tree . However, it is not reflected in the representation graph and must not be used to convey content information. In particular, the YAML processor need not preserve the anchor name once the representation is composed . Anchor names must not contain the “ [” , “ ]” , “ {” , “ }” and “ ,” characters. These characters would cause ambiguity with flow collection structures. [102] ns-anchor-char ::= ns-char - c-flow-indicator [103] ns-anchor-name ::= ns-anchor-char + Example 6.29. Node Anchors First occurrence: & anchor Value Second occurrence: * anchor Legend: c-ns-anchor-property ns-anchor-name %YAML 1.2 --- !!map { ? !!str \"First occurrence\" : &A !!str \"Value\", ? !!str \"Second occurrence\" : *A, } Chapter 7. Flow Styles YAML’s flow styles can be thought of as the natural extension of JSON to cover folding long content lines for readability, tagging nodes to control construction of native data structures , and using anchors and aliases to reuse constructed object instances. 7.1. Alias Nodes Subsequent occurrences of a previously serialized node are presented as alias nodes. The first occurrence of the node must be marked by an anchor to allow subsequent occurrences to be presented as alias nodes. An alias node is denoted by the “ *” indicator. The alias refers to the most recent preceding node having the same anchor . It is an error for an alias node to use an anchor that does not previously occur in the document . It is not an error to specify an anchor that is not used by any alias node. Note that an alias node must not specify any properties or content , as these were already specified at the first occurrence of the node . [104] c-ns-alias-node ::= “ *” ns-anchor-name Example 7.1. Alias Nodes First occurrence: & anchor Foo Second occurrence: * anchor Override anchor: & anchor Bar Reuse anchor: * anchor Legend: c-ns-alias-node ns-anchor-name %YAML 1.2 --- !!map { ? !!str \"First occurrence\" : &A !!str \"Foo\", ? !!str \"Override anchor\" : &B !!str \"Bar\", ? !!str \"Second occurrence\" : *A, ? !!str \"Reuse anchor\" : *B, } 7.2. Empty Nodes YAML allows the node content to be omitted in many cases. Nodes with empty content are interpreted as if they were plain scalars with an empty value. Such nodes are commonly resolved to a “ null” value. [105] e-scalar ::= /* Empty */ In the examples, empty scalars are sometimes displayed as the glyph “ °” for clarity. Note that this glyph corresponds to a position in the characters stream rather than to an actual character. Example 7.2. Empty Content { foo : !!str °, !!str ° : bar, } Legend: e-scalar %YAML 1.2 --- !!map { ? !!str \"foo\" : !!str \"\", ? !!str \"\" : !!str \"bar\", } Both the node’s properties and node content are optional. This allows for a completely empty node. Completely empty nodes are only valid when following some explicit indication for their existence. [106] e-node ::= e-scalar Example 7.3. Completely Empty Flow Nodes { ? foo : °, °: bar, } Legend: e-node %YAML 1.2 --- !!map { ? !!str \"foo\" : !!null \"\", ? !!null \"\" : !!str \"bar\", } 7.3. Flow Scalar Styles YAML provides three flow scalar styles: double-quoted , single-quoted and plain (unquoted). Each provides a different trade-off between readability and expressive power. The scalar style is a presentation detail and must not be used to convey content information, with the exception that plain scalars are distinguished for the purpose of tag resolution . 7.3.1. Double-Quoted Style The double-quoted style is specified by surrounding “ \"” indicators. This is the only style capable of expressing arbitrary strings, by using “ \\” escape sequences . This comes at the cost of having to escape the “ \\” and “ \"” characters. [107] nb-double-char ::= c-ns-esc-char | ( nb-json - “ \\” - “ \"” ) [108] ns-double-char ::= nb-double-char - s-white Double-quoted scalars are restricted to a single line when contained inside an implicit key . [109] c-double-quoted(n,c) ::= “ \"” nb-double-text(n,c) “ \"” [110] nb-double-text(n,c) ::= c = flow-out nb-double-multi-line(n) c = flow-in nb-double-multi-line(n) c = block-key nb-double-one-line c = flow-key nb-double-one-line [111] nb-double-one-line ::= nb-double-char * Example 7.4. Double Quoted Implicit Keys \" implicit block key\" : [ \" implicit flow key\" : value, ] Legend: nb-double-one-line c-double-quoted(n,c) %YAML 1.2 --- !!map { ? !!str \"implicit block key\" : !!seq [ !!map { ? !!str \"implicit flow key\" : !!str \"value\", } ] } In a multi-line double-quoted scalar, line breaks are are subject to flow line folding , which discards any trailing white space characters. It is also possible to escape the line break character. In this case, the line break is excluded from the content , and the trailing white space characters are preserved. Combined with the ability to escape white space characters, this allows double-quoted lines to be broken at arbitrary positions. [112] s-double-escaped(n) ::= s-white * “ \\” b-non-content l-empty(n,flow-in) * s-flow-line-prefix(n) [113] s-double-break(n) ::= s-double-escaped(n) | s-flow-folded(n) Example 7.5. Double Quoted Line Breaks \"folded · to a space, · to a line feed, or · \\ ·\\· non-content\" %YAML 1.2 --- !!str \"folded to a space,\\n\\ to a line feed, \\ or \\t \\tnon-content\" Legend: s-flow-folded(n) s-double-escaped(n) All leading and trailing white space characters are excluded from the content . Each continuation line must therefore contain at least one non- space character. Empty lines, if any, are consumed as part of the line folding . [114] nb-ns-double-in-line ::= ( s-white * ns-double-char )* [115] s-double-next-line(n) ::= s-double-break(n) ( ns-double-char nb-ns-double-in-line ( s-double-next-line(n) | s-white * ) )? [116] nb-double-multi-line(n) ::= nb-ns-double-in-line ( s-double-next-line(n) | s-white * ) Example 7.6. Double Quoted Lines \" ·1st non-empty · 2nd non-empty · 3rd non-empty·\" %YAML 1.2 --- !!str \" 1st non-empty\\n\\ 2nd non-empty \\ 3rd non-empty \" Legend: nb-ns-double-in-line s-double-next-line(n) 7.3.2. Single-Quoted Style The single-quoted style is specified by surrounding “ '” indicators. Therefore, within a single-quoted scalar, such characters need to be repeated. This is the only form of escaping performed in single-quoted scalars. In particular, the “ \\” and “ \"” characters may be freely used. This restricts single-quoted scalars to printable characters. In addition, it is only possible to break a long single-quoted line where a space character is surrounded by non- spaces . [117] c-quoted-quote ::= “ '” “ '” [118] nb-single-char ::= c-quoted-quote | ( nb-json - “ '” ) [119] ns-single-char ::= nb-single-char - s-white Example 7.7. Single Quoted Characters 'here ''s to \"quotes\"' Legend: c-quoted-quote %YAML 1.2 --- !!str \"here's to \\\"quotes\\\"\" Single-quoted scalars are restricted to a single line when contained inside a implicit key . [120] c-single-quoted(n,c) ::= “ '” nb-single-text(n,c) “ '” [121] nb-single-text(n,c) ::= c = flow-out nb-single-multi-line(n) c = flow-in nb-single-multi-line(n) c = block-key nb-single-one-line c = flow-key nb-single-one-line [122] nb-single-one-line ::= nb-single-char * Example 7.8. Single Quoted Implicit Keys ' implicit block key' : [ ' implicit flow key' : value, ] Legend: nb-single-one-line c-single-quoted(n,c) %YAML 1.2 --- !!map { ? !!str \"implicit block key\" : !!seq [ !!map { ? !!str \"implicit flow key\" : !!str \"value\", } ] } All leading and trailing white space characters are excluded from the content . Each continuation line must therefore contain at least one non- space character. Empty lines, if any, are consumed as part of the line folding . [123] nb-ns-single-in-line ::= ( s-white * ns-single-char )* [124] s-single-next-line(n) ::= s-flow-folded(n) ( ns-single-char nb-ns-single-in-line ( s-single-next-line(n) | s-white * ) )? [125] nb-single-multi-line(n) ::= nb-ns-single-in-line ( s-single-next-line(n) | s-white * ) Example 7.9. Single Quoted Lines ' ·1st non-empty · 2nd non-empty · 3rd non-empty·' %YAML 1.2 --- !!str \" 1st non-empty\\n\\ 2nd non-empty \\ 3rd non-empty \" Legend: nb-ns-single-in-line(n) s-single-next-line(n) 7.3.3. Plain Style The plain (unquoted) style has no identifying indicators and provides no form of escaping. It is therefore the most readable, most limited and most context sensitive style . In addition to a restricted character set, a plain scalar must not be empty, or contain leading or trailing white space characters. It is only possible to break a long plain line where a space character is surrounded by non- spaces . Plain scalars must not begin with most indicators , as this would cause ambiguity with other YAML constructs. However, the “ :” , “ ?” and “ -” indicators may be used as the first character if followed by a non- space “ safe” character, as this causes no ambiguity. [126] ns-plain-first(c) ::= ( ns-char - c-indicator ) | ( ( “ ?” | “ :” | “ -” ) /* Followed by an ns-plain-safe(c) ) */ ) Plain scalars must never contain the “ : ” and “ #” character combinations. Such combinations would cause ambiguity with mapping key: value pairs and comments . In addition, inside flow collections , or when used as implicit keys , plain scalars must not contain the “ [” , “ ]” , “ {” , “ }” and “ ,” characters. These characters would cause ambiguity with flow collection structures. [127] ns-plain-safe(c) ::= c = flow-out ns-plain-safe-out c = flow-in ns-plain-safe-in c = block-key ns-plain-safe-out c = flow-key ns-plain-safe-in [128] ns-plain-safe-out ::= ns-char [129] ns-plain-safe-in ::= ns-char - c-flow-indicator [130] ns-plain-char(c) ::= ( ns-plain-safe(c) - “ :” - “ #” ) | ( /* An ns-char preceding */ “ #” ) | ( “ :” /* Followed by an ns-plain-safe(c) */ ) Example 7.10. Plain Characters # Outside flow collection: - : :vector - \" : - ()\" - Up , up, and away! - -123 - http ://example.com/foo #bar # Inside flow collection: - [ : :vector, \" : - ()\", \"Up , up and away!\", -123, http ://example.com/foo #bar ] %YAML 1.2 --- !!seq [ !!str \"::vector\", !!str \": - ()\", !!str \"Up, up, and away!\", !!int \"-123\", !!str \"http://example.com/foo#bar\", !!seq [ !!str \"::vector\", !!str \": - ()\", !!str \"Up, up, and away!\", !!int \"-123\", !!str \"http://example.com/foo#bar\", ], ] Legend: ns-plain-first(c) Not ns-plain-first(c) ns-plain-char(c) Not ns-plain-char(c) Plain scalars are further restricted to a single line when contained inside an implicit key . [131] ns-plain(n,c) ::= c = flow-out ns-plain-multi-line(n,c) c = flow-in ns-plain-multi-line(n,c) c = block-key ns-plain-one-line(c) c = flow-key ns-plain-one-line(c) [132] nb-ns-plain-in-line(c) ::= ( s-white * ns-plain-char(c) )* [133] ns-plain-one-line(c) ::= ns-plain-first(c) nb-ns-plain-in-line(c) Example 7.11. Plain Implicit Keys implicit block key : [ implicit flow key : value, ] Legend: ns-plain-one-line(c) %YAML 1.2 --- !!map { ? !!str \"implicit block key\" : !!seq [ !!map { ? !!str \"implicit flow key\" : !!str \"value\", } ] } All leading and trailing white space characters are excluded from the content . Each continuation line must therefore contain at least one non- space character. Empty lines, if any, are consumed as part of the line folding . [134] s-ns-plain-next-line(n,c) ::= s-flow-folded(n) ns-plain-char(c) nb-ns-plain-in-line(c) [135] ns-plain-multi-line(n,c) ::= ns-plain-one-line(c) s-ns-plain-next-line(n,c) * Example 7.12. Plain Lines 1st non-empty · 2nd non-empty · 3rd non-empty %YAML 1.2 --- !!str \"1st non-empty\\n\\ 2nd non-empty \\ 3rd non-empty\" Legend: nb-ns-plain-in-line(c) s-ns-plain-next-line(n,c) 7.4. Flow Collection Styles A flow collection may be nested within a block collection ( flow-out context ), nested within another flow collection ( flow-in context ), or be a part of an implicit key ( flow-key context or block-key context ). Flow collection entries are terminated by the “ ,” indicator. The final “ ,” may be omitted. This does not cause ambiguity because flow collection entries can never be completely empty . [136] in-flow(c) ::= c = flow-out flow-in c = flow-in flow-in c = block-key flow-key c = flow-key flow-key 7.4.1. Flow Sequences Flow sequence content is denoted by surrounding “ [” and “ ]” characters. [137] c-flow-sequence(n,c) ::= “ [” s-separate(n,c) ? ns-s-flow-seq-entries(n, in-flow(c) ) ? “ ]” Sequence entries are separated by a “ ,” character. [138] ns-s-flow-seq-entries(n,c) ::= ns-flow-seq-entry(n,c) s-separate(n,c) ? ( “ ,” s-separate(n,c) ? ns-s-flow-seq-entries(n,c) ? )? Example 7.13. Flow Sequence - [ one, two, ] - [ three , four ] Legend: c-sequence-start c-sequence-end ns-flow-seq-entry(n,c) %YAML 1.2 --- !!seq [ !!seq [ !!str \"one\", !!str \"two\", ], !!seq [ !!str \"three\", !!str \"four\", ], ] Any flow node may be used as a flow sequence entry. In addition, YAML provides a compact notation for the case where a flow sequence entry is a mapping with a single key: value pair . [139] ns-flow-seq-entry(n,c) ::= ns-flow-pair(n,c) | ns-flow-node(n,c) Example 7.14. Flow Sequence Entries [ \"double quoted\", 'single quoted', plain text, [ nested ], single: pair, ] Legend: ns-flow-node(n,c) ns-flow-pair(n,c) %YAML 1.2 --- !!seq [ !!str \"double quoted\", !!str \"single quoted\", !!str \"plain text\", !!seq [ !!str \"nested\", ], !!map { ? !!str \"single\" : !!str \"pair\", }, ] 7.4.2. Flow Mappings Flow mappings are denoted by surrounding “ {” and “ }” characters. [140] c-flow-mapping(n,c) ::= “ {” s-separate(n,c) ? ns-s-flow-map-entries(n, in-flow(c) ) ? “ }” Mapping entries are separated by a “ ,” character. [141] ns-s-flow-map-entries(n,c) ::= ns-flow-map-entry(n,c) s-separate(n,c) ? ( “ ,” s-separate(n,c) ? ns-s-flow-map-entries(n,c) ? )? Example 7.15. Flow Mappings - { one : two , three: four , } - { five: six, seven : eight } Legend: c-mapping-start c-mapping-end ns-flow-map-entry(n,c) %YAML 1.2 --- !!seq [ !!map { ? !!str \"one\" : !!str \"two\", ? !!str \"three\" : !!str \"four\", }, !!map { ? !!str \"five\" : !!str \"six\", ? !!str \"seven\" : !!str \"eight\", }, ] If the optional “ ?” mapping key indicator is specified, the rest of the entry may be completely empty . [142] ns-flow-map-entry(n,c) ::= ( “ ?” s-separate(n,c) ns-flow-map-explicit-entry(n,c) ) | ns-flow-map-implicit-entry(n,c) [143] ns-flow-map-explicit-entry(n,c) ::= ns-flow-map-implicit-entry(n,c) | ( e-node /* Key */ e-node /* Value */ ) Example 7.16. Flow Mapping Entries { ? explicit: entry, implicit: entry, ? ° ° } Legend: ns-flow-map-explicit-entry(n,c) ns-flow-map-implicit-entry(n,c) e-node %YAML 1.2 --- !!map { ? !!str \"explicit\" : !!str \"entry\", ? !!str \"implicit\" : !!str \"entry\", ? !!null \"\" : !!null \"\", } Normally, YAML insists the “ :” mapping value indicator be separated from the value by white space . A benefit of this restriction is that the “ :” character can be used inside plain scalars , as long as it is not followed by white space . This allows for unquoted URLs and timestamps. It is also a potential source for confusion as “ a:1” is a plain scalar and not a key: value pair . Note that the value may be completely empty since its existence is indicated by the “ :”. [144] ns-flow-map-implicit-entry(n,c) ::= ns-flow-map-yaml-key-entry(n,c) | c-ns-flow-map-empty-key-entry(n,c) | c-ns-flow-map-json-key-entry(n,c) [145] ns-flow-map-yaml-key-entry(n,c) ::= ns-flow-yaml-node(n,c) ( ( s-separate(n,c) ? c-ns-flow-map-separate-value(n,c) ) | e-node ) [146] c-ns-flow-map-empty-key-entry(n,c) ::= e-node /* Key */ c-ns-flow-map-separate-value(n,c) [147] c-ns-flow-map-separate-value(n,c) ::= “ :” /* Not followed by an ns-plain-safe(c) */ ( ( s-separate(n,c) ns-flow-node(n,c) ) | e-node /* Value */ ) Example 7.17. Flow Mapping Separate Values { unquoted· :·\"separate\", http://foo.com, omitted value : °, ° :·omitted key, } Legend: ns-flow-yaml-node(n,c) e-node c-ns-flow-map-separate-value(n,c) %YAML 1.2 --- !!map { ? !!str \"unquoted\" : !!str \"separate\", ? !!str \"http://foo.com\" : !!null \"\", ? !!str \"omitted value\" : !!null \"\", ? !!null \"\" : !!str \"omitted key\", } To ensure JSON compatibility , if a key inside a flow mapping is JSON-like , YAML allows the following value to be specified adjacent to the “ :”. This causes no ambiguity, as all JSON-like keys are surrounded by indicators . However, as this greatly reduces readability, YAML processors should separate the value from the “ :” on output, even in this case. [148] c-ns-flow-map-json-key-entry(n,c) ::= c-flow-json-node(n,c) ( ( s-separate(n,c) ? c-ns-flow-map-adjacent-value(n,c) ) | e-node ) [149] c-ns-flow-map-adjacent-value(n,c) ::= “ :” ( ( s-separate(n,c) ? ns-flow-node(n,c) ) | e-node ) /* Value */ Example 7.18. Flow Mapping Adjacent Values { \"adjacent\": value, \"readable\": ·value, \"empty\": ° } Legend: c-flow-json-node(n,c) e-node c-ns-flow-map-adjacent-value(n,c) %YAML 1.2 --- !!map { ? !!str \"adjacent\" : !!str \"value\", ? !!str \"readable\" : !!str \"value\", ? !!str \"empty\" : !!null \"\", } A more compact notation is usable inside flow sequences , if the mapping contains a single key: value pair. This notation does not require the surrounding “ {” and “ }” characters. Note that it is not possible to specify any node properties for the mapping in this case. Example 7.19. Single Pair Flow Mappings [ foo: bar ] Legend: ns-flow-pair(n,c) %YAML 1.2 --- !!seq [ !!map { ? !!str \"foo\" : !!str \"bar\" } ] If the “ ?” indicator is explicitly specified, parsing is unambiguous, and the syntax is identical to the general case. [150] ns-flow-pair(n,c) ::= ( “ ?” s-separate(n,c) ns-flow-map-explicit-entry(n,c) ) | ns-flow-pair-entry(n,c) Example 7.20. Single Pair Explicit Entry [ ? foo bar : baz ] Legend: ns-flow-map-explicit-entry(n,c) %YAML 1.2 --- !!seq [ !!map { ? !!str \"foo bar\" : !!str \"baz\", }, ] If the “ ?” indicator is omitted, parsing needs to see past the implicit key to recognize it as such. To limit the amount of lookahead required, the “ :” indicator must appear at most 1024 Unicode characters beyond the start of the key . In addition, the key is restricted to a single line. Note that YAML allows arbitrary nodes to be used as keys . In particular, a key may be a sequence or a mapping . Thus, without the above restrictions, practical one-pass parsing would have been impossible to implement. [151] ns-flow-pair-entry(n,c) ::= ns-flow-pair-yaml-key-entry(n,c) | c-ns-flow-map-empty-key-entry(n,c) | c-ns-flow-pair-json-key-entry(n,c) [152] ns-flow-pair-yaml-key-entry(n,c) ::= ns-s-implicit-yaml-key(flow-key) c-ns-flow-map-separate-value(n,c) [153] c-ns-flow-pair-json-key-entry(n,c) ::= c-s-implicit-json-key(flow-key) c-ns-flow-map-adjacent-value(n,c) [154] ns-s-implicit-yaml-key(c) ::= ns-flow-yaml-node(n/a,c) s-separate-in-line ? /* At most 1024 characters altogether */ [155] c-s-implicit-json-key(c) ::= c-flow-json-node(n/a,c) s-separate-in-line ? /* At most 1024 characters altogether */ Example 7.21. Single Pair Implicit Entries - [ YAML· : separate ] - [ ° : empty key entry ] - [ {JSON: like} :adjacent ] Legend: ns-s-implicit-yaml-key c-s-implicit-json-key e-node Value %YAML 1.2 --- !!seq [ !!seq [ !!map { ? !!str \"YAML\" : !!str \"separate\" }, ], !!seq [ !!map { ? !!null \"\" : !!str \"empty key entry\" }, ], !!seq [ !!map { ? !!map { ? !!str \"JSON\" : !!str \"like\" } : \"adjacent\", }, ], ] Example 7.22. Invalid Implicit Keys [ foo bar: invalid, \"foo ...>1K characters...bar\": invalid ] ERROR: - The foo bar key spans multiple lines - The foo...bar key is too long 7.5. Flow Nodes JSON-like flow styles all have explicit start and end indicators . The only flow style that does not have this property is the plain scalar . Note that none of the “ JSON-like” styles is actually acceptable by JSON. Even the double-quoted style is a superset of the JSON string format. [156] ns-flow-yaml-content(n,c) ::= ns-plain(n,c) [157] c-flow-json-content(n,c) ::= c-flow-sequence(n,c) | c-flow-mapping(n,c) | c-single-quoted(n,c) | c-double-quoted(n,c) [158] ns-flow-content(n,c) ::= ns-flow-yaml-content(n,c) | c-flow-json-content(n,c) Example 7.23. Flow Content - [ a, b ] - { a: b } - \"a\" - 'b' - c Legend: c-flow-json-content(n,c) ns-flow-yaml-content(n,c) %YAML 1.2 --- !!seq [ !!seq [ !!str \"a\", !!str \"b\" ], !!map { ? !!str \"a\" : !!str \"b\" }, !!str \"a\", !!str \"b\", !!str \"c\", ] A complete flow node also has optional node properties , except for alias nodes which refer to the anchored node properties . [159] ns-flow-yaml-node(n,c) ::= c-ns-alias-node | ns-flow-yaml-content(n,c) | ( c-ns-properties(n,c) ( ( s-separate(n,c) ns-flow-yaml-content(n,c) ) | e-scalar ) ) [160] c-flow-json-node(n,c) ::= ( c-ns-properties(n,c) s-separate(n,c) )? c-flow-json-content(n,c) [161] ns-flow-node(n,c) ::= c-ns-alias-node | ns-flow-content(n,c) | ( c-ns-properties(n,c) ( ( s-separate(n,c) ns-flow-content(n,c) ) | e-scalar ) ) Example 7.24. Flow Nodes - !!str \"a\" - 'b' - &anchor \"c\" - *anchor - !!str° Legend: c-flow-json-node(n,c) ns-flow-yaml-node(n,c) %YAML 1.2 --- !!seq [ !!str \"a\", !!str \"b\", &A !!str \"c\", *A, !!str \"\", ] Chapter 8. Block Styles YAML’s block styles employ indentation rather than indicators to denote structure. This results in a more human readable (though less compact) notation. 8.1. Block Scalar Styles YAML provides two block scalar styles, literal and folded . Each provides a different trade-off between readability and expressive power. 8.1.1. Block Scalar Headers Block scalars are controlled by a few indicators given in a header preceding the content itself. This header is followed by a non-content line break with an optional comment . This is the only case where a comment must not be followed by additional comment lines. [162] c-b-block-header(m,t) ::= ( ( c-indentation-indicator(m) c-chomping-indicator(t) ) | ( c-chomping-indicator(t) c-indentation-indicator(m) ) ) s-b-comment Example 8.1. Block Scalar Header - | # Empty header literal - > 1 # Indentation indicator ·folded - |+ # Chomping indicator keep - > 1- # Both indicators ·strip %YAML 1.2 --- !!seq [ !!str \"literal\\n\", !!str \"·folded\\n\", !!str \"keep\\n\\n\", !!str \"·strip\", ] Legend: c-b-block-header(m,t) 8.1.1.1. Block Indentation Indicator Typically, the indentation level of a block scalar is detected from its first non- empty line. It is an error for any of the leading empty lines to contain more spaces than the first non- empty line . Detection fails when the first non- empty line contains leading content space characters. Content may safely start with a tab or a “ #” character. When detection would fail, YAML requires that the indentation level for the content be given using an explicit indentation indicator. This level is specified as the integer number of the additional indentation spaces used for the content , relative to its parent node . It is always valid to specify an indentation indicator for a block scalar node, though a YAML processor should only emit an explicit indentation indicator for cases where detection will fail. [163] c-indentation-indicator(m) ::= ns-dec-digit m = ns-dec-digit - #x30 /* Empty */ m = auto-detect() Example 8.2. Block Indentation Indicator - |° ·detected - > ° · ·· ··# detected - |1 ··explicit - > ° · ·detected %YAML 1.2 --- !!seq [ !!str \"detected\\n\", !!str \"\\n\\n# detected\\n\", !!str \"·explicit\\n\", !!str \"\\t·detected\\n\", ] Legend: c-indentation-indicator(m) s-indent(n) Example 8.3. Invalid Block Scalar Indentation Indicators - |· · ·text - > ··text ·text - |2 ·text ERROR: - A leading all-space line must not have too many spaces. - A following text line must not be less indented. - The text is less indented than the indicated level. 8.1.1.2. Block Chomping Indicator Chomping controls how final line breaks and trailing empty lines are interpreted. YAML provides three chomping methods: Strip Stripping is specified by the “ -” chomping indicator. In this case, the final line break and any trailing empty lines are excluded from the scalar’s content . Clip Clipping is the default behavior used if no explicit chomping indicator is specified. In this case, the final line break character is preserved in the scalar’s content . However, any trailing empty lines are excluded from the scalar’s content . Keep Keeping is specified by the “ +” chomping indicator. In this case, the final line break and any trailing empty lines are considered to be part of the scalar’s content . These additional lines are not subject to folding . The chomping method used is a presentation detail and must not be used to convey content information. [164] c-chomping-indicator(t) ::= “ -” t = strip “ +” t = keep /* Empty */ t = clip The interpretation of the final line break of a block scalar is controlled by the chomping indicator specified in the block scalar header . [165] b-chomped-last(t) ::= t = strip b-non-content | /* End of file */ t = clip b-as-line-feed | /* End of file */ t = keep b-as-line-feed | /* End of file */ Example 8.4. Chomping Final Line Break strip: |- text clip: | text keep: |+ text Legend: b-non-content b-as-line-feed %YAML 1.2 --- !!map { ? !!str \"strip\" : !!str \"text\", ? !!str \"clip\" : !!str \"text\\n\", ? !!str \"keep\" : !!str \"text\\n\", } The interpretation of the trailing empty lines following a block scalar is also controlled by the chomping indicator specified in the block scalar header . [166] l-chomped-empty(n,t) ::= t = strip l-strip-empty(n) t = clip l-strip-empty(n) t = keep l-keep-empty(n) [167] l-strip-empty(n) ::= ( s-indent( n) b-non-content )* l-trail-comments(n) ? [168] l-keep-empty(n) ::= l-empty(n,block-in) * l-trail-comments(n) ? Explicit comment lines may follow the trailing empty lines . To prevent ambiguity, the first such comment line must be less indented than the block scalar content . Additional comment lines, if any, are not so restricted. This is the only case where the indentation of comment lines is constrained. [169] l-trail-comments(n) ::= s-indent(<n) c-nb-comment-text b-comment l-comment * Example 8.5. Chomping Trailing Lines # Strip # Comments: strip: |- # text ·· ·# Clip ··# comments: clip: | # text · ·# Keep ··# comments: keep: |+ # text ·# Trail ··# comments. %YAML 1.2 --- !!map { ? !!str \"strip\" : !!str \"# text\", ? !!str \"clip\" : !!str \"# text\\n\", ? !!str \"keep\" : !!str \"# text\\n\", } Legend: l-strip-empty(n) l-keep-empty(n) l-trail-comments(n) If a block scalar consists only of empty lines , then these lines are considered as trailing lines and hence are affected by chomping. Example 8.6. Empty Scalar Chomping strip: >- clip: > keep: |+ Legend: l-strip-empty(n) l-keep-empty(n) %YAML 1.2 --- !!map { ? !!str \"strip\" : !!str \"\", ? !!str \"clip\" : !!str \"\", ? !!str \"keep\" : !!str \"\\n\", } 8.1.2. Literal Style The literal style is denoted by the “ |” indicator. It is the simplest, most restricted, and most readable scalar style . [170] c-l+literal(n) ::= “ |” c-b-block-header(m,t) l-literal-content(n+m,t) Example 8.7. Literal Scalar | ·literal · text Legend: c-l+literal(n) %YAML 1.2 --- !!str \"literal\\n\\ttext\\n\" Inside literal scalars, all ( indented ) characters are considered to be content , including white space characters. Note that all line break characters are normalized . In addition, empty lines are not folded , though final line breaks and trailing empty lines are chomped . There is no way to escape characters inside literal scalars. This restricts them to printable characters. In addition, there is no way to break a long literal line. [171] l-nb-literal-text(n) ::= l-empty(n,block-in) * s-indent(n) nb-char + [172] b-nb-literal-next(n) ::= b-as-line-feed l-nb-literal-text(n) [173] l-literal-content(n,t) ::= ( l-nb-literal-text(n) b-nb-literal-next(n) * b-chomped-last(t) )? l-chomped-empty(n,t) Example 8.8. Literal Content |· ·· ··literal ··· ·· ··text ·# Comment %YAML 1.2 --- !!str \"\\n\\nliteral\\n·\\n\\ntext\\n\" Legend: l-nb-literal-text(n) b-nb-literal-next(n) b-chomped-last(t) l-chomped-empty(n,t) 8.1.3. Folded Style The folded style is denoted by the “ >” indicator. It is similar to the literal style ; however, folded scalars are subject to line folding . [174] c-l+folded(n) ::= “ >” c-b-block-header(m,t) l-folded-content(n+m,t) Example 8.9. Folded Scalar > ·folded ·text %YAML 1.2 --- !!str \"folded text\\n\" Legend: c-l+folded(n) Folding allows long lines to be broken anywhere a single space character separates two non- space characters. [175] s-nb-folded-text(n) ::= s-indent(n) ns-char nb-char * [176] l-nb-folded-lines(n) ::= s-nb-folded-text(n) ( b-l-folded(n,block-in) s-nb-folded-text(n) )* Example 8.10. Folded Lines > ·folded ·line ·next ·line * bullet * list * lines ·last ·line # Comment %YAML 1.2 --- !!str \"\\n\\ folded line\\n\\ next line\\n\\ \\ * bullet\\n \\n\\ \\ * list\\n\\ \\ * lines\\n\\ \\n\\ last line\\n\" Legend: s-nb-folded-text(n) l-nb-folded-lines(n) (The following three examples duplicate this example, each highlighting different productions.) Lines starting with white space characters ( more-indented lines) are not folded . [177] s-nb-spaced-text(n) ::= s-indent(n) s-white nb-char * [178] b-l-spaced(n) ::= b-as-line-feed l-empty(n,block-in) * [179] l-nb-spaced-lines(n) ::= s-nb-spaced-text(n) ( b-l-spaced(n) s-nb-spaced-text(n) )* Example 8.11. More Indented Lines > folded line next line ···* bullet ···* list ···* lines last line # Comment %YAML 1.2 --- !!str \"\\n\\ folded line\\n\\ next line\\n\\ \\ * bullet\\n \\n\\ \\ * list\\n\\ \\ * lines\\n\\ \\n\\ last line\\n\" Legend: s-nb-spaced-text(n) l-nb-spaced-lines(n) Line breaks and empty lines separating folded and more-indented lines are also not folded . [180] l-nb-same-lines(n) ::= l-empty(n,block-in) * ( l-nb-folded-lines(n) | l-nb-spaced-lines(n) ) [181] l-nb-diff-lines(n) ::= l-nb-same-lines(n) ( b-as-line-feed l-nb-same-lines(n) )* Example 8.12. Empty Separation Lines > folded line next line * bullet * list * line last line # Comment %YAML 1.2 --- !!str \"\\n\\ folded line\\n\\ next line\\n\\ \\ * bullet\\n \\n\\ \\ * list\\n\\ \\ * lines\\n\\ \\n\\ last line\\n\" Legend: b-as-line-feed (separation) l-empty(n,c) The final line break , and trailing empty lines if any, are subject to chomping and are never folded . [182] l-folded-content(n,t) ::= ( l-nb-diff-lines(n) b-chomped-last(t) )? l-chomped-empty(n,t) Example 8.13. Final Empty Lines > folded line next line * bullet * list * line last line # Comment %YAML 1.2 --- !!str \"\\n\\ folded line\\n\\ next line\\n\\ \\ * bullet\\n \\n\\ \\ * list\\n\\ \\ * lines\\n\\ \\n\\ last line\\n\" Legend: b-chomped-last(t) l-chomped-empty(n,t) 8.2. Block Collection Styles For readability, block collections styles are not denoted by any indicator . Instead, YAML uses a lookahead method, where a block collection is distinguished from a plain scalar only when a key: value pair or a sequence entry is seen. 8.2.1. Block Sequences A block sequence is simply a series of nodes , each denoted by a leading “ -” indicator. The “ -” indicator must be separated from the node by white space . This allows “ -” to be used as the first character in a plain scalar if followed by a non-space character (e.g. “ -1”). [183] l+block-sequence(n) ::= ( s-indent(n+m) c-l-block-seq-entry(n+m) )+ /* For some fixed auto-detected m > 0 */ [184] c-l-block-seq-entry(n) ::= “ -” /* Not followed by an ns-char */ s-l+block-indented(n,block-in) Example 8.14. Block Sequence block sequence: ·· - one - two : three Legend: c-l-block-seq-entry(n) auto-detected s-indent(n) %YAML 1.2 --- !!map { ? !!str \"block sequence\" : !!seq [ !!str \"one\", !!map { ? !!str \"two\" : !!str \"three\" }, ], } The entry node may be either completely empty , be a nested block node , or use a compact in-line notation. The compact notation may be used when the entry is itself a nested block collection . In this case, both the “ -” indicator and the following spaces are considered to be part of the indentation of the nested collection . Note that it is not possible to specify node properties for such a collection . [185] s-l+block-indented(n,c) ::= ( s-indent(m) ( ns-l-compact-sequence(n+1+m) | ns-l-compact-mapping(n+1+m) ) ) | s-l+block-node(n,c) | ( e-node s-l-comments ) [186] ns-l-compact-sequence(n) ::= c-l-block-seq-entry(n) ( s-indent(n) c-l-block-seq-entry(n) )* Example 8.15. Block Sequence Entry Types - ° # Empty - | block node - ·- one # Compact ··- two # sequence - one: two # Compact mapping Legend: Empty s-l+block-node(n,c) ns-l-compact-sequence(n) ns-l-compact-mapping(n) %YAML 1.2 --- !!seq [ !!null \"\", !!str \"block node\\n\", !!seq [ !!str \"one\" !!str \"two\", ], !!map { ? !!str \"one\" : !!str \"two\", }, ] 8.2.2. Block Mappings A Block mapping is a series of entries, each presenting a key: value pair . [187] l+block-mapping(n) ::= ( s-indent(n+m) ns-l-block-map-entry(n+m) )+ /* For some fixed auto-detected m > 0 */ Example 8.16. Block Mappings block mapping: · key: value Legend: ns-l-block-map-entry(n) auto-detected s-indent(n) %YAML 1.2 --- !!map { ? !!str \"block mapping\" : !!map { ? !!str \"key\" : !!str \"value\", }, } If the “ ?” indicator is specified, the optional value node must be specified on a separate line, denoted by the “ :” indicator. Note that YAML allows here the same compact in-line notation described above for block sequence entries. [188] ns-l-block-map-entry(n) ::= c-l-block-map-explicit-entry(n) | ns-l-block-map-implicit-entry(n) [189] c-l-block-map-explicit-entry(n) ::= c-l-block-map-explicit-key(n) ( l-block-map-explicit-value(n) | e-node ) [190] c-l-block-map-explicit-key(n) ::= “ ?” s-l+block-indented(n,block-out) [191] l-block-map-explicit-value(n) ::= s-indent(n) “ :” s-l+block-indented(n,block-out) Example 8.17. Explicit Block Mapping Entries ? explicit key # Empty value ° ? | block key :·- one # Explicit compact ··- two # block value Legend: c-l-block-map-explicit-key(n) l-block-map-explicit-value(n) e-node %YAML 1.2 --- !!map { ? !!str \"explicit key\" : !!str \"\", ? !!str \"block key\\n\" : !!seq [ !!str \"one\", !!str \"two\", ], } If the “ ?” indicator is omitted, parsing needs to see past the implicit key , in the same way as in the single key: value pair flow mapping . Hence, such keys are subject to the same restrictions; they are limited to a single line and must not span more than 1024 Unicode characters. [192] ns-l-block-map-implicit-entry(n) ::= ( ns-s-block-map-implicit-key | e-node ) c-l-block-map-implicit-value(n) [193] ns-s-block-map-implicit-key ::= c-s-implicit-json-key(block-key) | ns-s-implicit-yaml-key(block-key) In this case, the value may be specified on the same line as the implicit key . Note however that in block mappings the value must never be adjacent to the “ :”, as this greatly reduces readability and is not required for JSON compatibility (unlike the case in flow mappings ). There is no compact notation for in-line values . Also, while both the implicit key and the value following it may be empty, the “ :” indicator is mandatory. This prevents a potential ambiguity with multi-line plain scalars . [194] c-l-block-map-implicit-value(n) ::= “ :” ( s-l+block-node(n,block-out) | ( e-node s-l-comments ) ) Example 8.18. Implicit Block Mapping Entries plain key : in-line value ° :° # Both empty \"quoted key\" : - entry Legend: ns-s-block-map-implicit-key c-l-block-map-implicit-value(n) %YAML 1.2 --- !!map { ? !!str \"plain key\" : !!str \"in-line value\", ? !!null \"\" : !!null \"\", ? !!str \"quoted key\" : !!seq [ !!str \"entry\" ], } A compact in-line notation is also available. This compact notation may be nested inside block sequences and explicit block mapping entries. Note that it is not possible to specify node properties for such a nested mapping. [195] ns-l-compact-mapping(n) ::= ns-l-block-map-entry(n) ( s-indent(n) ns-l-block-map-entry(n) )* Example 8.19. Compact Block Mappings - sun: yellow - ? earth: blue : moon: white Legend: ns-l-compact-mapping(n) %YAML 1.2 --- !!seq [ !!map { !!str \"sun\" : !!str \"yellow\", }, !!map { ? !!map { ? !!str \"earth\" : !!str \"blue\" }, : !!map { ? !!str \"moon\" : !!str \"white\" }, } ] 8.2.3. Block Nodes YAML allows flow nodes to be embedded inside block collections (but not vice-versa). Flow nodes must be indented by at least one more space than the parent block collection . Note that flow nodes may begin on a following line. It is at this point that parsing needs to distinguish between a plain scalar and an implicit key starting a nested block mapping . [196] s-l+block-node(n,c) ::= s-l+block-in-block(n,c) | s-l+flow-in-block(n) [197] s-l+flow-in-block(n) ::= s-separate(n+1,flow-out) ns-flow-node(n+1,flow-out) s-l-comments Example 8.20. Block Node Types - ··\"flow in block\" -· > Block scalar -· !!map # Block collection foo : bar Legend: s-l+flow-in-block(n) s-l+block-in-block(n,c) %YAML 1.2 --- !!seq [ !!str \"flow in block\", !!str \"Block scalar\\n\", !!map { ? !!str \"foo\" : !!str \"bar\", }, ] The block node’s properties may span across several lines. In this case, they must be indented by at least one more space than the block collection , regardless of the indentation of the block collection entries. [198] s-l+block-in-block(n,c) ::= s-l+block-scalar(n,c) | s-l+block-collection(n,c) [199] s-l+block-scalar(n,c) ::= s-separate(n+1,c) ( c-ns-properties(n+1,c) s-separate(n+1,c) )? ( c-l+literal(n) | c-l+folded(n) ) Example 8.21. Block Scalar Nodes literal: |2 ··value folded: ···!foo ··>1 ·value Legend: c-l+literal(n) c-l+folded(n) %YAML 1.2 --- !!map { ? !!str \"literal\" : !!str \"value\", ? !!str \"folded\" : !<!foo> \"value\", } Since people perceive the “ -” indicator as indentation , nested block sequences may be indented by one less space to compensate, except, of course, if nested inside another block sequence ( block-out context vs. block-in context ). [200] s-l+block-collection(n,c) ::= ( s-separate(n+1,c) c-ns-properties(n+1,c) )? s-l-comments ( l+block-sequence( seq-spaces(n,c) ) | l+block-mapping(n) ) [201] seq-spaces(n,c) ::= c = block-out n-1 c = block-in n Example 8.22. Block Collection Nodes sequence: !!seq - entry - !!seq - nested mapping: !!map foo: bar Legend: l+block-sequence(n) l+block-mapping(n) s-l+block-collection(n,c) %YAML 1.2 --- !!map { ? !!str \"sequence\" : !!seq [ !!str \"entry\", !!seq [ !!str \"nested\" ], ], ? !!str \"mapping\" : !!map { ? !!str \"foo\" : !!str \"bar\", }, } Chapter 9. YAML Character Stream 9.1. Documents A YAML character stream may contain several documents. Each document is completely independent from the rest. 9.1.1. Document Prefix A document may be preceded by a prefix specifying the character encoding , and optional comment lines. Note that all documents in a stream must use the same character encoding . However it is valid to re-specify the encoding using a byte order mark for each document in the stream. This makes it easier to concatenate streams. The existence of the optional prefix does not necessarily indicate the existence of an actual document . [202] l-document-prefix ::= c-byte-order-mark ? l-comment * Example 9.1. Document Prefix # Comment # lines Document Legend: l-document-prefix %YAML 1.2 --- !!str \"Document\" 9.1.2. Document Markers Using directives creates a potential ambiguity. It is valid to have a “ %” character at the start of a line (e.g. as the first character of the second line of a plain scalar ). How, then, to distinguish between an actual directive and a content line that happens to start with a “ %” character? The solution is the use of two special marker lines to control the processing of directives , one at the start of a document and one at the end. At the start of a document , lines beginning with a “ %” character are assumed to be directives . The (possibly empty) list of directives is terminated by a directives end marker line. Lines following this marker can safely use “ %” as the first character. At the end of a document , a document end marker line is used to signal the parser to begin scanning for directives again. The existence of this optional document suffix does not necessarily indicate the existence of an actual following document . Obviously, the actual content lines are therefore forbidden to begin with either of these markers. [203] c-directives-end ::= “ -” “ -” “ -” [204] c-document-end ::= “ .” “ .” “ .” [205] l-document-suffix ::= c-document-end s-l-comments [206] c-forbidden ::= /* Start of line */ ( c-directives-end | c-document-end ) ( b-char | s-white | /* End of file */ ) Example 9.2. Document Markers %YAML 1.2 --- Document ... # Suffix %YAML 1.2 --- !!str \"Document\" Legend: c-directives-end c-document-end l-document-suffix 9.1.3. Bare Documents A bare document does not begin with any directives or marker lines. Such documents are very “ clean” as they contain nothing other than the content . In this case, the first non-comment line may not start with a “ %” first character. Document nodes are indented as if they have a parent indented at -1 spaces . Since a node must be more indented than its parent node , this allows the document’s node to be indented at zero or more spaces . [207] l-bare-document ::= s-l+block-node(-1,block-in) /* Excluding c-forbidden content */ Example 9.3. Bare Documents Bare document ... # No document ... | %!PS-Adobe-2.0 # Not the first line %YAML 1.2 --- !!str \"Bare document\" %YAML 1.2 --- !!str \"%!PS-Adobe-2.0\\n\" Legend: l-bare-document 9.1.4. Explicit Documents An explicit document begins with an explicit directives end marker line but no directives . Since the existence of the document is indicated by this marker , the document itself may be completely empty . [208] l-explicit-document ::= c-directives-end ( l-bare-document | ( e-node s-l-comments ) ) Example 9.4. Explicit Documents --- { matches % : 20 } ... --- # Empty ... Legend: l-explicit-document %YAML 1.2 --- !!map { !!str \"matches %\": !!int \"20\" } ... %YAML 1.2 --- !!null \"\" 9.1.5. Directives Documents A directives document begins with some directives followed by an explicit directives end marker line. [209] l-directive-document ::= l-directive + l-explicit-document Example 9.5. Directives Documents %YAML 1.2 --- | %!PS-Adobe-2.0 ... %YAML1.2 --- # Empty ... Legend: l-explicit-document %YAML 1.2 --- !!str \"%!PS-Adobe-2.0\\n\" ... %YAML 1.2 --- !!null \"\" 9.2. Streams A YAML stream consists of zero or more documents . Subsequent documents require some sort of separation marker line. If a document is not terminated by a document end marker line, then the following document must begin with a directives end marker line. The stream format is intentionally “ sloppy” to better support common use cases, such as stream concatenation. [210] l-any-document ::= l-directive-document | l-explicit-document | l-bare-document [211] l-yaml-stream ::= l-document-prefix * l-any-document ? ( l-document-suffix + l-document-prefix * l-any-document ? | l-document-prefix * l-explicit-document ? )* Example 9.6. Stream Document --- # Empty ... %YAML 1.2 --- matches %: 20 Legend: l-any-document l-document-suffix l-explicit-document %YAML 1.2 --- !!str \"Document\" ... %YAML 1.2 --- !!null \"\" ... %YAML 1.2 --- !!map { !!str \"matches %\": !!int \"20\" } A sequence of bytes is a well-formed stream if, taken as a whole, it complies with the above l-yaml-stream production. Some common use case that can take advantage of the YAML stream structure are: Appending to Streams Allowing multiple documents in a single stream makes YAML suitable for log files and similar applications . Note that each document is independent of the rest, allowing for heterogeneous log file entries. Concatenating Streams Concatenating two YAML streams requires both to use the same character encoding . In addition, it is necessary to separate the last document of the first stream and the first document of the second stream. This is easily ensured by inserting a document end marker between the two streams. Note that this is safe regardless of the content of either stream. In particular, either or both may be empty, and the first stream may or may not already contain such a marker. Communication Streams The document end marker allows signaling the end of a document without closing the stream or starting the next document . This allows the receiver to complete processing a document without having to wait for the next one to arrive. The sender may also transmit \"keep-alive\" messages in the form of comment lines or repeated document end markers without signalling the start of the next document . Chapter 10. Recommended Schemas A YAML schema is a combination of a set of tags and a mechanism for resolving non-specific tags . 10.1. Failsafe Schema The failsafe schema is guaranteed to work with any YAML document . It is therefore the recommended schema for generic YAML tools. A YAML processor should therefore support this schema , at least as an option. 10.1.1. Tags 10.1.1.1. Generic Mapping URI: tag:yaml.org,2002:map Kind: Mapping . Definition: Represents an associative container, where each key is unique in the association and mapped to exactly one value . YAML places no restrictions on the type of keys ; in particular, they are not restricted to being scalars . Example bindings to native types include Perl’s hash, Python’s dictionary, and Java’s Hashtable. Example 10.1. !!map Examples Block style: !!map Clark : Evans Ingy : döt Net Oren : Ben-Kiki Flow style: !!map { Clark: Evans, Ingy: döt Net, Oren: Ben-Kiki } 10.1.1.2. Generic Sequence URI: tag:yaml.org,2002:seq Kind: Sequence . Definition: Represents a collection indexed by sequential integers starting with zero. Example bindings to native types include Perl’s array, Python’s list or tuple, and Java’s array or Vector. Example 10.2. !!seq Examples Block style: !!seq - Clark Evans - Ingy döt Net - Oren Ben-Kiki Flow style: !!seq [ Clark Evans, Ingy döt Net, Oren Ben-Kiki ] 10.1.1.3. Generic String URI: tag:yaml.org,2002:str Kind: Scalar . Definition: Represents a Unicode string, a sequence of zero or more Unicode characters. This type is usually bound to the native language’s string type, or, for languages lacking one (such as C), to a character array. Canonical Form: The obvious. Example 10.3. !!str Examples Block style: !!str |- String: just a theory. Flow style: !!str \"String: just a theory.\" 10.1.2. Tag Resolution All nodes with the “ !” non-specific tag are resolved , by the standard convention , to “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map”, or “ tag:yaml.org,2002:str”, according to their kind . All nodes with the “ ?” non-specific tag are left unresolved . This constrains the application to deal with a partial representation . 10.2. JSON Schema The JSON schema is the lowest common denominator of most modern computer languages, and allows parsing JSON files. A YAML processor should therefore support this schema , at least as an option. It is also strongly recommended that other schemas should be based on it. 10.2.1. Tags The JSON schema uses the following tags in addition to those defined by the failsafe schema: 10.2.1.1. Null URI: tag:yaml.org,2002:null Kind: Scalar . Definition: Represents the lack of a value. This is typically bound to a native null-like value (e.g., undef in Perl, None in Python). Note that a null is different from an empty string. Also, a mapping entry with some key and a null value is valid, and different from not having that key in the mapping . Canonical Form: null. Example 10.4. !!null Examples !!null null: value for null key key with null value: !!null null 10.2.1.2. Boolean URI: tag:yaml.org,2002:bool Kind: Scalar . Definition: Represents a true/false value. In languages without a native Boolean type (such as C), is usually bound to a native integer type, using one for true and zero for false. Canonical Form: Either true or false. Example 10.5. !!bool Examples YAML is a superset of JSON: !!bool true Pluto is a planet: !!bool false 10.2.1.3. Integer URI: tag:yaml.org,2002:int Kind: Scalar . Definition: Represents arbitrary sized finite mathematical integers. Scalars of this type should be bound to a native integer data type, if possible. Some languages (such as Perl) provide only a “ number” type that allows for both integer and floating-point values. A YAML processor may use such a type for integers, as long as they round-trip properly. In some languages (such as C), an integer may overflow the native type’s storage capability. A YAML processor may reject such a value as an error, truncate it with a warning, or find some other manner to round-trip it. In general, integers representable using 32 binary digits should safely round-trip through most systems. Canonical Form: Decimal integer notation, with a leading “ -” character for negative values, matching the regular expression 0 | -? [1-9] [0-9]* Example 10.6. !!int Examples negative: !!int -12 zero: !!int 0 positive: !!int 34 10.2.1.4. Floating Point URI: tag:yaml.org,2002:float Kind: Scalar . Definition: Represents an approximation to real numbers, including three special values (positive and negative infinity, and “ not a number”). Some languages (such as Perl) provide only a “ number” type that allows for both integer and floating-point values. A YAML processor may use such a type for floating-point numbers, as long as they round-trip properly. Not all floating-point values can be stored exactly in any given native type. Hence a float value may change by “ a small amount” when round-tripped. The supported range and accuracy depends on the implementation, though 32 bit IEEE floats should be safe. Since YAML does not specify a particular accuracy, using floating-point mapping keys requires great care and is not recommended. Canonical Form: Either 0, .inf, -.inf, .nan, or scientific notation matching the regular expression -? [1-9] ( \\. [0-9]* [1-9] )? ( e [-+] [1-9] [0-9]* )?. Example 10.7. !!float Examples negative: !!float -1 zero: !!float 0 positive: !!float 2.3e4 infinity: !!float .inf not a number: !!float .nan 10.2.2. Tag Resolution The JSON schema tag resolution is an extension of the failsafe schema tag resolution . All nodes with the “ !” non-specific tag are resolved , by the standard convention , to “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map”, or “ tag:yaml.org,2002:str”, according to their kind . Collections with the “ ?” non-specific tag (that is, untagged collections ) are resolved to “ tag:yaml.org,2002:seq” or “ tag:yaml.org,2002:map” according to their kind . Scalars with the “ ?” non-specific tag (that is, plain scalars ) are matched with a list of regular expressions (first match wins, e.g. 0 is resolved as !!int). In principle, JSON files should not contain any scalars that do not match at least one of these. Hence the YAML processor should consider them to be an error. Regular expression Resolved to tag null tag:yaml.org,2002:null true | false tag:yaml.org,2002:bool -? ( 0 | [1-9] [0-9]* ) tag:yaml.org,2002:int -? ( 0 | [1-9] [0-9]* ) ( \\. [0-9]* )? ( [eE] [-+]? [0-9]+ )? tag:yaml.org,2002:float * Error Example 10.8. JSON Tag Resolution A null: null Booleans: [ true, false ] Integers: [ 0, -0, 3, -19 ] Floats: [ 0., -0.0, 12e03, -2E+05 ] Invalid: [ True, Null, 0o7, 0x3A, +12.3 ] %YAML 1.2 --- !!map { !!str \"A null\" : !!null \"null\", !!str \"Booleans: !!seq [ !!bool \"true\", !!bool \"false\" ], !!str \"Integers\": !!seq [ !!int \"0\", !!int \"-0\", !!int \"3\", !!int \"-19\" ], !!str \"Floats\": !!seq [ !!float \"0.\", !!float \"-0.0\", !!float \"12e03\", !!float \"-2E+05\" ], !!str \"Invalid\": !!seq [ # Rejected by the schema True, Null, 0o7, 0x3A, +12.3, ], } ... 10.3. Core Schema The Core schema is an extension of the JSON schema , allowing for more human-readable presentation of the same types. This is the recommended default schema that YAML processor should use unless instructed otherwise. It is also strongly recommended that other schemas should be based on it. 10.3.1. Tags The core schema uses the same tags as the JSON schema . 10.3.2. Tag Resolution The core schema tag resolution is an extension of the JSON schema tag resolution . All nodes with the “ !” non-specific tag are resolved , by the standard convention , to “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map”, or “ tag:yaml.org,2002:str”, according to their kind . Collections with the “ ?” non-specific tag (that is, untagged collections ) are resolved to “ tag:yaml.org,2002:seq” or “ tag:yaml.org,2002:map” according to their kind . Scalars with the “ ?” non-specific tag (that is, plain scalars ) are matched with an extended list of regular expressions. However, in this case, if none of the regular expressions matches, the scalar is resolved to tag:yaml.org,2002:str (that is, considered to be a string). Regular expression Resolved to tag null | Null | NULL | ~ tag:yaml.org,2002:null /* Empty */ tag:yaml.org,2002:null true | True | TRUE | false | False | FALSE tag:yaml.org,2002:bool [-+]? [0-9]+ tag:yaml.org,2002:int (Base 10) 0o [0-7]+ tag:yaml.org,2002:int (Base 8) 0x [0-9a-fA-F]+ tag:yaml.org,2002:int (Base 16) [-+]? ( \\. [0-9]+ | [0-9]+ ( \\. [0-9]* )? ) ( [eE] [-+]? [0-9]+ )? tag:yaml.org,2002:float (Number) [-+]? ( \\.inf | \\.Inf | \\.INF ) tag:yaml.org,2002:float (Infinity) \\.nan | \\.NaN | \\.NAN tag:yaml.org,2002:float (Not a number) * tag:yaml.org,2002:str (Default) Example 10.9. Core Tag Resolution A null: null Also a null: # Empty Not a null: \"\" Booleans: [ true, True, false, FALSE ] Integers: [ 0, 0o7, 0x3A, -19 ] Floats: [ 0., -0.0, .5, +12e03, -2E+05 ] Also floats: [ .inf, -.Inf, +.INF, .NAN ] %YAML 1.2 --- !!map { !!str \"A null\" : !!null \"null\", !!str \"Also a null\" : !!null \"\", !!str \"Not a null\" : !!str \"\", !!str \"Booleans: !!seq [ !!bool \"true\", !!bool \"True\", !!bool \"false\", !!bool \"FALSE\", ], !!str \"Integers\": !!seq [ !!int \"0\", !!int \"0o7\", !!int \"0x3A\", !!int \"-19\", ], !!str \"Floats\": !!seq [ !!float \"0.\", !!float \"-0.0\", !!float \".5\", !!float \"+12e03\", !!float \"-2E+05\" ], !!str \"Also floats\": !!seq [ !!float \".inf\", !!float \"-.Inf\", !!float \"+.INF\", !!float \".NAN\", ], } ... 10.4. Other Schemas None of the above recommended schemas preclude the use of arbitrary explicit tags . Hence YAML processors for a particular programming language typically provide some form of local tags that map directly to the language’s native data structures (e.g., !ruby/object:Set). While such local tags are useful for ad-hoc applications , they do not suffice for stable, interoperable cross- application or cross-platform data exchange. Interoperable schemas make use of global tags (URIs) that represent the same data across different programming languages. In addition, an interoperable schema may provide additional tag resolution rules. Such rules may provide additional regular expressions, as well as consider the path to the node . This allows interoperable schemas to use untagged nodes . It is strongly recommended that such schemas be based on the core schema defined above. In addition, it is strongly recommended that such schemas make as much use as possible of the the YAML tag repository at http://yaml.org/type/ . This repository provides recommended global tags for increasing the portability of YAML documents between different applications . The tag repository is intentionally left out of the scope of this specification. This allows it to evolve to better support YAML applications . Hence, developers are encouraged to submit new “ universal” types to the repository. The yaml-core mailing list at http://lists.sourceforge.net/lists/listinfo/yaml-core is the preferred method for such submissions, as well as raising any questions regarding this draft. Index Indicators ! tag indicator, Tags , Indicator Characters , Node Tags ! local tag, Tags , Tag Handles , Tag Prefixes , Node Tags ! non-specific tag, Resolved Tags , Node Tags , Tag Resolution , Tag Resolution , Tag Resolution ! primary tag handle, Tag Handles !! secondary tag handle, Tag Handles !…! named handle, Tag Handles , Node Tags \" double-quoted style, Indicator Characters , Double-Quoted Style # comment, Collections , Indicator Characters , Comments , Plain Style , Block Indentation Indicator % directive, Indicator Characters , Directives , Document Markers , Bare Documents % escaping in URI, Tags , Miscellaneous Characters , Node Tags & anchor, Structures , Indicator Characters , Node Anchors ' reserved indicator, Indicator Characters ' single-quoted style, Indicator Characters , Single-Quoted Style * alias, Structures , Indicator Characters , Alias Nodes + keep chomping, Block Chomping Indicator , end flow entry, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Collection Styles , Flow Sequences , Flow Mappings - block sequence entry, Introduction , Collections , Structures , Production Parameters , Indicator Characters , Indentation Spaces , Plain Style , Block Collection Styles , Block Sequences , Block Nodes - strip chomping, Block Chomping Indicator : mapping value, Introduction , Collections , Structures , Indicator Characters , Indentation Spaces , Plain Style , Flow Mappings , Block Mappings <…> verbatim tag, Node Tags > folded style, Scalars , Indicator Characters , Folded Style ? mapping key, Structures , Indicator Characters , Indentation Spaces , Plain Style , Flow Mappings , Block Mappings ? non-specific tag, Resolved Tags , Node Tags , Tag Resolution , Tag Resolution , Tag Resolution @ reserved indicator, Indicator Characters [ start flow sequence, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Sequences \\ escaping in double-quoted scalars, Escaped Characters , Double-Quoted Style ] end flow sequence, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Sequences { start flow mapping, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Mappings | literal style, Scalars , Indicator Characters , Literal Style } end flow mapping, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Mappings prefix, Document Prefix A alias, Introduction , Prior Art , Structures , Dump , Serialization Tree , Anchors and Aliases , Loading Failure Points , Well-Formed Streams and Identified Aliases , Resolved Tags , Indicator Characters , Node Anchors , Flow Styles , Alias Nodes , Flow Nodes identified, Structures , Anchors and Aliases , Well-Formed Streams and Identified Aliases unidentified, Loading Failure Points , Well-Formed Streams and Identified Aliases anchor, Structures , Dump , Serialization Tree , Anchors and Aliases , Well-Formed Streams and Identified Aliases , Resolved Tags , Indicator Characters , Node Properties , Flow Styles , Alias Nodes , Flow Nodes application, Introduction , Prior Art , Tags , Processing YAML Information , Dump , Information Models , Tags , Serialization Tree , Keys Order , Resolved Tags , Available Tags , Tag Prefixes , Node Tags , Streams , Tag Resolution , Other Schemas B block scalar header, Comments , Block Scalar Headers , Block Chomping Indicator byte order mark, Character Encodings , Document Prefix C character encoding, Character Encodings , Document Prefix , Streams in URI, Miscellaneous Characters chomping, Production Parameters , Line Folding , Block Chomping Indicator , Literal Style , Folded Style clip, Production Parameters , Block Chomping Indicator keep, Production Parameters , Block Chomping Indicator strip, Production Parameters , Block Chomping Indicator collection, Prior Art , Representation Graph , Nodes , Node Comparison , Anchors and Aliases , Node Styles , Comments , Resolved Tags , Recognized and Valid Tags , Tag Resolution , Tag Resolution comment, Collections , Processes , Dump , Load , Presentation Stream , Comments , Resolved Tags , Indicator Characters , Comments , Separation Lines , Plain Style , Block Scalar Headers , Block Chomping Indicator , Document Prefix , Streams compose, Processes , Load , Keys Order , Anchors and Aliases , Resolved Tags , Recognized and Valid Tags , Available Tags , Node Anchors construct, Processes , Load , Serialization Tree , Loading Failure Points , Recognized and Valid Tags , Available Tags , Flow Styles , Generic Mapping , Generic Sequence , Generic String , Null , Boolean , Integer content, Structures , Dump , Nodes , Tags , Node Comparison , Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Character Encodings , Line Break Characters , Escaped Characters , Indentation Spaces , Separation Spaces , Line Prefixes , Empty Lines , Line Folding , Comments , Directives , Tag Handles , Node Properties , Node Tags , Node Anchors , Alias Nodes , Empty Nodes , Flow Scalar Styles , Double-Quoted Style , Single-Quoted Style , Plain Style , Block Scalar Headers , Block Indentation Indicator , Block Chomping Indicator , Literal Style , Document Markers , Bare Documents valid, Recognized and Valid Tags context, Production Parameters , Plain Style block-in, Production Parameters , Block Nodes block-key, Production Parameters , Flow Collection Styles block-out, Production Parameters , Block Nodes flow-in, Production Parameters , Flow Collection Styles flow-key, Production Parameters , Flow Collection Styles flow-out, Production Parameters , Flow Collection Styles D directive, Structures , Dump , Load , Presentation Stream , Directives , Indicator Characters , Directives , Document Markers , Bare Documents , Explicit Documents , Directives Documents reserved, Directives , Directives TAG, Tags , Directives , Indicator Characters , Directives , “TAG” Directives , Node Tags YAML, Directives , Directives , “YAML” Directives document, Prior Art , Structures , Presentation Stream , Directives , Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Character Encodings , Line Break Characters , “YAML” Directives , Tag Prefixes , Alias Nodes , Documents , Document Prefix , Document Markers , Explicit Documents , Streams , Failsafe Schema , Other Schemas bare, Bare Documents directives, Directives Documents explicit, Explicit Documents suffix, Document Markers dump, Processes , Dump E empty line, Prior Art , Scalars , Empty Lines , Line Folding , Block Indentation Indicator , Block Chomping Indicator , Literal Style , Folded Style equality, Relation to JSON , Dump , Representation Graph , Nodes , Tags , Node Comparison , Scalar Formats , Loading Failure Points , Recognized and Valid Tags escaping in double-quoted scalars, Prior Art , Scalars , Character Set , Character Encodings , Miscellaneous Characters , Escaped Characters , Double-Quoted Style in single-quoted scalars, Single-Quoted Style in URIs, Miscellaneous Characters non-content line break, Double-Quoted Style I identity, Node Comparison indicator, Introduction , Prior Art , Collections , Node Styles , Production Parameters , Indicator Characters , Line Folding , Plain Style , Flow Mappings , Flow Nodes , Block Styles , Block Scalar Headers , Block Collection Styles indentation, Block Indentation Indicator reserved, Indicator Characters information model, Information Models invalid content, Loading Failure Points , Recognized and Valid Tags J JSON compatibility, Character Set , Character Encodings , Line Break Characters , Escaped Characters , Comments , “YAML” Directives , Flow Mappings , Block Mappings JSON-like, Flow Mappings , Flow Nodes K key, Relation to JSON , Structures , Dump , Information Models , Representation Graph , Nodes , Node Comparison , Serialization Tree , Keys Order , Resolved Tags , Indicator Characters , Flow Mappings , Block Mappings , Generic Mapping , Null , Floating Point implicit, Separation Lines , Double-Quoted Style , Single-Quoted Style , Plain Style , Flow Collection Styles , Flow Mappings , Block Mappings , Block Nodes order, Processes , Dump , Load , Information Models , Serialization Tree , Keys Order key: value pair, Introduction , Collections , Structures , Nodes , Keys Order , Node Styles , Plain Style , Flow Mappings , Block Collection Styles , Block Mappings kind, Dump , Representation Graph , Nodes , Tags , Node Comparison , Node Styles , Resolved Tags , Node Tags , Tag Resolution , Tag Resolution , Tag Resolution L line break, Prior Art , Scalars , Production Parameters , Production Naming Conventions , Line Break Characters , White Space Characters , Empty Lines , Line Folding , Comments , Double-Quoted Style , Block Scalar Headers , Block Chomping Indicator , Literal Style , Folded Style non-ASCII, Line Break Characters , “YAML” Directives normalization, Line Break Characters , Literal Style line folding, Prior Art , Scalars , Line Folding , Flow Styles , Double-Quoted Style , Single-Quoted Style , Plain Style , Block Chomping Indicator , Folded Style block, Line Folding , Folded Style flow, Line Folding , Double-Quoted Style line prefix, Line Prefixes , Empty Lines load, Processes , Load , Loading Failure Points failure point, Load , Loading Failure Points M mapping, Introduction , Prior Art , Relation to JSON , Collections , Structures , Dump , Representation Graph , Nodes , Tags , Node Comparison , Keys Order , Resolved Tags , Plain Style , Flow Sequences , Flow Mappings , Generic Mapping , Null marker, Presentation Stream , Document Markers , Bare Documents , Explicit Documents , Streams directives end, Structures , Document Markers , Explicit Documents , Directives Documents , Streams document end, Structures , Document Markers , Streams more-indented, Scalars , Line Folding , Folded Style N native data structure, Introduction , Goals , Prior Art , Relation to JSON , Processing YAML Information , Processes , Dump , Load , Representation Graph , Nodes , Tags , Node Comparison , Serialization Tree , Loading Failure Points , Recognized and Valid Tags , Available Tags , Node Tags , Flow Styles , Generic Mapping , Generic Sequence , Generic String , Null , Boolean , Integer , Floating Point , Other Schemas need not, Terminology node, Structures , Dump , Representation Graph , Nodes , Tags , Node Comparison , Serialization Tree , Keys Order , Anchors and Aliases , Presentation Stream , Node Styles , Comments , Loading Failure Points , Well-Formed Streams and Identified Aliases , Resolved Tags , Recognized and Valid Tags , Syntax Conventions , Indentation Spaces , Node Properties , Node Tags , Node Anchors , Alias Nodes , Empty Nodes , Flow Mappings , Flow Nodes , Block Indentation Indicator , Block Sequences , Bare Documents , Tag Resolution , Tag Resolution , Tag Resolution , Other Schemas completely empty, Empty Nodes , Flow Collection Styles , Flow Mappings , Block Sequences , Explicit Documents property, Node Properties , Alias Nodes , Empty Nodes , Flow Mappings , Flow Nodes , Block Sequences , Block Mappings , Block Nodes root, Representation Graph , Resolved Tags P parse, Load , Presentation Stream , Resolved Tags , Production Parameters , Line Break Characters , Escaped Characters , Tag Handles , Node Tags , Flow Mappings , Block Mappings , Block Nodes , Document Markers , JSON Schema present, Processing YAML Information , Dump , Load , Nodes , Node Comparison , Presentation Stream , Scalar Formats , Character Set , Miscellaneous Characters , Node Tags , Alias Nodes , Block Mappings , Core Schema presentation, Processing YAML Information , Information Models , Presentation Stream , Production Parameters detail, Dump , Load , Information Models , Presentation Stream , Node Styles , Scalar Formats , Comments , Directives , Resolved Tags , Character Encodings , Line Break Characters , Escaped Characters , Indentation Spaces , Separation Spaces , Line Prefixes , Line Folding , Comments , Directives , Tag Handles , Node Tags , Flow Scalar Styles , Block Chomping Indicator printable character, Introduction , Prior Art , Character Set , White Space Characters , Escaped Characters , Single-Quoted Style , Literal Style processor, Terminology , Processing YAML Information , Dump , Node Comparison , Presentation Stream , Directives , Well-Formed Streams and Identified Aliases , Resolved Tags , Recognized and Valid Tags , Available Tags , Character Set , Character Encodings , Line Break Characters , Miscellaneous Characters , Comments , Directives , “YAML” Directives , Tag Handles , Node Tags , Node Anchors , Flow Mappings , Block Indentation Indicator , Failsafe Schema , JSON Schema , Integer , Floating Point , Tag Resolution , Core Schema , Other Schemas R represent, Introduction , Prior Art , Dump , Tags , Node Comparison , Keys Order , Generic Mapping , Generic Sequence , Generic String , Null , Boolean , Integer , Floating Point , Other Schemas representation, Processing YAML Information , Processes , Dump , Load , Information Models , Representation Graph , Nodes , Node Comparison , Serialization Tree , Keys Order , Anchors and Aliases , Presentation Stream , Node Styles , Scalar Formats , Comments , Directives , Available Tags , Node Anchors complete, Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Available Tags partial, Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Tag Resolution required, Terminology S scalar, Introduction , Prior Art , Scalars , Dump , Representation Graph , Nodes , Tags , Node Comparison , Scalar Formats , Comments , Recognized and Valid Tags , Line Break Characters , Separation Spaces , Line Prefixes , Comments , Empty Nodes , Block Chomping Indicator , Generic Mapping , Generic String , Null , Boolean , Integer , Floating Point , Tag Resolution , Tag Resolution canonical form, Prior Art , Tags , Node Comparison , Scalar Formats , Loading Failure Points content format, Dump , Load , Tags , Node Comparison , Presentation Stream , Scalar Formats , Loading Failure Points schema, Recommended Schemas , Failsafe Schema , JSON Schema , Tags , Core Schema , Tags , Other Schemas core, Core Schema , Tag Resolution , Other Schemas failsafe, Tags , Failsafe Schema , Tags , Tag Resolution JSON, Tags , JSON Schema , Tag Resolution , Core Schema , Tags , Tag Resolution sequence, Introduction , Prior Art , Dump , Representation Graph , Nodes , Tags , Node Comparison , Keys Order , Resolved Tags , Flow Mappings , Generic Sequence serialization, Processing YAML Information , Processes , Dump , Load , Information Models , Serialization Tree , Anchors and Aliases , Presentation Stream , Node Styles , Scalar Formats , Comments , Directives , Node Anchors detail, Dump , Load , Information Models , Keys Order , Anchors and Aliases , Node Anchors serialize, Introduction , Prior Art , Relation to JSON , Dump , Load , Keys Order , Anchors and Aliases , Alias Nodes shall, Terminology space, Prior Art , Scalars , White Space Characters , Indentation Spaces , Line Folding , Single-Quoted Style , Plain Style , Block Indentation Indicator , Folded Style , Block Sequences , Block Nodes , Bare Documents indentation, Introduction , Prior Art , Collections , Dump , Load , Information Models , Node Styles , Resolved Tags , Production Parameters , Production Naming Conventions , Indentation Spaces , Separation Spaces , Line Prefixes , Line Folding , Comments , Separation Lines , Directives , Block Styles , Block Indentation Indicator , Block Chomping Indicator , Literal Style , Block Sequences , Block Nodes , Bare Documents separation, Separation Spaces , Comments , Flow Mappings , Block Sequences white, Production Naming Conventions , White Space Characters , Separation Spaces , Line Prefixes , Line Folding , Comments , Double-Quoted Style , Single-Quoted Style , Plain Style , Flow Mappings , Literal Style , Folded Style , Block Sequences stream, Prior Art , Processing YAML Information , Processes , Dump , Load , Presentation Stream , Loading Failure Points , Well-Formed Streams and Identified Aliases , Resolved Tags , Syntax Conventions , Character Set , Character Encodings , Miscellaneous Characters , Comments , Tag Prefixes , Empty Nodes , Documents , Streams ill-formed, Load , Loading Failure Points , Well-Formed Streams and Identified Aliases well-formed, Well-Formed Streams and Identified Aliases , Streams style, Dump , Load , Information Models , Presentation Stream , Node Styles , Scalar Formats , Resolved Tags , Node Tags , Double-Quoted Style , Plain Style block, Prior Art , Scalars , Node Styles , Production Parameters , Indentation Spaces , Block Styles , Block Sequences collection, Collections , Structures , Indentation Spaces , Flow Collection Styles , Block Collection Styles , Block Sequences , Block Nodes folded, Scalars , Node Styles , Indicator Characters , Line Folding , Block Scalar Styles , Literal Style , Folded Style literal, Prior Art , Scalars , Node Styles , Indicator Characters , Block Scalar Styles , Literal Style , Folded Style mapping, Node Styles , Production Parameters , Block Mappings , Block Nodes scalar, Node Styles , Block Scalar Styles , Block Scalar Headers , Block Indentation Indicator , Block Chomping Indicator sequence, Collections , Node Styles , Production Parameters , Indicator Characters , Block Sequences , Block Mappings , Block Nodes compact block collection, Node Styles , Block Sequences , Block Mappings flow, Prior Art , Collections , Scalars , Node Styles , Production Parameters , Line Folding , Flow Styles , Flow Sequences , Flow Nodes , Block Nodes collection, Syntax Conventions , Production Parameters , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Collection Styles double-quoted, Prior Art , Scalars , Node Styles , Syntax Conventions , Character Set , Character Encodings , Indicator Characters , Escaped Characters , Flow Scalar Styles , Double-Quoted Style , Flow Nodes mapping, Collections , Node Styles , Production Parameters , Indicator Characters , Flow Mappings , Block Mappings plain, Scalars , Node Styles , Resolved Tags , Production Parameters , Indicator Characters , Node Tags , Empty Nodes , Flow Scalar Styles , Plain Style , Flow Mappings , Flow Nodes , Block Collection Styles , Block Sequences , Block Mappings , Block Nodes , Document Markers , Tag Resolution , Tag Resolution scalar, Scalars , Node Styles , Line Prefixes , Line Folding , Flow Scalar Styles sequence, Collections , Node Styles , Indicator Characters , Flow Sequences , Flow Mappings single-quoted, Node Styles , Production Parameters , Indicator Characters , Flow Scalar Styles , Single-Quoted Style scalar, Node Styles , Escaped Characters , Empty Lines , Flow Scalar Styles , Literal Style single key:value pair mapping, Keys Order , Node Styles , Flow Sequences , Flow Mappings , Block Mappings T tab, Prior Art , Character Set , White Space Characters , Indentation Spaces , Separation Spaces , Line Prefixes , Block Indentation Indicator tag, Prior Art , Tags , Dump , Representation Graph , Nodes , Tags , Node Comparison , Scalar Formats , Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Available Tags , Syntax Conventions , Production Parameters , Indicator Characters , Miscellaneous Characters , “TAG” Directives , Tag Prefixes , Node Properties , Node Tags , Flow Styles , Recommended Schemas , Tags , Tags , Other Schemas available, Available Tags global, Prior Art , Tags , Dump , Tags , Resolved Tags , Tag Handles , Tag Prefixes , Node Tags , Other Schemas handle, Tags , Processes , Dump , Indicator Characters , “TAG” Directives , Tag Handles , Tag Prefixes , Node Tags named, Miscellaneous Characters , Tag Handles , Node Tags primary, Tag Handles secondary, Tag Handles local, Prior Art , Tags , Dump , Tags , Resolved Tags , Indicator Characters , Tag Handles , Tag Prefixes , Node Tags , Other Schemas non-specific, Tags , Dump , Loading Failure Points , Resolved Tags , Indicator Characters , Node Tags , Recommended Schemas , Tag Resolution , Tag Resolution , Other Schemas prefix, “TAG” Directives , Tag Prefixes , Node Tags property, Resolved Tags , Indicator Characters , Node Tags recognized, Recognized and Valid Tags repository, Tags , Tag Handles , Other Schemas bool, Boolean float, Tags , Floating Point int, Tags , Integer map, Tags , Generic Mapping null, Tags , Empty Nodes , Null seq, Tags , Generic Sequence str, Tags , Generic String resolution, Tags , Loading Failure Points , Resolved Tags , Node Tags , Flow Scalar Styles , Recommended Schemas , Tag Resolution , Tag Resolution , Tag Resolution , Other Schemas convention, Resolved Tags , Node Tags , Tag Resolution , Tag Resolution , Tag Resolution shorthand, Tags , Miscellaneous Characters , “TAG” Directives , Tag Handles , Tag Prefixes , Node Tags specific, Resolved Tags , Node Tags unavailable, Load , Loading Failure Points , Available Tags unrecognized, Loading Failure Points , Recognized and Valid Tags unresolved, Loading Failure Points , Resolved Tags verbatim, Node Tags trimming, Line Folding V value, Dump , Nodes , Node Comparison , Resolved Tags , Indicator Characters , Flow Mappings , Block Mappings , Generic Mapping , Null Y YAML 1.1 processing, Line Break Characters , “YAML” Directives ",
                "urlTerms": [
                    "spec",
                    "html"
                ],
                "titleTerms": [
                    "yaml",
                    "markup",
                    "language",
                    "yaml™",
                    "version"
                ]
            }
        },
        {
            "timestamp": 1608987372791,
            "collection": "visits",
            "objectPk": [
                1608987372775,
                "yaml.org/spec/1.2/spec.html"
            ],
            "operation": "create",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "time": 1608987372775
            }
        },
        {
            "timestamp": 1608987372816,
            "collection": "annotations",
            "objectPk": "https://yaml.org/spec/1.2/spec.html#key/order//#1608987367776",
            "operation": "create",
            "object": {
                "pageTitle": "YAML Ain’t Markup Language (YAML™) Version 1.2",
                "pageUrl": "yaml.org/spec/1.2/spec.html",
                "body": "AML represents type information of native data structures with a simple identifier, called a tag. Global tags are URIs and hence globally unique across all applications. The “tag:” URI scheme is recommended for all global YAML tags. In contrast, local tags are specific to a single application. Local tags start with “!”, are not URIs and are not expected to be globally unique. YAML provides a “TAG” directive to make tag notation less verbose; it also offers easy migration from local to global tags. To ensure this, local tags are restricted to the URI character set and use URI character escaping. ",
                "comment": "",
                "selector": {
                    "quote": "AML represents type information of native data structures with a simple identifier, called a tag. Global tags are URIs and hence globally unique across all applications. The “tag:” URI scheme is recommended for all global YAML tags. In contrast, local tags are specific to a single application. Local tags start with “!”, are not URIs and are not expected to be globally unique. YAML provides a “TAG” directive to make tag notation less verbose; it also offers easy migration from local to global tags. To ensure this, local tags are restricted to the URI character set and use URI character escaping. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[1]/div[5]/div[3]/div[3]/div[4]/p[1]",
                                "startOffset": 14,
                                "endContainer": "/div[1]/div[5]/div[3]/div[3]/div[4]/p[1]",
                                "endOffset": 782
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 57257,
                                "end": 58025
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "AML represents type\n            information of native data\n            structures with a simple identifier, called a tag. Global tags are URIs and hence\n            globally unique across all applications. The\n            “tag:” URI scheme is\n            recommended for all global YAML tags. In contrast, local tags are specific\n            to a single application.\n            Local tags start with “!”, are not URIs\n            and are not expected to be globally unique. YAML provides a\n            “TAG”\n            directive to make tag notation less verbose; it also\n            offers easy migration from local to global tags. To ensure this,\n            local tags are restricted to the URI character set and use URI\n            character escaping.\n          ",
                                "prefix": "   \n              \n            Y",
                                "suffix": "\n              \n            YAML"
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T12:56:07.776Z",
                "lastEdited": "2020-12-26T12:56:07.776Z",
                "url": "https://yaml.org/spec/1.2/spec.html#key/order//#1608987367776"
            }
        },
        {
            "timestamp": 1608987758537,
            "collection": "pages",
            "objectPk": "yaml.org/spec/1.2/spec.html",
            "operation": "update",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "fullUrl": "https://yaml.org/spec/1.2/spec.html#id2708649",
                "domain": "yaml.org",
                "hostname": "yaml.org",
                "fullTitle": "YAML Ain’t Markup Language (YAML™) Version 1.2",
                "text": " YAML Ain’t Markup Language ( YAML ) Version 1.2 3rd Edition, Patched at 2009-10-01 Oren Ben-Kiki < oren@ben-kiki.org > Clark Evans < cce@clarkevans.com > Ingy döt Net < ingy@ingy.net > Latest (patched) version: HTML: http://yaml.org/spec/1.2/spec.html PDF: http://yaml.org/spec/1.2/spec.pdf PS: http://yaml.org/spec/1.2/spec.ps Errata: http://yaml.org/spec/1.2/errata.html Previous (original) version: http://yaml.org/spec/1.2/2009-07-21/spec.html Copyright © 2001-2009 Oren Ben-Kiki, Clark Evans, Ingy döt Net This document may be freely copied, provided it is not modified. Status of this Document This document reflects the third version of YAML data serialization language. The content of the specification was arrived at by consensus of its authors and through user feedback on the yaml-core mailing list. We encourage implementers to please update their software with support for this version. The primary objective of this revision is to bring YAML into compliance with JSON as an official subset. YAML 1.2 is compatible with 1.1 for most practical applications - this is a minor revision. An expected source of incompatibility with prior versions of YAML, especially the syck implementation, is the change in implicit typing rules. We have removed unique implicit typing rules and have updated these rules to align them with JSON's productions. In this version of YAML, boolean values may be serialized as “ true” or “ false”; the empty scalar as “ null”. Unquoted numeric values are a superset of JSON's numeric production. Other changes in the specification were the removal of the Unicode line breaks and production bug fixes. We also define 3 built-in implicit typing rule sets: untyped, strict JSON, and a more flexible YAML rule set that extends JSON typing. The difference between late 1.0 drafts which syck 0.55 implements and the 1.1 revision of this specification is much more extensive. We fixed usability issues with the tagging syntax. In particular, the single exclamation was re-defined for private types and a simple prefixing mechanism was introduced. This revision also fixed many production edge cases and introduced a type repository. Therefore, there are several incompatibilities between syck and this revision as well. The list of known errors in this specification is available at http://yaml.org/spec/1.2/errata.html . Please report errors in this document to the yaml-core mailing list. This revision contains fixes for all errors known as of 2009-10-01. We wish to thank implementers who have tirelessly tracked earlier versions of this specification, and our fabulous user community whose feedback has both validated and clarified our direction. Abstract YAML (rhymes with “ camel”) is a human-friendly, cross language, Unicode based data serialization language designed around the common native data types of agile programming languages. It is broadly useful for programming needs ranging from configuration files to Internet messaging to object persistence to data auditing. Together with the Unicode standard for characters , this specification provides all the information necessary to understand YAML Version 1.2 and to create programs that process YAML information. Table of Contents 1. Introduction 1.1. Goals 1.2. Prior Art 1.3. Relation to JSON 1.4. Relation to XML 1.5. Terminology 2. Preview 2.1. Collections 2.2. Structures 2.3. Scalars 2.4. Tags 2.5. Full Length Example 3. Processing YAML Information 3.1. Processes 3.1.1. Dump 3.1.2. Load 3.2. Information Models 3.2.1. Representation Graph 3.2.1.1. Nodes 3.2.1.2. Tags 3.2.1.3. Node Comparison 3.2.2. Serialization Tree 3.2.2.1. Keys Order 3.2.2.2. Anchors and Aliases 3.2.3. Presentation Stream 3.2.3.1. Node Styles 3.2.3.2. Scalar Formats 3.2.3.3. Comments 3.2.3.4. Directives 3.3. Loading Failure Points 3.3.1. Well-Formed Streams and Identified Aliases 3.3.2. Resolved Tags 3.3.3. Recognized and Valid Tags 3.3.4. Available Tags 4. Syntax Conventions 4.1. Production Parameters 4.2. Production Naming Conventions 5. Characters 5.1. Character Set 5.2. Character Encodings 5.3. Indicator Characters 5.4. Line Break Characters 5.5. White Space Characters 5.6. Miscellaneous Characters 5.7. Escaped Characters 6. Basic Structures 6.1. Indentation Spaces 6.2. Separation Spaces 6.3. Line Prefixes 6.4. Empty Lines 6.5. Line Folding 6.6. Comments 6.7. Separation Lines 6.8. Directives 6.8.1. “ YAML” Directives 6.8.2. “ TAG” Directives 6.8.2.1. Tag Handles 6.8.2.2. Tag Prefixes 6.9. Node Properties 6.9.1. Node Tags 6.9.2. Node Anchors 7. Flow Styles 7.1. Alias Nodes 7.2. Empty Nodes 7.3. Flow Scalar Styles 7.3.1. Double-Quoted Style 7.3.2. Single-Quoted Style 7.3.3. Plain Style 7.4. Flow Collection Styles 7.4.1. Flow Sequences 7.4.2. Flow Mappings 7.5. Flow Nodes 8. Block Styles 8.1. Block Scalar Styles 8.1.1. Block Scalar Headers 8.1.1.1. Block Indentation Indicator 8.1.1.2. Block Chomping Indicator 8.1.2. Literal Style 8.1.3. Folded Style 8.2. Block Collection Styles 8.2.1. Block Sequences 8.2.2. Block Mappings 8.2.3. Block Nodes 9. YAML Character Stream 9.1. Documents 9.1.1. Document Prefix 9.1.2. Document Markers 9.1.3. Bare Documents 9.1.4. Explicit Documents 9.1.5. Directives Documents 9.2. Streams 10. Recommended Schemas 10.1. Failsafe Schema 10.1.1. Tags 10.1.1.1. Generic Mapping 10.1.1.2. Generic Sequence 10.1.1.3. Generic String 10.1.2. Tag Resolution 10.2. JSON Schema 10.2.1. Tags 10.2.1.1. Null 10.2.1.2. Boolean 10.2.1.3. Integer 10.2.1.4. Floating Point 10.2.2. Tag Resolution 10.3. Core Schema 10.3.1. Tags 10.3.2. Tag Resolution 10.4. Other Schemas Index Chapter 1. Introduction “ YAML Ain’t Markup Language” (abbreviated YAML) is a data serialization language designed to be human-friendly and work well with modern programming languages for common everyday tasks. This specification is both an introduction to the YAML language and the concepts supporting it, and also a complete specification of the information needed to develop applications for processing YAML. Open, interoperable and readily understandable tools have advanced computing immensely. YAML was designed from the start to be useful and friendly to people working with data. It uses Unicode printable characters, some of which provide structural information and the rest containing the data itself. YAML achieves a unique cleanness by minimizing the amount of structural characters and allowing the data to show itself in a natural and meaningful way. For example, indentation may be used for structure, colons separate key: value pairs , and dashes are used to create “ bullet” lists . There are myriad flavors of data structures , but they can all be adequately represented with three basic primitives: mappings (hashes/dictionaries), sequences (arrays/lists) and scalars (strings/numbers). YAML leverages these primitives, and adds a simple typing system and aliasing mechanism to form a complete language for serializing any native data structure . While most programming languages can use YAML for data serialization, YAML excels in working with those languages that are fundamentally built around the three basic primitives. These include the new wave of agile languages such as Perl, Python, PHP, Ruby, and Javascript. There are hundreds of different languages for programming, but only a handful of languages for storing and transferring data. Even though its potential is virtually boundless, YAML was specifically created to work well for common use cases such as: configuration files, log files, interprocess messaging, cross-language data sharing, object persistence, and debugging of complex data structures. When data is easy to view and understand, programming becomes a simpler task. 1.1. Goals The design goals for YAML are, in decreasing priority: YAML is easily readable by humans. YAML data is portable between programming languages. YAML matches the native data structures of agile languages. YAML has a consistent model to support generic tools. YAML supports one-pass processing. YAML is expressive and extensible. YAML is easy to implement and use. 1.2. Prior Art YAML’s initial direction was set by the data serialization and markup language discussions among SML-DEV members . Later on, it directly incorporated experience from Ingy döt Net’s Perl module Data::Denter . Since then, YAML has matured through ideas and support from its user community. YAML integrates and builds upon concepts described by C , Java , Perl , Python , Ruby , RFC0822 (MAIL), RFC1866 (HTML), RFC2045 (MIME), RFC2396 (URI), XML , SAX , SOAP , and JSON . The syntax of YAML was motivated by Internet Mail (RFC0822) and remains partially compatible with that standard. Further, borrowing from MIME (RFC2045), YAML’s top-level production is a stream of independent documents , ideal for message-based distributed processing systems. YAML’s indentation -based scoping is similar to Python’s (without the ambiguities caused by tabs ). Indented blocks facilitate easy inspection of the data’s structure. YAML’s literal style leverages this by enabling formatted text to be cleanly mixed within an indented structure without troublesome escaping . YAML also allows the use of traditional indicator -based scoping similar to JSON’s and Perl’s. Such flow content can be freely nested inside indented blocks . YAML’s double-quoted style uses familiar C-style escape sequences . This enables ASCII encoding of non- printable or 8-bit (ISO 8859-1) characters such as “ \\x3B” . Non- printable 16-bit Unicode and 32-bit (ISO/IEC 10646) characters are supported with escape sequences such as “ \\u003B” and “ \\U0000003B” . Motivated by HTML’s end-of-line normalization, YAML’s line folding employs an intuitive method of handling line breaks . A single line break is folded into a single space , while empty lines are interpreted as line break characters. This technique allows for paragraphs to be word-wrapped without affecting the canonical form of the scalar content . YAML’s core type system is based on the requirements of agile languages such as Perl, Python, and Ruby. YAML directly supports both collections ( mappings , sequences ) and scalars . Support for these common types enables programmers to use their language’s native data structures for YAML manipulation, instead of requiring a special document object model (DOM). Like XML’s SOAP, YAML supports serializing a graph of native data structures through an aliasing mechanism. Also like SOAP, YAML provides for application -defined types . This allows YAML to represent rich data structures required for modern distributed computing. YAML provides globally unique type names using a namespace mechanism inspired by Java’s DNS-based package naming convention and XML’s URI-based namespaces. In addition, YAML allows for private types specific to a single application . YAML was designed to support incremental interfaces that include both input (“ getNextEvent()”) and output (“ sendNextEvent()”) one-pass interfaces. Together, these enable YAML to support the processing of large documents (e.g. transaction logs) or continuous streams (e.g. feeds from a production machine). 1.3. Relation to JSON Both JSON and YAML aim to be human readable data interchange formats. However, JSON and YAML have different priorities. JSON’s foremost design goal is simplicity and universality. Thus, JSON is trivial to generate and parse, at the cost of reduced human readability. It also uses a lowest common denominator information model, ensuring any JSON data can be easily processed by every modern programming environment. In contrast, YAML’s foremost design goals are human readability and support for serializing arbitrary native data structures . Thus, YAML allows for extremely readable files, but is more complex to generate and parse. In addition, YAML ventures beyond the lowest common denominator data types, requiring more complex processing when crossing between different programming environments. YAML can therefore be viewed as a natural superset of JSON, offering improved human readability and a more complete information model. This is also the case in practice; every JSON file is also a valid YAML file. This makes it easy to migrate from JSON to YAML if/when the additional features are required. JSON's RFC4627 requires that mappings keys merely “ SHOULD” be unique , while YAML insists they “ MUST” be. Technically, YAML therefore complies with the JSON spec, choosing to treat duplicates as an error. In practice, since JSON is silent on the semantics of such duplicates, the only portable JSON files are those with unique keys, which are therefore valid YAML files. It may be useful to define a intermediate format between YAML and JSON. Such a format would be trivial to parse (but not very human readable), like JSON. At the same time, it would allow for serializing arbitrary native data structures , like YAML. Such a format might also serve as YAML’s \"canonical format\". Defining such a “ YSON” format (YSON is a Serialized Object Notation) can be done either by enhancing the JSON specification or by restricting the YAML specification. Such a definition is beyond the scope of this specification. 1.4. Relation to XML Newcomers to YAML often search for its correlation to the eXtensible Markup Language (XML). Although the two languages may actually compete in several application domains, there is no direct correlation between them. YAML is primarily a data serialization language. XML was designed to be backwards compatible with the Standard Generalized Markup Language (SGML), which was designed to support structured documentation. XML therefore had many design constraints placed on it that YAML does not share. XML is a pioneer in many domains, YAML is the result of lessons learned from XML and other technologies. It should be mentioned that there are ongoing efforts to define standard XML/YAML mappings. This generally requires that a subset of each language be used. For more information on using both XML and YAML, please visit http://yaml.org/xml . 1.5. Terminology This specification uses key words based on RFC2119 to indicate requirement level. In particular, the following words are used to describe the actions of a YAML processor : May The word may, or the adjective optional, mean that conforming YAML processors are permitted to, but need not behave as described. Should The word should, or the adjective recommended, mean that there could be reasons for a YAML processor to deviate from the behavior described, but that such deviation could hurt interoperability and should therefore be advertised with appropriate notice. Must The word must, or the term required or shall, mean that the behavior described is an absolute requirement of the specification. The rest of this document is arranged as follows. Chapter 2 provides a short preview of the main YAML features. Chapter 3 describes the YAML information model, and the processes for converting from and to this model and the YAML text format. The bulk of the document, chapters 4 through 9 , formally define this text format. Finally, chapter 10 recommends basic YAML schemas. Chapter 2. Preview This section provides a quick glimpse into the expressive power of YAML. It is not expected that the first-time reader grok all of the examples. Rather, these selections are used as motivation for the remainder of the specification. 2.1. Collections YAML’s block collections use indentation for scope and begin each entry on its own line. Block sequences indicate each entry with a dash and space ( “ - ” ). Mappings use a colon and space ( “ : ” ) to mark each key: value pair . Comments begin with an octothorpe (also called a “ hash”, “ sharp”, “ pound”, or “ number sign” - “ #” ). Example 2.1. Sequence of Scalars (ball players) - Mark McGwire - Sammy Sosa - Ken Griffey Example 2.2. Mapping Scalars to Scalars (player statistics) hr: 65 # Home runs avg: 0.278 # Batting average rbi: 147 # Runs Batted In Example 2.3. Mapping Scalars to Sequences (ball clubs in each league) american: - Boston Red Sox - Detroit Tigers - New York Yankees national: - New York Mets - Chicago Cubs - Atlanta Braves Example 2.4. Sequence of Mappings (players’ statistics) - name: Mark McGwire hr: 65 avg: 0.278 - name: Sammy Sosa hr: 63 avg: 0.288 YAML also has flow styles , using explicit indicators rather than indentation to denote scope. The flow sequence is written as a comma separated list within square brackets . In a similar manner, the flow mapping uses curly braces . Example 2.5. Sequence of Sequences - [name , hr, avg ] - [Mark McGwire, 65, 0.278] - [Sammy Sosa , 63, 0.288] Example 2.6. Mapping of Mappings Mark McGwire: {hr: 65, avg: 0.278} Sammy Sosa: { hr: 63, avg: 0.288 } 2.2. Structures YAML uses three dashes ( “ ---” ) to separate directives from document content . This also serves to signal the start of a document if no directives are present. Three dots ( “ ...” ) indicate the end of a document without starting a new one, for use in communication channels. Example 2.7. Two Documents in a Stream (each with a leading comment) # Ranking of 1998 home runs --- - Mark McGwire - Sammy Sosa - Ken Griffey # Team ranking --- - Chicago Cubs - St Louis Cardinals Example 2.8. Play by Play Feed from a Game --- time: 20:03:20 player: Sammy Sosa action: strike (miss) ... --- time: 20:03:47 player: Sammy Sosa action: grand slam ... Repeated nodes (objects) are first identified by an anchor (marked with the ampersand - “ &” ), and are then aliased (referenced with an asterisk - “ *” ) thereafter. Example 2.9. Single Document with Two Comments --- hr: # 1998 hr ranking - Mark McGwire - Sammy Sosa rbi: # 1998 rbi ranking - Sammy Sosa - Ken Griffey Example 2.10. Node for “ Sammy Sosa” appears twice in this document --- hr: - Mark McGwire # Following node labeled SS - &SS Sammy Sosa rbi: - *SS # Subsequent occurrence - Ken Griffey A question mark and space ( “ ? ” ) indicate a complex mapping key . Within a block collection , key: value pairs can start immediately following the dash , colon , or question mark . Example 2.11. Mapping between Sequences ? - Detroit Tigers - Chicago cubs : - 2001-07-23 ? [ New York Yankees, Atlanta Braves ] : [ 2001-07-02, 2001-08-12, 2001-08-14 ] Example 2.12. Compact Nested Mapping --- # Products purchased - item : Super Hoop quantity: 1 - item : Basketball quantity: 4 - item : Big Shoes quantity: 1 2.3. Scalars Scalar content can be written in block notation, using a literal style (indicated by “ |” ) where all line breaks are significant. Alternatively, they can be written with the folded style (denoted by “ >” ) where each line break is folded to a space unless it ends an empty or a more-indented line. Example 2.13. In literals, newlines are preserved # ASCII Art --- | \\//||\\/|| // || ||__ Example 2.14. In the folded scalars, newlines become spaces --- > Mark McGwire's year was crippled by a knee injury. Example 2.15. Folded newlines are preserved for \"more indented\" and blank lines > Sammy Sosa completed another fine season with great stats. 63 Home Runs 0.288 Batting Average What a year! Example 2.16. Indentation determines scope name: Mark McGwire accomplishment: > Mark set a major league home run record in 1998. stats: | 65 Home Runs 0.278 Batting Average YAML’s flow scalars include the plain style (most examples thus far) and two quoted styles. The double-quoted style provides escape sequences . The single-quoted style is useful when escaping is not needed. All flow scalars can span multiple lines; line breaks are always folded . Example 2.17. Quoted Scalars unicode: \"Sosa did fine.\\u263A\" control: \"\\b1998\\t1999\\t2000\\n\" hex esc: \"\\x0d\\x0a is \\r\\n\" single: '\"Howdy!\" he cried.' quoted: ' # Not a ''comment''.' tie-fighter: '|\\-*-/|' Example 2.18. Multi-line Flow Scalars plain: This unquoted scalar spans many lines. quoted: \"So does this quoted scalar.\\n\" 2.4. Tags In YAML, untagged nodes are given a type depending on the application . The examples in this specification generally use the seq , map and str types from the fail safe schema . A few examples also use the int , float , and null types from the JSON schema . The repository includes additional types such as binary , omap , set and others. Example 2.19. Integers canonical: 12345 decimal: +12345 octal: 0o14 hexadecimal: 0xC Example 2.20. Floating Point canonical: 1.23015e+3 exponential: 12.3015e+02 fixed: 1230.15 negative infinity: -.inf not a number: .NaN Example 2.21. Miscellaneous null: booleans: [ true, false ] string: '012345' Example 2.22. Timestamps canonical: 2001-12-15T02:59:43.1Z iso8601: 2001-12-14t21:59:43.10-05:00 spaced: 2001-12-14 21:59:43.10 -5 date: 2002-12-14 Explicit typing is denoted with a tag using the exclamation point ( “ !” ) symbol. Global tags are URIs and may be specified in a tag shorthand notation using a handle . Application -specific local tags may also be used. Example 2.23. Various Explicit Tags --- not-date: !!str 2002-04-28 picture: !!binary | R0lGODlhDAAMAIQAAP//9/X 17unp5WZmZgAAAOfn515eXv Pz7Y6OjuDg4J+fn5OTk6enp 56enmleECcgggoBADs= application specific tag: !something | The semantics of the tag above may be different for different documents. Example 2.24. Global Tags %TAG ! tag:clarkevans.com,2002: --- !shape # Use the ! handle for presenting # tag:clarkevans.com,2002:circle - !circle center: &ORIGIN {x: 73, y: 129} radius: 7 - !line start: *ORIGIN finish: { x: 89, y: 102 } - !label start: *ORIGIN color: 0xFFEEBB text: Pretty vector drawing. Example 2.25. Unordered Sets # Sets are represented as a # Mapping where each key is # associated with a null value --- !!set ? Mark McGwire ? Sammy Sosa ? Ken Griff Example 2.26. Ordered Mappings # Ordered maps are represented as # A sequence of mappings, with # each mapping having one key --- !!omap - Mark McGwire: 65 - Sammy Sosa: 63 - Ken Griffy: 58 2.5. Full Length Example Below are two full-length examples of YAML. On the left is a sample invoice; on the right is a sample log file. Example 2.27. Invoice --- !<tag:clarkevans.com,2002:invoice> invoice: 34843 date : 2001-01-23 bill-to: &id001 given : Chris family : Dumars address: lines: | 458 Walkman Dr. Suite #292 city : Royal Oak state : MI postal : 48046 ship-to: *id001 product: - sku : BL394D quantity : 4 description : Basketball price : 450.00 - sku : BL4438H quantity : 1 description : Super Hoop price : 2392.00 tax : 251.42 total: 4443.52 comments: Late afternoon is best. Backup contact is Nancy Billsmer @ 338-4338. Example 2.28. Log File --- Time: 2001-11-23 15:01:42 -5 User: ed Warning: This is an error message for the log file --- Time: 2001-11-23 15:02:31 -5 User: ed Warning: A slightly different error message. --- Date: 2001-11-23 15:03:17 -5 User: ed Fatal: Unknown variable \"bar\" Stack: - file: TopClass.py line: 23 code: | x = MoreObject(\"345\\n\") - file: MoreClass.py line: 58 code: |- foo = bar Chapter 3. Processing YAML Information YAML is both a text format and a method for presenting any native data structure in this format. Therefore, this specification defines two concepts: a class of data objects called YAML representations , and a syntax for presenting YAML representations as a series of characters, called a YAML stream . A YAML processor is a tool for converting information between these complementary views. It is assumed that a YAML processor does its work on behalf of another module, called an application. This chapter describes the information structures a YAML processor must provide to or obtain from the application. YAML information is used in two ways: for machine processing, and for human consumption. The challenge of reconciling these two perspectives is best done in three distinct translation stages: representation , serialization , and presentation . Representation addresses how YAML views native data structures to achieve portability between programming environments. Serialization concerns itself with turning a YAML representation into a serial form, that is, a form with sequential access constraints. Presentation deals with the formatting of a YAML serialization as a series of characters in a human-friendly manner. 3.1. Processes Translating between native data structures and a character stream is done in several logically distinct stages, each with a well defined input and output data model, as shown in the following diagram: Figure 3.1. Processing Overview A YAML processor need not expose the serialization or representation stages. It may translate directly between native data structures and a character stream ( dump and load in the diagram above). However, such a direct translation should take place so that the native data structures are constructed only from information available in the representation . In particular, mapping key order , comments , and tag handles should not be referenced during composition . 3.1.1. Dump Dumping native data structures to a character stream is done using the following three stages: Representing Native Data Structures YAML represents any native data structure using three node kinds : sequence - an ordered series of entries; mapping - an unordered association of unique keys to values ; and scalar - any datum with opaque structure presentable as a series of Unicode characters. Combined, these primitives generate directed graph structures. These primitives were chosen because they are both powerful and familiar: the sequence corresponds to a Perl array and a Python list, the mapping corresponds to a Perl hash table and a Python dictionary. The scalar represents strings, integers, dates, and other atomic data types. Each YAML node requires, in addition to its kind and content , a tag specifying its data type. Type specifiers are either global URIs, or are local in scope to a single application . For example, an integer is represented in YAML with a scalar plus the global tag “ tag:yaml.org,2002:int”. Similarly, an invoice object, particular to a given organization, could be represented as a mapping together with the local tag “ !invoice”. This simple model can represent any data structure independent of programming language. Serializing the Representation Graph For sequential access mediums, such as an event callback API, a YAML representation must be serialized to an ordered tree. Since in a YAML representation , mapping keys are unordered and nodes may be referenced more than once (have more than one incoming “ arrow”), the serialization process is required to impose an ordering on the mapping keys and to replace the second and subsequent references to a given node with place holders called aliases . YAML does not specify how these serialization details are chosen. It is up to the YAML processor to come up with human-friendly key order and anchor names, possibly with the help of the application . The result of this process, a YAML serialization tree , can then be traversed to produce a series of event calls for one-pass processing of YAML data. Presenting the Serialization Tree The final output process is presenting the YAML serializations as a character stream in a human-friendly manner. To maximize human readability, YAML offers a rich set of stylistic options which go far beyond the minimal functional needs of simple data storage. Therefore the YAML processor is required to introduce various presentation details when creating the stream , such as the choice of node styles , how to format scalar content , the amount of indentation , which tag handles to use, the node tags to leave unspecified , the set of directives to provide and possibly even what comments to add. While some of this can be done with the help of the application , in general this process should be guided by the preferences of the user. 3.1.2. Load Loading native data structures from a character stream is done using the following three stages: Parsing the Presentation Stream Parsing is the inverse process of presentation , it takes a stream of characters and produces a series of events. Parsing discards all the details introduced in the presentation process, reporting only the serialization events. Parsing can fail due to ill-formed input. Composing the Representation Graph Composing takes a series of serialization events and produces a representation graph . Composing discards all the details introduced in the serialization process, producing only the representation graph . Composing can fail due to any of several reasons, detailed below . Constructing Native Data Structures The final input process is constructing native data structures from the YAML representation . Construction must be based only on the information available in the representation , and not on additional serialization or presentation details such as comments , directives , mapping key order , node styles , scalar content format , indentation levels etc. Construction can fail due to the unavailability of the required native data types . 3.2. Information Models This section specifies the formal details of the results of the above processes. To maximize data portability between programming languages and implementations, users of YAML should be mindful of the distinction between serialization or presentation properties and those which are part of the YAML representation . Thus, while imposing a order on mapping keys is necessary for flattening YAML representations to a sequential access medium, this serialization detail must not be used to convey application level information. In a similar manner, while indentation technique and a choice of a node style are needed for the human readability, these presentation details are neither part of the YAML serialization nor the YAML representation . By carefully separating properties needed for serialization and presentation , YAML representations of application information will be consistent and portable between various programming environments. The following diagram summarizes the three information models. Full arrows denote composition, hollow arrows denote inheritance, “ 1” and “ *” denote “ one” and “ many” relationships. A single “ +” denotes serialization details, a double “ ++” denotes presentation details. Figure 3.2. Information Models 3.2.1. Representation Graph YAML’s representation of native data structure is a rooted, connected, directed graph of tagged nodes . By “ directed graph” we mean a set of nodes and directed edges (“ arrows”), where each edge connects one node to another (see a formal definition ). All the nodes must be reachable from the root node via such edges. Note that the YAML graph may include cycles, and a node may have more than one incoming edge. Nodes that are defined in terms of other nodes are collections ; nodes that are independent of any other nodes are scalars . YAML supports two kinds of collection nodes : sequences and mappings . Mapping nodes are somewhat tricky because their keys are unordered and must be unique . Figure 3.3. Representation Model 3.2.1.1. Nodes A YAML node represents a single native data structure . Such nodes have content of one of three kinds: scalar, sequence, or mapping. In addition, each node has a tag which serves to restrict the set of possible values the content can have. Scalar The content of a scalar node is an opaque datum that can be presented as a series of zero or more Unicode characters. Sequence The content of a sequence node is an ordered series of zero or more nodes. In particular, a sequence may contain the same node more than once. It could even contain itself (directly or indirectly). Mapping The content of a mapping node is an unordered set of key: value node pairs, with the restriction that each of the keys is unique . YAML places no further restrictions on the nodes. In particular, keys may be arbitrary nodes, the same node may be used as the value of several key: value pairs, and a mapping could even contain itself as a key or a value (directly or indirectly). When appropriate, it is convenient to consider sequences and mappings together, as collections. In this view, sequences are treated as mappings with integer keys starting at zero. Having a unified collections view for sequences and mappings is helpful both for theoretical analysis and for creating practical YAML tools and APIs. This strategy is also used by the Javascript programming language. 3.2.1.2. Tags YAML represents type information of native data structures with a simple identifier, called a tag. Global tags are URIs and hence globally unique across all applications . The “ tag:” URI scheme is recommended for all global YAML tags. In contrast, local tags are specific to a single application . Local tags start with “ !”, are not URIs and are not expected to be globally unique. YAML provides a “ TAG” directive to make tag notation less verbose; it also offers easy migration from local to global tags. To ensure this, local tags are restricted to the URI character set and use URI character escaping . YAML does not mandate any special relationship between different tags that begin with the same substring. Tags ending with URI fragments (containing “ #”) are no exception; tags that share the same base URI but differ in their fragment part are considered to be different, independent tags. By convention, fragments are used to identify different “ variants” of a tag, while “ /” is used to define nested tag “ namespace” hierarchies. However, this is merely a convention, and each tag may employ its own rules. For example, Perl tags may use “ ::” to express namespace hierarchies, Java tags may use “ .”, etc. YAML tags are used to associate meta information with each node . In particular, each tag must specify the expected node kind ( scalar , sequence , or mapping ). Scalar tags must also provide a mechanism for converting formatted content to a canonical form for supporting equality testing. Furthermore, a tag may provide additional information such as the set of allowed content values for validation, a mechanism for tag resolution , or any other data that is applicable to all of the tag’s nodes . 3.2.1.3. Node Comparison Since YAML mappings require key uniqueness, representations must include a mechanism for testing the equality of nodes . This is non-trivial since YAML allows various ways to format scalar content . For example, the integer eleven can be written as “ 0o13” (octal) or “ 0xB” (hexadecimal). If both notations are used as keys in the same mapping , only a YAML processor which recognizes integer formats would correctly flag the duplicate key as an error. Canonical Form YAML supports the need for scalar equality by requiring that every scalar tag must specify a mechanism for producing the canonical form of any formatted content . This form is a Unicode character string which also presents the same content , and can be used for equality testing. While this requirement is stronger than a well defined equality operator, it has other uses, such as the production of digital signatures. Equality Two nodes must have the same tag and content to be equal. Since each tag applies to exactly one kind , this implies that the two nodes must have the same kind to be equal. Two scalars are equal only when their tags and canonical forms are equal character-by-character. Equality of collections is defined recursively. Two sequences are equal only when they have the same tag and length, and each node in one sequence is equal to the corresponding node in the other sequence . Two mappings are equal only when they have the same tag and an equal set of keys , and each key in this set is associated with equal values in both mappings . Different URI schemes may define different rules for testing the equality of URIs. Since a YAML processor cannot be reasonably expected to be aware of them all, it must resort to a simple character-by-character comparison of tags to ensure consistency. This also happens to be the comparison method defined by the “ tag:” URI scheme. Tags in a YAML stream must therefore be presented in a canonical way so that such comparison would yield the correct results. Identity Two nodes are identical only when they represent the same native data structure . Typically, this corresponds to a single memory address. Identity should not be confused with equality; two equal nodes need not have the same identity. A YAML processor may treat equal scalars as if they were identical. In contrast, the separate identity of two distinct but equal collections must be preserved. 3.2.2. Serialization Tree To express a YAML representation using a serial API, it is necessary to impose an order on mapping keys and employ alias nodes to indicate a subsequent occurrence of a previously encountered node . The result of this process is a serialization tree, where each node has an ordered set of children. This tree can be traversed for a serial event-based API. Construction of native data structures from the serial interface should not use key order or anchor names for the preservation of application data. Figure 3.4. Serialization Model 3.2.2.1. Keys Order In the representation model, mapping keys do not have an order. To serialize a mapping , it is necessary to impose an ordering on its keys . This order is a serialization detail and should not be used when composing the representation graph (and hence for the preservation of application data). In every case where node order is significant, a sequence must be used. For example, an ordered mapping can be represented as a sequence of mappings , where each mapping is a single key: value pair . YAML provides convenient compact notation for this case. 3.2.2.2. Anchors and Aliases In the representation graph , a node may appear in more than one collection . When serializing such data, the first occurrence of the node is identified by an anchor. Each subsequent occurrence is serialized as an alias node which refers back to this anchor. Otherwise, anchor names are a serialization detail and are discarded once composing is completed. When composing a representation graph from serialized events, an alias node refers to the most recent node in the serialization having the specified anchor. Therefore, anchors need not be unique within a serialization . In addition, an anchor need not have an alias node referring to it. It is therefore possible to provide an anchor for all nodes in serialization . 3.2.3. Presentation Stream A YAML presentation is a stream of Unicode characters making use of of styles , scalar content formats , comments , directives and other presentation details to present a YAML serialization in a human readable way. Although a YAML processor may provide these details when parsing , they should not be reflected in the resulting serialization . YAML allows several serialization trees to be contained in the same YAML character stream, as a series of documents separated by markers . Documents appearing in the same stream are independent; that is, a node must not appear in more than one serialization tree or representation graph . Figure 3.5. Presentation Model 3.2.3.1. Node Styles Each node is presented in some style, depending on its kind . The node style is a presentation detail and is not reflected in the serialization tree or representation graph . There are two groups of styles. Block styles use indentation to denote structure; In contrast, flow styles styles rely on explicit indicators . YAML provides a rich set of scalar styles. Block scalar styles include the literal style and the folded style . Flow scalar styles include the plain style and two quoted styles, the single-quoted style and the double-quoted style . These styles offer a range of trade-offs between expressive power and readability. Normally, block sequences and mappings begin on the next line. In some cases, YAML also allows nested block collections to start in-line for a more compact notation . In addition, YAML provides a compact notation for flow mappings with a single key: value pair , nested inside a flow sequence . These allow for a natural “ ordered mapping” notation. Figure 3.6. Kind/Style Combinations 3.2.3.2. Scalar Formats YAML allows scalars to be presented in several formats. For example, the integer “ 11” might also be written as “ 0xB”. Tags must specify a mechanism for converting the formatted content to a canonical form for use in equality testing. Like node style , the format is a presentation detail and is not reflected in the serialization tree and representation graph . 3.2.3.3. Comments Comments are a presentation detail and must not have any effect on the serialization tree or representation graph . In particular, comments are not associated with a particular node . The usual purpose of a comment is to communicate between the human maintainers of a file. A typical example is comments in a configuration file. Comments must not appear inside scalars , but may be interleaved with such scalars inside collections . 3.2.3.4. Directives Each document may be associated with a set of directives . A directive has a name and an optional sequence of parameters. Directives are instructions to the YAML processor , and like all other presentation details are not reflected in the YAML serialization tree or representation graph . This version of YAML defines a two directives, “ YAML” and “ TAG” . All other directives are reserved for future versions of YAML. 3.3. Loading Failure Points The process of loading native data structures from a YAML stream has several potential failure points. The character stream may be ill-formed , aliases may be unidentified , unspecified tags may be unresolvable , tags may be unrecognized , the content may be invalid , and a native type may be unavailable . Each of these failures results with an incomplete loading. A partial representation need not resolve the tag of each node , and the canonical form of formatted scalar content need not be available. This weaker representation is useful for cases of incomplete knowledge of the types used in the document . In contrast, a complete representation specifies the tag of each node , and provides the canonical form of formatted scalar content , allowing for equality testing. A complete representation is required in order to construct native data structures . Figure 3.7. Loading Failure Points 3.3.1. Well-Formed Streams and Identified Aliases A well-formed character stream must match the BNF productions specified in the following chapters. Successful loading also requires that each alias shall refer to a previous node identified by the anchor . A YAML processor should reject ill-formed streams and unidentified aliases. A YAML processor may recover from syntax errors, possibly by ignoring certain parts of the input, but it must provide a mechanism for reporting such errors. 3.3.2. Resolved Tags Typically, most tags are not explicitly specified in the character stream . During parsing , nodes lacking an explicit tag are given a non-specific tag: “ !” for non- plain scalars , and “ ?” for all other nodes . Composing a complete representation requires each such non-specific tag to be resolved to a specific tag, be it a global tag or a local tag . Resolving the tag of a node must only depend on the following three parameters: (1) the non-specific tag of the node , (2) the path leading from the root to the node , and (3) the content (and hence the kind ) of the node . When a node has more than one occurrence (using aliases ), tag resolution must depend only on the path to the first ( anchored ) occurrence of the node . Note that resolution must not consider presentation details such as comments , indentation and node style . Also, resolution must not consider the content of any other node , except for the content of the key nodes directly along the path leading from the root to the resolved node . Finally, resolution must not consider the content of a sibling node in a collection , or the content of the value node associated with a key node being resolved. These rules ensure that tag resolution can be performed as soon as a node is first encountered in the stream , typically before its content is parsed . Also, tag resolution only requires referring to a relatively small number of previously parsed nodes . Thus, in most cases, tag resolution in one-pass processors is both possible and practical. YAML processors should resolve nodes having the “ !” non-specific tag as “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map” or “ tag:yaml.org,2002:str” depending on their kind . This tag resolution convention allows the author of a YAML character stream to effectively “ disable” the tag resolution process. By explicitly specifying a “ !” non-specific tag property , the node would then be resolved to a “ vanilla” sequence , mapping , or string, according to its kind . Application specific tag resolution rules should be restricted to resolving the “ ?” non-specific tag, most commonly to resolving plain scalars . These may be matched against a set of regular expressions to provide automatic resolution of integers, floats, timestamps, and similar types. An application may also match the content of mapping nodes against sets of expected keys to automatically resolve points, complex numbers, and similar types. Resolved sequence node types such as the “ ordered mapping” are also possible. That said, tag resolution is specific to the application . YAML processors should therefore provide a mechanism allowing the application to override and expand these default tag resolution rules. If a document contains unresolved tags, the YAML processor is unable to compose a complete representation graph. In such a case, the YAML processor may compose a partial representation , based on each node’s kind and allowing for non-specific tags. 3.3.3. Recognized and Valid Tags To be valid, a node must have a tag which is recognized by the YAML processor and its content must satisfy the constraints imposed by this tag . If a document contains a scalar node with an unrecognized tag or invalid content, only a partial representation may be composed . In contrast, a YAML processor can always compose a complete representation for an unrecognized or an invalid collection , since collection equality does not depend upon knowledge of the collection’s data type. However, such a complete representation cannot be used to construct a native data structure . 3.3.4. Available Tags In a given processing environment, there need not be an available native type corresponding to a given tag . If a node’s tag is unavailable, a YAML processor will not be able to construct a native data structure for it. In this case, a complete representation may still be composed , and an application may wish to use this representation directly. Chapter 4. Syntax Conventions The following chapters formally define the syntax of YAML character streams , using parameterized BNF productions. Each BNF production is both named and numbered for easy reference. Whenever possible, basic structures are specified before the more complex structures using them in a “ bottom up” fashion. The order of alternatives inside a production is significant. Subsequent alternatives are only considered when previous ones fails. See for example the b-break production. In addition, production matching is expected to be greedy. Optional ( ?), zero-or-more ( *) and one-or-more ( +) patterns are always expected to match as much of the input as possible. The productions are accompanied by examples, which are given side-by-side next to equivalent YAML text in an explanatory format. This format uses only flow collections , double-quoted scalars , and explicit tags for each node . A reference implementation using the productions is available as the YamlReference Haskell package. This reference implementation is also available as an interactive web application at http://dev.yaml.org/ypaste . 4.1. Production Parameters YAML’s syntax is designed for maximal human readability. This requires parsing to depend on the surrounding text. For notational compactness, this dependency is expressed using parameterized BNF productions. This context sensitivity is the cause of most of the complexity of the YAML syntax definition. It is further complicated by struggling with the human tendency to look ahead when interpreting text. These complications are of course the source of most of YAML’s power to present data in a very human readable way. Productions use any of the following parameters: Indentation: n or m Many productions use an explicit indentation level parameter. This is less elegant than Python’s “ indent” and “ undent” conceptual tokens. However it is required to formally express YAML’s indentation rules. Context: c This parameter allows productions to tweak their behavior according to their surrounding. YAML supports two groups of contexts, distinguishing between block styles and flow styles . In block styles , indentation is used to delineate structure. To capture human perception of indentation the rules require special treatment of the “ -” character, used in block sequences . Hence in some cases productions need to behave differently inside block sequences ( block-in context) and outside them ( block-out context). In flow styles , explicit indicators are used to delineate structure. These styles can be viewed as the natural extension of JSON to cover tagged , single-quoted and plain scalars . Since the latter have no delineating indicators , they are subject to some restrictions to avoid ambiguities. These restrictions depend on where they appear: as implicit keys directly inside a block mapping ( block-key); as implicit keys inside a flow mapping ( flow-key); as values inside a flow collection ( flow-in); or as values outside one ( flow-out). (Block) Chomping: t Block scalars offer three possible mechanisms for chomping any trailing line breaks : strip , clip and keep . Unlike the previous parameters, this only controls interpretation; the line breaks are valid in all cases. 4.2. Production Naming Conventions To make it easier to follow production combinations, production names use a Hungarian-style naming convention. Each production is given a prefix based on the type of characters it begins and ends with. e- A production matching no characters. c- A production starting and ending with a special character. b- A production matching a single line break . nb- A production starting and ending with a non- break character. s- A production starting and ending with a white space character. ns- A production starting and ending with a non- space character. l- A production matching complete line(s). X - Y - A production starting with an X - character and ending with a Y - character, where X - and Y - are any of the above prefixes. X +, X - Y + A production as above, with the additional property that the matched content indentation level is greater than the specified n parameter. Chapter 5. Characters 5.1. Character Set To ensure readability, YAML streams use only the printable subset of the Unicode character set. The allowed character range explicitly excludes the C0 control block #x0-#x1F (except for TAB #x9, LF #xA, and CR #xD which are allowed), DEL #x7F, the C1 control block #x80-#x9F (except for NEL #x85 which is allowed), the surrogate block #xD800-#xDFFF, #xFFFE, and #xFFFF. On input, a YAML processor must accept all Unicode characters except those explicitly excluded above. On output, a YAML processor must only produce acceptable characters. Any excluded characters must be presented using escape sequences. In addition, any allowed characters known to be non-printable should also be escaped . This isn’t mandatory since a full implementation would require extensive character property tables. [1] c-printable ::= #x9 | #xA | #xD | [#x20-#x7E] /* 8 bit */ | #x85 | [#xA0-#xD7FF] | [#xE000-#xFFFD] /* 16 bit */ | [#x10000-#x10FFFF] /* 32 bit */ To ensure JSON compatibility , YAML processors must allow all non-control characters inside quoted scalars . To ensure readability, non-printable characters should be escaped on output, even inside such scalars . Note that JSON quoted scalars cannot span multiple lines or contain tabs , but YAML quoted scalars can. [2] nb-json ::= #x9 | [#x20-#x10FFFF] 5.2. Character Encodings All characters mentioned in this specification are Unicode code points. Each such code point is written as one or more bytes depending on the character encoding used. Note that in UTF-16, characters above #xFFFF are written as four bytes, using a surrogate pair. The character encoding is a presentation detail and must not be used to convey content information. On input, a YAML processor must support the UTF-8 and UTF-16 character encodings. For JSON compatibility , the UTF-32 encodings must also be supported. If a character stream begins with a byte order mark, the character encoding will be taken to be as as indicated by the byte order mark. Otherwise, the stream must begin with an ASCII character. This allows the encoding to be deduced by the pattern of null ( #x00) characters. To make it easier to concatenate streams , byte order marks may appear at the start of any document . However all documents in the same stream must use the same character encoding. To allow for JSON compatibility , byte order marks are also allowed inside quoted scalars . For readability, such content byte order marks should be escaped on output. The encoding can therefore be deduced by matching the first few bytes of the stream with the following table rows (in order): Byte0 Byte1 Byte2 Byte3 Encoding Explicit BOM #x00 #x00 #xFE #xFF UTF-32BE ASCII first character #x00 #x00 #x00 any UTF-32BE Explicit BOM #xFF #xFE #x00 #x00 UTF-32LE ASCII first character any #x00 #x00 #x00 UTF-32LE Explicit BOM #xFE #xFF UTF-16BE ASCII first character #x00 any UTF-16BE Explicit BOM #xFF #xFE UTF-16LE ASCII first character any #x00 UTF-16LE Explicit BOM #xEF #xBB #xBF UTF-8 Default UTF-8 The recommended output encoding is UTF-8. If another encoding is used, it is recommended that an explicit byte order mark be used, even if the first stream character is ASCII. For more information about the byte order mark and the Unicode character encoding schemes see the Unicode FAQ . [3] c-byte-order-mark ::= #xFEFF In the examples, byte order mark characters are displayed as “ ”. Example 5.1. Byte Order Mark # Comment only. Legend: c-byte-order-mark # This stream contains no # documents, only comments. Example 5.2. Invalid Byte Order Mark - Invalid use of BOM - Inside a document. ERROR: A BOM must not appear inside a document. 5.3. Indicator Characters Indicators are characters that have special semantics. [4] c-sequence-entry ::= “ -” A “ -” ( #x2D, hyphen) denotes a block sequence entry. [5] c-mapping-key ::= “ ?” A “ ?” ( #x3F, question mark) denotes a mapping key . [6] c-mapping-value ::= “ :” A “ :” ( #x3A, colon) denotes a mapping value . Example 5.3. Block Structure Indicators sequence : - one - two mapping : ? sky : blue sea : green Legend: c-sequence-entry c-mapping-key c-mapping-value %YAML 1.2 --- !!map { ? !!str \"sequence\" : !!seq [ !!str \"one\", !!str \"two\" ], ? !!str \"mapping\" : !!map { ? !!str \"sky\" : !!str \"blue\", ? !!str \"sea\" : !!str \"green\", }, } [7] c-collect-entry ::= “ ,” A “ ,” ( #x2C, comma) ends a flow collection entry. [8] c-sequence-start ::= “ [” A “ [” ( #x5B, left bracket) starts a flow sequence . [9] c-sequence-end ::= “ ]” A “ ]” ( #x5D, right bracket) ends a flow sequence . [10] c-mapping-start ::= “ {” A “ {” ( #x7B, left brace) starts a flow mapping . [11] c-mapping-end ::= “ }” A “ }” ( #x7D, right brace) ends a flow mapping . Example 5.4. Flow Collection Indicators sequence: [ one , two , ] mapping: { sky: blue , sea: green } Legend: c-sequence-start c-sequence-end c-mapping-start c-mapping-end c-collect-entry %YAML 1.2 --- !!map { ? !!str \"sequence\" : !!seq [ !!str \"one\", !!str \"two\" ], ? !!str \"mapping\" : !!map { ? !!str \"sky\" : !!str \"blue\", ? !!str \"sea\" : !!str \"green\", }, } [12] c-comment ::= “ #” An “ #” ( #x23, octothorpe, hash, sharp, pound, number sign) denotes a comment . Example 5.5. Comment Indicator # Comment only. Legend: c-comment # This stream contains no # documents, only comments. [13] c-anchor ::= “ &” An “ &” ( #x26, ampersand) denotes a node’s anchor property . [14] c-alias ::= “ *” An “ *” ( #x2A, asterisk) denotes an alias node . [15] c-tag ::= “ !” The “ !” ( #x21, exclamation) is heavily overloaded for specifying node tags . It is used to denote tag handles used in tag directives and tag properties ; to denote local tags ; and as the non-specific tag for non- plain scalars . Example 5.6. Node Property Indicators anchored: !local &anchor value alias: *anchor Legend: c-tag c-anchor c-alias %YAML 1.2 --- !!map { ? !!str \"anchored\" : !local &A1 \"value\", ? !!str \"alias\" : *A1, } [16] c-literal ::= “ |” A “ |” ( 7C, vertical bar) denotes a literal block scalar . [17] c-folded ::= “ >” A “ >” ( #x3E, greater than) denotes a folded block scalar . Example 5.7. Block Scalar Indicators literal: | some text folded: > some text Legend: c-literal c-folded %YAML 1.2 --- !!map { ? !!str \"literal\" : !!str \"some\\ntext\\n\", ? !!str \"folded\" : !!str \"some text\\n\", } [18] c-single-quote ::= “ '” An “ '” ( #x27, apostrophe, single quote) surrounds a single-quoted flow scalar . [19] c-double-quote ::= “ \"” A “ \"” ( #x22, double quote) surrounds a double-quoted flow scalar . Example 5.8. Quoted Scalar Indicators single: 'text ' double: \"text \" Legend: c-single-quote c-double-quote %YAML 1.2 --- !!map { ? !!str \"single\" : !!str \"text\", ? !!str \"double\" : !!str \"text\", } [20] c-directive ::= “ %” A “ %” ( #x25, percent) denotes a directive line. Example 5.9. Directive Indicator %YAML 1.2 --- text Legend: c-directive %YAML 1.2 --- !!str \"text\" [21] c-reserved ::= “ @” | “ `” The “ @” ( #x40, at) and “ `” ( #x60, grave accent) are reserved for future use. Example 5.10. Invalid use of Reserved Indicators commercial-at: @text grave-accent: `text ERROR: Reserved indicators can't start a plain scalar. Any indicator character: [22] c-indicator ::= “ -” | “ ?” | “ :” | “ ,” | “ [” | “ ]” | “ {” | “ }” | “ #” | “ &” | “ *” | “ !” | “ |” | “ >” | “ '” | “ \"” | “ %” | “ @” | “ `” The “ [” , “ ]” , “ {” , “ }” and “ ,” indicators denote structure in flow collections . They are therefore forbidden in some cases, to avoid ambiguity in several constructs. This is handled on a case-by-case basis by the relevant productions. [23] c-flow-indicator ::= “ ,” | “ [” | “ ]” | “ {” | “ }” 5.4. Line Break Characters YAML recognizes the following ASCII line break characters. [24] b-line-feed ::= #xA /* LF */ [25] b-carriage-return ::= #xD /* CR */ [26] b-char ::= b-line-feed | b-carriage-return All other characters, including the form feed ( #x0C), are considered to be non-break characters. Note that these include the non-ASCII line breaks: next line ( #x85), line separator ( #x2028) and paragraph separator ( #x2029). YAML version 1.1 did support the above non-ASCII line break characters; however, JSON does not. Hence, to ensure JSON compatibility , YAML treats them as non-break characters as of version 1.2. In theory this would cause incompatibility with version 1.1 ; in practice these characters were rarely (if ever) used. YAML 1.2 processors parsing a version 1.1 document should therefore treat these line breaks as non-break characters, with an appropriate warning. [27] nb-char ::= c-printable - b-char - c-byte-order-mark Line breaks are interpreted differently by different systems, and have several widely used formats. [28] b-break ::= ( b-carriage-return b-line-feed ) /* DOS, Windows */ | b-carriage-return /* MacOS upto 9.x */ | b-line-feed /* UNIX, MacOS X */ Line breaks inside scalar content must be normalized by the YAML processor . Each such line break must be parsed into a single line feed character. The original line break format is a presentation detail and must not be used to convey content information. [29] b-as-line-feed ::= b-break Outside scalar content , YAML allows any line break to be used to terminate lines. [30] b-non-content ::= b-break On output, a YAML processor is free to emit line breaks using whatever convention is most appropriate. In the examples, line breaks are sometimes displayed using the “ ” glyph for clarity. Example 5.11. Line Break Characters | Line break (no glyph) Line break (glyphed) Legend: b-break %YAML 1.2 --- !!str \"line break (no glyph)\\n\\ line break (glyphed)\\n\" 5.5. White Space Characters YAML recognizes two white space characters: space and tab. [31] s-space ::= #x20 /* SP */ [32] s-tab ::= #x9 /* TAB */ [33] s-white ::= s-space | s-tab The rest of the ( printable ) non- break characters are considered to be non-space characters. [34] ns-char ::= nb-char - s-white In the examples, tab characters are displayed as the glyph “ ”. Space characters are sometimes displayed as the glyph “ ·” for clarity. Example 5.12. Tabs and Spaces # Tabs and spaces quoted: ·\"Quoted \" block: | ··void main() { ·· printf(\"Hello, world!\\n\"); ··} Legend: s-space s-tab %YAML 1.2 --- !!map { ? !!str \"quoted\" : \"Quoted \\t\", ? !!str \"block\" : \"void main() {\\n\\ \\tprintf(\\\"Hello, world!\\\\n\\\");\\n\\ }\\n\", } 5.6. Miscellaneous Characters The YAML syntax productions make use of the following additional character classes: A decimal digit for numbers: [35] ns-dec-digit ::= [#x30-#x39] /* 0-9 */ A hexadecimal digit for escape sequences : [36] ns-hex-digit ::= ns-dec-digit | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */ ASCII letter (alphabetic) characters: [37] ns-ascii-letter ::= [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */ Word (alphanumeric) characters for identifiers: [38] ns-word-char ::= ns-dec-digit | ns-ascii-letter | “ -” URI characters for tags , as specified in RFC2396 , with the addition of the “ [” and “ ]” for presenting IPv6 addresses as proposed in RFC2732 . By convention, any URI characters other than the allowed printable ASCII characters are first encoded in UTF-8, and then each byte is escaped using the “ %” character. The YAML processor must not expand such escaped characters. Tag characters must be preserved and compared exactly as presented in the YAML stream , without any processing. [39] ns-uri-char ::= “ %” ns-hex-digit ns-hex-digit | ns-word-char | “ #” | “ ;” | “ /” | “ ?” | “ :” | “ @” | “ &” | “ =” | “ +” | “ $” | “ ,” | “ _” | “ .” | “ !” | “ ~” | “ *” | “ '” | “ (” | “ )” | “ [” | “ ]” The “ !” character is used to indicate the end of a named tag handle ; hence its use in tag shorthands is restricted. In addition, such shorthands must not contain the “ [” , “ ]” , “ {” , “ }” and “ ,” characters. These characters would cause ambiguity with flow collection structures. [40] ns-tag-char ::= ns-uri-char - “ !” - c-flow-indicator 5.7. Escaped Characters All non- printable characters must be escaped. YAML escape sequences use the “ \\” notation common to most modern computer languages. Each escape sequence must be parsed into the appropriate Unicode character. The original escape sequence is a presentation detail and must not be used to convey content information. Note that escape sequences are only interpreted in double-quoted scalars . In all other scalar styles , the “ \\” character has no special meaning and non- printable characters are not available. [41] c-escape ::= “ \\” YAML escape sequences are a superset of C’s escape sequences: [42] ns-esc-null ::= “ 0” Escaped ASCII null ( #x0) character. [43] ns-esc-bell ::= “ a” Escaped ASCII bell ( #x7) character. [44] ns-esc-backspace ::= “ b” Escaped ASCII backspace ( #x8) character. [45] ns-esc-horizontal-tab ::= “ t” | #x9 Escaped ASCII horizontal tab ( #x9) character. This is useful at the start or the end of a line to force a leading or trailing tab to become part of the content . [46] ns-esc-line-feed ::= “ n” Escaped ASCII line feed ( #xA) character. [47] ns-esc-vertical-tab ::= “ v” Escaped ASCII vertical tab ( #xB) character. [48] ns-esc-form-feed ::= “ f” Escaped ASCII form feed ( #xC) character. [49] ns-esc-carriage-return ::= “ r” Escaped ASCII carriage return ( #xD) character. [50] ns-esc-escape ::= “ e” Escaped ASCII escape ( #x1B) character. [51] ns-esc-space ::= #x20 Escaped ASCII space ( #x20) character. This is useful at the start or the end of a line to force a leading or trailing space to become part of the content . [52] ns-esc-double-quote ::= “ \"” Escaped ASCII double quote ( #x22). [53] ns-esc-slash ::= “ /” Escaped ASCII slash ( #x2F), for JSON compatibility . [54] ns-esc-backslash ::= “ \\” Escaped ASCII back slash ( #x5C). [55] ns-esc-next-line ::= “ N” Escaped Unicode next line ( #x85) character. [56] ns-esc-non-breaking-space ::= “ _” Escaped Unicode non-breaking space ( #xA0) character. [57] ns-esc-line-separator ::= “ L” Escaped Unicode line separator ( #x2028) character. [58] ns-esc-paragraph-separator ::= “ P” Escaped Unicode paragraph separator ( #x2029) character. [59] ns-esc-8-bit ::= “ x” ( ns-hex-digit × 2 ) Escaped 8-bit Unicode character. [60] ns-esc-16-bit ::= “ u” ( ns-hex-digit × 4 ) Escaped 16-bit Unicode character. [61] ns-esc-32-bit ::= “ U” ( ns-hex-digit × 8 ) Escaped 32-bit Unicode character. Any escaped character: [62] c-ns-esc-char ::= “ \\” ( ns-esc-null | ns-esc-bell | ns-esc-backspace | ns-esc-horizontal-tab | ns-esc-line-feed | ns-esc-vertical-tab | ns-esc-form-feed | ns-esc-carriage-return | ns-esc-escape | ns-esc-space | ns-esc-double-quote | ns-esc-slash | ns-esc-backslash | ns-esc-next-line | ns-esc-non-breaking-space | ns-esc-line-separator | ns-esc-paragraph-separator | ns-esc-8-bit | ns-esc-16-bit | ns-esc-32-bit ) Example 5.13. Escaped Characters \"Fun with \\\\ \\\" \\a \\b \\e \\f \\ \\n \\r \\t \\v \\0 \\ \\ \\_ \\N \\L \\P \\ \\x41 \\u0041 \\U00000041\" Legend: c-ns-esc-char %YAML 1.2 --- \"Fun with \\x5C \\x22 \\x07 \\x08 \\x1B \\x0C \\x0A \\x0D \\x09 \\x0B \\x00 \\x20 \\xA0 \\x85 \\u2028 \\u2029 A A A\" Example 5.14. Invalid Escaped Characters Bad escapes: \"\\ c \\x q-\" ERROR: - c is an invalid escaped character. - q and - are invalid hex digits. Chapter 6. Basic Structures 6.1. Indentation Spaces In YAML block styles , structure is determined by indentation. In general, indentation is defined as a zero or more space characters at the start of a line. To maintain portability, tab characters must not be used in indentation, since different systems treat tabs differently. Note that most modern editors may be configured so that pressing the tab key results in the insertion of an appropriate number of spaces . The amount of indentation is a presentation detail and must not be used to convey content information. [63] s-indent(n) ::= s-space × n A block style construct is terminated when encountering a line which is less indented than the construct. The productions use the notation “ s-indent(<n)” and “ s-indent( n)” to express this. [64] s-indent(<n) ::= s-space × m /* Where m < n */ [65] s-indent( n) ::= s-space × m /* Where m n */ Each node must be indented further than its parent node . All sibling nodes must use the exact same indentation level. However the content of each sibling node may be further indented independently. Example 6.1. Indentation Spaces ··# Leading comment line spaces are ···# neither content nor indentation. ···· Not indented: ·By one space: | ····By four ···· ··spaces ·Flow style: [ # Leading spaces ·· ·By two, # in flow style ··Also by two, # are neither ·· Still by two # content nor ·· ··] # indentation. Legend: s-indent(n) Content Neither content nor indentation %YAML 1.2 - - - !!map { ? !!str \"Not indented\" : !!map { ? !!str \"By one space\" : !!str \"By four\\n spaces\\n\", ? !!str \"Flow style\" : !!seq [ !!str \"By two\", !!str \"Also by two\", !!str \"Still by two\", ] } } The “ -” , “ ?” and “ :” characters used to denote block collection entries are perceived by people to be part of the indentation. This is handled on a case-by-case basis by the relevant productions. Example 6.2. Indentation Indicators ?·a : · - b ·· - ·· - c ····· -·d Legend: Total Indentation s-indent(n) Indicator as indentation %YAML 1.2 --- !!map { ? !!str \"a\" : !!seq [ !!str \"b\", !!seq [ !!str \"c\", !!str \"d\" ] ], } 6.2. Separation Spaces Outside indentation and scalar content , YAML uses white space characters for separation between tokens within a line. Note that such white space may safely include tab characters. Separation spaces are a presentation detail and must not be used to convey content information. [66] s-separate-in-line ::= s-white + | /* Start of line */ Example 6.3. Separation Spaces - ·foo: ·bar - - ·baz - baz Legend: s-separate-in-line %YAML 1.2 --- !!seq [ !!map { ? !!str \"foo\" : !!str \"bar\", }, !!seq [ !!str \"baz\", !!str \"baz\" ], ] 6.3. Line Prefixes Inside scalar content , each line begins with a non- content line prefix. This prefix always includes the indentation . For flow scalar styles it additionally includes all leading white space , which may contain tab characters. Line prefixes are a presentation detail and must not be used to convey content information. [67] s-line-prefix(n,c) ::= c = block-out s-block-line-prefix(n) c = block-in s-block-line-prefix(n) c = flow-out s-flow-line-prefix(n) c = flow-in s-flow-line-prefix(n) [68] s-block-line-prefix(n) ::= s-indent(n) [69] s-flow-line-prefix(n) ::= s-indent(n) s-separate-in-line ? Example 6.4. Line Prefixes plain: text ··lines quoted: \"text ·· lines\" block: | ··text ··· lines Legend: s-flow-line-prefix(n) s-block-line-prefix(n) s-indent(n) %YAML 1.2 --- !!map { ? !!str \"plain\" : !!str \"text lines\", ? !!str \"quoted\" : !!str \"text lines\", ? !!str \"block\" : !!str \"text\\n· lines\\n\", } 6.4. Empty Lines An empty line line consists of the non- content prefix followed by a line break . [70] l-empty(n,c) ::= ( s-line-prefix(n,c) | s-indent(<n) ) b-as-line-feed The semantics of empty lines depend on the scalar style they appear in. This is handled on a case-by-case basis by the relevant productions. Example 6.5. Empty Lines Folding: \"Empty line ··· as a line feed\" Chomping: | Clipped empty lines · Legend: l-empty(n,c) %YAML 1.2 --- !!map { ? !!str \"Folding\" : !!str \"Empty line\\nas a line feed\", ? !!str \"Chomping\" : !!str \"Clipped empty lines\\n\", } 6.5. Line Folding Line folding allows long lines to be broken for readability, while retaining the semantics of the original long line. If a line break is followed by an empty line , it is trimmed; the first line break is discarded and the rest are retained as content . [71] b-l-trimmed(n,c) ::= b-non-content l-empty(n,c) + Otherwise (the following line is not empty ), the line break is converted to a single space ( #x20). [72] b-as-space ::= b-break A folded non- empty line may end with either of the above line breaks . [73] b-l-folded(n,c) ::= b-l-trimmed(n,c) | b-as-space Example 6.6. Line Folding >- trimmed ·· · as space %YAML 1.2 --- !!str \"trimmed\\n\\n\\nas space\" Legend: b-l-trimmed(n,c) b-as-space The above rules are common to both the folded block style and the scalar flow styles . Folding does distinguish between these cases in the following way: Block Folding In the folded block style , the final line break and trailing empty lines are subject to chomping , and are never folded. In addition, folding does not apply to line breaks surrounding text lines that contain leading white space . Note that such a more-indented line may consist only of such leading white space . The combined effect of the block line folding rules is that each “ paragraph” is interpreted as a line, empty lines are interpreted as a line feed, and the formatting of more-indented lines is preserved. Example 6.7. Block Folding > ··foo · · ·· ·bar ··baz %YAML 1.2 --- !!str \"foo \\n\\n\\t bar\\n\\nbaz\\n\" Legend: b-l-folded(n,c) Non-content spaces Content spaces Flow Folding Folding in flow styles provides more relaxed semantics. Flow styles typically depend on explicit indicators rather than indentation to convey structure. Hence spaces preceding or following the text in a line are a presentation detail and must not be used to convey content information. Once all such spaces have been discarded, all line breaks are folded, without exception. The combined effect of the flow line folding rules is that each “ paragraph” is interpreted as a line, empty lines are interpreted as line feeds, and text can be freely more-indented without affecting the content information. [74] s-flow-folded(n) ::= s-separate-in-line ? b-l-folded(n,flow-in) s-flow-line-prefix(n) Example 6.8. Flow Folding \" ··foo · · ·· ·bar ··baz \" %YAML 1.2 --- !!str \" foo\\nbar\\nbaz \" Legend: s-flow-folded(n) Non-content spaces 6.6. Comments An explicit comment is marked by a “ #” indicator. Comments are a presentation detail and must not be used to convey content information. Comments must be separated from other tokens by white space characters. To ensure JSON compatibility , YAML processors must allow for the omission of the final comment line break of the input stream . However, as this confuses many tools, YAML processors should terminate the stream with an explicit line break on output. [75] c-nb-comment-text ::= “ #” nb-char * [76] b-comment ::= b-non-content | /* End of file */ [77] s-b-comment ::= ( s-separate-in-line c-nb-comment-text ? )? b-comment Example 6.9. Separated Comment key: ···· # Comment value eof Legend: c-nb-comment-text b-comment s-b-comment %YAML 1.2 --- !!map { ? !!str \"key\" : !!str \"value\", } Outside scalar content , comments may appear on a line of their own, independent of the indentation level. Note that outside scalar content , a line containing only white space characters is taken to be a comment line. [78] l-comment ::= s-separate-in-line c-nb-comment-text ? b-comment Example 6.10. Comment Lines ·· # Comment ··· # This stream contains no # documents, only comments. Legend: s-b-comment l-comment In most cases, when a line may end with a comment, YAML allows it to be followed by additional comment lines. The only exception is a comment ending a block scalar header . [79] s-l-comments ::= ( s-b-comment | /* Start of line */ ) l-comment * Example 6.11. Multi-Line Comments key: ····# Comment ········# lines value %YAML 1.2 --- !!map { ? !!str \"key\" : !!str \"value\", } Legend: s-b-comment l-comment s-l-comments 6.7. Separation Lines Implicit keys are restricted to a single line. In all other cases, YAML allows tokens to be separated by multi-line (possibly empty) comments . Note that structures following multi-line comment separation must be properly indented , even though there is no such restriction on the separation comment lines themselves. [80] s-separate(n,c) ::= c = block-out s-separate-lines(n) c = block-in s-separate-lines(n) c = flow-out s-separate-lines(n) c = flow-in s-separate-lines(n) c = block-key s-separate-in-line c = flow-key s-separate-in-line [81] s-separate-lines(n) ::= ( s-l-comments s-flow-line-prefix(n) ) | s-separate-in-line Example 6.12. Separation Spaces { ·first: ·Sammy, ·last: ·Sosa ·}: # Statistics: ··hr: ··# Home runs ·····65 ··avg: ·# Average ···0.278 Legend: s-separate-in-line s-separate-lines(n) s-indent(n) %YAML 1.2 --- !!map { ? !!map { ? !!str \"first\" : !!str \"Sammy\", ? !!str \"last\" : !!str \"Sosa\", } : !!map { ? !!str \"hr\" : !!int \"65\", ? !!str \"avg\" : !!float \"0.278\", }, } 6.8. Directives Directives are instructions to the YAML processor . This specification defines two directives, “ YAML” and “ TAG” , and reserves all other directives for future use. There is no way to define private directives. This is intentional. Directives are a presentation detail and must not be used to convey content information. [82] l-directive ::= “ %” ( ns-yaml-directive | ns-tag-directive | ns-reserved-directive ) s-l-comments Each directive is specified on a separate non- indented line starting with the “ %” indicator, followed by the directive name and a list of parameters. The semantics of these parameters depends on the specific directive. A YAML processor should ignore unknown directives with an appropriate warning. [83] ns-reserved-directive ::= ns-directive-name ( s-separate-in-line ns-directive-parameter )* [84] ns-directive-name ::= ns-char + [85] ns-directive-parameter ::= ns-char + Example 6.13. Reserved Directives % FOO bar baz # Should be ignored # with a warning. --- \"foo\" %YAML 1.2 --- !!str \"foo\" Legend: ns-reserved-directive ns-directive-name ns-directive-parameter 6.8.1. “ YAML” Directives The “ YAML” directive specifies the version of YAML the document conforms to. This specification defines version “ 1.2”, including recommendations for YAML 1.1 processing. A version 1.2 YAML processor must accept documents with an explicit “ %YAML 1.2” directive, as well as documents lacking a “ YAML” directive. Such documents are assumed to conform to the 1.2 version specification. Documents with a “ YAML” directive specifying a higher minor version (e.g. “ %YAML 1.3”) should be processed with an appropriate warning. Documents with a “ YAML” directive specifying a higher major version (e.g. “ %YAML 2.0”) should be rejected with an appropriate error message. A version 1.2 YAML processor must also accept documents with an explicit “ %YAML 1.1” directive. Note that version 1.2 is mostly a superset of version 1.1, defined for the purpose of ensuring JSON compatibility. Hence a version 1.2 processor should process version 1.1 documents as if they were version 1.2, giving a warning on points of incompatibility (handling of non-ASCII line breaks , as described above ). [86] ns-yaml-directive ::= “ Y” “ A” “ M” “ L” s-separate-in-line ns-yaml-version [87] ns-yaml-version ::= ns-dec-digit + “ .” ns-dec-digit + Example 6.14. “ YAML” directive % YAML 1.3 # Attempt parsing # with a warning --- \"foo\" %YAML 1.2 --- !!str \"foo\" Legend: ns-yaml-directive ns-yaml-version It is an error to specify more than one “ YAML” directive for the same document, even if both occurrences give the same version number. Example 6.15. Invalid Repeated YAML directive %YAML 1.2 % YAML 1.1 foo ERROR: The YAML directive must only be given at most once per document. 6.8.2. “ TAG” Directives The “ TAG” directive establishes a tag shorthand notation for specifying node tags . Each “ TAG” directive associates a handle with a prefix . This allows for compact and readable tag notation. [88] ns-tag-directive ::= “ T” “ A” “ G” s-separate-in-line c-tag-handle s-separate-in-line ns-tag-prefix Example 6.16. “ TAG” directive % TAG !yaml! tag:yaml.org,2002: --- !yaml!str \"foo\" %YAML 1.2 --- !!str \"foo\" Legend: ns-tag-directive c-tag-handle ns-tag-prefix It is an error to specify more than one “ TAG” directive for the same handle in the same document, even if both occurrences give the same prefix . Example 6.17. Invalid Repeated TAG directive %TAG ! !foo %TAG ! !foo bar ERROR: The TAG directive must only be given at most once per handle in the same document. 6.8.2.1. Tag Handles The tag handle exactly matches the prefix of the affected tag shorthand . There are three tag handle variants: [89] c-tag-handle ::= c-named-tag-handle | c-secondary-tag-handle | c-primary-tag-handle Primary Handle The primary tag handle is a single “ !” character. This allows using the most compact possible notation for a single “ primary” name space. By default, the prefix associated with this handle is “ !” . Thus, by default, shorthands using this handle are interpreted as local tags . It is possible to override the default behavior by providing an explicit “ TAG” directive, associating a different prefix for this handle. This provides smooth migration from using local tags to using global tags , by the simple addition of a single “ TAG” directive. [90] c-primary-tag-handle ::= “ !” Example 6.18. Primary Tag Handle # Private !foo \"bar\" ... # Global %TAG ! tag:example.com,2000:app/ --- !foo \"bar\" %YAML 1.2 --- !<!foo> \"bar\" ... --- !<tag:example.com,2000:app/foo> \"bar\" Legend: c-primary-tag-handle Secondary Handle The secondary tag handle is written as “ !!”. This allows using a compact notation for a single “ secondary” name space. By default, the prefix associated with this handle is “ tag:yaml.org,2002:”. This prefix is used by the YAML tag repository . It is possible to override this default behavior by providing an explicit “ TAG” directive associating a different prefix for this handle. [91] c-secondary-tag-handle ::= “ !” “ !” Example 6.19. Secondary Tag Handle %TAG !! tag:example.com,2000:app/ --- !!int 1 - 3 # Interval, not integer Legend: c-secondary-tag-handle %YAML 1.2 --- !<tag:example.com,2000:app/int> \"1 - 3\" Named Handles A named tag handle surrounds a non-empty name with “ !” characters. A handle name must not be used in a tag shorthand unless an explicit “ TAG” directive has associated some prefix with it. The name of the handle is a presentation detail and must not be used to convey content information. In particular, the YAML processor need not preserve the handle name once parsing is completed. [92] c-named-tag-handle ::= “ !” ns-word-char + “ !” Example 6.20. Tag Handles %TAG !e! tag:example.com,2000:app/ --- !e!foo \"bar\" Legend: c-named-tag-handle %YAML 1.2 --- !<tag:example.com,2000:app/foo> \"bar\" 6.8.2.2. Tag Prefixes There are two tag prefix variants: [93] ns-tag-prefix ::= c-ns-local-tag-prefix | ns-global-tag-prefix Local Tag Prefix If the prefix begins with a “ !” character, shorthands using the handle are expanded to a local tag . Note that such a tag is intentionally not a valid URI, and its semantics are specific to the application . In particular, two documents in the same stream may assign different semantics to the same local tag . [94] c-ns-local-tag-prefix ::= “ !” ns-uri-char * Example 6.21. Local Tag Prefix %TAG !m! !my- --- # Bulb here !m!light fluorescent ... %TAG !m! !my- --- # Color here !m!light green Legend: c-ns-local-tag-prefix %YAML 1.2 --- !<!my-light> \"fluorescent\" ... %YAML 1.2 --- !<!my-light> \"green\" Global Tag Prefix If the prefix begins with a character other than “ !” , it must to be a valid URI prefix, and should contain at least the scheme and the authority. Shorthands using the associated handle are expanded to globally unique URI tags, and their semantics is consistent across applications . In particular, every documents in every stream must assign the same semantics to the same global tag . [95] ns-global-tag-prefix ::= ns-tag-char ns-uri-char * Example 6.22. Global Tag Prefix %TAG !e! tag:example.com,2000:app/ --- - !e!foo \"bar\" Legend: ns-global-tag-prefix %YAML 1.2 --- !<tag:example.com,2000:app/foo> \"bar\" 6.9. Node Properties Each node may have two optional properties, anchor and tag , in addition to its content . Node properties may be specified in any order before the node’s content . Either or both may be omitted. [96] c-ns-properties(n,c) ::= ( c-ns-tag-property ( s-separate(n,c) c-ns-anchor-property )? ) | ( c-ns-anchor-property ( s-separate(n,c) c-ns-tag-property )? ) Example 6.23. Node Properties !!str &a1 \"foo\": !!str bar &a2 baz : *a1 Legend: c-ns-properties(n,c) c-ns-anchor-property c-ns-tag-property %YAML 1.2 --- !!map { ? &B1 !!str \"foo\" : !!str \"bar\", ? !!str \"baz\" : *B1, } 6.9.1. Node Tags The tag property identifies the type of the native data structure presented by the node . A tag is denoted by the “ !” indicator. [97] c-ns-tag-property ::= c-verbatim-tag | c-ns-shorthand-tag | c-non-specific-tag Verbatim Tags A tag may be written verbatim by surrounding it with the “ <” and “ >” characters. In this case, the YAML processor must deliver the verbatim tag as-is to the application . In particular, verbatim tags are not subject to tag resolution . A verbatim tag must either begin with a “ !” (a local tag ) or be a valid URI (a global tag ). [98] c-verbatim-tag ::= “ !” “ <” ns-uri-char + “ >” Example 6.24. Verbatim Tags !<tag:yaml.org,2002:str> foo : !<!bar> baz Legend: c-verbatim-tag %YAML 1.2 --- !!map { ? !<tag:yaml.org,2002:str> \"foo\" : !<!bar> \"baz\", } Example 6.25. Invalid Verbatim Tags - !< !> foo - !< $:?> bar ERROR: - Verbatim tags aren't resolved, so ! is invalid. - The $:? tag is neither a global URI tag nor a local tag starting with “ !”. Tag Shorthands A tag shorthand consists of a valid tag handle followed by a non-empty suffix. The tag handle must be associated with a prefix , either by default or by using a “ TAG” directive . The resulting parsed tag is the concatenation of the prefix and the suffix, and must either begin with “ !” (a local tag ) or be a valid URI (a global tag ). The choice of tag handle is a presentation detail and must not be used to convey content information. In particular, the tag handle may be discarded once parsing is completed. The suffix must not contain any “ !” character. This would cause the tag shorthand to be interpreted as having a named tag handle . In addition, the suffix must not contain the “ [” , “ ]” , “ {” , “ }” and “ ,” characters. These characters would cause ambiguity with flow collection structures. If the suffix needs to specify any of the above restricted characters, they must be escaped using the “ %” character. This behavior is consistent with the URI character escaping rules (specifically, section 2.3 of RFC2396 ). [99] c-ns-shorthand-tag ::= c-tag-handle ns-tag-char + Example 6.26. Tag Shorthands %TAG !e! tag:example.com,2000:app/ --- - !local foo - !!str bar - !e!tag%21 baz Legend: c-ns-shorthand-tag %YAML 1.2 --- !!seq [ !<!local> \"foo\", !<tag:yaml.org,2002:str> \"bar\", !<tag:example.com,2000:app/tag!> \"baz\" ] Example 6.27. Invalid Tag Shorthands %TAG !e! tag:example,2000:app/ --- - !e! foo - !h!bar baz ERROR: - The !o! handle has no suffix. - The !h! handle wasn't declared. Non-Specific Tags If a node has no tag property, it is assigned a non-specific tag that needs to be resolved to a specific one. This non-specific tag is “ !” for non- plain scalars and “ ?” for all other nodes . This is the only case where the node style has any effect on the content information. It is possible for the tag property to be explicitly set to the “ !” non-specific tag . By convention , this “ disables” tag resolution , forcing the node to be interpreted as “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map”, or “ tag:yaml.org,2002:str”, according to its kind . There is no way to explicitly specify the “ ?” non-specific tag. This is intentional. [100] c-non-specific-tag ::= “ !” Example 6.28. Non-Specific Tags # Assuming conventional resolution: - \"12\" - 12 - ! 12 Legend: c-non-specific-tag %YAML 1.2 --- !!seq [ !<tag:yaml.org,2002:str> \"12\", !<tag:yaml.org,2002:int> \"12\", !<tag:yaml.org,2002:str> \"12\", ] 6.9.2. Node Anchors An anchor is denoted by the “ &” indicator. It marks a node for future reference. An alias node can then be used to indicate additional inclusions of the anchored node . An anchored node need not be referenced by any alias nodes ; in particular, it is valid for all nodes to be anchored. [101] c-ns-anchor-property ::= “ &” ns-anchor-name Note that as a serialization detail , the anchor name is preserved in the serialization tree . However, it is not reflected in the representation graph and must not be used to convey content information. In particular, the YAML processor need not preserve the anchor name once the representation is composed . Anchor names must not contain the “ [” , “ ]” , “ {” , “ }” and “ ,” characters. These characters would cause ambiguity with flow collection structures. [102] ns-anchor-char ::= ns-char - c-flow-indicator [103] ns-anchor-name ::= ns-anchor-char + Example 6.29. Node Anchors First occurrence: & anchor Value Second occurrence: * anchor Legend: c-ns-anchor-property ns-anchor-name %YAML 1.2 --- !!map { ? !!str \"First occurrence\" : &A !!str \"Value\", ? !!str \"Second occurrence\" : *A, } Chapter 7. Flow Styles YAML’s flow styles can be thought of as the natural extension of JSON to cover folding long content lines for readability, tagging nodes to control construction of native data structures , and using anchors and aliases to reuse constructed object instances. 7.1. Alias Nodes Subsequent occurrences of a previously serialized node are presented as alias nodes. The first occurrence of the node must be marked by an anchor to allow subsequent occurrences to be presented as alias nodes. An alias node is denoted by the “ *” indicator. The alias refers to the most recent preceding node having the same anchor . It is an error for an alias node to use an anchor that does not previously occur in the document . It is not an error to specify an anchor that is not used by any alias node. Note that an alias node must not specify any properties or content , as these were already specified at the first occurrence of the node . [104] c-ns-alias-node ::= “ *” ns-anchor-name Example 7.1. Alias Nodes First occurrence: & anchor Foo Second occurrence: * anchor Override anchor: & anchor Bar Reuse anchor: * anchor Legend: c-ns-alias-node ns-anchor-name %YAML 1.2 --- !!map { ? !!str \"First occurrence\" : &A !!str \"Foo\", ? !!str \"Override anchor\" : &B !!str \"Bar\", ? !!str \"Second occurrence\" : *A, ? !!str \"Reuse anchor\" : *B, } 7.2. Empty Nodes YAML allows the node content to be omitted in many cases. Nodes with empty content are interpreted as if they were plain scalars with an empty value. Such nodes are commonly resolved to a “ null” value. [105] e-scalar ::= /* Empty */ In the examples, empty scalars are sometimes displayed as the glyph “ °” for clarity. Note that this glyph corresponds to a position in the characters stream rather than to an actual character. Example 7.2. Empty Content { foo : !!str °, !!str ° : bar, } Legend: e-scalar %YAML 1.2 --- !!map { ? !!str \"foo\" : !!str \"\", ? !!str \"\" : !!str \"bar\", } Both the node’s properties and node content are optional. This allows for a completely empty node. Completely empty nodes are only valid when following some explicit indication for their existence. [106] e-node ::= e-scalar Example 7.3. Completely Empty Flow Nodes { ? foo : °, °: bar, } Legend: e-node %YAML 1.2 --- !!map { ? !!str \"foo\" : !!null \"\", ? !!null \"\" : !!str \"bar\", } 7.3. Flow Scalar Styles YAML provides three flow scalar styles: double-quoted , single-quoted and plain (unquoted). Each provides a different trade-off between readability and expressive power. The scalar style is a presentation detail and must not be used to convey content information, with the exception that plain scalars are distinguished for the purpose of tag resolution . 7.3.1. Double-Quoted Style The double-quoted style is specified by surrounding “ \"” indicators. This is the only style capable of expressing arbitrary strings, by using “ \\” escape sequences . This comes at the cost of having to escape the “ \\” and “ \"” characters. [107] nb-double-char ::= c-ns-esc-char | ( nb-json - “ \\” - “ \"” ) [108] ns-double-char ::= nb-double-char - s-white Double-quoted scalars are restricted to a single line when contained inside an implicit key . [109] c-double-quoted(n,c) ::= “ \"” nb-double-text(n,c) “ \"” [110] nb-double-text(n,c) ::= c = flow-out nb-double-multi-line(n) c = flow-in nb-double-multi-line(n) c = block-key nb-double-one-line c = flow-key nb-double-one-line [111] nb-double-one-line ::= nb-double-char * Example 7.4. Double Quoted Implicit Keys \" implicit block key\" : [ \" implicit flow key\" : value, ] Legend: nb-double-one-line c-double-quoted(n,c) %YAML 1.2 --- !!map { ? !!str \"implicit block key\" : !!seq [ !!map { ? !!str \"implicit flow key\" : !!str \"value\", } ] } In a multi-line double-quoted scalar, line breaks are are subject to flow line folding , which discards any trailing white space characters. It is also possible to escape the line break character. In this case, the line break is excluded from the content , and the trailing white space characters are preserved. Combined with the ability to escape white space characters, this allows double-quoted lines to be broken at arbitrary positions. [112] s-double-escaped(n) ::= s-white * “ \\” b-non-content l-empty(n,flow-in) * s-flow-line-prefix(n) [113] s-double-break(n) ::= s-double-escaped(n) | s-flow-folded(n) Example 7.5. Double Quoted Line Breaks \"folded · to a space, · to a line feed, or · \\ ·\\· non-content\" %YAML 1.2 --- !!str \"folded to a space,\\n\\ to a line feed, \\ or \\t \\tnon-content\" Legend: s-flow-folded(n) s-double-escaped(n) All leading and trailing white space characters are excluded from the content . Each continuation line must therefore contain at least one non- space character. Empty lines, if any, are consumed as part of the line folding . [114] nb-ns-double-in-line ::= ( s-white * ns-double-char )* [115] s-double-next-line(n) ::= s-double-break(n) ( ns-double-char nb-ns-double-in-line ( s-double-next-line(n) | s-white * ) )? [116] nb-double-multi-line(n) ::= nb-ns-double-in-line ( s-double-next-line(n) | s-white * ) Example 7.6. Double Quoted Lines \" ·1st non-empty · 2nd non-empty · 3rd non-empty·\" %YAML 1.2 --- !!str \" 1st non-empty\\n\\ 2nd non-empty \\ 3rd non-empty \" Legend: nb-ns-double-in-line s-double-next-line(n) 7.3.2. Single-Quoted Style The single-quoted style is specified by surrounding “ '” indicators. Therefore, within a single-quoted scalar, such characters need to be repeated. This is the only form of escaping performed in single-quoted scalars. In particular, the “ \\” and “ \"” characters may be freely used. This restricts single-quoted scalars to printable characters. In addition, it is only possible to break a long single-quoted line where a space character is surrounded by non- spaces . [117] c-quoted-quote ::= “ '” “ '” [118] nb-single-char ::= c-quoted-quote | ( nb-json - “ '” ) [119] ns-single-char ::= nb-single-char - s-white Example 7.7. Single Quoted Characters 'here ''s to \"quotes\"' Legend: c-quoted-quote %YAML 1.2 --- !!str \"here's to \\\"quotes\\\"\" Single-quoted scalars are restricted to a single line when contained inside a implicit key . [120] c-single-quoted(n,c) ::= “ '” nb-single-text(n,c) “ '” [121] nb-single-text(n,c) ::= c = flow-out nb-single-multi-line(n) c = flow-in nb-single-multi-line(n) c = block-key nb-single-one-line c = flow-key nb-single-one-line [122] nb-single-one-line ::= nb-single-char * Example 7.8. Single Quoted Implicit Keys ' implicit block key' : [ ' implicit flow key' : value, ] Legend: nb-single-one-line c-single-quoted(n,c) %YAML 1.2 --- !!map { ? !!str \"implicit block key\" : !!seq [ !!map { ? !!str \"implicit flow key\" : !!str \"value\", } ] } All leading and trailing white space characters are excluded from the content . Each continuation line must therefore contain at least one non- space character. Empty lines, if any, are consumed as part of the line folding . [123] nb-ns-single-in-line ::= ( s-white * ns-single-char )* [124] s-single-next-line(n) ::= s-flow-folded(n) ( ns-single-char nb-ns-single-in-line ( s-single-next-line(n) | s-white * ) )? [125] nb-single-multi-line(n) ::= nb-ns-single-in-line ( s-single-next-line(n) | s-white * ) Example 7.9. Single Quoted Lines ' ·1st non-empty · 2nd non-empty · 3rd non-empty·' %YAML 1.2 --- !!str \" 1st non-empty\\n\\ 2nd non-empty \\ 3rd non-empty \" Legend: nb-ns-single-in-line(n) s-single-next-line(n) 7.3.3. Plain Style The plain (unquoted) style has no identifying indicators and provides no form of escaping. It is therefore the most readable, most limited and most context sensitive style . In addition to a restricted character set, a plain scalar must not be empty, or contain leading or trailing white space characters. It is only possible to break a long plain line where a space character is surrounded by non- spaces . Plain scalars must not begin with most indicators , as this would cause ambiguity with other YAML constructs. However, the “ :” , “ ?” and “ -” indicators may be used as the first character if followed by a non- space “ safe” character, as this causes no ambiguity. [126] ns-plain-first(c) ::= ( ns-char - c-indicator ) | ( ( “ ?” | “ :” | “ -” ) /* Followed by an ns-plain-safe(c) ) */ ) Plain scalars must never contain the “ : ” and “ #” character combinations. Such combinations would cause ambiguity with mapping key: value pairs and comments . In addition, inside flow collections , or when used as implicit keys , plain scalars must not contain the “ [” , “ ]” , “ {” , “ }” and “ ,” characters. These characters would cause ambiguity with flow collection structures. [127] ns-plain-safe(c) ::= c = flow-out ns-plain-safe-out c = flow-in ns-plain-safe-in c = block-key ns-plain-safe-out c = flow-key ns-plain-safe-in [128] ns-plain-safe-out ::= ns-char [129] ns-plain-safe-in ::= ns-char - c-flow-indicator [130] ns-plain-char(c) ::= ( ns-plain-safe(c) - “ :” - “ #” ) | ( /* An ns-char preceding */ “ #” ) | ( “ :” /* Followed by an ns-plain-safe(c) */ ) Example 7.10. Plain Characters # Outside flow collection: - : :vector - \" : - ()\" - Up , up, and away! - -123 - http ://example.com/foo #bar # Inside flow collection: - [ : :vector, \" : - ()\", \"Up , up and away!\", -123, http ://example.com/foo #bar ] %YAML 1.2 --- !!seq [ !!str \"::vector\", !!str \": - ()\", !!str \"Up, up, and away!\", !!int \"-123\", !!str \"http://example.com/foo#bar\", !!seq [ !!str \"::vector\", !!str \": - ()\", !!str \"Up, up, and away!\", !!int \"-123\", !!str \"http://example.com/foo#bar\", ], ] Legend: ns-plain-first(c) Not ns-plain-first(c) ns-plain-char(c) Not ns-plain-char(c) Plain scalars are further restricted to a single line when contained inside an implicit key . [131] ns-plain(n,c) ::= c = flow-out ns-plain-multi-line(n,c) c = flow-in ns-plain-multi-line(n,c) c = block-key ns-plain-one-line(c) c = flow-key ns-plain-one-line(c) [132] nb-ns-plain-in-line(c) ::= ( s-white * ns-plain-char(c) )* [133] ns-plain-one-line(c) ::= ns-plain-first(c) nb-ns-plain-in-line(c) Example 7.11. Plain Implicit Keys implicit block key : [ implicit flow key : value, ] Legend: ns-plain-one-line(c) %YAML 1.2 --- !!map { ? !!str \"implicit block key\" : !!seq [ !!map { ? !!str \"implicit flow key\" : !!str \"value\", } ] } All leading and trailing white space characters are excluded from the content . Each continuation line must therefore contain at least one non- space character. Empty lines, if any, are consumed as part of the line folding . [134] s-ns-plain-next-line(n,c) ::= s-flow-folded(n) ns-plain-char(c) nb-ns-plain-in-line(c) [135] ns-plain-multi-line(n,c) ::= ns-plain-one-line(c) s-ns-plain-next-line(n,c) * Example 7.12. Plain Lines 1st non-empty · 2nd non-empty · 3rd non-empty %YAML 1.2 --- !!str \"1st non-empty\\n\\ 2nd non-empty \\ 3rd non-empty\" Legend: nb-ns-plain-in-line(c) s-ns-plain-next-line(n,c) 7.4. Flow Collection Styles A flow collection may be nested within a block collection ( flow-out context ), nested within another flow collection ( flow-in context ), or be a part of an implicit key ( flow-key context or block-key context ). Flow collection entries are terminated by the “ ,” indicator. The final “ ,” may be omitted. This does not cause ambiguity because flow collection entries can never be completely empty . [136] in-flow(c) ::= c = flow-out flow-in c = flow-in flow-in c = block-key flow-key c = flow-key flow-key 7.4.1. Flow Sequences Flow sequence content is denoted by surrounding “ [” and “ ]” characters. [137] c-flow-sequence(n,c) ::= “ [” s-separate(n,c) ? ns-s-flow-seq-entries(n, in-flow(c) ) ? “ ]” Sequence entries are separated by a “ ,” character. [138] ns-s-flow-seq-entries(n,c) ::= ns-flow-seq-entry(n,c) s-separate(n,c) ? ( “ ,” s-separate(n,c) ? ns-s-flow-seq-entries(n,c) ? )? Example 7.13. Flow Sequence - [ one, two, ] - [ three , four ] Legend: c-sequence-start c-sequence-end ns-flow-seq-entry(n,c) %YAML 1.2 --- !!seq [ !!seq [ !!str \"one\", !!str \"two\", ], !!seq [ !!str \"three\", !!str \"four\", ], ] Any flow node may be used as a flow sequence entry. In addition, YAML provides a compact notation for the case where a flow sequence entry is a mapping with a single key: value pair . [139] ns-flow-seq-entry(n,c) ::= ns-flow-pair(n,c) | ns-flow-node(n,c) Example 7.14. Flow Sequence Entries [ \"double quoted\", 'single quoted', plain text, [ nested ], single: pair, ] Legend: ns-flow-node(n,c) ns-flow-pair(n,c) %YAML 1.2 --- !!seq [ !!str \"double quoted\", !!str \"single quoted\", !!str \"plain text\", !!seq [ !!str \"nested\", ], !!map { ? !!str \"single\" : !!str \"pair\", }, ] 7.4.2. Flow Mappings Flow mappings are denoted by surrounding “ {” and “ }” characters. [140] c-flow-mapping(n,c) ::= “ {” s-separate(n,c) ? ns-s-flow-map-entries(n, in-flow(c) ) ? “ }” Mapping entries are separated by a “ ,” character. [141] ns-s-flow-map-entries(n,c) ::= ns-flow-map-entry(n,c) s-separate(n,c) ? ( “ ,” s-separate(n,c) ? ns-s-flow-map-entries(n,c) ? )? Example 7.15. Flow Mappings - { one : two , three: four , } - { five: six, seven : eight } Legend: c-mapping-start c-mapping-end ns-flow-map-entry(n,c) %YAML 1.2 --- !!seq [ !!map { ? !!str \"one\" : !!str \"two\", ? !!str \"three\" : !!str \"four\", }, !!map { ? !!str \"five\" : !!str \"six\", ? !!str \"seven\" : !!str \"eight\", }, ] If the optional “ ?” mapping key indicator is specified, the rest of the entry may be completely empty . [142] ns-flow-map-entry(n,c) ::= ( “ ?” s-separate(n,c) ns-flow-map-explicit-entry(n,c) ) | ns-flow-map-implicit-entry(n,c) [143] ns-flow-map-explicit-entry(n,c) ::= ns-flow-map-implicit-entry(n,c) | ( e-node /* Key */ e-node /* Value */ ) Example 7.16. Flow Mapping Entries { ? explicit: entry, implicit: entry, ? ° ° } Legend: ns-flow-map-explicit-entry(n,c) ns-flow-map-implicit-entry(n,c) e-node %YAML 1.2 --- !!map { ? !!str \"explicit\" : !!str \"entry\", ? !!str \"implicit\" : !!str \"entry\", ? !!null \"\" : !!null \"\", } Normally, YAML insists the “ :” mapping value indicator be separated from the value by white space . A benefit of this restriction is that the “ :” character can be used inside plain scalars , as long as it is not followed by white space . This allows for unquoted URLs and timestamps. It is also a potential source for confusion as “ a:1” is a plain scalar and not a key: value pair . Note that the value may be completely empty since its existence is indicated by the “ :”. [144] ns-flow-map-implicit-entry(n,c) ::= ns-flow-map-yaml-key-entry(n,c) | c-ns-flow-map-empty-key-entry(n,c) | c-ns-flow-map-json-key-entry(n,c) [145] ns-flow-map-yaml-key-entry(n,c) ::= ns-flow-yaml-node(n,c) ( ( s-separate(n,c) ? c-ns-flow-map-separate-value(n,c) ) | e-node ) [146] c-ns-flow-map-empty-key-entry(n,c) ::= e-node /* Key */ c-ns-flow-map-separate-value(n,c) [147] c-ns-flow-map-separate-value(n,c) ::= “ :” /* Not followed by an ns-plain-safe(c) */ ( ( s-separate(n,c) ns-flow-node(n,c) ) | e-node /* Value */ ) Example 7.17. Flow Mapping Separate Values { unquoted· :·\"separate\", http://foo.com, omitted value : °, ° :·omitted key, } Legend: ns-flow-yaml-node(n,c) e-node c-ns-flow-map-separate-value(n,c) %YAML 1.2 --- !!map { ? !!str \"unquoted\" : !!str \"separate\", ? !!str \"http://foo.com\" : !!null \"\", ? !!str \"omitted value\" : !!null \"\", ? !!null \"\" : !!str \"omitted key\", } To ensure JSON compatibility , if a key inside a flow mapping is JSON-like , YAML allows the following value to be specified adjacent to the “ :”. This causes no ambiguity, as all JSON-like keys are surrounded by indicators . However, as this greatly reduces readability, YAML processors should separate the value from the “ :” on output, even in this case. [148] c-ns-flow-map-json-key-entry(n,c) ::= c-flow-json-node(n,c) ( ( s-separate(n,c) ? c-ns-flow-map-adjacent-value(n,c) ) | e-node ) [149] c-ns-flow-map-adjacent-value(n,c) ::= “ :” ( ( s-separate(n,c) ? ns-flow-node(n,c) ) | e-node ) /* Value */ Example 7.18. Flow Mapping Adjacent Values { \"adjacent\": value, \"readable\": ·value, \"empty\": ° } Legend: c-flow-json-node(n,c) e-node c-ns-flow-map-adjacent-value(n,c) %YAML 1.2 --- !!map { ? !!str \"adjacent\" : !!str \"value\", ? !!str \"readable\" : !!str \"value\", ? !!str \"empty\" : !!null \"\", } A more compact notation is usable inside flow sequences , if the mapping contains a single key: value pair. This notation does not require the surrounding “ {” and “ }” characters. Note that it is not possible to specify any node properties for the mapping in this case. Example 7.19. Single Pair Flow Mappings [ foo: bar ] Legend: ns-flow-pair(n,c) %YAML 1.2 --- !!seq [ !!map { ? !!str \"foo\" : !!str \"bar\" } ] If the “ ?” indicator is explicitly specified, parsing is unambiguous, and the syntax is identical to the general case. [150] ns-flow-pair(n,c) ::= ( “ ?” s-separate(n,c) ns-flow-map-explicit-entry(n,c) ) | ns-flow-pair-entry(n,c) Example 7.20. Single Pair Explicit Entry [ ? foo bar : baz ] Legend: ns-flow-map-explicit-entry(n,c) %YAML 1.2 --- !!seq [ !!map { ? !!str \"foo bar\" : !!str \"baz\", }, ] If the “ ?” indicator is omitted, parsing needs to see past the implicit key to recognize it as such. To limit the amount of lookahead required, the “ :” indicator must appear at most 1024 Unicode characters beyond the start of the key . In addition, the key is restricted to a single line. Note that YAML allows arbitrary nodes to be used as keys . In particular, a key may be a sequence or a mapping . Thus, without the above restrictions, practical one-pass parsing would have been impossible to implement. [151] ns-flow-pair-entry(n,c) ::= ns-flow-pair-yaml-key-entry(n,c) | c-ns-flow-map-empty-key-entry(n,c) | c-ns-flow-pair-json-key-entry(n,c) [152] ns-flow-pair-yaml-key-entry(n,c) ::= ns-s-implicit-yaml-key(flow-key) c-ns-flow-map-separate-value(n,c) [153] c-ns-flow-pair-json-key-entry(n,c) ::= c-s-implicit-json-key(flow-key) c-ns-flow-map-adjacent-value(n,c) [154] ns-s-implicit-yaml-key(c) ::= ns-flow-yaml-node(n/a,c) s-separate-in-line ? /* At most 1024 characters altogether */ [155] c-s-implicit-json-key(c) ::= c-flow-json-node(n/a,c) s-separate-in-line ? /* At most 1024 characters altogether */ Example 7.21. Single Pair Implicit Entries - [ YAML· : separate ] - [ ° : empty key entry ] - [ {JSON: like} :adjacent ] Legend: ns-s-implicit-yaml-key c-s-implicit-json-key e-node Value %YAML 1.2 --- !!seq [ !!seq [ !!map { ? !!str \"YAML\" : !!str \"separate\" }, ], !!seq [ !!map { ? !!null \"\" : !!str \"empty key entry\" }, ], !!seq [ !!map { ? !!map { ? !!str \"JSON\" : !!str \"like\" } : \"adjacent\", }, ], ] Example 7.22. Invalid Implicit Keys [ foo bar: invalid, \"foo ...>1K characters...bar\": invalid ] ERROR: - The foo bar key spans multiple lines - The foo...bar key is too long 7.5. Flow Nodes JSON-like flow styles all have explicit start and end indicators . The only flow style that does not have this property is the plain scalar . Note that none of the “ JSON-like” styles is actually acceptable by JSON. Even the double-quoted style is a superset of the JSON string format. [156] ns-flow-yaml-content(n,c) ::= ns-plain(n,c) [157] c-flow-json-content(n,c) ::= c-flow-sequence(n,c) | c-flow-mapping(n,c) | c-single-quoted(n,c) | c-double-quoted(n,c) [158] ns-flow-content(n,c) ::= ns-flow-yaml-content(n,c) | c-flow-json-content(n,c) Example 7.23. Flow Content - [ a, b ] - { a: b } - \"a\" - 'b' - c Legend: c-flow-json-content(n,c) ns-flow-yaml-content(n,c) %YAML 1.2 --- !!seq [ !!seq [ !!str \"a\", !!str \"b\" ], !!map { ? !!str \"a\" : !!str \"b\" }, !!str \"a\", !!str \"b\", !!str \"c\", ] A complete flow node also has optional node properties , except for alias nodes which refer to the anchored node properties . [159] ns-flow-yaml-node(n,c) ::= c-ns-alias-node | ns-flow-yaml-content(n,c) | ( c-ns-properties(n,c) ( ( s-separate(n,c) ns-flow-yaml-content(n,c) ) | e-scalar ) ) [160] c-flow-json-node(n,c) ::= ( c-ns-properties(n,c) s-separate(n,c) )? c-flow-json-content(n,c) [161] ns-flow-node(n,c) ::= c-ns-alias-node | ns-flow-content(n,c) | ( c-ns-properties(n,c) ( ( s-separate(n,c) ns-flow-content(n,c) ) | e-scalar ) ) Example 7.24. Flow Nodes - !!str \"a\" - 'b' - &anchor \"c\" - *anchor - !!str° Legend: c-flow-json-node(n,c) ns-flow-yaml-node(n,c) %YAML 1.2 --- !!seq [ !!str \"a\", !!str \"b\", &A !!str \"c\", *A, !!str \"\", ] Chapter 8. Block Styles YAML’s block styles employ indentation rather than indicators to denote structure. This results in a more human readable (though less compact) notation. 8.1. Block Scalar Styles YAML provides two block scalar styles, literal and folded . Each provides a different trade-off between readability and expressive power. 8.1.1. Block Scalar Headers Block scalars are controlled by a few indicators given in a header preceding the content itself. This header is followed by a non-content line break with an optional comment . This is the only case where a comment must not be followed by additional comment lines. [162] c-b-block-header(m,t) ::= ( ( c-indentation-indicator(m) c-chomping-indicator(t) ) | ( c-chomping-indicator(t) c-indentation-indicator(m) ) ) s-b-comment Example 8.1. Block Scalar Header - | # Empty header literal - > 1 # Indentation indicator ·folded - |+ # Chomping indicator keep - > 1- # Both indicators ·strip %YAML 1.2 --- !!seq [ !!str \"literal\\n\", !!str \"·folded\\n\", !!str \"keep\\n\\n\", !!str \"·strip\", ] Legend: c-b-block-header(m,t) 8.1.1.1. Block Indentation Indicator Typically, the indentation level of a block scalar is detected from its first non- empty line. It is an error for any of the leading empty lines to contain more spaces than the first non- empty line . Detection fails when the first non- empty line contains leading content space characters. Content may safely start with a tab or a “ #” character. When detection would fail, YAML requires that the indentation level for the content be given using an explicit indentation indicator. This level is specified as the integer number of the additional indentation spaces used for the content , relative to its parent node . It is always valid to specify an indentation indicator for a block scalar node, though a YAML processor should only emit an explicit indentation indicator for cases where detection will fail. [163] c-indentation-indicator(m) ::= ns-dec-digit m = ns-dec-digit - #x30 /* Empty */ m = auto-detect() Example 8.2. Block Indentation Indicator - |° ·detected - > ° · ·· ··# detected - |1 ··explicit - > ° · ·detected %YAML 1.2 --- !!seq [ !!str \"detected\\n\", !!str \"\\n\\n# detected\\n\", !!str \"·explicit\\n\", !!str \"\\t·detected\\n\", ] Legend: c-indentation-indicator(m) s-indent(n) Example 8.3. Invalid Block Scalar Indentation Indicators - |· · ·text - > ··text ·text - |2 ·text ERROR: - A leading all-space line must not have too many spaces. - A following text line must not be less indented. - The text is less indented than the indicated level. 8.1.1.2. Block Chomping Indicator Chomping controls how final line breaks and trailing empty lines are interpreted. YAML provides three chomping methods: Strip Stripping is specified by the “ -” chomping indicator. In this case, the final line break and any trailing empty lines are excluded from the scalar’s content . Clip Clipping is the default behavior used if no explicit chomping indicator is specified. In this case, the final line break character is preserved in the scalar’s content . However, any trailing empty lines are excluded from the scalar’s content . Keep Keeping is specified by the “ +” chomping indicator. In this case, the final line break and any trailing empty lines are considered to be part of the scalar’s content . These additional lines are not subject to folding . The chomping method used is a presentation detail and must not be used to convey content information. [164] c-chomping-indicator(t) ::= “ -” t = strip “ +” t = keep /* Empty */ t = clip The interpretation of the final line break of a block scalar is controlled by the chomping indicator specified in the block scalar header . [165] b-chomped-last(t) ::= t = strip b-non-content | /* End of file */ t = clip b-as-line-feed | /* End of file */ t = keep b-as-line-feed | /* End of file */ Example 8.4. Chomping Final Line Break strip: |- text clip: | text keep: |+ text Legend: b-non-content b-as-line-feed %YAML 1.2 --- !!map { ? !!str \"strip\" : !!str \"text\", ? !!str \"clip\" : !!str \"text\\n\", ? !!str \"keep\" : !!str \"text\\n\", } The interpretation of the trailing empty lines following a block scalar is also controlled by the chomping indicator specified in the block scalar header . [166] l-chomped-empty(n,t) ::= t = strip l-strip-empty(n) t = clip l-strip-empty(n) t = keep l-keep-empty(n) [167] l-strip-empty(n) ::= ( s-indent( n) b-non-content )* l-trail-comments(n) ? [168] l-keep-empty(n) ::= l-empty(n,block-in) * l-trail-comments(n) ? Explicit comment lines may follow the trailing empty lines . To prevent ambiguity, the first such comment line must be less indented than the block scalar content . Additional comment lines, if any, are not so restricted. This is the only case where the indentation of comment lines is constrained. [169] l-trail-comments(n) ::= s-indent(<n) c-nb-comment-text b-comment l-comment * Example 8.5. Chomping Trailing Lines # Strip # Comments: strip: |- # text ·· ·# Clip ··# comments: clip: | # text · ·# Keep ··# comments: keep: |+ # text ·# Trail ··# comments. %YAML 1.2 --- !!map { ? !!str \"strip\" : !!str \"# text\", ? !!str \"clip\" : !!str \"# text\\n\", ? !!str \"keep\" : !!str \"# text\\n\", } Legend: l-strip-empty(n) l-keep-empty(n) l-trail-comments(n) If a block scalar consists only of empty lines , then these lines are considered as trailing lines and hence are affected by chomping. Example 8.6. Empty Scalar Chomping strip: >- clip: > keep: |+ Legend: l-strip-empty(n) l-keep-empty(n) %YAML 1.2 --- !!map { ? !!str \"strip\" : !!str \"\", ? !!str \"clip\" : !!str \"\", ? !!str \"keep\" : !!str \"\\n\", } 8.1.2. Literal Style The literal style is denoted by the “ |” indicator. It is the simplest, most restricted, and most readable scalar style . [170] c-l+literal(n) ::= “ |” c-b-block-header(m,t) l-literal-content(n+m,t) Example 8.7. Literal Scalar | ·literal · text Legend: c-l+literal(n) %YAML 1.2 --- !!str \"literal\\n\\ttext\\n\" Inside literal scalars, all ( indented ) characters are considered to be content , including white space characters. Note that all line break characters are normalized . In addition, empty lines are not folded , though final line breaks and trailing empty lines are chomped . There is no way to escape characters inside literal scalars. This restricts them to printable characters. In addition, there is no way to break a long literal line. [171] l-nb-literal-text(n) ::= l-empty(n,block-in) * s-indent(n) nb-char + [172] b-nb-literal-next(n) ::= b-as-line-feed l-nb-literal-text(n) [173] l-literal-content(n,t) ::= ( l-nb-literal-text(n) b-nb-literal-next(n) * b-chomped-last(t) )? l-chomped-empty(n,t) Example 8.8. Literal Content |· ·· ··literal ··· ·· ··text ·# Comment %YAML 1.2 --- !!str \"\\n\\nliteral\\n·\\n\\ntext\\n\" Legend: l-nb-literal-text(n) b-nb-literal-next(n) b-chomped-last(t) l-chomped-empty(n,t) 8.1.3. Folded Style The folded style is denoted by the “ >” indicator. It is similar to the literal style ; however, folded scalars are subject to line folding . [174] c-l+folded(n) ::= “ >” c-b-block-header(m,t) l-folded-content(n+m,t) Example 8.9. Folded Scalar > ·folded ·text %YAML 1.2 --- !!str \"folded text\\n\" Legend: c-l+folded(n) Folding allows long lines to be broken anywhere a single space character separates two non- space characters. [175] s-nb-folded-text(n) ::= s-indent(n) ns-char nb-char * [176] l-nb-folded-lines(n) ::= s-nb-folded-text(n) ( b-l-folded(n,block-in) s-nb-folded-text(n) )* Example 8.10. Folded Lines > ·folded ·line ·next ·line * bullet * list * lines ·last ·line # Comment %YAML 1.2 --- !!str \"\\n\\ folded line\\n\\ next line\\n\\ \\ * bullet\\n \\n\\ \\ * list\\n\\ \\ * lines\\n\\ \\n\\ last line\\n\" Legend: s-nb-folded-text(n) l-nb-folded-lines(n) (The following three examples duplicate this example, each highlighting different productions.) Lines starting with white space characters ( more-indented lines) are not folded . [177] s-nb-spaced-text(n) ::= s-indent(n) s-white nb-char * [178] b-l-spaced(n) ::= b-as-line-feed l-empty(n,block-in) * [179] l-nb-spaced-lines(n) ::= s-nb-spaced-text(n) ( b-l-spaced(n) s-nb-spaced-text(n) )* Example 8.11. More Indented Lines > folded line next line ···* bullet ···* list ···* lines last line # Comment %YAML 1.2 --- !!str \"\\n\\ folded line\\n\\ next line\\n\\ \\ * bullet\\n \\n\\ \\ * list\\n\\ \\ * lines\\n\\ \\n\\ last line\\n\" Legend: s-nb-spaced-text(n) l-nb-spaced-lines(n) Line breaks and empty lines separating folded and more-indented lines are also not folded . [180] l-nb-same-lines(n) ::= l-empty(n,block-in) * ( l-nb-folded-lines(n) | l-nb-spaced-lines(n) ) [181] l-nb-diff-lines(n) ::= l-nb-same-lines(n) ( b-as-line-feed l-nb-same-lines(n) )* Example 8.12. Empty Separation Lines > folded line next line * bullet * list * line last line # Comment %YAML 1.2 --- !!str \"\\n\\ folded line\\n\\ next line\\n\\ \\ * bullet\\n \\n\\ \\ * list\\n\\ \\ * lines\\n\\ \\n\\ last line\\n\" Legend: b-as-line-feed (separation) l-empty(n,c) The final line break , and trailing empty lines if any, are subject to chomping and are never folded . [182] l-folded-content(n,t) ::= ( l-nb-diff-lines(n) b-chomped-last(t) )? l-chomped-empty(n,t) Example 8.13. Final Empty Lines > folded line next line * bullet * list * line last line # Comment %YAML 1.2 --- !!str \"\\n\\ folded line\\n\\ next line\\n\\ \\ * bullet\\n \\n\\ \\ * list\\n\\ \\ * lines\\n\\ \\n\\ last line\\n\" Legend: b-chomped-last(t) l-chomped-empty(n,t) 8.2. Block Collection Styles For readability, block collections styles are not denoted by any indicator . Instead, YAML uses a lookahead method, where a block collection is distinguished from a plain scalar only when a key: value pair or a sequence entry is seen. 8.2.1. Block Sequences A block sequence is simply a series of nodes , each denoted by a leading “ -” indicator. The “ -” indicator must be separated from the node by white space . This allows “ -” to be used as the first character in a plain scalar if followed by a non-space character (e.g. “ -1”). [183] l+block-sequence(n) ::= ( s-indent(n+m) c-l-block-seq-entry(n+m) )+ /* For some fixed auto-detected m > 0 */ [184] c-l-block-seq-entry(n) ::= “ -” /* Not followed by an ns-char */ s-l+block-indented(n,block-in) Example 8.14. Block Sequence block sequence: ·· - one - two : three Legend: c-l-block-seq-entry(n) auto-detected s-indent(n) %YAML 1.2 --- !!map { ? !!str \"block sequence\" : !!seq [ !!str \"one\", !!map { ? !!str \"two\" : !!str \"three\" }, ], } The entry node may be either completely empty , be a nested block node , or use a compact in-line notation. The compact notation may be used when the entry is itself a nested block collection . In this case, both the “ -” indicator and the following spaces are considered to be part of the indentation of the nested collection . Note that it is not possible to specify node properties for such a collection . [185] s-l+block-indented(n,c) ::= ( s-indent(m) ( ns-l-compact-sequence(n+1+m) | ns-l-compact-mapping(n+1+m) ) ) | s-l+block-node(n,c) | ( e-node s-l-comments ) [186] ns-l-compact-sequence(n) ::= c-l-block-seq-entry(n) ( s-indent(n) c-l-block-seq-entry(n) )* Example 8.15. Block Sequence Entry Types - ° # Empty - | block node - ·- one # Compact ··- two # sequence - one: two # Compact mapping Legend: Empty s-l+block-node(n,c) ns-l-compact-sequence(n) ns-l-compact-mapping(n) %YAML 1.2 --- !!seq [ !!null \"\", !!str \"block node\\n\", !!seq [ !!str \"one\" !!str \"two\", ], !!map { ? !!str \"one\" : !!str \"two\", }, ] 8.2.2. Block Mappings A Block mapping is a series of entries, each presenting a key: value pair . [187] l+block-mapping(n) ::= ( s-indent(n+m) ns-l-block-map-entry(n+m) )+ /* For some fixed auto-detected m > 0 */ Example 8.16. Block Mappings block mapping: · key: value Legend: ns-l-block-map-entry(n) auto-detected s-indent(n) %YAML 1.2 --- !!map { ? !!str \"block mapping\" : !!map { ? !!str \"key\" : !!str \"value\", }, } If the “ ?” indicator is specified, the optional value node must be specified on a separate line, denoted by the “ :” indicator. Note that YAML allows here the same compact in-line notation described above for block sequence entries. [188] ns-l-block-map-entry(n) ::= c-l-block-map-explicit-entry(n) | ns-l-block-map-implicit-entry(n) [189] c-l-block-map-explicit-entry(n) ::= c-l-block-map-explicit-key(n) ( l-block-map-explicit-value(n) | e-node ) [190] c-l-block-map-explicit-key(n) ::= “ ?” s-l+block-indented(n,block-out) [191] l-block-map-explicit-value(n) ::= s-indent(n) “ :” s-l+block-indented(n,block-out) Example 8.17. Explicit Block Mapping Entries ? explicit key # Empty value ° ? | block key :·- one # Explicit compact ··- two # block value Legend: c-l-block-map-explicit-key(n) l-block-map-explicit-value(n) e-node %YAML 1.2 --- !!map { ? !!str \"explicit key\" : !!str \"\", ? !!str \"block key\\n\" : !!seq [ !!str \"one\", !!str \"two\", ], } If the “ ?” indicator is omitted, parsing needs to see past the implicit key , in the same way as in the single key: value pair flow mapping . Hence, such keys are subject to the same restrictions; they are limited to a single line and must not span more than 1024 Unicode characters. [192] ns-l-block-map-implicit-entry(n) ::= ( ns-s-block-map-implicit-key | e-node ) c-l-block-map-implicit-value(n) [193] ns-s-block-map-implicit-key ::= c-s-implicit-json-key(block-key) | ns-s-implicit-yaml-key(block-key) In this case, the value may be specified on the same line as the implicit key . Note however that in block mappings the value must never be adjacent to the “ :”, as this greatly reduces readability and is not required for JSON compatibility (unlike the case in flow mappings ). There is no compact notation for in-line values . Also, while both the implicit key and the value following it may be empty, the “ :” indicator is mandatory. This prevents a potential ambiguity with multi-line plain scalars . [194] c-l-block-map-implicit-value(n) ::= “ :” ( s-l+block-node(n,block-out) | ( e-node s-l-comments ) ) Example 8.18. Implicit Block Mapping Entries plain key : in-line value ° :° # Both empty \"quoted key\" : - entry Legend: ns-s-block-map-implicit-key c-l-block-map-implicit-value(n) %YAML 1.2 --- !!map { ? !!str \"plain key\" : !!str \"in-line value\", ? !!null \"\" : !!null \"\", ? !!str \"quoted key\" : !!seq [ !!str \"entry\" ], } A compact in-line notation is also available. This compact notation may be nested inside block sequences and explicit block mapping entries. Note that it is not possible to specify node properties for such a nested mapping. [195] ns-l-compact-mapping(n) ::= ns-l-block-map-entry(n) ( s-indent(n) ns-l-block-map-entry(n) )* Example 8.19. Compact Block Mappings - sun: yellow - ? earth: blue : moon: white Legend: ns-l-compact-mapping(n) %YAML 1.2 --- !!seq [ !!map { !!str \"sun\" : !!str \"yellow\", }, !!map { ? !!map { ? !!str \"earth\" : !!str \"blue\" }, : !!map { ? !!str \"moon\" : !!str \"white\" }, } ] 8.2.3. Block Nodes YAML allows flow nodes to be embedded inside block collections (but not vice-versa). Flow nodes must be indented by at least one more space than the parent block collection . Note that flow nodes may begin on a following line. It is at this point that parsing needs to distinguish between a plain scalar and an implicit key starting a nested block mapping . [196] s-l+block-node(n,c) ::= s-l+block-in-block(n,c) | s-l+flow-in-block(n) [197] s-l+flow-in-block(n) ::= s-separate(n+1,flow-out) ns-flow-node(n+1,flow-out) s-l-comments Example 8.20. Block Node Types - ··\"flow in block\" -· > Block scalar -· !!map # Block collection foo : bar Legend: s-l+flow-in-block(n) s-l+block-in-block(n,c) %YAML 1.2 --- !!seq [ !!str \"flow in block\", !!str \"Block scalar\\n\", !!map { ? !!str \"foo\" : !!str \"bar\", }, ] The block node’s properties may span across several lines. In this case, they must be indented by at least one more space than the block collection , regardless of the indentation of the block collection entries. [198] s-l+block-in-block(n,c) ::= s-l+block-scalar(n,c) | s-l+block-collection(n,c) [199] s-l+block-scalar(n,c) ::= s-separate(n+1,c) ( c-ns-properties(n+1,c) s-separate(n+1,c) )? ( c-l+literal(n) | c-l+folded(n) ) Example 8.21. Block Scalar Nodes literal: |2 ··value folded: ···!foo ··>1 ·value Legend: c-l+literal(n) c-l+folded(n) %YAML 1.2 --- !!map { ? !!str \"literal\" : !!str \"value\", ? !!str \"folded\" : !<!foo> \"value\", } Since people perceive the “ -” indicator as indentation , nested block sequences may be indented by one less space to compensate, except, of course, if nested inside another block sequence ( block-out context vs. block-in context ). [200] s-l+block-collection(n,c) ::= ( s-separate(n+1,c) c-ns-properties(n+1,c) )? s-l-comments ( l+block-sequence( seq-spaces(n,c) ) | l+block-mapping(n) ) [201] seq-spaces(n,c) ::= c = block-out n-1 c = block-in n Example 8.22. Block Collection Nodes sequence: !!seq - entry - !!seq - nested mapping: !!map foo: bar Legend: l+block-sequence(n) l+block-mapping(n) s-l+block-collection(n,c) %YAML 1.2 --- !!map { ? !!str \"sequence\" : !!seq [ !!str \"entry\", !!seq [ !!str \"nested\" ], ], ? !!str \"mapping\" : !!map { ? !!str \"foo\" : !!str \"bar\", }, } Chapter 9. YAML Character Stream 9.1. Documents A YAML character stream may contain several documents. Each document is completely independent from the rest. 9.1.1. Document Prefix A document may be preceded by a prefix specifying the character encoding , and optional comment lines. Note that all documents in a stream must use the same character encoding . However it is valid to re-specify the encoding using a byte order mark for each document in the stream. This makes it easier to concatenate streams. The existence of the optional prefix does not necessarily indicate the existence of an actual document . [202] l-document-prefix ::= c-byte-order-mark ? l-comment * Example 9.1. Document Prefix # Comment # lines Document Legend: l-document-prefix %YAML 1.2 --- !!str \"Document\" 9.1.2. Document Markers Using directives creates a potential ambiguity. It is valid to have a “ %” character at the start of a line (e.g. as the first character of the second line of a plain scalar ). How, then, to distinguish between an actual directive and a content line that happens to start with a “ %” character? The solution is the use of two special marker lines to control the processing of directives , one at the start of a document and one at the end. At the start of a document , lines beginning with a “ %” character are assumed to be directives . The (possibly empty) list of directives is terminated by a directives end marker line. Lines following this marker can safely use “ %” as the first character. At the end of a document , a document end marker line is used to signal the parser to begin scanning for directives again. The existence of this optional document suffix does not necessarily indicate the existence of an actual following document . Obviously, the actual content lines are therefore forbidden to begin with either of these markers. [203] c-directives-end ::= “ -” “ -” “ -” [204] c-document-end ::= “ .” “ .” “ .” [205] l-document-suffix ::= c-document-end s-l-comments [206] c-forbidden ::= /* Start of line */ ( c-directives-end | c-document-end ) ( b-char | s-white | /* End of file */ ) Example 9.2. Document Markers %YAML 1.2 --- Document ... # Suffix %YAML 1.2 --- !!str \"Document\" Legend: c-directives-end c-document-end l-document-suffix 9.1.3. Bare Documents A bare document does not begin with any directives or marker lines. Such documents are very “ clean” as they contain nothing other than the content . In this case, the first non-comment line may not start with a “ %” first character. Document nodes are indented as if they have a parent indented at -1 spaces . Since a node must be more indented than its parent node , this allows the document’s node to be indented at zero or more spaces . [207] l-bare-document ::= s-l+block-node(-1,block-in) /* Excluding c-forbidden content */ Example 9.3. Bare Documents Bare document ... # No document ... | %!PS-Adobe-2.0 # Not the first line %YAML 1.2 --- !!str \"Bare document\" %YAML 1.2 --- !!str \"%!PS-Adobe-2.0\\n\" Legend: l-bare-document 9.1.4. Explicit Documents An explicit document begins with an explicit directives end marker line but no directives . Since the existence of the document is indicated by this marker , the document itself may be completely empty . [208] l-explicit-document ::= c-directives-end ( l-bare-document | ( e-node s-l-comments ) ) Example 9.4. Explicit Documents --- { matches % : 20 } ... --- # Empty ... Legend: l-explicit-document %YAML 1.2 --- !!map { !!str \"matches %\": !!int \"20\" } ... %YAML 1.2 --- !!null \"\" 9.1.5. Directives Documents A directives document begins with some directives followed by an explicit directives end marker line. [209] l-directive-document ::= l-directive + l-explicit-document Example 9.5. Directives Documents %YAML 1.2 --- | %!PS-Adobe-2.0 ... %YAML1.2 --- # Empty ... Legend: l-explicit-document %YAML 1.2 --- !!str \"%!PS-Adobe-2.0\\n\" ... %YAML 1.2 --- !!null \"\" 9.2. Streams A YAML stream consists of zero or more documents . Subsequent documents require some sort of separation marker line. If a document is not terminated by a document end marker line, then the following document must begin with a directives end marker line. The stream format is intentionally “ sloppy” to better support common use cases, such as stream concatenation. [210] l-any-document ::= l-directive-document | l-explicit-document | l-bare-document [211] l-yaml-stream ::= l-document-prefix * l-any-document ? ( l-document-suffix + l-document-prefix * l-any-document ? | l-document-prefix * l-explicit-document ? )* Example 9.6. Stream Document --- # Empty ... %YAML 1.2 --- matches %: 20 Legend: l-any-document l-document-suffix l-explicit-document %YAML 1.2 --- !!str \"Document\" ... %YAML 1.2 --- !!null \"\" ... %YAML 1.2 --- !!map { !!str \"matches %\": !!int \"20\" } A sequence of bytes is a well-formed stream if, taken as a whole, it complies with the above l-yaml-stream production. Some common use case that can take advantage of the YAML stream structure are: Appending to Streams Allowing multiple documents in a single stream makes YAML suitable for log files and similar applications . Note that each document is independent of the rest, allowing for heterogeneous log file entries. Concatenating Streams Concatenating two YAML streams requires both to use the same character encoding . In addition, it is necessary to separate the last document of the first stream and the first document of the second stream. This is easily ensured by inserting a document end marker between the two streams. Note that this is safe regardless of the content of either stream. In particular, either or both may be empty, and the first stream may or may not already contain such a marker. Communication Streams The document end marker allows signaling the end of a document without closing the stream or starting the next document . This allows the receiver to complete processing a document without having to wait for the next one to arrive. The sender may also transmit \"keep-alive\" messages in the form of comment lines or repeated document end markers without signalling the start of the next document . Chapter 10. Recommended Schemas A YAML schema is a combination of a set of tags and a mechanism for resolving non-specific tags . 10.1. Failsafe Schema The failsafe schema is guaranteed to work with any YAML document . It is therefore the recommended schema for generic YAML tools. A YAML processor should therefore support this schema , at least as an option. 10.1.1. Tags 10.1.1.1. Generic Mapping URI: tag:yaml.org,2002:map Kind: Mapping . Definition: Represents an associative container, where each key is unique in the association and mapped to exactly one value . YAML places no restrictions on the type of keys ; in particular, they are not restricted to being scalars . Example bindings to native types include Perl’s hash, Python’s dictionary, and Java’s Hashtable. Example 10.1. !!map Examples Block style: !!map Clark : Evans Ingy : döt Net Oren : Ben-Kiki Flow style: !!map { Clark: Evans, Ingy: döt Net, Oren: Ben-Kiki } 10.1.1.2. Generic Sequence URI: tag:yaml.org,2002:seq Kind: Sequence . Definition: Represents a collection indexed by sequential integers starting with zero. Example bindings to native types include Perl’s array, Python’s list or tuple, and Java’s array or Vector. Example 10.2. !!seq Examples Block style: !!seq - Clark Evans - Ingy döt Net - Oren Ben-Kiki Flow style: !!seq [ Clark Evans, Ingy döt Net, Oren Ben-Kiki ] 10.1.1.3. Generic String URI: tag:yaml.org,2002:str Kind: Scalar . Definition: Represents a Unicode string, a sequence of zero or more Unicode characters. This type is usually bound to the native language’s string type, or, for languages lacking one (such as C), to a character array. Canonical Form: The obvious. Example 10.3. !!str Examples Block style: !!str |- String: just a theory. Flow style: !!str \"String: just a theory.\" 10.1.2. Tag Resolution All nodes with the “ !” non-specific tag are resolved , by the standard convention , to “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map”, or “ tag:yaml.org,2002:str”, according to their kind . All nodes with the “ ?” non-specific tag are left unresolved . This constrains the application to deal with a partial representation . 10.2. JSON Schema The JSON schema is the lowest common denominator of most modern computer languages, and allows parsing JSON files. A YAML processor should therefore support this schema , at least as an option. It is also strongly recommended that other schemas should be based on it. 10.2.1. Tags The JSON schema uses the following tags in addition to those defined by the failsafe schema: 10.2.1.1. Null URI: tag:yaml.org,2002:null Kind: Scalar . Definition: Represents the lack of a value. This is typically bound to a native null-like value (e.g., undef in Perl, None in Python). Note that a null is different from an empty string. Also, a mapping entry with some key and a null value is valid, and different from not having that key in the mapping . Canonical Form: null. Example 10.4. !!null Examples !!null null: value for null key key with null value: !!null null 10.2.1.2. Boolean URI: tag:yaml.org,2002:bool Kind: Scalar . Definition: Represents a true/false value. In languages without a native Boolean type (such as C), is usually bound to a native integer type, using one for true and zero for false. Canonical Form: Either true or false. Example 10.5. !!bool Examples YAML is a superset of JSON: !!bool true Pluto is a planet: !!bool false 10.2.1.3. Integer URI: tag:yaml.org,2002:int Kind: Scalar . Definition: Represents arbitrary sized finite mathematical integers. Scalars of this type should be bound to a native integer data type, if possible. Some languages (such as Perl) provide only a “ number” type that allows for both integer and floating-point values. A YAML processor may use such a type for integers, as long as they round-trip properly. In some languages (such as C), an integer may overflow the native type’s storage capability. A YAML processor may reject such a value as an error, truncate it with a warning, or find some other manner to round-trip it. In general, integers representable using 32 binary digits should safely round-trip through most systems. Canonical Form: Decimal integer notation, with a leading “ -” character for negative values, matching the regular expression 0 | -? [1-9] [0-9]* Example 10.6. !!int Examples negative: !!int -12 zero: !!int 0 positive: !!int 34 10.2.1.4. Floating Point URI: tag:yaml.org,2002:float Kind: Scalar . Definition: Represents an approximation to real numbers, including three special values (positive and negative infinity, and “ not a number”). Some languages (such as Perl) provide only a “ number” type that allows for both integer and floating-point values. A YAML processor may use such a type for floating-point numbers, as long as they round-trip properly. Not all floating-point values can be stored exactly in any given native type. Hence a float value may change by “ a small amount” when round-tripped. The supported range and accuracy depends on the implementation, though 32 bit IEEE floats should be safe. Since YAML does not specify a particular accuracy, using floating-point mapping keys requires great care and is not recommended. Canonical Form: Either 0, .inf, -.inf, .nan, or scientific notation matching the regular expression -? [1-9] ( \\. [0-9]* [1-9] )? ( e [-+] [1-9] [0-9]* )?. Example 10.7. !!float Examples negative: !!float -1 zero: !!float 0 positive: !!float 2.3e4 infinity: !!float .inf not a number: !!float .nan 10.2.2. Tag Resolution The JSON schema tag resolution is an extension of the failsafe schema tag resolution . All nodes with the “ !” non-specific tag are resolved , by the standard convention , to “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map”, or “ tag:yaml.org,2002:str”, according to their kind . Collections with the “ ?” non-specific tag (that is, untagged collections ) are resolved to “ tag:yaml.org,2002:seq” or “ tag:yaml.org,2002:map” according to their kind . Scalars with the “ ?” non-specific tag (that is, plain scalars ) are matched with a list of regular expressions (first match wins, e.g. 0 is resolved as !!int). In principle, JSON files should not contain any scalars that do not match at least one of these. Hence the YAML processor should consider them to be an error. Regular expression Resolved to tag null tag:yaml.org,2002:null true | false tag:yaml.org,2002:bool -? ( 0 | [1-9] [0-9]* ) tag:yaml.org,2002:int -? ( 0 | [1-9] [0-9]* ) ( \\. [0-9]* )? ( [eE] [-+]? [0-9]+ )? tag:yaml.org,2002:float * Error Example 10.8. JSON Tag Resolution A null: null Booleans: [ true, false ] Integers: [ 0, -0, 3, -19 ] Floats: [ 0., -0.0, 12e03, -2E+05 ] Invalid: [ True, Null, 0o7, 0x3A, +12.3 ] %YAML 1.2 --- !!map { !!str \"A null\" : !!null \"null\", !!str \"Booleans: !!seq [ !!bool \"true\", !!bool \"false\" ], !!str \"Integers\": !!seq [ !!int \"0\", !!int \"-0\", !!int \"3\", !!int \"-19\" ], !!str \"Floats\": !!seq [ !!float \"0.\", !!float \"-0.0\", !!float \"12e03\", !!float \"-2E+05\" ], !!str \"Invalid\": !!seq [ # Rejected by the schema True, Null, 0o7, 0x3A, +12.3, ], } ... 10.3. Core Schema The Core schema is an extension of the JSON schema , allowing for more human-readable presentation of the same types. This is the recommended default schema that YAML processor should use unless instructed otherwise. It is also strongly recommended that other schemas should be based on it. 10.3.1. Tags The core schema uses the same tags as the JSON schema . 10.3.2. Tag Resolution The core schema tag resolution is an extension of the JSON schema tag resolution . All nodes with the “ !” non-specific tag are resolved , by the standard convention , to “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map”, or “ tag:yaml.org,2002:str”, according to their kind . Collections with the “ ?” non-specific tag (that is, untagged collections ) are resolved to “ tag:yaml.org,2002:seq” or “ tag:yaml.org,2002:map” according to their kind . Scalars with the “ ?” non-specific tag (that is, plain scalars ) are matched with an extended list of regular expressions. However, in this case, if none of the regular expressions matches, the scalar is resolved to tag:yaml.org,2002:str (that is, considered to be a string). Regular expression Resolved to tag null | Null | NULL | ~ tag:yaml.org,2002:null /* Empty */ tag:yaml.org,2002:null true | True | TRUE | false | False | FALSE tag:yaml.org,2002:bool [-+]? [0-9]+ tag:yaml.org,2002:int (Base 10) 0o [0-7]+ tag:yaml.org,2002:int (Base 8) 0x [0-9a-fA-F]+ tag:yaml.org,2002:int (Base 16) [-+]? ( \\. [0-9]+ | [0-9]+ ( \\. [0-9]* )? ) ( [eE] [-+]? [0-9]+ )? tag:yaml.org,2002:float (Number) [-+]? ( \\.inf | \\.Inf | \\.INF ) tag:yaml.org,2002:float (Infinity) \\.nan | \\.NaN | \\.NAN tag:yaml.org,2002:float (Not a number) * tag:yaml.org,2002:str (Default) Example 10.9. Core Tag Resolution A null: null Also a null: # Empty Not a null: \"\" Booleans: [ true, True, false, FALSE ] Integers: [ 0, 0o7, 0x3A, -19 ] Floats: [ 0., -0.0, .5, +12e03, -2E+05 ] Also floats: [ .inf, -.Inf, +.INF, .NAN ] %YAML 1.2 --- !!map { !!str \"A null\" : !!null \"null\", !!str \"Also a null\" : !!null \"\", !!str \"Not a null\" : !!str \"\", !!str \"Booleans: !!seq [ !!bool \"true\", !!bool \"True\", !!bool \"false\", !!bool \"FALSE\", ], !!str \"Integers\": !!seq [ !!int \"0\", !!int \"0o7\", !!int \"0x3A\", !!int \"-19\", ], !!str \"Floats\": !!seq [ !!float \"0.\", !!float \"-0.0\", !!float \".5\", !!float \"+12e03\", !!float \"-2E+05\" ], !!str \"Also floats\": !!seq [ !!float \".inf\", !!float \"-.Inf\", !!float \"+.INF\", !!float \".NAN\", ], } ... 10.4. Other Schemas None of the above recommended schemas preclude the use of arbitrary explicit tags . Hence YAML processors for a particular programming language typically provide some form of local tags that map directly to the language’s native data structures (e.g., !ruby/object:Set). While such local tags are useful for ad-hoc applications , they do not suffice for stable, interoperable cross- application or cross-platform data exchange. Interoperable schemas make use of global tags (URIs) that represent the same data across different programming languages. In addition, an interoperable schema may provide additional tag resolution rules. Such rules may provide additional regular expressions, as well as consider the path to the node . This allows interoperable schemas to use untagged nodes . It is strongly recommended that such schemas be based on the core schema defined above. In addition, it is strongly recommended that such schemas make as much use as possible of the the YAML tag repository at http://yaml.org/type/ . This repository provides recommended global tags for increasing the portability of YAML documents between different applications . The tag repository is intentionally left out of the scope of this specification. This allows it to evolve to better support YAML applications . Hence, developers are encouraged to submit new “ universal” types to the repository. The yaml-core mailing list at http://lists.sourceforge.net/lists/listinfo/yaml-core is the preferred method for such submissions, as well as raising any questions regarding this draft. Index Indicators ! tag indicator, Tags , Indicator Characters , Node Tags ! local tag, Tags , Tag Handles , Tag Prefixes , Node Tags ! non-specific tag, Resolved Tags , Node Tags , Tag Resolution , Tag Resolution , Tag Resolution ! primary tag handle, Tag Handles !! secondary tag handle, Tag Handles !…! named handle, Tag Handles , Node Tags \" double-quoted style, Indicator Characters , Double-Quoted Style # comment, Collections , Indicator Characters , Comments , Plain Style , Block Indentation Indicator % directive, Indicator Characters , Directives , Document Markers , Bare Documents % escaping in URI, Tags , Miscellaneous Characters , Node Tags & anchor, Structures , Indicator Characters , Node Anchors ' reserved indicator, Indicator Characters ' single-quoted style, Indicator Characters , Single-Quoted Style * alias, Structures , Indicator Characters , Alias Nodes + keep chomping, Block Chomping Indicator , end flow entry, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Collection Styles , Flow Sequences , Flow Mappings - block sequence entry, Introduction , Collections , Structures , Production Parameters , Indicator Characters , Indentation Spaces , Plain Style , Block Collection Styles , Block Sequences , Block Nodes - strip chomping, Block Chomping Indicator : mapping value, Introduction , Collections , Structures , Indicator Characters , Indentation Spaces , Plain Style , Flow Mappings , Block Mappings <…> verbatim tag, Node Tags > folded style, Scalars , Indicator Characters , Folded Style ? mapping key, Structures , Indicator Characters , Indentation Spaces , Plain Style , Flow Mappings , Block Mappings ? non-specific tag, Resolved Tags , Node Tags , Tag Resolution , Tag Resolution , Tag Resolution @ reserved indicator, Indicator Characters [ start flow sequence, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Sequences \\ escaping in double-quoted scalars, Escaped Characters , Double-Quoted Style ] end flow sequence, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Sequences { start flow mapping, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Mappings | literal style, Scalars , Indicator Characters , Literal Style } end flow mapping, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Mappings prefix, Document Prefix A alias, Introduction , Prior Art , Structures , Dump , Serialization Tree , Anchors and Aliases , Loading Failure Points , Well-Formed Streams and Identified Aliases , Resolved Tags , Indicator Characters , Node Anchors , Flow Styles , Alias Nodes , Flow Nodes identified, Structures , Anchors and Aliases , Well-Formed Streams and Identified Aliases unidentified, Loading Failure Points , Well-Formed Streams and Identified Aliases anchor, Structures , Dump , Serialization Tree , Anchors and Aliases , Well-Formed Streams and Identified Aliases , Resolved Tags , Indicator Characters , Node Properties , Flow Styles , Alias Nodes , Flow Nodes application, Introduction , Prior Art , Tags , Processing YAML Information , Dump , Information Models , Tags , Serialization Tree , Keys Order , Resolved Tags , Available Tags , Tag Prefixes , Node Tags , Streams , Tag Resolution , Other Schemas B block scalar header, Comments , Block Scalar Headers , Block Chomping Indicator byte order mark, Character Encodings , Document Prefix C character encoding, Character Encodings , Document Prefix , Streams in URI, Miscellaneous Characters chomping, Production Parameters , Line Folding , Block Chomping Indicator , Literal Style , Folded Style clip, Production Parameters , Block Chomping Indicator keep, Production Parameters , Block Chomping Indicator strip, Production Parameters , Block Chomping Indicator collection, Prior Art , Representation Graph , Nodes , Node Comparison , Anchors and Aliases , Node Styles , Comments , Resolved Tags , Recognized and Valid Tags , Tag Resolution , Tag Resolution comment, Collections , Processes , Dump , Load , Presentation Stream , Comments , Resolved Tags , Indicator Characters , Comments , Separation Lines , Plain Style , Block Scalar Headers , Block Chomping Indicator , Document Prefix , Streams compose, Processes , Load , Keys Order , Anchors and Aliases , Resolved Tags , Recognized and Valid Tags , Available Tags , Node Anchors construct, Processes , Load , Serialization Tree , Loading Failure Points , Recognized and Valid Tags , Available Tags , Flow Styles , Generic Mapping , Generic Sequence , Generic String , Null , Boolean , Integer content, Structures , Dump , Nodes , Tags , Node Comparison , Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Character Encodings , Line Break Characters , Escaped Characters , Indentation Spaces , Separation Spaces , Line Prefixes , Empty Lines , Line Folding , Comments , Directives , Tag Handles , Node Properties , Node Tags , Node Anchors , Alias Nodes , Empty Nodes , Flow Scalar Styles , Double-Quoted Style , Single-Quoted Style , Plain Style , Block Scalar Headers , Block Indentation Indicator , Block Chomping Indicator , Literal Style , Document Markers , Bare Documents valid, Recognized and Valid Tags context, Production Parameters , Plain Style block-in, Production Parameters , Block Nodes block-key, Production Parameters , Flow Collection Styles block-out, Production Parameters , Block Nodes flow-in, Production Parameters , Flow Collection Styles flow-key, Production Parameters , Flow Collection Styles flow-out, Production Parameters , Flow Collection Styles D directive, Structures , Dump , Load , Presentation Stream , Directives , Indicator Characters , Directives , Document Markers , Bare Documents , Explicit Documents , Directives Documents reserved, Directives , Directives TAG, Tags , Directives , Indicator Characters , Directives , “TAG” Directives , Node Tags YAML, Directives , Directives , “YAML” Directives document, Prior Art , Structures , Presentation Stream , Directives , Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Character Encodings , Line Break Characters , “YAML” Directives , Tag Prefixes , Alias Nodes , Documents , Document Prefix , Document Markers , Explicit Documents , Streams , Failsafe Schema , Other Schemas bare, Bare Documents directives, Directives Documents explicit, Explicit Documents suffix, Document Markers dump, Processes , Dump E empty line, Prior Art , Scalars , Empty Lines , Line Folding , Block Indentation Indicator , Block Chomping Indicator , Literal Style , Folded Style equality, Relation to JSON , Dump , Representation Graph , Nodes , Tags , Node Comparison , Scalar Formats , Loading Failure Points , Recognized and Valid Tags escaping in double-quoted scalars, Prior Art , Scalars , Character Set , Character Encodings , Miscellaneous Characters , Escaped Characters , Double-Quoted Style in single-quoted scalars, Single-Quoted Style in URIs, Miscellaneous Characters non-content line break, Double-Quoted Style I identity, Node Comparison indicator, Introduction , Prior Art , Collections , Node Styles , Production Parameters , Indicator Characters , Line Folding , Plain Style , Flow Mappings , Flow Nodes , Block Styles , Block Scalar Headers , Block Collection Styles indentation, Block Indentation Indicator reserved, Indicator Characters information model, Information Models invalid content, Loading Failure Points , Recognized and Valid Tags J JSON compatibility, Character Set , Character Encodings , Line Break Characters , Escaped Characters , Comments , “YAML” Directives , Flow Mappings , Block Mappings JSON-like, Flow Mappings , Flow Nodes K key, Relation to JSON , Structures , Dump , Information Models , Representation Graph , Nodes , Node Comparison , Serialization Tree , Keys Order , Resolved Tags , Indicator Characters , Flow Mappings , Block Mappings , Generic Mapping , Null , Floating Point implicit, Separation Lines , Double-Quoted Style , Single-Quoted Style , Plain Style , Flow Collection Styles , Flow Mappings , Block Mappings , Block Nodes order, Processes , Dump , Load , Information Models , Serialization Tree , Keys Order key: value pair, Introduction , Collections , Structures , Nodes , Keys Order , Node Styles , Plain Style , Flow Mappings , Block Collection Styles , Block Mappings kind, Dump , Representation Graph , Nodes , Tags , Node Comparison , Node Styles , Resolved Tags , Node Tags , Tag Resolution , Tag Resolution , Tag Resolution L line break, Prior Art , Scalars , Production Parameters , Production Naming Conventions , Line Break Characters , White Space Characters , Empty Lines , Line Folding , Comments , Double-Quoted Style , Block Scalar Headers , Block Chomping Indicator , Literal Style , Folded Style non-ASCII, Line Break Characters , “YAML” Directives normalization, Line Break Characters , Literal Style line folding, Prior Art , Scalars , Line Folding , Flow Styles , Double-Quoted Style , Single-Quoted Style , Plain Style , Block Chomping Indicator , Folded Style block, Line Folding , Folded Style flow, Line Folding , Double-Quoted Style line prefix, Line Prefixes , Empty Lines load, Processes , Load , Loading Failure Points failure point, Load , Loading Failure Points M mapping, Introduction , Prior Art , Relation to JSON , Collections , Structures , Dump , Representation Graph , Nodes , Tags , Node Comparison , Keys Order , Resolved Tags , Plain Style , Flow Sequences , Flow Mappings , Generic Mapping , Null marker, Presentation Stream , Document Markers , Bare Documents , Explicit Documents , Streams directives end, Structures , Document Markers , Explicit Documents , Directives Documents , Streams document end, Structures , Document Markers , Streams more-indented, Scalars , Line Folding , Folded Style N native data structure, Introduction , Goals , Prior Art , Relation to JSON , Processing YAML Information , Processes , Dump , Load , Representation Graph , Nodes , Tags , Node Comparison , Serialization Tree , Loading Failure Points , Recognized and Valid Tags , Available Tags , Node Tags , Flow Styles , Generic Mapping , Generic Sequence , Generic String , Null , Boolean , Integer , Floating Point , Other Schemas need not, Terminology node, Structures , Dump , Representation Graph , Nodes , Tags , Node Comparison , Serialization Tree , Keys Order , Anchors and Aliases , Presentation Stream , Node Styles , Comments , Loading Failure Points , Well-Formed Streams and Identified Aliases , Resolved Tags , Recognized and Valid Tags , Syntax Conventions , Indentation Spaces , Node Properties , Node Tags , Node Anchors , Alias Nodes , Empty Nodes , Flow Mappings , Flow Nodes , Block Indentation Indicator , Block Sequences , Bare Documents , Tag Resolution , Tag Resolution , Tag Resolution , Other Schemas completely empty, Empty Nodes , Flow Collection Styles , Flow Mappings , Block Sequences , Explicit Documents property, Node Properties , Alias Nodes , Empty Nodes , Flow Mappings , Flow Nodes , Block Sequences , Block Mappings , Block Nodes root, Representation Graph , Resolved Tags P parse, Load , Presentation Stream , Resolved Tags , Production Parameters , Line Break Characters , Escaped Characters , Tag Handles , Node Tags , Flow Mappings , Block Mappings , Block Nodes , Document Markers , JSON Schema present, Processing YAML Information , Dump , Load , Nodes , Node Comparison , Presentation Stream , Scalar Formats , Character Set , Miscellaneous Characters , Node Tags , Alias Nodes , Block Mappings , Core Schema presentation, Processing YAML Information , Information Models , Presentation Stream , Production Parameters detail, Dump , Load , Information Models , Presentation Stream , Node Styles , Scalar Formats , Comments , Directives , Resolved Tags , Character Encodings , Line Break Characters , Escaped Characters , Indentation Spaces , Separation Spaces , Line Prefixes , Line Folding , Comments , Directives , Tag Handles , Node Tags , Flow Scalar Styles , Block Chomping Indicator printable character, Introduction , Prior Art , Character Set , White Space Characters , Escaped Characters , Single-Quoted Style , Literal Style processor, Terminology , Processing YAML Information , Dump , Node Comparison , Presentation Stream , Directives , Well-Formed Streams and Identified Aliases , Resolved Tags , Recognized and Valid Tags , Available Tags , Character Set , Character Encodings , Line Break Characters , Miscellaneous Characters , Comments , Directives , “YAML” Directives , Tag Handles , Node Tags , Node Anchors , Flow Mappings , Block Indentation Indicator , Failsafe Schema , JSON Schema , Integer , Floating Point , Tag Resolution , Core Schema , Other Schemas R represent, Introduction , Prior Art , Dump , Tags , Node Comparison , Keys Order , Generic Mapping , Generic Sequence , Generic String , Null , Boolean , Integer , Floating Point , Other Schemas representation, Processing YAML Information , Processes , Dump , Load , Information Models , Representation Graph , Nodes , Node Comparison , Serialization Tree , Keys Order , Anchors and Aliases , Presentation Stream , Node Styles , Scalar Formats , Comments , Directives , Available Tags , Node Anchors complete, Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Available Tags partial, Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Tag Resolution required, Terminology S scalar, Introduction , Prior Art , Scalars , Dump , Representation Graph , Nodes , Tags , Node Comparison , Scalar Formats , Comments , Recognized and Valid Tags , Line Break Characters , Separation Spaces , Line Prefixes , Comments , Empty Nodes , Block Chomping Indicator , Generic Mapping , Generic String , Null , Boolean , Integer , Floating Point , Tag Resolution , Tag Resolution canonical form, Prior Art , Tags , Node Comparison , Scalar Formats , Loading Failure Points content format, Dump , Load , Tags , Node Comparison , Presentation Stream , Scalar Formats , Loading Failure Points schema, Recommended Schemas , Failsafe Schema , JSON Schema , Tags , Core Schema , Tags , Other Schemas core, Core Schema , Tag Resolution , Other Schemas failsafe, Tags , Failsafe Schema , Tags , Tag Resolution JSON, Tags , JSON Schema , Tag Resolution , Core Schema , Tags , Tag Resolution sequence, Introduction , Prior Art , Dump , Representation Graph , Nodes , Tags , Node Comparison , Keys Order , Resolved Tags , Flow Mappings , Generic Sequence serialization, Processing YAML Information , Processes , Dump , Load , Information Models , Serialization Tree , Anchors and Aliases , Presentation Stream , Node Styles , Scalar Formats , Comments , Directives , Node Anchors detail, Dump , Load , Information Models , Keys Order , Anchors and Aliases , Node Anchors serialize, Introduction , Prior Art , Relation to JSON , Dump , Load , Keys Order , Anchors and Aliases , Alias Nodes shall, Terminology space, Prior Art , Scalars , White Space Characters , Indentation Spaces , Line Folding , Single-Quoted Style , Plain Style , Block Indentation Indicator , Folded Style , Block Sequences , Block Nodes , Bare Documents indentation, Introduction , Prior Art , Collections , Dump , Load , Information Models , Node Styles , Resolved Tags , Production Parameters , Production Naming Conventions , Indentation Spaces , Separation Spaces , Line Prefixes , Line Folding , Comments , Separation Lines , Directives , Block Styles , Block Indentation Indicator , Block Chomping Indicator , Literal Style , Block Sequences , Block Nodes , Bare Documents separation, Separation Spaces , Comments , Flow Mappings , Block Sequences white, Production Naming Conventions , White Space Characters , Separation Spaces , Line Prefixes , Line Folding , Comments , Double-Quoted Style , Single-Quoted Style , Plain Style , Flow Mappings , Literal Style , Folded Style , Block Sequences stream, Prior Art , Processing YAML Information , Processes , Dump , Load , Presentation Stream , Loading Failure Points , Well-Formed Streams and Identified Aliases , Resolved Tags , Syntax Conventions , Character Set , Character Encodings , Miscellaneous Characters , Comments , Tag Prefixes , Empty Nodes , Documents , Streams ill-formed, Load , Loading Failure Points , Well-Formed Streams and Identified Aliases well-formed, Well-Formed Streams and Identified Aliases , Streams style, Dump , Load , Information Models , Presentation Stream , Node Styles , Scalar Formats , Resolved Tags , Node Tags , Double-Quoted Style , Plain Style block, Prior Art , Scalars , Node Styles , Production Parameters , Indentation Spaces , Block Styles , Block Sequences collection, Collections , Structures , Indentation Spaces , Flow Collection Styles , Block Collection Styles , Block Sequences , Block Nodes folded, Scalars , Node Styles , Indicator Characters , Line Folding , Block Scalar Styles , Literal Style , Folded Style literal, Prior Art , Scalars , Node Styles , Indicator Characters , Block Scalar Styles , Literal Style , Folded Style mapping, Node Styles , Production Parameters , Block Mappings , Block Nodes scalar, Node Styles , Block Scalar Styles , Block Scalar Headers , Block Indentation Indicator , Block Chomping Indicator sequence, Collections , Node Styles , Production Parameters , Indicator Characters , Block Sequences , Block Mappings , Block Nodes compact block collection, Node Styles , Block Sequences , Block Mappings flow, Prior Art , Collections , Scalars , Node Styles , Production Parameters , Line Folding , Flow Styles , Flow Sequences , Flow Nodes , Block Nodes collection, Syntax Conventions , Production Parameters , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Collection Styles double-quoted, Prior Art , Scalars , Node Styles , Syntax Conventions , Character Set , Character Encodings , Indicator Characters , Escaped Characters , Flow Scalar Styles , Double-Quoted Style , Flow Nodes mapping, Collections , Node Styles , Production Parameters , Indicator Characters , Flow Mappings , Block Mappings plain, Scalars , Node Styles , Resolved Tags , Production Parameters , Indicator Characters , Node Tags , Empty Nodes , Flow Scalar Styles , Plain Style , Flow Mappings , Flow Nodes , Block Collection Styles , Block Sequences , Block Mappings , Block Nodes , Document Markers , Tag Resolution , Tag Resolution scalar, Scalars , Node Styles , Line Prefixes , Line Folding , Flow Scalar Styles sequence, Collections , Node Styles , Indicator Characters , Flow Sequences , Flow Mappings single-quoted, Node Styles , Production Parameters , Indicator Characters , Flow Scalar Styles , Single-Quoted Style scalar, Node Styles , Escaped Characters , Empty Lines , Flow Scalar Styles , Literal Style single key:value pair mapping, Keys Order , Node Styles , Flow Sequences , Flow Mappings , Block Mappings T tab, Prior Art , Character Set , White Space Characters , Indentation Spaces , Separation Spaces , Line Prefixes , Block Indentation Indicator tag, Prior Art , Tags , Dump , Representation Graph , Nodes , Tags , Node Comparison , Scalar Formats , Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Available Tags , Syntax Conventions , Production Parameters , Indicator Characters , Miscellaneous Characters , “TAG” Directives , Tag Prefixes , Node Properties , Node Tags , Flow Styles , Recommended Schemas , Tags , Tags , Other Schemas available, Available Tags global, Prior Art , Tags , Dump , Tags , Resolved Tags , Tag Handles , Tag Prefixes , Node Tags , Other Schemas handle, Tags , Processes , Dump , Indicator Characters , “TAG” Directives , Tag Handles , Tag Prefixes , Node Tags named, Miscellaneous Characters , Tag Handles , Node Tags primary, Tag Handles secondary, Tag Handles local, Prior Art , Tags , Dump , Tags , Resolved Tags , Indicator Characters , Tag Handles , Tag Prefixes , Node Tags , Other Schemas non-specific, Tags , Dump , Loading Failure Points , Resolved Tags , Indicator Characters , Node Tags , Recommended Schemas , Tag Resolution , Tag Resolution , Other Schemas prefix, “TAG” Directives , Tag Prefixes , Node Tags property, Resolved Tags , Indicator Characters , Node Tags recognized, Recognized and Valid Tags repository, Tags , Tag Handles , Other Schemas bool, Boolean float, Tags , Floating Point int, Tags , Integer map, Tags , Generic Mapping null, Tags , Empty Nodes , Null seq, Tags , Generic Sequence str, Tags , Generic String resolution, Tags , Loading Failure Points , Resolved Tags , Node Tags , Flow Scalar Styles , Recommended Schemas , Tag Resolution , Tag Resolution , Tag Resolution , Other Schemas convention, Resolved Tags , Node Tags , Tag Resolution , Tag Resolution , Tag Resolution shorthand, Tags , Miscellaneous Characters , “TAG” Directives , Tag Handles , Tag Prefixes , Node Tags specific, Resolved Tags , Node Tags unavailable, Load , Loading Failure Points , Available Tags unrecognized, Loading Failure Points , Recognized and Valid Tags unresolved, Loading Failure Points , Resolved Tags verbatim, Node Tags trimming, Line Folding V value, Dump , Nodes , Node Comparison , Resolved Tags , Indicator Characters , Flow Mappings , Block Mappings , Generic Mapping , Null Y YAML 1.1 processing, Line Break Characters , “YAML” Directives ",
                "urlTerms": [
                    "spec",
                    "html"
                ],
                "titleTerms": [
                    "yaml",
                    "markup",
                    "language",
                    "yaml™",
                    "version"
                ]
            }
        },
        {
            "timestamp": 1608987758791,
            "collection": "visits",
            "objectPk": [
                1608987758774,
                "yaml.org/spec/1.2/spec.html"
            ],
            "operation": "create",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "time": 1608987758774
            }
        },
        {
            "timestamp": 1608987758826,
            "collection": "visits",
            "objectPk": [
                1608987758803,
                "yaml.org/spec/1.2/spec.html"
            ],
            "operation": "create",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "time": 1608987758803
            }
        },
        {
            "timestamp": 1608987758851,
            "collection": "annotations",
            "objectPk": "https://yaml.org/spec/1.2/spec.html#application///#1608987751184",
            "operation": "create",
            "object": {
                "pageTitle": "YAML Ain’t Markup Language (YAML™) Version 1.2",
                "pageUrl": "yaml.org/spec/1.2/spec.html",
                "body": "A YAML processor need not expose the serialization or representation stages. It may translate directly between native data structures and a character stream (dump and load in the diagram above). However, such a direct translation should take place so that the native data structures are constructed only from information available in the representation. In particular, mapping key order, comments, and tag handles should not be referenced during composition. ",
                "comment": "#dump #YAML",
                "selector": {
                    "quote": "A YAML processor need not expose the serialization or representation stages. It may translate directly between native data structures and a character stream (dump and load in the diagram above). However, such a direct translation should take place so that the native data structures are constructed only from information available in the representation. In particular, mapping key order, comments, and tag handles should not be referenced during composition. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[1]/div[5]/div[2]/p[2]",
                                "startOffset": 9,
                                "endContainer": "/div[1]/div[5]/div[2]/p[2]",
                                "endOffset": 530
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 44934,
                                "end": 45455
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "A YAML processor need not expose the serialization or representation stages. It may\n        translate directly between native data structures and a character stream (dump and load in the diagram above). However, such a\n        direct translation should take place so that the native data structures are\n        constructed only from\n        information available in the representation. In particular,\n        mapping key order,\n        comments, and tag handles should not be\n        referenced during composition.\n      ",
                                "prefix": " \n          \n          \n        ",
                                "suffix": "\n          \n            \n       "
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T13:02:31.184Z",
                "lastEdited": "2020-12-26T13:12:10.987Z",
                "url": "https://yaml.org/spec/1.2/spec.html#application///#1608987751184"
            }
        },
        {
            "timestamp": 1608987758865,
            "collection": "annotations",
            "objectPk": "https://yaml.org/spec/1.2/spec.html#application///#1608987753881",
            "operation": "create",
            "object": {
                "pageTitle": "YAML Ain’t Markup Language (YAML™) Version 1.2",
                "pageUrl": "yaml.org/spec/1.2/spec.html",
                "body": "A YAML processor need not expose the serialization or representation stages. It may translate directly between native data structures and a character stream (dump and load in the diagram above). However, such a direct translation should take place so that the native data structures are constructed only from information available in the representation. In particular, mapping key order, comments, and tag handles should not be referenced during composition. ",
                "comment": "",
                "selector": {
                    "quote": "A YAML processor need not expose the serialization or representation stages. It may translate directly between native data structures and a character stream (dump and load in the diagram above). However, such a direct translation should take place so that the native data structures are constructed only from information available in the representation. In particular, mapping key order, comments, and tag handles should not be referenced during composition. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[1]/div[5]/div[2]/p[2]",
                                "startOffset": 9,
                                "endContainer": "/div[1]/div[5]/div[2]/p[2]",
                                "endOffset": 530
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 44934,
                                "end": 45455
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "A YAML processor need not expose the serialization or representation stages. It may\n        translate directly between native data structures and a character stream (dump and load in the diagram above). However, such a\n        direct translation should take place so that the native data structures are\n        constructed only from\n        information available in the representation. In particular,\n        mapping key order,\n        comments, and tag handles should not be\n        referenced during composition.\n      ",
                                "prefix": " \n          \n          \n        ",
                                "suffix": "\n          \n            \n       "
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T13:02:33.881Z",
                "lastEdited": "2020-12-26T13:02:33.881Z",
                "url": "https://yaml.org/spec/1.2/spec.html#application///#1608987753881"
            }
        },
        {
            "timestamp": 1608988283419,
            "collection": "pages",
            "objectPk": "yaml.org/spec/1.2/spec.html",
            "operation": "update",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "fullUrl": "https://yaml.org/spec/1.2/spec.html#id2708649",
                "domain": "yaml.org",
                "hostname": "yaml.org",
                "fullTitle": "YAML Ain’t Markup Language (YAML™) Version 1.2",
                "text": " YAML Ain’t Markup Language ( YAML ) Version 1.2 3rd Edition, Patched at 2009-10-01 Oren Ben-Kiki < oren@ben-kiki.org > Clark Evans < cce@clarkevans.com > Ingy döt Net < ingy@ingy.net > Latest (patched) version: HTML: http://yaml.org/spec/1.2/spec.html PDF: http://yaml.org/spec/1.2/spec.pdf PS: http://yaml.org/spec/1.2/spec.ps Errata: http://yaml.org/spec/1.2/errata.html Previous (original) version: http://yaml.org/spec/1.2/2009-07-21/spec.html Copyright © 2001-2009 Oren Ben-Kiki, Clark Evans, Ingy döt Net This document may be freely copied, provided it is not modified. Status of this Document This document reflects the third version of YAML data serialization language. The content of the specification was arrived at by consensus of its authors and through user feedback on the yaml-core mailing list. We encourage implementers to please update their software with support for this version. The primary objective of this revision is to bring YAML into compliance with JSON as an official subset. YAML 1.2 is compatible with 1.1 for most practical applications - this is a minor revision. An expected source of incompatibility with prior versions of YAML, especially the syck implementation, is the change in implicit typing rules. We have removed unique implicit typing rules and have updated these rules to align them with JSON's productions. In this version of YAML, boolean values may be serialized as “ true” or “ false”; the empty scalar as “ null”. Unquoted numeric values are a superset of JSON's numeric production. Other changes in the specification were the removal of the Unicode line breaks and production bug fixes. We also define 3 built-in implicit typing rule sets: untyped, strict JSON, and a more flexible YAML rule set that extends JSON typing. The difference between late 1.0 drafts which syck 0.55 implements and the 1.1 revision of this specification is much more extensive. We fixed usability issues with the tagging syntax. In particular, the single exclamation was re-defined for private types and a simple prefixing mechanism was introduced. This revision also fixed many production edge cases and introduced a type repository. Therefore, there are several incompatibilities between syck and this revision as well. The list of known errors in this specification is available at http://yaml.org/spec/1.2/errata.html . Please report errors in this document to the yaml-core mailing list. This revision contains fixes for all errors known as of 2009-10-01. We wish to thank implementers who have tirelessly tracked earlier versions of this specification, and our fabulous user community whose feedback has both validated and clarified our direction. Abstract YAML (rhymes with “ camel”) is a human-friendly, cross language, Unicode based data serialization language designed around the common native data types of agile programming languages. It is broadly useful for programming needs ranging from configuration files to Internet messaging to object persistence to data auditing. Together with the Unicode standard for characters , this specification provides all the information necessary to understand YAML Version 1.2 and to create programs that process YAML information. Table of Contents 1. Introduction 1.1. Goals 1.2. Prior Art 1.3. Relation to JSON 1.4. Relation to XML 1.5. Terminology 2. Preview 2.1. Collections 2.2. Structures 2.3. Scalars 2.4. Tags 2.5. Full Length Example 3. Processing YAML Information 3.1. Processes 3.1.1. Dump 3.1.2. Load 3.2. Information Models 3.2.1. Representation Graph 3.2.1.1. Nodes 3.2.1.2. Tags 3.2.1.3. Node Comparison 3.2.2. Serialization Tree 3.2.2.1. Keys Order 3.2.2.2. Anchors and Aliases 3.2.3. Presentation Stream 3.2.3.1. Node Styles 3.2.3.2. Scalar Formats 3.2.3.3. Comments 3.2.3.4. Directives 3.3. Loading Failure Points 3.3.1. Well-Formed Streams and Identified Aliases 3.3.2. Resolved Tags 3.3.3. Recognized and Valid Tags 3.3.4. Available Tags 4. Syntax Conventions 4.1. Production Parameters 4.2. Production Naming Conventions 5. Characters 5.1. Character Set 5.2. Character Encodings 5.3. Indicator Characters 5.4. Line Break Characters 5.5. White Space Characters 5.6. Miscellaneous Characters 5.7. Escaped Characters 6. Basic Structures 6.1. Indentation Spaces 6.2. Separation Spaces 6.3. Line Prefixes 6.4. Empty Lines 6.5. Line Folding 6.6. Comments 6.7. Separation Lines 6.8. Directives 6.8.1. “ YAML” Directives 6.8.2. “ TAG” Directives 6.8.2.1. Tag Handles 6.8.2.2. Tag Prefixes 6.9. Node Properties 6.9.1. Node Tags 6.9.2. Node Anchors 7. Flow Styles 7.1. Alias Nodes 7.2. Empty Nodes 7.3. Flow Scalar Styles 7.3.1. Double-Quoted Style 7.3.2. Single-Quoted Style 7.3.3. Plain Style 7.4. Flow Collection Styles 7.4.1. Flow Sequences 7.4.2. Flow Mappings 7.5. Flow Nodes 8. Block Styles 8.1. Block Scalar Styles 8.1.1. Block Scalar Headers 8.1.1.1. Block Indentation Indicator 8.1.1.2. Block Chomping Indicator 8.1.2. Literal Style 8.1.3. Folded Style 8.2. Block Collection Styles 8.2.1. Block Sequences 8.2.2. Block Mappings 8.2.3. Block Nodes 9. YAML Character Stream 9.1. Documents 9.1.1. Document Prefix 9.1.2. Document Markers 9.1.3. Bare Documents 9.1.4. Explicit Documents 9.1.5. Directives Documents 9.2. Streams 10. Recommended Schemas 10.1. Failsafe Schema 10.1.1. Tags 10.1.1.1. Generic Mapping 10.1.1.2. Generic Sequence 10.1.1.3. Generic String 10.1.2. Tag Resolution 10.2. JSON Schema 10.2.1. Tags 10.2.1.1. Null 10.2.1.2. Boolean 10.2.1.3. Integer 10.2.1.4. Floating Point 10.2.2. Tag Resolution 10.3. Core Schema 10.3.1. Tags 10.3.2. Tag Resolution 10.4. Other Schemas Index Chapter 1. Introduction “ YAML Ain’t Markup Language” (abbreviated YAML) is a data serialization language designed to be human-friendly and work well with modern programming languages for common everyday tasks. This specification is both an introduction to the YAML language and the concepts supporting it, and also a complete specification of the information needed to develop applications for processing YAML. Open, interoperable and readily understandable tools have advanced computing immensely. YAML was designed from the start to be useful and friendly to people working with data. It uses Unicode printable characters, some of which provide structural information and the rest containing the data itself. YAML achieves a unique cleanness by minimizing the amount of structural characters and allowing the data to show itself in a natural and meaningful way. For example, indentation may be used for structure, colons separate key: value pairs , and dashes are used to create “ bullet” lists . There are myriad flavors of data structures , but they can all be adequately represented with three basic primitives: mappings (hashes/dictionaries), sequences (arrays/lists) and scalars (strings/numbers). YAML leverages these primitives, and adds a simple typing system and aliasing mechanism to form a complete language for serializing any native data structure . While most programming languages can use YAML for data serialization, YAML excels in working with those languages that are fundamentally built around the three basic primitives. These include the new wave of agile languages such as Perl, Python, PHP, Ruby, and Javascript. There are hundreds of different languages for programming, but only a handful of languages for storing and transferring data. Even though its potential is virtually boundless, YAML was specifically created to work well for common use cases such as: configuration files, log files, interprocess messaging, cross-language data sharing, object persistence, and debugging of complex data structures. When data is easy to view and understand, programming becomes a simpler task. 1.1. Goals The design goals for YAML are, in decreasing priority: YAML is easily readable by humans. YAML data is portable between programming languages. YAML matches the native data structures of agile languages. YAML has a consistent model to support generic tools. YAML supports one-pass processing. YAML is expressive and extensible. YAML is easy to implement and use. 1.2. Prior Art YAML’s initial direction was set by the data serialization and markup language discussions among SML-DEV members . Later on, it directly incorporated experience from Ingy döt Net’s Perl module Data::Denter . Since then, YAML has matured through ideas and support from its user community. YAML integrates and builds upon concepts described by C , Java , Perl , Python , Ruby , RFC0822 (MAIL), RFC1866 (HTML), RFC2045 (MIME), RFC2396 (URI), XML , SAX , SOAP , and JSON . The syntax of YAML was motivated by Internet Mail (RFC0822) and remains partially compatible with that standard. Further, borrowing from MIME (RFC2045), YAML’s top-level production is a stream of independent documents , ideal for message-based distributed processing systems. YAML’s indentation -based scoping is similar to Python’s (without the ambiguities caused by tabs ). Indented blocks facilitate easy inspection of the data’s structure. YAML’s literal style leverages this by enabling formatted text to be cleanly mixed within an indented structure without troublesome escaping . YAML also allows the use of traditional indicator -based scoping similar to JSON’s and Perl’s. Such flow content can be freely nested inside indented blocks . YAML’s double-quoted style uses familiar C-style escape sequences . This enables ASCII encoding of non- printable or 8-bit (ISO 8859-1) characters such as “ \\x3B” . Non- printable 16-bit Unicode and 32-bit (ISO/IEC 10646) characters are supported with escape sequences such as “ \\u003B” and “ \\U0000003B” . Motivated by HTML’s end-of-line normalization, YAML’s line folding employs an intuitive method of handling line breaks . A single line break is folded into a single space , while empty lines are interpreted as line break characters. This technique allows for paragraphs to be word-wrapped without affecting the canonical form of the scalar content . YAML’s core type system is based on the requirements of agile languages such as Perl, Python, and Ruby. YAML directly supports both collections ( mappings , sequences ) and scalars . Support for these common types enables programmers to use their language’s native data structures for YAML manipulation, instead of requiring a special document object model (DOM). Like XML’s SOAP, YAML supports serializing a graph of native data structures through an aliasing mechanism. Also like SOAP, YAML provides for application -defined types . This allows YAML to represent rich data structures required for modern distributed computing. YAML provides globally unique type names using a namespace mechanism inspired by Java’s DNS-based package naming convention and XML’s URI-based namespaces. In addition, YAML allows for private types specific to a single application . YAML was designed to support incremental interfaces that include both input (“ getNextEvent()”) and output (“ sendNextEvent()”) one-pass interfaces. Together, these enable YAML to support the processing of large documents (e.g. transaction logs) or continuous streams (e.g. feeds from a production machine). 1.3. Relation to JSON Both JSON and YAML aim to be human readable data interchange formats. However, JSON and YAML have different priorities. JSON’s foremost design goal is simplicity and universality. Thus, JSON is trivial to generate and parse, at the cost of reduced human readability. It also uses a lowest common denominator information model, ensuring any JSON data can be easily processed by every modern programming environment. In contrast, YAML’s foremost design goals are human readability and support for serializing arbitrary native data structures . Thus, YAML allows for extremely readable files, but is more complex to generate and parse. In addition, YAML ventures beyond the lowest common denominator data types, requiring more complex processing when crossing between different programming environments. YAML can therefore be viewed as a natural superset of JSON, offering improved human readability and a more complete information model. This is also the case in practice; every JSON file is also a valid YAML file. This makes it easy to migrate from JSON to YAML if/when the additional features are required. JSON's RFC4627 requires that mappings keys merely “ SHOULD” be unique , while YAML insists they “ MUST” be. Technically, YAML therefore complies with the JSON spec, choosing to treat duplicates as an error. In practice, since JSON is silent on the semantics of such duplicates, the only portable JSON files are those with unique keys, which are therefore valid YAML files. It may be useful to define a intermediate format between YAML and JSON. Such a format would be trivial to parse (but not very human readable), like JSON. At the same time, it would allow for serializing arbitrary native data structures , like YAML. Such a format might also serve as YAML’s \"canonical format\". Defining such a “ YSON” format (YSON is a Serialized Object Notation) can be done either by enhancing the JSON specification or by restricting the YAML specification. Such a definition is beyond the scope of this specification. 1.4. Relation to XML Newcomers to YAML often search for its correlation to the eXtensible Markup Language (XML). Although the two languages may actually compete in several application domains, there is no direct correlation between them. YAML is primarily a data serialization language. XML was designed to be backwards compatible with the Standard Generalized Markup Language (SGML), which was designed to support structured documentation. XML therefore had many design constraints placed on it that YAML does not share. XML is a pioneer in many domains, YAML is the result of lessons learned from XML and other technologies. It should be mentioned that there are ongoing efforts to define standard XML/YAML mappings. This generally requires that a subset of each language be used. For more information on using both XML and YAML, please visit http://yaml.org/xml . 1.5. Terminology This specification uses key words based on RFC2119 to indicate requirement level. In particular, the following words are used to describe the actions of a YAML processor : May The word may, or the adjective optional, mean that conforming YAML processors are permitted to, but need not behave as described. Should The word should, or the adjective recommended, mean that there could be reasons for a YAML processor to deviate from the behavior described, but that such deviation could hurt interoperability and should therefore be advertised with appropriate notice. Must The word must, or the term required or shall, mean that the behavior described is an absolute requirement of the specification. The rest of this document is arranged as follows. Chapter 2 provides a short preview of the main YAML features. Chapter 3 describes the YAML information model, and the processes for converting from and to this model and the YAML text format. The bulk of the document, chapters 4 through 9 , formally define this text format. Finally, chapter 10 recommends basic YAML schemas. Chapter 2. Preview This section provides a quick glimpse into the expressive power of YAML. It is not expected that the first-time reader grok all of the examples. Rather, these selections are used as motivation for the remainder of the specification. 2.1. Collections YAML’s block collections use indentation for scope and begin each entry on its own line. Block sequences indicate each entry with a dash and space ( “ - ” ). Mappings use a colon and space ( “ : ” ) to mark each key: value pair . Comments begin with an octothorpe (also called a “ hash”, “ sharp”, “ pound”, or “ number sign” - “ #” ). Example 2.1. Sequence of Scalars (ball players) - Mark McGwire - Sammy Sosa - Ken Griffey Example 2.2. Mapping Scalars to Scalars (player statistics) hr: 65 # Home runs avg: 0.278 # Batting average rbi: 147 # Runs Batted In Example 2.3. Mapping Scalars to Sequences (ball clubs in each league) american: - Boston Red Sox - Detroit Tigers - New York Yankees national: - New York Mets - Chicago Cubs - Atlanta Braves Example 2.4. Sequence of Mappings (players’ statistics) - name: Mark McGwire hr: 65 avg: 0.278 - name: Sammy Sosa hr: 63 avg: 0.288 YAML also has flow styles , using explicit indicators rather than indentation to denote scope. The flow sequence is written as a comma separated list within square brackets . In a similar manner, the flow mapping uses curly braces . Example 2.5. Sequence of Sequences - [name , hr, avg ] - [Mark McGwire, 65, 0.278] - [Sammy Sosa , 63, 0.288] Example 2.6. Mapping of Mappings Mark McGwire: {hr: 65, avg: 0.278} Sammy Sosa: { hr: 63, avg: 0.288 } 2.2. Structures YAML uses three dashes ( “ ---” ) to separate directives from document content . This also serves to signal the start of a document if no directives are present. Three dots ( “ ...” ) indicate the end of a document without starting a new one, for use in communication channels. Example 2.7. Two Documents in a Stream (each with a leading comment) # Ranking of 1998 home runs --- - Mark McGwire - Sammy Sosa - Ken Griffey # Team ranking --- - Chicago Cubs - St Louis Cardinals Example 2.8. Play by Play Feed from a Game --- time: 20:03:20 player: Sammy Sosa action: strike (miss) ... --- time: 20:03:47 player: Sammy Sosa action: grand slam ... Repeated nodes (objects) are first identified by an anchor (marked with the ampersand - “ &” ), and are then aliased (referenced with an asterisk - “ *” ) thereafter. Example 2.9. Single Document with Two Comments --- hr: # 1998 hr ranking - Mark McGwire - Sammy Sosa rbi: # 1998 rbi ranking - Sammy Sosa - Ken Griffey Example 2.10. Node for “ Sammy Sosa” appears twice in this document --- hr: - Mark McGwire # Following node labeled SS - &SS Sammy Sosa rbi: - *SS # Subsequent occurrence - Ken Griffey A question mark and space ( “ ? ” ) indicate a complex mapping key . Within a block collection , key: value pairs can start immediately following the dash , colon , or question mark . Example 2.11. Mapping between Sequences ? - Detroit Tigers - Chicago cubs : - 2001-07-23 ? [ New York Yankees, Atlanta Braves ] : [ 2001-07-02, 2001-08-12, 2001-08-14 ] Example 2.12. Compact Nested Mapping --- # Products purchased - item : Super Hoop quantity: 1 - item : Basketball quantity: 4 - item : Big Shoes quantity: 1 2.3. Scalars Scalar content can be written in block notation, using a literal style (indicated by “ |” ) where all line breaks are significant. Alternatively, they can be written with the folded style (denoted by “ >” ) where each line break is folded to a space unless it ends an empty or a more-indented line. Example 2.13. In literals, newlines are preserved # ASCII Art --- | \\//||\\/|| // || ||__ Example 2.14. In the folded scalars, newlines become spaces --- > Mark McGwire's year was crippled by a knee injury. Example 2.15. Folded newlines are preserved for \"more indented\" and blank lines > Sammy Sosa completed another fine season with great stats. 63 Home Runs 0.288 Batting Average What a year! Example 2.16. Indentation determines scope name: Mark McGwire accomplishment: > Mark set a major league home run record in 1998. stats: | 65 Home Runs 0.278 Batting Average YAML’s flow scalars include the plain style (most examples thus far) and two quoted styles. The double-quoted style provides escape sequences . The single-quoted style is useful when escaping is not needed. All flow scalars can span multiple lines; line breaks are always folded . Example 2.17. Quoted Scalars unicode: \"Sosa did fine.\\u263A\" control: \"\\b1998\\t1999\\t2000\\n\" hex esc: \"\\x0d\\x0a is \\r\\n\" single: '\"Howdy!\" he cried.' quoted: ' # Not a ''comment''.' tie-fighter: '|\\-*-/|' Example 2.18. Multi-line Flow Scalars plain: This unquoted scalar spans many lines. quoted: \"So does this quoted scalar.\\n\" 2.4. Tags In YAML, untagged nodes are given a type depending on the application . The examples in this specification generally use the seq , map and str types from the fail safe schema . A few examples also use the int , float , and null types from the JSON schema . The repository includes additional types such as binary , omap , set and others. Example 2.19. Integers canonical: 12345 decimal: +12345 octal: 0o14 hexadecimal: 0xC Example 2.20. Floating Point canonical: 1.23015e+3 exponential: 12.3015e+02 fixed: 1230.15 negative infinity: -.inf not a number: .NaN Example 2.21. Miscellaneous null: booleans: [ true, false ] string: '012345' Example 2.22. Timestamps canonical: 2001-12-15T02:59:43.1Z iso8601: 2001-12-14t21:59:43.10-05:00 spaced: 2001-12-14 21:59:43.10 -5 date: 2002-12-14 Explicit typing is denoted with a tag using the exclamation point ( “ !” ) symbol. Global tags are URIs and may be specified in a tag shorthand notation using a handle . Application -specific local tags may also be used. Example 2.23. Various Explicit Tags --- not-date: !!str 2002-04-28 picture: !!binary | R0lGODlhDAAMAIQAAP//9/X 17unp5WZmZgAAAOfn515eXv Pz7Y6OjuDg4J+fn5OTk6enp 56enmleECcgggoBADs= application specific tag: !something | The semantics of the tag above may be different for different documents. Example 2.24. Global Tags %TAG ! tag:clarkevans.com,2002: --- !shape # Use the ! handle for presenting # tag:clarkevans.com,2002:circle - !circle center: &ORIGIN {x: 73, y: 129} radius: 7 - !line start: *ORIGIN finish: { x: 89, y: 102 } - !label start: *ORIGIN color: 0xFFEEBB text: Pretty vector drawing. Example 2.25. Unordered Sets # Sets are represented as a # Mapping where each key is # associated with a null value --- !!set ? Mark McGwire ? Sammy Sosa ? Ken Griff Example 2.26. Ordered Mappings # Ordered maps are represented as # A sequence of mappings, with # each mapping having one key --- !!omap - Mark McGwire: 65 - Sammy Sosa: 63 - Ken Griffy: 58 2.5. Full Length Example Below are two full-length examples of YAML. On the left is a sample invoice; on the right is a sample log file. Example 2.27. Invoice --- !<tag:clarkevans.com,2002:invoice> invoice: 34843 date : 2001-01-23 bill-to: &id001 given : Chris family : Dumars address: lines: | 458 Walkman Dr. Suite #292 city : Royal Oak state : MI postal : 48046 ship-to: *id001 product: - sku : BL394D quantity : 4 description : Basketball price : 450.00 - sku : BL4438H quantity : 1 description : Super Hoop price : 2392.00 tax : 251.42 total: 4443.52 comments: Late afternoon is best. Backup contact is Nancy Billsmer @ 338-4338. Example 2.28. Log File --- Time: 2001-11-23 15:01:42 -5 User: ed Warning: This is an error message for the log file --- Time: 2001-11-23 15:02:31 -5 User: ed Warning: A slightly different error message. --- Date: 2001-11-23 15:03:17 -5 User: ed Fatal: Unknown variable \"bar\" Stack: - file: TopClass.py line: 23 code: | x = MoreObject(\"345\\n\") - file: MoreClass.py line: 58 code: |- foo = bar Chapter 3. Processing YAML Information YAML is both a text format and a method for presenting any native data structure in this format. Therefore, this specification defines two concepts: a class of data objects called YAML representations , and a syntax for presenting YAML representations as a series of characters, called a YAML stream . A YAML processor is a tool for converting information between these complementary views. It is assumed that a YAML processor does its work on behalf of another module, called an application. This chapter describes the information structures a YAML processor must provide to or obtain from the application. YAML information is used in two ways: for machine processing, and for human consumption. The challenge of reconciling these two perspectives is best done in three distinct translation stages: representation , serialization , and presentation . Representation addresses how YAML views native data structures to achieve portability between programming environments. Serialization concerns itself with turning a YAML representation into a serial form, that is, a form with sequential access constraints. Presentation deals with the formatting of a YAML serialization as a series of characters in a human-friendly manner. 3.1. Processes Translating between native data structures and a character stream is done in several logically distinct stages, each with a well defined input and output data model, as shown in the following diagram: Figure 3.1. Processing Overview A YAML processor need not expose the serialization or representation stages. It may translate directly between native data structures and a character stream ( dump and load in the diagram above). However, such a direct translation should take place so that the native data structures are constructed only from information available in the representation . In particular, mapping key order , comments , and tag handles should not be referenced during composition . 3.1.1. Dump Dumping native data structures to a character stream is done using the following three stages: Representing Native Data Structures YAML represents any native data structure using three node kinds : sequence - an ordered series of entries; mapping - an unordered association of unique keys to values ; and scalar - any datum with opaque structure presentable as a series of Unicode characters. Combined, these primitives generate directed graph structures. These primitives were chosen because they are both powerful and familiar: the sequence corresponds to a Perl array and a Python list, the mapping corresponds to a Perl hash table and a Python dictionary. The scalar represents strings, integers, dates, and other atomic data types. Each YAML node requires, in addition to its kind and content , a tag specifying its data type. Type specifiers are either global URIs, or are local in scope to a single application . For example, an integer is represented in YAML with a scalar plus the global tag “ tag:yaml.org,2002:int”. Similarly, an invoice object, particular to a given organization, could be represented as a mapping together with the local tag “ !invoice”. This simple model can represent any data structure independent of programming language. Serializing the Representation Graph For sequential access mediums, such as an event callback API, a YAML representation must be serialized to an ordered tree. Since in a YAML representation , mapping keys are unordered and nodes may be referenced more than once (have more than one incoming “ arrow”), the serialization process is required to impose an ordering on the mapping keys and to replace the second and subsequent references to a given node with place holders called aliases . YAML does not specify how these serialization details are chosen. It is up to the YAML processor to come up with human-friendly key order and anchor names, possibly with the help of the application . The result of this process, a YAML serialization tree , can then be traversed to produce a series of event calls for one-pass processing of YAML data. Presenting the Serialization Tree The final output process is presenting the YAML serializations as a character stream in a human-friendly manner. To maximize human readability, YAML offers a rich set of stylistic options which go far beyond the minimal functional needs of simple data storage. Therefore the YAML processor is required to introduce various presentation details when creating the stream , such as the choice of node styles , how to format scalar content , the amount of indentation , which tag handles to use, the node tags to leave unspecified , the set of directives to provide and possibly even what comments to add. While some of this can be done with the help of the application , in general this process should be guided by the preferences of the user. 3.1.2. Load Loading native data structures from a character stream is done using the following three stages: Parsing the Presentation Stream Parsing is the inverse process of presentation , it takes a stream of characters and produces a series of events. Parsing discards all the details introduced in the presentation process, reporting only the serialization events. Parsing can fail due to ill-formed input. Composing the Representation Graph Composing takes a series of serialization events and produces a representation graph . Composing discards all the details introduced in the serialization process, producing only the representation graph . Composing can fail due to any of several reasons, detailed below . Constructing Native Data Structures The final input process is constructing native data structures from the YAML representation . Construction must be based only on the information available in the representation , and not on additional serialization or presentation details such as comments , directives , mapping key order , node styles , scalar content format , indentation levels etc. Construction can fail due to the unavailability of the required native data types . 3.2. Information Models This section specifies the formal details of the results of the above processes. To maximize data portability between programming languages and implementations, users of YAML should be mindful of the distinction between serialization or presentation properties and those which are part of the YAML representation . Thus, while imposing a order on mapping keys is necessary for flattening YAML representations to a sequential access medium, this serialization detail must not be used to convey application level information. In a similar manner, while indentation technique and a choice of a node style are needed for the human readability, these presentation details are neither part of the YAML serialization nor the YAML representation . By carefully separating properties needed for serialization and presentation , YAML representations of application information will be consistent and portable between various programming environments. The following diagram summarizes the three information models. Full arrows denote composition, hollow arrows denote inheritance, “ 1” and “ *” denote “ one” and “ many” relationships. A single “ +” denotes serialization details, a double “ ++” denotes presentation details. Figure 3.2. Information Models 3.2.1. Representation Graph YAML’s representation of native data structure is a rooted, connected, directed graph of tagged nodes . By “ directed graph” we mean a set of nodes and directed edges (“ arrows”), where each edge connects one node to another (see a formal definition ). All the nodes must be reachable from the root node via such edges. Note that the YAML graph may include cycles, and a node may have more than one incoming edge. Nodes that are defined in terms of other nodes are collections ; nodes that are independent of any other nodes are scalars . YAML supports two kinds of collection nodes : sequences and mappings . Mapping nodes are somewhat tricky because their keys are unordered and must be unique . Figure 3.3. Representation Model 3.2.1.1. Nodes A YAML node represents a single native data structure . Such nodes have content of one of three kinds: scalar, sequence, or mapping. In addition, each node has a tag which serves to restrict the set of possible values the content can have. Scalar The content of a scalar node is an opaque datum that can be presented as a series of zero or more Unicode characters. Sequence The content of a sequence node is an ordered series of zero or more nodes. In particular, a sequence may contain the same node more than once. It could even contain itself (directly or indirectly). Mapping The content of a mapping node is an unordered set of key: value node pairs, with the restriction that each of the keys is unique . YAML places no further restrictions on the nodes. In particular, keys may be arbitrary nodes, the same node may be used as the value of several key: value pairs, and a mapping could even contain itself as a key or a value (directly or indirectly). When appropriate, it is convenient to consider sequences and mappings together, as collections. In this view, sequences are treated as mappings with integer keys starting at zero. Having a unified collections view for sequences and mappings is helpful both for theoretical analysis and for creating practical YAML tools and APIs. This strategy is also used by the Javascript programming language. 3.2.1.2. Tags YAML represents type information of native data structures with a simple identifier, called a tag. Global tags are URIs and hence globally unique across all applications . The “ tag:” URI scheme is recommended for all global YAML tags. In contrast, local tags are specific to a single application . Local tags start with “ !”, are not URIs and are not expected to be globally unique. YAML provides a “ TAG” directive to make tag notation less verbose; it also offers easy migration from local to global tags. To ensure this, local tags are restricted to the URI character set and use URI character escaping . YAML does not mandate any special relationship between different tags that begin with the same substring. Tags ending with URI fragments (containing “ #”) are no exception; tags that share the same base URI but differ in their fragment part are considered to be different, independent tags. By convention, fragments are used to identify different “ variants” of a tag, while “ /” is used to define nested tag “ namespace” hierarchies. However, this is merely a convention, and each tag may employ its own rules. For example, Perl tags may use “ ::” to express namespace hierarchies, Java tags may use “ .”, etc. YAML tags are used to associate meta information with each node . In particular, each tag must specify the expected node kind ( scalar , sequence , or mapping ). Scalar tags must also provide a mechanism for converting formatted content to a canonical form for supporting equality testing. Furthermore, a tag may provide additional information such as the set of allowed content values for validation, a mechanism for tag resolution , or any other data that is applicable to all of the tag’s nodes . 3.2.1.3. Node Comparison Since YAML mappings require key uniqueness, representations must include a mechanism for testing the equality of nodes . This is non-trivial since YAML allows various ways to format scalar content . For example, the integer eleven can be written as “ 0o13” (octal) or “ 0xB” (hexadecimal). If both notations are used as keys in the same mapping , only a YAML processor which recognizes integer formats would correctly flag the duplicate key as an error. Canonical Form YAML supports the need for scalar equality by requiring that every scalar tag must specify a mechanism for producing the canonical form of any formatted content . This form is a Unicode character string which also presents the same content , and can be used for equality testing. While this requirement is stronger than a well defined equality operator, it has other uses, such as the production of digital signatures. Equality Two nodes must have the same tag and content to be equal. Since each tag applies to exactly one kind , this implies that the two nodes must have the same kind to be equal. Two scalars are equal only when their tags and canonical forms are equal character-by-character. Equality of collections is defined recursively. Two sequences are equal only when they have the same tag and length, and each node in one sequence is equal to the corresponding node in the other sequence . Two mappings are equal only when they have the same tag and an equal set of keys , and each key in this set is associated with equal values in both mappings . Different URI schemes may define different rules for testing the equality of URIs. Since a YAML processor cannot be reasonably expected to be aware of them all, it must resort to a simple character-by-character comparison of tags to ensure consistency. This also happens to be the comparison method defined by the “ tag:” URI scheme. Tags in a YAML stream must therefore be presented in a canonical way so that such comparison would yield the correct results. Identity Two nodes are identical only when they represent the same native data structure . Typically, this corresponds to a single memory address. Identity should not be confused with equality; two equal nodes need not have the same identity. A YAML processor may treat equal scalars as if they were identical. In contrast, the separate identity of two distinct but equal collections must be preserved. 3.2.2. Serialization Tree To express a YAML representation using a serial API, it is necessary to impose an order on mapping keys and employ alias nodes to indicate a subsequent occurrence of a previously encountered node . The result of this process is a serialization tree, where each node has an ordered set of children. This tree can be traversed for a serial event-based API. Construction of native data structures from the serial interface should not use key order or anchor names for the preservation of application data. Figure 3.4. Serialization Model 3.2.2.1. Keys Order In the representation model, mapping keys do not have an order. To serialize a mapping , it is necessary to impose an ordering on its keys . This order is a serialization detail and should not be used when composing the representation graph (and hence for the preservation of application data). In every case where node order is significant, a sequence must be used. For example, an ordered mapping can be represented as a sequence of mappings , where each mapping is a single key: value pair . YAML provides convenient compact notation for this case. 3.2.2.2. Anchors and Aliases In the representation graph , a node may appear in more than one collection . When serializing such data, the first occurrence of the node is identified by an anchor. Each subsequent occurrence is serialized as an alias node which refers back to this anchor. Otherwise, anchor names are a serialization detail and are discarded once composing is completed. When composing a representation graph from serialized events, an alias node refers to the most recent node in the serialization having the specified anchor. Therefore, anchors need not be unique within a serialization . In addition, an anchor need not have an alias node referring to it. It is therefore possible to provide an anchor for all nodes in serialization . 3.2.3. Presentation Stream A YAML presentation is a stream of Unicode characters making use of of styles , scalar content formats , comments , directives and other presentation details to present a YAML serialization in a human readable way. Although a YAML processor may provide these details when parsing , they should not be reflected in the resulting serialization . YAML allows several serialization trees to be contained in the same YAML character stream, as a series of documents separated by markers . Documents appearing in the same stream are independent; that is, a node must not appear in more than one serialization tree or representation graph . Figure 3.5. Presentation Model 3.2.3.1. Node Styles Each node is presented in some style, depending on its kind . The node style is a presentation detail and is not reflected in the serialization tree or representation graph . There are two groups of styles. Block styles use indentation to denote structure; In contrast, flow styles styles rely on explicit indicators . YAML provides a rich set of scalar styles. Block scalar styles include the literal style and the folded style . Flow scalar styles include the plain style and two quoted styles, the single-quoted style and the double-quoted style . These styles offer a range of trade-offs between expressive power and readability. Normally, block sequences and mappings begin on the next line. In some cases, YAML also allows nested block collections to start in-line for a more compact notation . In addition, YAML provides a compact notation for flow mappings with a single key: value pair , nested inside a flow sequence . These allow for a natural “ ordered mapping” notation. Figure 3.6. Kind/Style Combinations 3.2.3.2. Scalar Formats YAML allows scalars to be presented in several formats. For example, the integer “ 11” might also be written as “ 0xB”. Tags must specify a mechanism for converting the formatted content to a canonical form for use in equality testing. Like node style , the format is a presentation detail and is not reflected in the serialization tree and representation graph . 3.2.3.3. Comments Comments are a presentation detail and must not have any effect on the serialization tree or representation graph . In particular, comments are not associated with a particular node . The usual purpose of a comment is to communicate between the human maintainers of a file. A typical example is comments in a configuration file. Comments must not appear inside scalars , but may be interleaved with such scalars inside collections . 3.2.3.4. Directives Each document may be associated with a set of directives . A directive has a name and an optional sequence of parameters. Directives are instructions to the YAML processor , and like all other presentation details are not reflected in the YAML serialization tree or representation graph . This version of YAML defines a two directives, “ YAML” and “ TAG” . All other directives are reserved for future versions of YAML. 3.3. Loading Failure Points The process of loading native data structures from a YAML stream has several potential failure points. The character stream may be ill-formed , aliases may be unidentified , unspecified tags may be unresolvable , tags may be unrecognized , the content may be invalid , and a native type may be unavailable . Each of these failures results with an incomplete loading. A partial representation need not resolve the tag of each node , and the canonical form of formatted scalar content need not be available. This weaker representation is useful for cases of incomplete knowledge of the types used in the document . In contrast, a complete representation specifies the tag of each node , and provides the canonical form of formatted scalar content , allowing for equality testing. A complete representation is required in order to construct native data structures . Figure 3.7. Loading Failure Points 3.3.1. Well-Formed Streams and Identified Aliases A well-formed character stream must match the BNF productions specified in the following chapters. Successful loading also requires that each alias shall refer to a previous node identified by the anchor . A YAML processor should reject ill-formed streams and unidentified aliases. A YAML processor may recover from syntax errors, possibly by ignoring certain parts of the input, but it must provide a mechanism for reporting such errors. 3.3.2. Resolved Tags Typically, most tags are not explicitly specified in the character stream . During parsing , nodes lacking an explicit tag are given a non-specific tag: “ !” for non- plain scalars , and “ ?” for all other nodes . Composing a complete representation requires each such non-specific tag to be resolved to a specific tag, be it a global tag or a local tag . Resolving the tag of a node must only depend on the following three parameters: (1) the non-specific tag of the node , (2) the path leading from the root to the node , and (3) the content (and hence the kind ) of the node . When a node has more than one occurrence (using aliases ), tag resolution must depend only on the path to the first ( anchored ) occurrence of the node . Note that resolution must not consider presentation details such as comments , indentation and node style . Also, resolution must not consider the content of any other node , except for the content of the key nodes directly along the path leading from the root to the resolved node . Finally, resolution must not consider the content of a sibling node in a collection , or the content of the value node associated with a key node being resolved. These rules ensure that tag resolution can be performed as soon as a node is first encountered in the stream , typically before its content is parsed . Also, tag resolution only requires referring to a relatively small number of previously parsed nodes . Thus, in most cases, tag resolution in one-pass processors is both possible and practical. YAML processors should resolve nodes having the “ !” non-specific tag as “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map” or “ tag:yaml.org,2002:str” depending on their kind . This tag resolution convention allows the author of a YAML character stream to effectively “ disable” the tag resolution process. By explicitly specifying a “ !” non-specific tag property , the node would then be resolved to a “ vanilla” sequence , mapping , or string, according to its kind . Application specific tag resolution rules should be restricted to resolving the “ ?” non-specific tag, most commonly to resolving plain scalars . These may be matched against a set of regular expressions to provide automatic resolution of integers, floats, timestamps, and similar types. An application may also match the content of mapping nodes against sets of expected keys to automatically resolve points, complex numbers, and similar types. Resolved sequence node types such as the “ ordered mapping” are also possible. That said, tag resolution is specific to the application . YAML processors should therefore provide a mechanism allowing the application to override and expand these default tag resolution rules. If a document contains unresolved tags, the YAML processor is unable to compose a complete representation graph. In such a case, the YAML processor may compose a partial representation , based on each node’s kind and allowing for non-specific tags. 3.3.3. Recognized and Valid Tags To be valid, a node must have a tag which is recognized by the YAML processor and its content must satisfy the constraints imposed by this tag . If a document contains a scalar node with an unrecognized tag or invalid content, only a partial representation may be composed . In contrast, a YAML processor can always compose a complete representation for an unrecognized or an invalid collection , since collection equality does not depend upon knowledge of the collection’s data type. However, such a complete representation cannot be used to construct a native data structure . 3.3.4. Available Tags In a given processing environment, there need not be an available native type corresponding to a given tag . If a node’s tag is unavailable, a YAML processor will not be able to construct a native data structure for it. In this case, a complete representation may still be composed , and an application may wish to use this representation directly. Chapter 4. Syntax Conventions The following chapters formally define the syntax of YAML character streams , using parameterized BNF productions. Each BNF production is both named and numbered for easy reference. Whenever possible, basic structures are specified before the more complex structures using them in a “ bottom up” fashion. The order of alternatives inside a production is significant. Subsequent alternatives are only considered when previous ones fails. See for example the b-break production. In addition, production matching is expected to be greedy. Optional ( ?), zero-or-more ( *) and one-or-more ( +) patterns are always expected to match as much of the input as possible. The productions are accompanied by examples, which are given side-by-side next to equivalent YAML text in an explanatory format. This format uses only flow collections , double-quoted scalars , and explicit tags for each node . A reference implementation using the productions is available as the YamlReference Haskell package. This reference implementation is also available as an interactive web application at http://dev.yaml.org/ypaste . 4.1. Production Parameters YAML’s syntax is designed for maximal human readability. This requires parsing to depend on the surrounding text. For notational compactness, this dependency is expressed using parameterized BNF productions. This context sensitivity is the cause of most of the complexity of the YAML syntax definition. It is further complicated by struggling with the human tendency to look ahead when interpreting text. These complications are of course the source of most of YAML’s power to present data in a very human readable way. Productions use any of the following parameters: Indentation: n or m Many productions use an explicit indentation level parameter. This is less elegant than Python’s “ indent” and “ undent” conceptual tokens. However it is required to formally express YAML’s indentation rules. Context: c This parameter allows productions to tweak their behavior according to their surrounding. YAML supports two groups of contexts, distinguishing between block styles and flow styles . In block styles , indentation is used to delineate structure. To capture human perception of indentation the rules require special treatment of the “ -” character, used in block sequences . Hence in some cases productions need to behave differently inside block sequences ( block-in context) and outside them ( block-out context). In flow styles , explicit indicators are used to delineate structure. These styles can be viewed as the natural extension of JSON to cover tagged , single-quoted and plain scalars . Since the latter have no delineating indicators , they are subject to some restrictions to avoid ambiguities. These restrictions depend on where they appear: as implicit keys directly inside a block mapping ( block-key); as implicit keys inside a flow mapping ( flow-key); as values inside a flow collection ( flow-in); or as values outside one ( flow-out). (Block) Chomping: t Block scalars offer three possible mechanisms for chomping any trailing line breaks : strip , clip and keep . Unlike the previous parameters, this only controls interpretation; the line breaks are valid in all cases. 4.2. Production Naming Conventions To make it easier to follow production combinations, production names use a Hungarian-style naming convention. Each production is given a prefix based on the type of characters it begins and ends with. e- A production matching no characters. c- A production starting and ending with a special character. b- A production matching a single line break . nb- A production starting and ending with a non- break character. s- A production starting and ending with a white space character. ns- A production starting and ending with a non- space character. l- A production matching complete line(s). X - Y - A production starting with an X - character and ending with a Y - character, where X - and Y - are any of the above prefixes. X +, X - Y + A production as above, with the additional property that the matched content indentation level is greater than the specified n parameter. Chapter 5. Characters 5.1. Character Set To ensure readability, YAML streams use only the printable subset of the Unicode character set. The allowed character range explicitly excludes the C0 control block #x0-#x1F (except for TAB #x9, LF #xA, and CR #xD which are allowed), DEL #x7F, the C1 control block #x80-#x9F (except for NEL #x85 which is allowed), the surrogate block #xD800-#xDFFF, #xFFFE, and #xFFFF. On input, a YAML processor must accept all Unicode characters except those explicitly excluded above. On output, a YAML processor must only produce acceptable characters. Any excluded characters must be presented using escape sequences. In addition, any allowed characters known to be non-printable should also be escaped . This isn’t mandatory since a full implementation would require extensive character property tables. [1] c-printable ::= #x9 | #xA | #xD | [#x20-#x7E] /* 8 bit */ | #x85 | [#xA0-#xD7FF] | [#xE000-#xFFFD] /* 16 bit */ | [#x10000-#x10FFFF] /* 32 bit */ To ensure JSON compatibility , YAML processors must allow all non-control characters inside quoted scalars . To ensure readability, non-printable characters should be escaped on output, even inside such scalars . Note that JSON quoted scalars cannot span multiple lines or contain tabs , but YAML quoted scalars can. [2] nb-json ::= #x9 | [#x20-#x10FFFF] 5.2. Character Encodings All characters mentioned in this specification are Unicode code points. Each such code point is written as one or more bytes depending on the character encoding used. Note that in UTF-16, characters above #xFFFF are written as four bytes, using a surrogate pair. The character encoding is a presentation detail and must not be used to convey content information. On input, a YAML processor must support the UTF-8 and UTF-16 character encodings. For JSON compatibility , the UTF-32 encodings must also be supported. If a character stream begins with a byte order mark, the character encoding will be taken to be as as indicated by the byte order mark. Otherwise, the stream must begin with an ASCII character. This allows the encoding to be deduced by the pattern of null ( #x00) characters. To make it easier to concatenate streams , byte order marks may appear at the start of any document . However all documents in the same stream must use the same character encoding. To allow for JSON compatibility , byte order marks are also allowed inside quoted scalars . For readability, such content byte order marks should be escaped on output. The encoding can therefore be deduced by matching the first few bytes of the stream with the following table rows (in order): Byte0 Byte1 Byte2 Byte3 Encoding Explicit BOM #x00 #x00 #xFE #xFF UTF-32BE ASCII first character #x00 #x00 #x00 any UTF-32BE Explicit BOM #xFF #xFE #x00 #x00 UTF-32LE ASCII first character any #x00 #x00 #x00 UTF-32LE Explicit BOM #xFE #xFF UTF-16BE ASCII first character #x00 any UTF-16BE Explicit BOM #xFF #xFE UTF-16LE ASCII first character any #x00 UTF-16LE Explicit BOM #xEF #xBB #xBF UTF-8 Default UTF-8 The recommended output encoding is UTF-8. If another encoding is used, it is recommended that an explicit byte order mark be used, even if the first stream character is ASCII. For more information about the byte order mark and the Unicode character encoding schemes see the Unicode FAQ . [3] c-byte-order-mark ::= #xFEFF In the examples, byte order mark characters are displayed as “ ”. Example 5.1. Byte Order Mark # Comment only. Legend: c-byte-order-mark # This stream contains no # documents, only comments. Example 5.2. Invalid Byte Order Mark - Invalid use of BOM - Inside a document. ERROR: A BOM must not appear inside a document. 5.3. Indicator Characters Indicators are characters that have special semantics. [4] c-sequence-entry ::= “ -” A “ -” ( #x2D, hyphen) denotes a block sequence entry. [5] c-mapping-key ::= “ ?” A “ ?” ( #x3F, question mark) denotes a mapping key . [6] c-mapping-value ::= “ :” A “ :” ( #x3A, colon) denotes a mapping value . Example 5.3. Block Structure Indicators sequence : - one - two mapping : ? sky : blue sea : green Legend: c-sequence-entry c-mapping-key c-mapping-value %YAML 1.2 --- !!map { ? !!str \"sequence\" : !!seq [ !!str \"one\", !!str \"two\" ], ? !!str \"mapping\" : !!map { ? !!str \"sky\" : !!str \"blue\", ? !!str \"sea\" : !!str \"green\", }, } [7] c-collect-entry ::= “ ,” A “ ,” ( #x2C, comma) ends a flow collection entry. [8] c-sequence-start ::= “ [” A “ [” ( #x5B, left bracket) starts a flow sequence . [9] c-sequence-end ::= “ ]” A “ ]” ( #x5D, right bracket) ends a flow sequence . [10] c-mapping-start ::= “ {” A “ {” ( #x7B, left brace) starts a flow mapping . [11] c-mapping-end ::= “ }” A “ }” ( #x7D, right brace) ends a flow mapping . Example 5.4. Flow Collection Indicators sequence: [ one , two , ] mapping: { sky: blue , sea: green } Legend: c-sequence-start c-sequence-end c-mapping-start c-mapping-end c-collect-entry %YAML 1.2 --- !!map { ? !!str \"sequence\" : !!seq [ !!str \"one\", !!str \"two\" ], ? !!str \"mapping\" : !!map { ? !!str \"sky\" : !!str \"blue\", ? !!str \"sea\" : !!str \"green\", }, } [12] c-comment ::= “ #” An “ #” ( #x23, octothorpe, hash, sharp, pound, number sign) denotes a comment . Example 5.5. Comment Indicator # Comment only. Legend: c-comment # This stream contains no # documents, only comments. [13] c-anchor ::= “ &” An “ &” ( #x26, ampersand) denotes a node’s anchor property . [14] c-alias ::= “ *” An “ *” ( #x2A, asterisk) denotes an alias node . [15] c-tag ::= “ !” The “ !” ( #x21, exclamation) is heavily overloaded for specifying node tags . It is used to denote tag handles used in tag directives and tag properties ; to denote local tags ; and as the non-specific tag for non- plain scalars . Example 5.6. Node Property Indicators anchored: !local &anchor value alias: *anchor Legend: c-tag c-anchor c-alias %YAML 1.2 --- !!map { ? !!str \"anchored\" : !local &A1 \"value\", ? !!str \"alias\" : *A1, } [16] c-literal ::= “ |” A “ |” ( 7C, vertical bar) denotes a literal block scalar . [17] c-folded ::= “ >” A “ >” ( #x3E, greater than) denotes a folded block scalar . Example 5.7. Block Scalar Indicators literal: | some text folded: > some text Legend: c-literal c-folded %YAML 1.2 --- !!map { ? !!str \"literal\" : !!str \"some\\ntext\\n\", ? !!str \"folded\" : !!str \"some text\\n\", } [18] c-single-quote ::= “ '” An “ '” ( #x27, apostrophe, single quote) surrounds a single-quoted flow scalar . [19] c-double-quote ::= “ \"” A “ \"” ( #x22, double quote) surrounds a double-quoted flow scalar . Example 5.8. Quoted Scalar Indicators single: 'text ' double: \"text \" Legend: c-single-quote c-double-quote %YAML 1.2 --- !!map { ? !!str \"single\" : !!str \"text\", ? !!str \"double\" : !!str \"text\", } [20] c-directive ::= “ %” A “ %” ( #x25, percent) denotes a directive line. Example 5.9. Directive Indicator %YAML 1.2 --- text Legend: c-directive %YAML 1.2 --- !!str \"text\" [21] c-reserved ::= “ @” | “ `” The “ @” ( #x40, at) and “ `” ( #x60, grave accent) are reserved for future use. Example 5.10. Invalid use of Reserved Indicators commercial-at: @text grave-accent: `text ERROR: Reserved indicators can't start a plain scalar. Any indicator character: [22] c-indicator ::= “ -” | “ ?” | “ :” | “ ,” | “ [” | “ ]” | “ {” | “ }” | “ #” | “ &” | “ *” | “ !” | “ |” | “ >” | “ '” | “ \"” | “ %” | “ @” | “ `” The “ [” , “ ]” , “ {” , “ }” and “ ,” indicators denote structure in flow collections . They are therefore forbidden in some cases, to avoid ambiguity in several constructs. This is handled on a case-by-case basis by the relevant productions. [23] c-flow-indicator ::= “ ,” | “ [” | “ ]” | “ {” | “ }” 5.4. Line Break Characters YAML recognizes the following ASCII line break characters. [24] b-line-feed ::= #xA /* LF */ [25] b-carriage-return ::= #xD /* CR */ [26] b-char ::= b-line-feed | b-carriage-return All other characters, including the form feed ( #x0C), are considered to be non-break characters. Note that these include the non-ASCII line breaks: next line ( #x85), line separator ( #x2028) and paragraph separator ( #x2029). YAML version 1.1 did support the above non-ASCII line break characters; however, JSON does not. Hence, to ensure JSON compatibility , YAML treats them as non-break characters as of version 1.2. In theory this would cause incompatibility with version 1.1 ; in practice these characters were rarely (if ever) used. YAML 1.2 processors parsing a version 1.1 document should therefore treat these line breaks as non-break characters, with an appropriate warning. [27] nb-char ::= c-printable - b-char - c-byte-order-mark Line breaks are interpreted differently by different systems, and have several widely used formats. [28] b-break ::= ( b-carriage-return b-line-feed ) /* DOS, Windows */ | b-carriage-return /* MacOS upto 9.x */ | b-line-feed /* UNIX, MacOS X */ Line breaks inside scalar content must be normalized by the YAML processor . Each such line break must be parsed into a single line feed character. The original line break format is a presentation detail and must not be used to convey content information. [29] b-as-line-feed ::= b-break Outside scalar content , YAML allows any line break to be used to terminate lines. [30] b-non-content ::= b-break On output, a YAML processor is free to emit line breaks using whatever convention is most appropriate. In the examples, line breaks are sometimes displayed using the “ ” glyph for clarity. Example 5.11. Line Break Characters | Line break (no glyph) Line break (glyphed) Legend: b-break %YAML 1.2 --- !!str \"line break (no glyph)\\n\\ line break (glyphed)\\n\" 5.5. White Space Characters YAML recognizes two white space characters: space and tab. [31] s-space ::= #x20 /* SP */ [32] s-tab ::= #x9 /* TAB */ [33] s-white ::= s-space | s-tab The rest of the ( printable ) non- break characters are considered to be non-space characters. [34] ns-char ::= nb-char - s-white In the examples, tab characters are displayed as the glyph “ ”. Space characters are sometimes displayed as the glyph “ ·” for clarity. Example 5.12. Tabs and Spaces # Tabs and spaces quoted: ·\"Quoted \" block: | ··void main() { ·· printf(\"Hello, world!\\n\"); ··} Legend: s-space s-tab %YAML 1.2 --- !!map { ? !!str \"quoted\" : \"Quoted \\t\", ? !!str \"block\" : \"void main() {\\n\\ \\tprintf(\\\"Hello, world!\\\\n\\\");\\n\\ }\\n\", } 5.6. Miscellaneous Characters The YAML syntax productions make use of the following additional character classes: A decimal digit for numbers: [35] ns-dec-digit ::= [#x30-#x39] /* 0-9 */ A hexadecimal digit for escape sequences : [36] ns-hex-digit ::= ns-dec-digit | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */ ASCII letter (alphabetic) characters: [37] ns-ascii-letter ::= [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */ Word (alphanumeric) characters for identifiers: [38] ns-word-char ::= ns-dec-digit | ns-ascii-letter | “ -” URI characters for tags , as specified in RFC2396 , with the addition of the “ [” and “ ]” for presenting IPv6 addresses as proposed in RFC2732 . By convention, any URI characters other than the allowed printable ASCII characters are first encoded in UTF-8, and then each byte is escaped using the “ %” character. The YAML processor must not expand such escaped characters. Tag characters must be preserved and compared exactly as presented in the YAML stream , without any processing. [39] ns-uri-char ::= “ %” ns-hex-digit ns-hex-digit | ns-word-char | “ #” | “ ;” | “ /” | “ ?” | “ :” | “ @” | “ &” | “ =” | “ +” | “ $” | “ ,” | “ _” | “ .” | “ !” | “ ~” | “ *” | “ '” | “ (” | “ )” | “ [” | “ ]” The “ !” character is used to indicate the end of a named tag handle ; hence its use in tag shorthands is restricted. In addition, such shorthands must not contain the “ [” , “ ]” , “ {” , “ }” and “ ,” characters. These characters would cause ambiguity with flow collection structures. [40] ns-tag-char ::= ns-uri-char - “ !” - c-flow-indicator 5.7. Escaped Characters All non- printable characters must be escaped. YAML escape sequences use the “ \\” notation common to most modern computer languages. Each escape sequence must be parsed into the appropriate Unicode character. The original escape sequence is a presentation detail and must not be used to convey content information. Note that escape sequences are only interpreted in double-quoted scalars . In all other scalar styles , the “ \\” character has no special meaning and non- printable characters are not available. [41] c-escape ::= “ \\” YAML escape sequences are a superset of C’s escape sequences: [42] ns-esc-null ::= “ 0” Escaped ASCII null ( #x0) character. [43] ns-esc-bell ::= “ a” Escaped ASCII bell ( #x7) character. [44] ns-esc-backspace ::= “ b” Escaped ASCII backspace ( #x8) character. [45] ns-esc-horizontal-tab ::= “ t” | #x9 Escaped ASCII horizontal tab ( #x9) character. This is useful at the start or the end of a line to force a leading or trailing tab to become part of the content . [46] ns-esc-line-feed ::= “ n” Escaped ASCII line feed ( #xA) character. [47] ns-esc-vertical-tab ::= “ v” Escaped ASCII vertical tab ( #xB) character. [48] ns-esc-form-feed ::= “ f” Escaped ASCII form feed ( #xC) character. [49] ns-esc-carriage-return ::= “ r” Escaped ASCII carriage return ( #xD) character. [50] ns-esc-escape ::= “ e” Escaped ASCII escape ( #x1B) character. [51] ns-esc-space ::= #x20 Escaped ASCII space ( #x20) character. This is useful at the start or the end of a line to force a leading or trailing space to become part of the content . [52] ns-esc-double-quote ::= “ \"” Escaped ASCII double quote ( #x22). [53] ns-esc-slash ::= “ /” Escaped ASCII slash ( #x2F), for JSON compatibility . [54] ns-esc-backslash ::= “ \\” Escaped ASCII back slash ( #x5C). [55] ns-esc-next-line ::= “ N” Escaped Unicode next line ( #x85) character. [56] ns-esc-non-breaking-space ::= “ _” Escaped Unicode non-breaking space ( #xA0) character. [57] ns-esc-line-separator ::= “ L” Escaped Unicode line separator ( #x2028) character. [58] ns-esc-paragraph-separator ::= “ P” Escaped Unicode paragraph separator ( #x2029) character. [59] ns-esc-8-bit ::= “ x” ( ns-hex-digit × 2 ) Escaped 8-bit Unicode character. [60] ns-esc-16-bit ::= “ u” ( ns-hex-digit × 4 ) Escaped 16-bit Unicode character. [61] ns-esc-32-bit ::= “ U” ( ns-hex-digit × 8 ) Escaped 32-bit Unicode character. Any escaped character: [62] c-ns-esc-char ::= “ \\” ( ns-esc-null | ns-esc-bell | ns-esc-backspace | ns-esc-horizontal-tab | ns-esc-line-feed | ns-esc-vertical-tab | ns-esc-form-feed | ns-esc-carriage-return | ns-esc-escape | ns-esc-space | ns-esc-double-quote | ns-esc-slash | ns-esc-backslash | ns-esc-next-line | ns-esc-non-breaking-space | ns-esc-line-separator | ns-esc-paragraph-separator | ns-esc-8-bit | ns-esc-16-bit | ns-esc-32-bit ) Example 5.13. Escaped Characters \"Fun with \\\\ \\\" \\a \\b \\e \\f \\ \\n \\r \\t \\v \\0 \\ \\ \\_ \\N \\L \\P \\ \\x41 \\u0041 \\U00000041\" Legend: c-ns-esc-char %YAML 1.2 --- \"Fun with \\x5C \\x22 \\x07 \\x08 \\x1B \\x0C \\x0A \\x0D \\x09 \\x0B \\x00 \\x20 \\xA0 \\x85 \\u2028 \\u2029 A A A\" Example 5.14. Invalid Escaped Characters Bad escapes: \"\\ c \\x q-\" ERROR: - c is an invalid escaped character. - q and - are invalid hex digits. Chapter 6. Basic Structures 6.1. Indentation Spaces In YAML block styles , structure is determined by indentation. In general, indentation is defined as a zero or more space characters at the start of a line. To maintain portability, tab characters must not be used in indentation, since different systems treat tabs differently. Note that most modern editors may be configured so that pressing the tab key results in the insertion of an appropriate number of spaces . The amount of indentation is a presentation detail and must not be used to convey content information. [63] s-indent(n) ::= s-space × n A block style construct is terminated when encountering a line which is less indented than the construct. The productions use the notation “ s-indent(<n)” and “ s-indent( n)” to express this. [64] s-indent(<n) ::= s-space × m /* Where m < n */ [65] s-indent( n) ::= s-space × m /* Where m n */ Each node must be indented further than its parent node . All sibling nodes must use the exact same indentation level. However the content of each sibling node may be further indented independently. Example 6.1. Indentation Spaces ··# Leading comment line spaces are ···# neither content nor indentation. ···· Not indented: ·By one space: | ····By four ···· ··spaces ·Flow style: [ # Leading spaces ·· ·By two, # in flow style ··Also by two, # are neither ·· Still by two # content nor ·· ··] # indentation. Legend: s-indent(n) Content Neither content nor indentation %YAML 1.2 - - - !!map { ? !!str \"Not indented\" : !!map { ? !!str \"By one space\" : !!str \"By four\\n spaces\\n\", ? !!str \"Flow style\" : !!seq [ !!str \"By two\", !!str \"Also by two\", !!str \"Still by two\", ] } } The “ -” , “ ?” and “ :” characters used to denote block collection entries are perceived by people to be part of the indentation. This is handled on a case-by-case basis by the relevant productions. Example 6.2. Indentation Indicators ?·a : · - b ·· - ·· - c ····· -·d Legend: Total Indentation s-indent(n) Indicator as indentation %YAML 1.2 --- !!map { ? !!str \"a\" : !!seq [ !!str \"b\", !!seq [ !!str \"c\", !!str \"d\" ] ], } 6.2. Separation Spaces Outside indentation and scalar content , YAML uses white space characters for separation between tokens within a line. Note that such white space may safely include tab characters. Separation spaces are a presentation detail and must not be used to convey content information. [66] s-separate-in-line ::= s-white + | /* Start of line */ Example 6.3. Separation Spaces - ·foo: ·bar - - ·baz - baz Legend: s-separate-in-line %YAML 1.2 --- !!seq [ !!map { ? !!str \"foo\" : !!str \"bar\", }, !!seq [ !!str \"baz\", !!str \"baz\" ], ] 6.3. Line Prefixes Inside scalar content , each line begins with a non- content line prefix. This prefix always includes the indentation . For flow scalar styles it additionally includes all leading white space , which may contain tab characters. Line prefixes are a presentation detail and must not be used to convey content information. [67] s-line-prefix(n,c) ::= c = block-out s-block-line-prefix(n) c = block-in s-block-line-prefix(n) c = flow-out s-flow-line-prefix(n) c = flow-in s-flow-line-prefix(n) [68] s-block-line-prefix(n) ::= s-indent(n) [69] s-flow-line-prefix(n) ::= s-indent(n) s-separate-in-line ? Example 6.4. Line Prefixes plain: text ··lines quoted: \"text ·· lines\" block: | ··text ··· lines Legend: s-flow-line-prefix(n) s-block-line-prefix(n) s-indent(n) %YAML 1.2 --- !!map { ? !!str \"plain\" : !!str \"text lines\", ? !!str \"quoted\" : !!str \"text lines\", ? !!str \"block\" : !!str \"text\\n· lines\\n\", } 6.4. Empty Lines An empty line line consists of the non- content prefix followed by a line break . [70] l-empty(n,c) ::= ( s-line-prefix(n,c) | s-indent(<n) ) b-as-line-feed The semantics of empty lines depend on the scalar style they appear in. This is handled on a case-by-case basis by the relevant productions. Example 6.5. Empty Lines Folding: \"Empty line ··· as a line feed\" Chomping: | Clipped empty lines · Legend: l-empty(n,c) %YAML 1.2 --- !!map { ? !!str \"Folding\" : !!str \"Empty line\\nas a line feed\", ? !!str \"Chomping\" : !!str \"Clipped empty lines\\n\", } 6.5. Line Folding Line folding allows long lines to be broken for readability, while retaining the semantics of the original long line. If a line break is followed by an empty line , it is trimmed; the first line break is discarded and the rest are retained as content . [71] b-l-trimmed(n,c) ::= b-non-content l-empty(n,c) + Otherwise (the following line is not empty ), the line break is converted to a single space ( #x20). [72] b-as-space ::= b-break A folded non- empty line may end with either of the above line breaks . [73] b-l-folded(n,c) ::= b-l-trimmed(n,c) | b-as-space Example 6.6. Line Folding >- trimmed ·· · as space %YAML 1.2 --- !!str \"trimmed\\n\\n\\nas space\" Legend: b-l-trimmed(n,c) b-as-space The above rules are common to both the folded block style and the scalar flow styles . Folding does distinguish between these cases in the following way: Block Folding In the folded block style , the final line break and trailing empty lines are subject to chomping , and are never folded. In addition, folding does not apply to line breaks surrounding text lines that contain leading white space . Note that such a more-indented line may consist only of such leading white space . The combined effect of the block line folding rules is that each “ paragraph” is interpreted as a line, empty lines are interpreted as a line feed, and the formatting of more-indented lines is preserved. Example 6.7. Block Folding > ··foo · · ·· ·bar ··baz %YAML 1.2 --- !!str \"foo \\n\\n\\t bar\\n\\nbaz\\n\" Legend: b-l-folded(n,c) Non-content spaces Content spaces Flow Folding Folding in flow styles provides more relaxed semantics. Flow styles typically depend on explicit indicators rather than indentation to convey structure. Hence spaces preceding or following the text in a line are a presentation detail and must not be used to convey content information. Once all such spaces have been discarded, all line breaks are folded, without exception. The combined effect of the flow line folding rules is that each “ paragraph” is interpreted as a line, empty lines are interpreted as line feeds, and text can be freely more-indented without affecting the content information. [74] s-flow-folded(n) ::= s-separate-in-line ? b-l-folded(n,flow-in) s-flow-line-prefix(n) Example 6.8. Flow Folding \" ··foo · · ·· ·bar ··baz \" %YAML 1.2 --- !!str \" foo\\nbar\\nbaz \" Legend: s-flow-folded(n) Non-content spaces 6.6. Comments An explicit comment is marked by a “ #” indicator. Comments are a presentation detail and must not be used to convey content information. Comments must be separated from other tokens by white space characters. To ensure JSON compatibility , YAML processors must allow for the omission of the final comment line break of the input stream . However, as this confuses many tools, YAML processors should terminate the stream with an explicit line break on output. [75] c-nb-comment-text ::= “ #” nb-char * [76] b-comment ::= b-non-content | /* End of file */ [77] s-b-comment ::= ( s-separate-in-line c-nb-comment-text ? )? b-comment Example 6.9. Separated Comment key: ···· # Comment value eof Legend: c-nb-comment-text b-comment s-b-comment %YAML 1.2 --- !!map { ? !!str \"key\" : !!str \"value\", } Outside scalar content , comments may appear on a line of their own, independent of the indentation level. Note that outside scalar content , a line containing only white space characters is taken to be a comment line. [78] l-comment ::= s-separate-in-line c-nb-comment-text ? b-comment Example 6.10. Comment Lines ·· # Comment ··· # This stream contains no # documents, only comments. Legend: s-b-comment l-comment In most cases, when a line may end with a comment, YAML allows it to be followed by additional comment lines. The only exception is a comment ending a block scalar header . [79] s-l-comments ::= ( s-b-comment | /* Start of line */ ) l-comment * Example 6.11. Multi-Line Comments key: ····# Comment ········# lines value %YAML 1.2 --- !!map { ? !!str \"key\" : !!str \"value\", } Legend: s-b-comment l-comment s-l-comments 6.7. Separation Lines Implicit keys are restricted to a single line. In all other cases, YAML allows tokens to be separated by multi-line (possibly empty) comments . Note that structures following multi-line comment separation must be properly indented , even though there is no such restriction on the separation comment lines themselves. [80] s-separate(n,c) ::= c = block-out s-separate-lines(n) c = block-in s-separate-lines(n) c = flow-out s-separate-lines(n) c = flow-in s-separate-lines(n) c = block-key s-separate-in-line c = flow-key s-separate-in-line [81] s-separate-lines(n) ::= ( s-l-comments s-flow-line-prefix(n) ) | s-separate-in-line Example 6.12. Separation Spaces { ·first: ·Sammy, ·last: ·Sosa ·}: # Statistics: ··hr: ··# Home runs ·····65 ··avg: ·# Average ···0.278 Legend: s-separate-in-line s-separate-lines(n) s-indent(n) %YAML 1.2 --- !!map { ? !!map { ? !!str \"first\" : !!str \"Sammy\", ? !!str \"last\" : !!str \"Sosa\", } : !!map { ? !!str \"hr\" : !!int \"65\", ? !!str \"avg\" : !!float \"0.278\", }, } 6.8. Directives Directives are instructions to the YAML processor . This specification defines two directives, “ YAML” and “ TAG” , and reserves all other directives for future use. There is no way to define private directives. This is intentional. Directives are a presentation detail and must not be used to convey content information. [82] l-directive ::= “ %” ( ns-yaml-directive | ns-tag-directive | ns-reserved-directive ) s-l-comments Each directive is specified on a separate non- indented line starting with the “ %” indicator, followed by the directive name and a list of parameters. The semantics of these parameters depends on the specific directive. A YAML processor should ignore unknown directives with an appropriate warning. [83] ns-reserved-directive ::= ns-directive-name ( s-separate-in-line ns-directive-parameter )* [84] ns-directive-name ::= ns-char + [85] ns-directive-parameter ::= ns-char + Example 6.13. Reserved Directives % FOO bar baz # Should be ignored # with a warning. --- \"foo\" %YAML 1.2 --- !!str \"foo\" Legend: ns-reserved-directive ns-directive-name ns-directive-parameter 6.8.1. “ YAML” Directives The “ YAML” directive specifies the version of YAML the document conforms to. This specification defines version “ 1.2”, including recommendations for YAML 1.1 processing. A version 1.2 YAML processor must accept documents with an explicit “ %YAML 1.2” directive, as well as documents lacking a “ YAML” directive. Such documents are assumed to conform to the 1.2 version specification. Documents with a “ YAML” directive specifying a higher minor version (e.g. “ %YAML 1.3”) should be processed with an appropriate warning. Documents with a “ YAML” directive specifying a higher major version (e.g. “ %YAML 2.0”) should be rejected with an appropriate error message. A version 1.2 YAML processor must also accept documents with an explicit “ %YAML 1.1” directive. Note that version 1.2 is mostly a superset of version 1.1, defined for the purpose of ensuring JSON compatibility. Hence a version 1.2 processor should process version 1.1 documents as if they were version 1.2, giving a warning on points of incompatibility (handling of non-ASCII line breaks , as described above ). [86] ns-yaml-directive ::= “ Y” “ A” “ M” “ L” s-separate-in-line ns-yaml-version [87] ns-yaml-version ::= ns-dec-digit + “ .” ns-dec-digit + Example 6.14. “ YAML” directive % YAML 1.3 # Attempt parsing # with a warning --- \"foo\" %YAML 1.2 --- !!str \"foo\" Legend: ns-yaml-directive ns-yaml-version It is an error to specify more than one “ YAML” directive for the same document, even if both occurrences give the same version number. Example 6.15. Invalid Repeated YAML directive %YAML 1.2 % YAML 1.1 foo ERROR: The YAML directive must only be given at most once per document. 6.8.2. “ TAG” Directives The “ TAG” directive establishes a tag shorthand notation for specifying node tags . Each “ TAG” directive associates a handle with a prefix . This allows for compact and readable tag notation. [88] ns-tag-directive ::= “ T” “ A” “ G” s-separate-in-line c-tag-handle s-separate-in-line ns-tag-prefix Example 6.16. “ TAG” directive % TAG !yaml! tag:yaml.org,2002: --- !yaml!str \"foo\" %YAML 1.2 --- !!str \"foo\" Legend: ns-tag-directive c-tag-handle ns-tag-prefix It is an error to specify more than one “ TAG” directive for the same handle in the same document, even if both occurrences give the same prefix . Example 6.17. Invalid Repeated TAG directive %TAG ! !foo %TAG ! !foo bar ERROR: The TAG directive must only be given at most once per handle in the same document. 6.8.2.1. Tag Handles The tag handle exactly matches the prefix of the affected tag shorthand . There are three tag handle variants: [89] c-tag-handle ::= c-named-tag-handle | c-secondary-tag-handle | c-primary-tag-handle Primary Handle The primary tag handle is a single “ !” character. This allows using the most compact possible notation for a single “ primary” name space. By default, the prefix associated with this handle is “ !” . Thus, by default, shorthands using this handle are interpreted as local tags . It is possible to override the default behavior by providing an explicit “ TAG” directive, associating a different prefix for this handle. This provides smooth migration from using local tags to using global tags , by the simple addition of a single “ TAG” directive. [90] c-primary-tag-handle ::= “ !” Example 6.18. Primary Tag Handle # Private !foo \"bar\" ... # Global %TAG ! tag:example.com,2000:app/ --- !foo \"bar\" %YAML 1.2 --- !<!foo> \"bar\" ... --- !<tag:example.com,2000:app/foo> \"bar\" Legend: c-primary-tag-handle Secondary Handle The secondary tag handle is written as “ !!”. This allows using a compact notation for a single “ secondary” name space. By default, the prefix associated with this handle is “ tag:yaml.org,2002:”. This prefix is used by the YAML tag repository . It is possible to override this default behavior by providing an explicit “ TAG” directive associating a different prefix for this handle. [91] c-secondary-tag-handle ::= “ !” “ !” Example 6.19. Secondary Tag Handle %TAG !! tag:example.com,2000:app/ --- !!int 1 - 3 # Interval, not integer Legend: c-secondary-tag-handle %YAML 1.2 --- !<tag:example.com,2000:app/int> \"1 - 3\" Named Handles A named tag handle surrounds a non-empty name with “ !” characters. A handle name must not be used in a tag shorthand unless an explicit “ TAG” directive has associated some prefix with it. The name of the handle is a presentation detail and must not be used to convey content information. In particular, the YAML processor need not preserve the handle name once parsing is completed. [92] c-named-tag-handle ::= “ !” ns-word-char + “ !” Example 6.20. Tag Handles %TAG !e! tag:example.com,2000:app/ --- !e!foo \"bar\" Legend: c-named-tag-handle %YAML 1.2 --- !<tag:example.com,2000:app/foo> \"bar\" 6.8.2.2. Tag Prefixes There are two tag prefix variants: [93] ns-tag-prefix ::= c-ns-local-tag-prefix | ns-global-tag-prefix Local Tag Prefix If the prefix begins with a “ !” character, shorthands using the handle are expanded to a local tag . Note that such a tag is intentionally not a valid URI, and its semantics are specific to the application . In particular, two documents in the same stream may assign different semantics to the same local tag . [94] c-ns-local-tag-prefix ::= “ !” ns-uri-char * Example 6.21. Local Tag Prefix %TAG !m! !my- --- # Bulb here !m!light fluorescent ... %TAG !m! !my- --- # Color here !m!light green Legend: c-ns-local-tag-prefix %YAML 1.2 --- !<!my-light> \"fluorescent\" ... %YAML 1.2 --- !<!my-light> \"green\" Global Tag Prefix If the prefix begins with a character other than “ !” , it must to be a valid URI prefix, and should contain at least the scheme and the authority. Shorthands using the associated handle are expanded to globally unique URI tags, and their semantics is consistent across applications . In particular, every documents in every stream must assign the same semantics to the same global tag . [95] ns-global-tag-prefix ::= ns-tag-char ns-uri-char * Example 6.22. Global Tag Prefix %TAG !e! tag:example.com,2000:app/ --- - !e!foo \"bar\" Legend: ns-global-tag-prefix %YAML 1.2 --- !<tag:example.com,2000:app/foo> \"bar\" 6.9. Node Properties Each node may have two optional properties, anchor and tag , in addition to its content . Node properties may be specified in any order before the node’s content . Either or both may be omitted. [96] c-ns-properties(n,c) ::= ( c-ns-tag-property ( s-separate(n,c) c-ns-anchor-property )? ) | ( c-ns-anchor-property ( s-separate(n,c) c-ns-tag-property )? ) Example 6.23. Node Properties !!str &a1 \"foo\": !!str bar &a2 baz : *a1 Legend: c-ns-properties(n,c) c-ns-anchor-property c-ns-tag-property %YAML 1.2 --- !!map { ? &B1 !!str \"foo\" : !!str \"bar\", ? !!str \"baz\" : *B1, } 6.9.1. Node Tags The tag property identifies the type of the native data structure presented by the node . A tag is denoted by the “ !” indicator. [97] c-ns-tag-property ::= c-verbatim-tag | c-ns-shorthand-tag | c-non-specific-tag Verbatim Tags A tag may be written verbatim by surrounding it with the “ <” and “ >” characters. In this case, the YAML processor must deliver the verbatim tag as-is to the application . In particular, verbatim tags are not subject to tag resolution . A verbatim tag must either begin with a “ !” (a local tag ) or be a valid URI (a global tag ). [98] c-verbatim-tag ::= “ !” “ <” ns-uri-char + “ >” Example 6.24. Verbatim Tags !<tag:yaml.org,2002:str> foo : !<!bar> baz Legend: c-verbatim-tag %YAML 1.2 --- !!map { ? !<tag:yaml.org,2002:str> \"foo\" : !<!bar> \"baz\", } Example 6.25. Invalid Verbatim Tags - !< !> foo - !< $:?> bar ERROR: - Verbatim tags aren't resolved, so ! is invalid. - The $:? tag is neither a global URI tag nor a local tag starting with “ !”. Tag Shorthands A tag shorthand consists of a valid tag handle followed by a non-empty suffix. The tag handle must be associated with a prefix , either by default or by using a “ TAG” directive . The resulting parsed tag is the concatenation of the prefix and the suffix, and must either begin with “ !” (a local tag ) or be a valid URI (a global tag ). The choice of tag handle is a presentation detail and must not be used to convey content information. In particular, the tag handle may be discarded once parsing is completed. The suffix must not contain any “ !” character. This would cause the tag shorthand to be interpreted as having a named tag handle . In addition, the suffix must not contain the “ [” , “ ]” , “ {” , “ }” and “ ,” characters. These characters would cause ambiguity with flow collection structures. If the suffix needs to specify any of the above restricted characters, they must be escaped using the “ %” character. This behavior is consistent with the URI character escaping rules (specifically, section 2.3 of RFC2396 ). [99] c-ns-shorthand-tag ::= c-tag-handle ns-tag-char + Example 6.26. Tag Shorthands %TAG !e! tag:example.com,2000:app/ --- - !local foo - !!str bar - !e!tag%21 baz Legend: c-ns-shorthand-tag %YAML 1.2 --- !!seq [ !<!local> \"foo\", !<tag:yaml.org,2002:str> \"bar\", !<tag:example.com,2000:app/tag!> \"baz\" ] Example 6.27. Invalid Tag Shorthands %TAG !e! tag:example,2000:app/ --- - !e! foo - !h!bar baz ERROR: - The !o! handle has no suffix. - The !h! handle wasn't declared. Non-Specific Tags If a node has no tag property, it is assigned a non-specific tag that needs to be resolved to a specific one. This non-specific tag is “ !” for non- plain scalars and “ ?” for all other nodes . This is the only case where the node style has any effect on the content information. It is possible for the tag property to be explicitly set to the “ !” non-specific tag . By convention , this “ disables” tag resolution , forcing the node to be interpreted as “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map”, or “ tag:yaml.org,2002:str”, according to its kind . There is no way to explicitly specify the “ ?” non-specific tag. This is intentional. [100] c-non-specific-tag ::= “ !” Example 6.28. Non-Specific Tags # Assuming conventional resolution: - \"12\" - 12 - ! 12 Legend: c-non-specific-tag %YAML 1.2 --- !!seq [ !<tag:yaml.org,2002:str> \"12\", !<tag:yaml.org,2002:int> \"12\", !<tag:yaml.org,2002:str> \"12\", ] 6.9.2. Node Anchors An anchor is denoted by the “ &” indicator. It marks a node for future reference. An alias node can then be used to indicate additional inclusions of the anchored node . An anchored node need not be referenced by any alias nodes ; in particular, it is valid for all nodes to be anchored. [101] c-ns-anchor-property ::= “ &” ns-anchor-name Note that as a serialization detail , the anchor name is preserved in the serialization tree . However, it is not reflected in the representation graph and must not be used to convey content information. In particular, the YAML processor need not preserve the anchor name once the representation is composed . Anchor names must not contain the “ [” , “ ]” , “ {” , “ }” and “ ,” characters. These characters would cause ambiguity with flow collection structures. [102] ns-anchor-char ::= ns-char - c-flow-indicator [103] ns-anchor-name ::= ns-anchor-char + Example 6.29. Node Anchors First occurrence: & anchor Value Second occurrence: * anchor Legend: c-ns-anchor-property ns-anchor-name %YAML 1.2 --- !!map { ? !!str \"First occurrence\" : &A !!str \"Value\", ? !!str \"Second occurrence\" : *A, } Chapter 7. Flow Styles YAML’s flow styles can be thought of as the natural extension of JSON to cover folding long content lines for readability, tagging nodes to control construction of native data structures , and using anchors and aliases to reuse constructed object instances. 7.1. Alias Nodes Subsequent occurrences of a previously serialized node are presented as alias nodes. The first occurrence of the node must be marked by an anchor to allow subsequent occurrences to be presented as alias nodes. An alias node is denoted by the “ *” indicator. The alias refers to the most recent preceding node having the same anchor . It is an error for an alias node to use an anchor that does not previously occur in the document . It is not an error to specify an anchor that is not used by any alias node. Note that an alias node must not specify any properties or content , as these were already specified at the first occurrence of the node . [104] c-ns-alias-node ::= “ *” ns-anchor-name Example 7.1. Alias Nodes First occurrence: & anchor Foo Second occurrence: * anchor Override anchor: & anchor Bar Reuse anchor: * anchor Legend: c-ns-alias-node ns-anchor-name %YAML 1.2 --- !!map { ? !!str \"First occurrence\" : &A !!str \"Foo\", ? !!str \"Override anchor\" : &B !!str \"Bar\", ? !!str \"Second occurrence\" : *A, ? !!str \"Reuse anchor\" : *B, } 7.2. Empty Nodes YAML allows the node content to be omitted in many cases. Nodes with empty content are interpreted as if they were plain scalars with an empty value. Such nodes are commonly resolved to a “ null” value. [105] e-scalar ::= /* Empty */ In the examples, empty scalars are sometimes displayed as the glyph “ °” for clarity. Note that this glyph corresponds to a position in the characters stream rather than to an actual character. Example 7.2. Empty Content { foo : !!str °, !!str ° : bar, } Legend: e-scalar %YAML 1.2 --- !!map { ? !!str \"foo\" : !!str \"\", ? !!str \"\" : !!str \"bar\", } Both the node’s properties and node content are optional. This allows for a completely empty node. Completely empty nodes are only valid when following some explicit indication for their existence. [106] e-node ::= e-scalar Example 7.3. Completely Empty Flow Nodes { ? foo : °, °: bar, } Legend: e-node %YAML 1.2 --- !!map { ? !!str \"foo\" : !!null \"\", ? !!null \"\" : !!str \"bar\", } 7.3. Flow Scalar Styles YAML provides three flow scalar styles: double-quoted , single-quoted and plain (unquoted). Each provides a different trade-off between readability and expressive power. The scalar style is a presentation detail and must not be used to convey content information, with the exception that plain scalars are distinguished for the purpose of tag resolution . 7.3.1. Double-Quoted Style The double-quoted style is specified by surrounding “ \"” indicators. This is the only style capable of expressing arbitrary strings, by using “ \\” escape sequences . This comes at the cost of having to escape the “ \\” and “ \"” characters. [107] nb-double-char ::= c-ns-esc-char | ( nb-json - “ \\” - “ \"” ) [108] ns-double-char ::= nb-double-char - s-white Double-quoted scalars are restricted to a single line when contained inside an implicit key . [109] c-double-quoted(n,c) ::= “ \"” nb-double-text(n,c) “ \"” [110] nb-double-text(n,c) ::= c = flow-out nb-double-multi-line(n) c = flow-in nb-double-multi-line(n) c = block-key nb-double-one-line c = flow-key nb-double-one-line [111] nb-double-one-line ::= nb-double-char * Example 7.4. Double Quoted Implicit Keys \" implicit block key\" : [ \" implicit flow key\" : value, ] Legend: nb-double-one-line c-double-quoted(n,c) %YAML 1.2 --- !!map { ? !!str \"implicit block key\" : !!seq [ !!map { ? !!str \"implicit flow key\" : !!str \"value\", } ] } In a multi-line double-quoted scalar, line breaks are are subject to flow line folding , which discards any trailing white space characters. It is also possible to escape the line break character. In this case, the line break is excluded from the content , and the trailing white space characters are preserved. Combined with the ability to escape white space characters, this allows double-quoted lines to be broken at arbitrary positions. [112] s-double-escaped(n) ::= s-white * “ \\” b-non-content l-empty(n,flow-in) * s-flow-line-prefix(n) [113] s-double-break(n) ::= s-double-escaped(n) | s-flow-folded(n) Example 7.5. Double Quoted Line Breaks \"folded · to a space, · to a line feed, or · \\ ·\\· non-content\" %YAML 1.2 --- !!str \"folded to a space,\\n\\ to a line feed, \\ or \\t \\tnon-content\" Legend: s-flow-folded(n) s-double-escaped(n) All leading and trailing white space characters are excluded from the content . Each continuation line must therefore contain at least one non- space character. Empty lines, if any, are consumed as part of the line folding . [114] nb-ns-double-in-line ::= ( s-white * ns-double-char )* [115] s-double-next-line(n) ::= s-double-break(n) ( ns-double-char nb-ns-double-in-line ( s-double-next-line(n) | s-white * ) )? [116] nb-double-multi-line(n) ::= nb-ns-double-in-line ( s-double-next-line(n) | s-white * ) Example 7.6. Double Quoted Lines \" ·1st non-empty · 2nd non-empty · 3rd non-empty·\" %YAML 1.2 --- !!str \" 1st non-empty\\n\\ 2nd non-empty \\ 3rd non-empty \" Legend: nb-ns-double-in-line s-double-next-line(n) 7.3.2. Single-Quoted Style The single-quoted style is specified by surrounding “ '” indicators. Therefore, within a single-quoted scalar, such characters need to be repeated. This is the only form of escaping performed in single-quoted scalars. In particular, the “ \\” and “ \"” characters may be freely used. This restricts single-quoted scalars to printable characters. In addition, it is only possible to break a long single-quoted line where a space character is surrounded by non- spaces . [117] c-quoted-quote ::= “ '” “ '” [118] nb-single-char ::= c-quoted-quote | ( nb-json - “ '” ) [119] ns-single-char ::= nb-single-char - s-white Example 7.7. Single Quoted Characters 'here ''s to \"quotes\"' Legend: c-quoted-quote %YAML 1.2 --- !!str \"here's to \\\"quotes\\\"\" Single-quoted scalars are restricted to a single line when contained inside a implicit key . [120] c-single-quoted(n,c) ::= “ '” nb-single-text(n,c) “ '” [121] nb-single-text(n,c) ::= c = flow-out nb-single-multi-line(n) c = flow-in nb-single-multi-line(n) c = block-key nb-single-one-line c = flow-key nb-single-one-line [122] nb-single-one-line ::= nb-single-char * Example 7.8. Single Quoted Implicit Keys ' implicit block key' : [ ' implicit flow key' : value, ] Legend: nb-single-one-line c-single-quoted(n,c) %YAML 1.2 --- !!map { ? !!str \"implicit block key\" : !!seq [ !!map { ? !!str \"implicit flow key\" : !!str \"value\", } ] } All leading and trailing white space characters are excluded from the content . Each continuation line must therefore contain at least one non- space character. Empty lines, if any, are consumed as part of the line folding . [123] nb-ns-single-in-line ::= ( s-white * ns-single-char )* [124] s-single-next-line(n) ::= s-flow-folded(n) ( ns-single-char nb-ns-single-in-line ( s-single-next-line(n) | s-white * ) )? [125] nb-single-multi-line(n) ::= nb-ns-single-in-line ( s-single-next-line(n) | s-white * ) Example 7.9. Single Quoted Lines ' ·1st non-empty · 2nd non-empty · 3rd non-empty·' %YAML 1.2 --- !!str \" 1st non-empty\\n\\ 2nd non-empty \\ 3rd non-empty \" Legend: nb-ns-single-in-line(n) s-single-next-line(n) 7.3.3. Plain Style The plain (unquoted) style has no identifying indicators and provides no form of escaping. It is therefore the most readable, most limited and most context sensitive style . In addition to a restricted character set, a plain scalar must not be empty, or contain leading or trailing white space characters. It is only possible to break a long plain line where a space character is surrounded by non- spaces . Plain scalars must not begin with most indicators , as this would cause ambiguity with other YAML constructs. However, the “ :” , “ ?” and “ -” indicators may be used as the first character if followed by a non- space “ safe” character, as this causes no ambiguity. [126] ns-plain-first(c) ::= ( ns-char - c-indicator ) | ( ( “ ?” | “ :” | “ -” ) /* Followed by an ns-plain-safe(c) ) */ ) Plain scalars must never contain the “ : ” and “ #” character combinations. Such combinations would cause ambiguity with mapping key: value pairs and comments . In addition, inside flow collections , or when used as implicit keys , plain scalars must not contain the “ [” , “ ]” , “ {” , “ }” and “ ,” characters. These characters would cause ambiguity with flow collection structures. [127] ns-plain-safe(c) ::= c = flow-out ns-plain-safe-out c = flow-in ns-plain-safe-in c = block-key ns-plain-safe-out c = flow-key ns-plain-safe-in [128] ns-plain-safe-out ::= ns-char [129] ns-plain-safe-in ::= ns-char - c-flow-indicator [130] ns-plain-char(c) ::= ( ns-plain-safe(c) - “ :” - “ #” ) | ( /* An ns-char preceding */ “ #” ) | ( “ :” /* Followed by an ns-plain-safe(c) */ ) Example 7.10. Plain Characters # Outside flow collection: - : :vector - \" : - ()\" - Up , up, and away! - -123 - http ://example.com/foo #bar # Inside flow collection: - [ : :vector, \" : - ()\", \"Up , up and away!\", -123, http ://example.com/foo #bar ] %YAML 1.2 --- !!seq [ !!str \"::vector\", !!str \": - ()\", !!str \"Up, up, and away!\", !!int \"-123\", !!str \"http://example.com/foo#bar\", !!seq [ !!str \"::vector\", !!str \": - ()\", !!str \"Up, up, and away!\", !!int \"-123\", !!str \"http://example.com/foo#bar\", ], ] Legend: ns-plain-first(c) Not ns-plain-first(c) ns-plain-char(c) Not ns-plain-char(c) Plain scalars are further restricted to a single line when contained inside an implicit key . [131] ns-plain(n,c) ::= c = flow-out ns-plain-multi-line(n,c) c = flow-in ns-plain-multi-line(n,c) c = block-key ns-plain-one-line(c) c = flow-key ns-plain-one-line(c) [132] nb-ns-plain-in-line(c) ::= ( s-white * ns-plain-char(c) )* [133] ns-plain-one-line(c) ::= ns-plain-first(c) nb-ns-plain-in-line(c) Example 7.11. Plain Implicit Keys implicit block key : [ implicit flow key : value, ] Legend: ns-plain-one-line(c) %YAML 1.2 --- !!map { ? !!str \"implicit block key\" : !!seq [ !!map { ? !!str \"implicit flow key\" : !!str \"value\", } ] } All leading and trailing white space characters are excluded from the content . Each continuation line must therefore contain at least one non- space character. Empty lines, if any, are consumed as part of the line folding . [134] s-ns-plain-next-line(n,c) ::= s-flow-folded(n) ns-plain-char(c) nb-ns-plain-in-line(c) [135] ns-plain-multi-line(n,c) ::= ns-plain-one-line(c) s-ns-plain-next-line(n,c) * Example 7.12. Plain Lines 1st non-empty · 2nd non-empty · 3rd non-empty %YAML 1.2 --- !!str \"1st non-empty\\n\\ 2nd non-empty \\ 3rd non-empty\" Legend: nb-ns-plain-in-line(c) s-ns-plain-next-line(n,c) 7.4. Flow Collection Styles A flow collection may be nested within a block collection ( flow-out context ), nested within another flow collection ( flow-in context ), or be a part of an implicit key ( flow-key context or block-key context ). Flow collection entries are terminated by the “ ,” indicator. The final “ ,” may be omitted. This does not cause ambiguity because flow collection entries can never be completely empty . [136] in-flow(c) ::= c = flow-out flow-in c = flow-in flow-in c = block-key flow-key c = flow-key flow-key 7.4.1. Flow Sequences Flow sequence content is denoted by surrounding “ [” and “ ]” characters. [137] c-flow-sequence(n,c) ::= “ [” s-separate(n,c) ? ns-s-flow-seq-entries(n, in-flow(c) ) ? “ ]” Sequence entries are separated by a “ ,” character. [138] ns-s-flow-seq-entries(n,c) ::= ns-flow-seq-entry(n,c) s-separate(n,c) ? ( “ ,” s-separate(n,c) ? ns-s-flow-seq-entries(n,c) ? )? Example 7.13. Flow Sequence - [ one, two, ] - [ three , four ] Legend: c-sequence-start c-sequence-end ns-flow-seq-entry(n,c) %YAML 1.2 --- !!seq [ !!seq [ !!str \"one\", !!str \"two\", ], !!seq [ !!str \"three\", !!str \"four\", ], ] Any flow node may be used as a flow sequence entry. In addition, YAML provides a compact notation for the case where a flow sequence entry is a mapping with a single key: value pair . [139] ns-flow-seq-entry(n,c) ::= ns-flow-pair(n,c) | ns-flow-node(n,c) Example 7.14. Flow Sequence Entries [ \"double quoted\", 'single quoted', plain text, [ nested ], single: pair, ] Legend: ns-flow-node(n,c) ns-flow-pair(n,c) %YAML 1.2 --- !!seq [ !!str \"double quoted\", !!str \"single quoted\", !!str \"plain text\", !!seq [ !!str \"nested\", ], !!map { ? !!str \"single\" : !!str \"pair\", }, ] 7.4.2. Flow Mappings Flow mappings are denoted by surrounding “ {” and “ }” characters. [140] c-flow-mapping(n,c) ::= “ {” s-separate(n,c) ? ns-s-flow-map-entries(n, in-flow(c) ) ? “ }” Mapping entries are separated by a “ ,” character. [141] ns-s-flow-map-entries(n,c) ::= ns-flow-map-entry(n,c) s-separate(n,c) ? ( “ ,” s-separate(n,c) ? ns-s-flow-map-entries(n,c) ? )? Example 7.15. Flow Mappings - { one : two , three: four , } - { five: six, seven : eight } Legend: c-mapping-start c-mapping-end ns-flow-map-entry(n,c) %YAML 1.2 --- !!seq [ !!map { ? !!str \"one\" : !!str \"two\", ? !!str \"three\" : !!str \"four\", }, !!map { ? !!str \"five\" : !!str \"six\", ? !!str \"seven\" : !!str \"eight\", }, ] If the optional “ ?” mapping key indicator is specified, the rest of the entry may be completely empty . [142] ns-flow-map-entry(n,c) ::= ( “ ?” s-separate(n,c) ns-flow-map-explicit-entry(n,c) ) | ns-flow-map-implicit-entry(n,c) [143] ns-flow-map-explicit-entry(n,c) ::= ns-flow-map-implicit-entry(n,c) | ( e-node /* Key */ e-node /* Value */ ) Example 7.16. Flow Mapping Entries { ? explicit: entry, implicit: entry, ? ° ° } Legend: ns-flow-map-explicit-entry(n,c) ns-flow-map-implicit-entry(n,c) e-node %YAML 1.2 --- !!map { ? !!str \"explicit\" : !!str \"entry\", ? !!str \"implicit\" : !!str \"entry\", ? !!null \"\" : !!null \"\", } Normally, YAML insists the “ :” mapping value indicator be separated from the value by white space . A benefit of this restriction is that the “ :” character can be used inside plain scalars , as long as it is not followed by white space . This allows for unquoted URLs and timestamps. It is also a potential source for confusion as “ a:1” is a plain scalar and not a key: value pair . Note that the value may be completely empty since its existence is indicated by the “ :”. [144] ns-flow-map-implicit-entry(n,c) ::= ns-flow-map-yaml-key-entry(n,c) | c-ns-flow-map-empty-key-entry(n,c) | c-ns-flow-map-json-key-entry(n,c) [145] ns-flow-map-yaml-key-entry(n,c) ::= ns-flow-yaml-node(n,c) ( ( s-separate(n,c) ? c-ns-flow-map-separate-value(n,c) ) | e-node ) [146] c-ns-flow-map-empty-key-entry(n,c) ::= e-node /* Key */ c-ns-flow-map-separate-value(n,c) [147] c-ns-flow-map-separate-value(n,c) ::= “ :” /* Not followed by an ns-plain-safe(c) */ ( ( s-separate(n,c) ns-flow-node(n,c) ) | e-node /* Value */ ) Example 7.17. Flow Mapping Separate Values { unquoted· :·\"separate\", http://foo.com, omitted value : °, ° :·omitted key, } Legend: ns-flow-yaml-node(n,c) e-node c-ns-flow-map-separate-value(n,c) %YAML 1.2 --- !!map { ? !!str \"unquoted\" : !!str \"separate\", ? !!str \"http://foo.com\" : !!null \"\", ? !!str \"omitted value\" : !!null \"\", ? !!null \"\" : !!str \"omitted key\", } To ensure JSON compatibility , if a key inside a flow mapping is JSON-like , YAML allows the following value to be specified adjacent to the “ :”. This causes no ambiguity, as all JSON-like keys are surrounded by indicators . However, as this greatly reduces readability, YAML processors should separate the value from the “ :” on output, even in this case. [148] c-ns-flow-map-json-key-entry(n,c) ::= c-flow-json-node(n,c) ( ( s-separate(n,c) ? c-ns-flow-map-adjacent-value(n,c) ) | e-node ) [149] c-ns-flow-map-adjacent-value(n,c) ::= “ :” ( ( s-separate(n,c) ? ns-flow-node(n,c) ) | e-node ) /* Value */ Example 7.18. Flow Mapping Adjacent Values { \"adjacent\": value, \"readable\": ·value, \"empty\": ° } Legend: c-flow-json-node(n,c) e-node c-ns-flow-map-adjacent-value(n,c) %YAML 1.2 --- !!map { ? !!str \"adjacent\" : !!str \"value\", ? !!str \"readable\" : !!str \"value\", ? !!str \"empty\" : !!null \"\", } A more compact notation is usable inside flow sequences , if the mapping contains a single key: value pair. This notation does not require the surrounding “ {” and “ }” characters. Note that it is not possible to specify any node properties for the mapping in this case. Example 7.19. Single Pair Flow Mappings [ foo: bar ] Legend: ns-flow-pair(n,c) %YAML 1.2 --- !!seq [ !!map { ? !!str \"foo\" : !!str \"bar\" } ] If the “ ?” indicator is explicitly specified, parsing is unambiguous, and the syntax is identical to the general case. [150] ns-flow-pair(n,c) ::= ( “ ?” s-separate(n,c) ns-flow-map-explicit-entry(n,c) ) | ns-flow-pair-entry(n,c) Example 7.20. Single Pair Explicit Entry [ ? foo bar : baz ] Legend: ns-flow-map-explicit-entry(n,c) %YAML 1.2 --- !!seq [ !!map { ? !!str \"foo bar\" : !!str \"baz\", }, ] If the “ ?” indicator is omitted, parsing needs to see past the implicit key to recognize it as such. To limit the amount of lookahead required, the “ :” indicator must appear at most 1024 Unicode characters beyond the start of the key . In addition, the key is restricted to a single line. Note that YAML allows arbitrary nodes to be used as keys . In particular, a key may be a sequence or a mapping . Thus, without the above restrictions, practical one-pass parsing would have been impossible to implement. [151] ns-flow-pair-entry(n,c) ::= ns-flow-pair-yaml-key-entry(n,c) | c-ns-flow-map-empty-key-entry(n,c) | c-ns-flow-pair-json-key-entry(n,c) [152] ns-flow-pair-yaml-key-entry(n,c) ::= ns-s-implicit-yaml-key(flow-key) c-ns-flow-map-separate-value(n,c) [153] c-ns-flow-pair-json-key-entry(n,c) ::= c-s-implicit-json-key(flow-key) c-ns-flow-map-adjacent-value(n,c) [154] ns-s-implicit-yaml-key(c) ::= ns-flow-yaml-node(n/a,c) s-separate-in-line ? /* At most 1024 characters altogether */ [155] c-s-implicit-json-key(c) ::= c-flow-json-node(n/a,c) s-separate-in-line ? /* At most 1024 characters altogether */ Example 7.21. Single Pair Implicit Entries - [ YAML· : separate ] - [ ° : empty key entry ] - [ {JSON: like} :adjacent ] Legend: ns-s-implicit-yaml-key c-s-implicit-json-key e-node Value %YAML 1.2 --- !!seq [ !!seq [ !!map { ? !!str \"YAML\" : !!str \"separate\" }, ], !!seq [ !!map { ? !!null \"\" : !!str \"empty key entry\" }, ], !!seq [ !!map { ? !!map { ? !!str \"JSON\" : !!str \"like\" } : \"adjacent\", }, ], ] Example 7.22. Invalid Implicit Keys [ foo bar: invalid, \"foo ...>1K characters...bar\": invalid ] ERROR: - The foo bar key spans multiple lines - The foo...bar key is too long 7.5. Flow Nodes JSON-like flow styles all have explicit start and end indicators . The only flow style that does not have this property is the plain scalar . Note that none of the “ JSON-like” styles is actually acceptable by JSON. Even the double-quoted style is a superset of the JSON string format. [156] ns-flow-yaml-content(n,c) ::= ns-plain(n,c) [157] c-flow-json-content(n,c) ::= c-flow-sequence(n,c) | c-flow-mapping(n,c) | c-single-quoted(n,c) | c-double-quoted(n,c) [158] ns-flow-content(n,c) ::= ns-flow-yaml-content(n,c) | c-flow-json-content(n,c) Example 7.23. Flow Content - [ a, b ] - { a: b } - \"a\" - 'b' - c Legend: c-flow-json-content(n,c) ns-flow-yaml-content(n,c) %YAML 1.2 --- !!seq [ !!seq [ !!str \"a\", !!str \"b\" ], !!map { ? !!str \"a\" : !!str \"b\" }, !!str \"a\", !!str \"b\", !!str \"c\", ] A complete flow node also has optional node properties , except for alias nodes which refer to the anchored node properties . [159] ns-flow-yaml-node(n,c) ::= c-ns-alias-node | ns-flow-yaml-content(n,c) | ( c-ns-properties(n,c) ( ( s-separate(n,c) ns-flow-yaml-content(n,c) ) | e-scalar ) ) [160] c-flow-json-node(n,c) ::= ( c-ns-properties(n,c) s-separate(n,c) )? c-flow-json-content(n,c) [161] ns-flow-node(n,c) ::= c-ns-alias-node | ns-flow-content(n,c) | ( c-ns-properties(n,c) ( ( s-separate(n,c) ns-flow-content(n,c) ) | e-scalar ) ) Example 7.24. Flow Nodes - !!str \"a\" - 'b' - &anchor \"c\" - *anchor - !!str° Legend: c-flow-json-node(n,c) ns-flow-yaml-node(n,c) %YAML 1.2 --- !!seq [ !!str \"a\", !!str \"b\", &A !!str \"c\", *A, !!str \"\", ] Chapter 8. Block Styles YAML’s block styles employ indentation rather than indicators to denote structure. This results in a more human readable (though less compact) notation. 8.1. Block Scalar Styles YAML provides two block scalar styles, literal and folded . Each provides a different trade-off between readability and expressive power. 8.1.1. Block Scalar Headers Block scalars are controlled by a few indicators given in a header preceding the content itself. This header is followed by a non-content line break with an optional comment . This is the only case where a comment must not be followed by additional comment lines. [162] c-b-block-header(m,t) ::= ( ( c-indentation-indicator(m) c-chomping-indicator(t) ) | ( c-chomping-indicator(t) c-indentation-indicator(m) ) ) s-b-comment Example 8.1. Block Scalar Header - | # Empty header literal - > 1 # Indentation indicator ·folded - |+ # Chomping indicator keep - > 1- # Both indicators ·strip %YAML 1.2 --- !!seq [ !!str \"literal\\n\", !!str \"·folded\\n\", !!str \"keep\\n\\n\", !!str \"·strip\", ] Legend: c-b-block-header(m,t) 8.1.1.1. Block Indentation Indicator Typically, the indentation level of a block scalar is detected from its first non- empty line. It is an error for any of the leading empty lines to contain more spaces than the first non- empty line . Detection fails when the first non- empty line contains leading content space characters. Content may safely start with a tab or a “ #” character. When detection would fail, YAML requires that the indentation level for the content be given using an explicit indentation indicator. This level is specified as the integer number of the additional indentation spaces used for the content , relative to its parent node . It is always valid to specify an indentation indicator for a block scalar node, though a YAML processor should only emit an explicit indentation indicator for cases where detection will fail. [163] c-indentation-indicator(m) ::= ns-dec-digit m = ns-dec-digit - #x30 /* Empty */ m = auto-detect() Example 8.2. Block Indentation Indicator - |° ·detected - > ° · ·· ··# detected - |1 ··explicit - > ° · ·detected %YAML 1.2 --- !!seq [ !!str \"detected\\n\", !!str \"\\n\\n# detected\\n\", !!str \"·explicit\\n\", !!str \"\\t·detected\\n\", ] Legend: c-indentation-indicator(m) s-indent(n) Example 8.3. Invalid Block Scalar Indentation Indicators - |· · ·text - > ··text ·text - |2 ·text ERROR: - A leading all-space line must not have too many spaces. - A following text line must not be less indented. - The text is less indented than the indicated level. 8.1.1.2. Block Chomping Indicator Chomping controls how final line breaks and trailing empty lines are interpreted. YAML provides three chomping methods: Strip Stripping is specified by the “ -” chomping indicator. In this case, the final line break and any trailing empty lines are excluded from the scalar’s content . Clip Clipping is the default behavior used if no explicit chomping indicator is specified. In this case, the final line break character is preserved in the scalar’s content . However, any trailing empty lines are excluded from the scalar’s content . Keep Keeping is specified by the “ +” chomping indicator. In this case, the final line break and any trailing empty lines are considered to be part of the scalar’s content . These additional lines are not subject to folding . The chomping method used is a presentation detail and must not be used to convey content information. [164] c-chomping-indicator(t) ::= “ -” t = strip “ +” t = keep /* Empty */ t = clip The interpretation of the final line break of a block scalar is controlled by the chomping indicator specified in the block scalar header . [165] b-chomped-last(t) ::= t = strip b-non-content | /* End of file */ t = clip b-as-line-feed | /* End of file */ t = keep b-as-line-feed | /* End of file */ Example 8.4. Chomping Final Line Break strip: |- text clip: | text keep: |+ text Legend: b-non-content b-as-line-feed %YAML 1.2 --- !!map { ? !!str \"strip\" : !!str \"text\", ? !!str \"clip\" : !!str \"text\\n\", ? !!str \"keep\" : !!str \"text\\n\", } The interpretation of the trailing empty lines following a block scalar is also controlled by the chomping indicator specified in the block scalar header . [166] l-chomped-empty(n,t) ::= t = strip l-strip-empty(n) t = clip l-strip-empty(n) t = keep l-keep-empty(n) [167] l-strip-empty(n) ::= ( s-indent( n) b-non-content )* l-trail-comments(n) ? [168] l-keep-empty(n) ::= l-empty(n,block-in) * l-trail-comments(n) ? Explicit comment lines may follow the trailing empty lines . To prevent ambiguity, the first such comment line must be less indented than the block scalar content . Additional comment lines, if any, are not so restricted. This is the only case where the indentation of comment lines is constrained. [169] l-trail-comments(n) ::= s-indent(<n) c-nb-comment-text b-comment l-comment * Example 8.5. Chomping Trailing Lines # Strip # Comments: strip: |- # text ·· ·# Clip ··# comments: clip: | # text · ·# Keep ··# comments: keep: |+ # text ·# Trail ··# comments. %YAML 1.2 --- !!map { ? !!str \"strip\" : !!str \"# text\", ? !!str \"clip\" : !!str \"# text\\n\", ? !!str \"keep\" : !!str \"# text\\n\", } Legend: l-strip-empty(n) l-keep-empty(n) l-trail-comments(n) If a block scalar consists only of empty lines , then these lines are considered as trailing lines and hence are affected by chomping. Example 8.6. Empty Scalar Chomping strip: >- clip: > keep: |+ Legend: l-strip-empty(n) l-keep-empty(n) %YAML 1.2 --- !!map { ? !!str \"strip\" : !!str \"\", ? !!str \"clip\" : !!str \"\", ? !!str \"keep\" : !!str \"\\n\", } 8.1.2. Literal Style The literal style is denoted by the “ |” indicator. It is the simplest, most restricted, and most readable scalar style . [170] c-l+literal(n) ::= “ |” c-b-block-header(m,t) l-literal-content(n+m,t) Example 8.7. Literal Scalar | ·literal · text Legend: c-l+literal(n) %YAML 1.2 --- !!str \"literal\\n\\ttext\\n\" Inside literal scalars, all ( indented ) characters are considered to be content , including white space characters. Note that all line break characters are normalized . In addition, empty lines are not folded , though final line breaks and trailing empty lines are chomped . There is no way to escape characters inside literal scalars. This restricts them to printable characters. In addition, there is no way to break a long literal line. [171] l-nb-literal-text(n) ::= l-empty(n,block-in) * s-indent(n) nb-char + [172] b-nb-literal-next(n) ::= b-as-line-feed l-nb-literal-text(n) [173] l-literal-content(n,t) ::= ( l-nb-literal-text(n) b-nb-literal-next(n) * b-chomped-last(t) )? l-chomped-empty(n,t) Example 8.8. Literal Content |· ·· ··literal ··· ·· ··text ·# Comment %YAML 1.2 --- !!str \"\\n\\nliteral\\n·\\n\\ntext\\n\" Legend: l-nb-literal-text(n) b-nb-literal-next(n) b-chomped-last(t) l-chomped-empty(n,t) 8.1.3. Folded Style The folded style is denoted by the “ >” indicator. It is similar to the literal style ; however, folded scalars are subject to line folding . [174] c-l+folded(n) ::= “ >” c-b-block-header(m,t) l-folded-content(n+m,t) Example 8.9. Folded Scalar > ·folded ·text %YAML 1.2 --- !!str \"folded text\\n\" Legend: c-l+folded(n) Folding allows long lines to be broken anywhere a single space character separates two non- space characters. [175] s-nb-folded-text(n) ::= s-indent(n) ns-char nb-char * [176] l-nb-folded-lines(n) ::= s-nb-folded-text(n) ( b-l-folded(n,block-in) s-nb-folded-text(n) )* Example 8.10. Folded Lines > ·folded ·line ·next ·line * bullet * list * lines ·last ·line # Comment %YAML 1.2 --- !!str \"\\n\\ folded line\\n\\ next line\\n\\ \\ * bullet\\n \\n\\ \\ * list\\n\\ \\ * lines\\n\\ \\n\\ last line\\n\" Legend: s-nb-folded-text(n) l-nb-folded-lines(n) (The following three examples duplicate this example, each highlighting different productions.) Lines starting with white space characters ( more-indented lines) are not folded . [177] s-nb-spaced-text(n) ::= s-indent(n) s-white nb-char * [178] b-l-spaced(n) ::= b-as-line-feed l-empty(n,block-in) * [179] l-nb-spaced-lines(n) ::= s-nb-spaced-text(n) ( b-l-spaced(n) s-nb-spaced-text(n) )* Example 8.11. More Indented Lines > folded line next line ···* bullet ···* list ···* lines last line # Comment %YAML 1.2 --- !!str \"\\n\\ folded line\\n\\ next line\\n\\ \\ * bullet\\n \\n\\ \\ * list\\n\\ \\ * lines\\n\\ \\n\\ last line\\n\" Legend: s-nb-spaced-text(n) l-nb-spaced-lines(n) Line breaks and empty lines separating folded and more-indented lines are also not folded . [180] l-nb-same-lines(n) ::= l-empty(n,block-in) * ( l-nb-folded-lines(n) | l-nb-spaced-lines(n) ) [181] l-nb-diff-lines(n) ::= l-nb-same-lines(n) ( b-as-line-feed l-nb-same-lines(n) )* Example 8.12. Empty Separation Lines > folded line next line * bullet * list * line last line # Comment %YAML 1.2 --- !!str \"\\n\\ folded line\\n\\ next line\\n\\ \\ * bullet\\n \\n\\ \\ * list\\n\\ \\ * lines\\n\\ \\n\\ last line\\n\" Legend: b-as-line-feed (separation) l-empty(n,c) The final line break , and trailing empty lines if any, are subject to chomping and are never folded . [182] l-folded-content(n,t) ::= ( l-nb-diff-lines(n) b-chomped-last(t) )? l-chomped-empty(n,t) Example 8.13. Final Empty Lines > folded line next line * bullet * list * line last line # Comment %YAML 1.2 --- !!str \"\\n\\ folded line\\n\\ next line\\n\\ \\ * bullet\\n \\n\\ \\ * list\\n\\ \\ * lines\\n\\ \\n\\ last line\\n\" Legend: b-chomped-last(t) l-chomped-empty(n,t) 8.2. Block Collection Styles For readability, block collections styles are not denoted by any indicator . Instead, YAML uses a lookahead method, where a block collection is distinguished from a plain scalar only when a key: value pair or a sequence entry is seen. 8.2.1. Block Sequences A block sequence is simply a series of nodes , each denoted by a leading “ -” indicator. The “ -” indicator must be separated from the node by white space . This allows “ -” to be used as the first character in a plain scalar if followed by a non-space character (e.g. “ -1”). [183] l+block-sequence(n) ::= ( s-indent(n+m) c-l-block-seq-entry(n+m) )+ /* For some fixed auto-detected m > 0 */ [184] c-l-block-seq-entry(n) ::= “ -” /* Not followed by an ns-char */ s-l+block-indented(n,block-in) Example 8.14. Block Sequence block sequence: ·· - one - two : three Legend: c-l-block-seq-entry(n) auto-detected s-indent(n) %YAML 1.2 --- !!map { ? !!str \"block sequence\" : !!seq [ !!str \"one\", !!map { ? !!str \"two\" : !!str \"three\" }, ], } The entry node may be either completely empty , be a nested block node , or use a compact in-line notation. The compact notation may be used when the entry is itself a nested block collection . In this case, both the “ -” indicator and the following spaces are considered to be part of the indentation of the nested collection . Note that it is not possible to specify node properties for such a collection . [185] s-l+block-indented(n,c) ::= ( s-indent(m) ( ns-l-compact-sequence(n+1+m) | ns-l-compact-mapping(n+1+m) ) ) | s-l+block-node(n,c) | ( e-node s-l-comments ) [186] ns-l-compact-sequence(n) ::= c-l-block-seq-entry(n) ( s-indent(n) c-l-block-seq-entry(n) )* Example 8.15. Block Sequence Entry Types - ° # Empty - | block node - ·- one # Compact ··- two # sequence - one: two # Compact mapping Legend: Empty s-l+block-node(n,c) ns-l-compact-sequence(n) ns-l-compact-mapping(n) %YAML 1.2 --- !!seq [ !!null \"\", !!str \"block node\\n\", !!seq [ !!str \"one\" !!str \"two\", ], !!map { ? !!str \"one\" : !!str \"two\", }, ] 8.2.2. Block Mappings A Block mapping is a series of entries, each presenting a key: value pair . [187] l+block-mapping(n) ::= ( s-indent(n+m) ns-l-block-map-entry(n+m) )+ /* For some fixed auto-detected m > 0 */ Example 8.16. Block Mappings block mapping: · key: value Legend: ns-l-block-map-entry(n) auto-detected s-indent(n) %YAML 1.2 --- !!map { ? !!str \"block mapping\" : !!map { ? !!str \"key\" : !!str \"value\", }, } If the “ ?” indicator is specified, the optional value node must be specified on a separate line, denoted by the “ :” indicator. Note that YAML allows here the same compact in-line notation described above for block sequence entries. [188] ns-l-block-map-entry(n) ::= c-l-block-map-explicit-entry(n) | ns-l-block-map-implicit-entry(n) [189] c-l-block-map-explicit-entry(n) ::= c-l-block-map-explicit-key(n) ( l-block-map-explicit-value(n) | e-node ) [190] c-l-block-map-explicit-key(n) ::= “ ?” s-l+block-indented(n,block-out) [191] l-block-map-explicit-value(n) ::= s-indent(n) “ :” s-l+block-indented(n,block-out) Example 8.17. Explicit Block Mapping Entries ? explicit key # Empty value ° ? | block key :·- one # Explicit compact ··- two # block value Legend: c-l-block-map-explicit-key(n) l-block-map-explicit-value(n) e-node %YAML 1.2 --- !!map { ? !!str \"explicit key\" : !!str \"\", ? !!str \"block key\\n\" : !!seq [ !!str \"one\", !!str \"two\", ], } If the “ ?” indicator is omitted, parsing needs to see past the implicit key , in the same way as in the single key: value pair flow mapping . Hence, such keys are subject to the same restrictions; they are limited to a single line and must not span more than 1024 Unicode characters. [192] ns-l-block-map-implicit-entry(n) ::= ( ns-s-block-map-implicit-key | e-node ) c-l-block-map-implicit-value(n) [193] ns-s-block-map-implicit-key ::= c-s-implicit-json-key(block-key) | ns-s-implicit-yaml-key(block-key) In this case, the value may be specified on the same line as the implicit key . Note however that in block mappings the value must never be adjacent to the “ :”, as this greatly reduces readability and is not required for JSON compatibility (unlike the case in flow mappings ). There is no compact notation for in-line values . Also, while both the implicit key and the value following it may be empty, the “ :” indicator is mandatory. This prevents a potential ambiguity with multi-line plain scalars . [194] c-l-block-map-implicit-value(n) ::= “ :” ( s-l+block-node(n,block-out) | ( e-node s-l-comments ) ) Example 8.18. Implicit Block Mapping Entries plain key : in-line value ° :° # Both empty \"quoted key\" : - entry Legend: ns-s-block-map-implicit-key c-l-block-map-implicit-value(n) %YAML 1.2 --- !!map { ? !!str \"plain key\" : !!str \"in-line value\", ? !!null \"\" : !!null \"\", ? !!str \"quoted key\" : !!seq [ !!str \"entry\" ], } A compact in-line notation is also available. This compact notation may be nested inside block sequences and explicit block mapping entries. Note that it is not possible to specify node properties for such a nested mapping. [195] ns-l-compact-mapping(n) ::= ns-l-block-map-entry(n) ( s-indent(n) ns-l-block-map-entry(n) )* Example 8.19. Compact Block Mappings - sun: yellow - ? earth: blue : moon: white Legend: ns-l-compact-mapping(n) %YAML 1.2 --- !!seq [ !!map { !!str \"sun\" : !!str \"yellow\", }, !!map { ? !!map { ? !!str \"earth\" : !!str \"blue\" }, : !!map { ? !!str \"moon\" : !!str \"white\" }, } ] 8.2.3. Block Nodes YAML allows flow nodes to be embedded inside block collections (but not vice-versa). Flow nodes must be indented by at least one more space than the parent block collection . Note that flow nodes may begin on a following line. It is at this point that parsing needs to distinguish between a plain scalar and an implicit key starting a nested block mapping . [196] s-l+block-node(n,c) ::= s-l+block-in-block(n,c) | s-l+flow-in-block(n) [197] s-l+flow-in-block(n) ::= s-separate(n+1,flow-out) ns-flow-node(n+1,flow-out) s-l-comments Example 8.20. Block Node Types - ··\"flow in block\" -· > Block scalar -· !!map # Block collection foo : bar Legend: s-l+flow-in-block(n) s-l+block-in-block(n,c) %YAML 1.2 --- !!seq [ !!str \"flow in block\", !!str \"Block scalar\\n\", !!map { ? !!str \"foo\" : !!str \"bar\", }, ] The block node’s properties may span across several lines. In this case, they must be indented by at least one more space than the block collection , regardless of the indentation of the block collection entries. [198] s-l+block-in-block(n,c) ::= s-l+block-scalar(n,c) | s-l+block-collection(n,c) [199] s-l+block-scalar(n,c) ::= s-separate(n+1,c) ( c-ns-properties(n+1,c) s-separate(n+1,c) )? ( c-l+literal(n) | c-l+folded(n) ) Example 8.21. Block Scalar Nodes literal: |2 ··value folded: ···!foo ··>1 ·value Legend: c-l+literal(n) c-l+folded(n) %YAML 1.2 --- !!map { ? !!str \"literal\" : !!str \"value\", ? !!str \"folded\" : !<!foo> \"value\", } Since people perceive the “ -” indicator as indentation , nested block sequences may be indented by one less space to compensate, except, of course, if nested inside another block sequence ( block-out context vs. block-in context ). [200] s-l+block-collection(n,c) ::= ( s-separate(n+1,c) c-ns-properties(n+1,c) )? s-l-comments ( l+block-sequence( seq-spaces(n,c) ) | l+block-mapping(n) ) [201] seq-spaces(n,c) ::= c = block-out n-1 c = block-in n Example 8.22. Block Collection Nodes sequence: !!seq - entry - !!seq - nested mapping: !!map foo: bar Legend: l+block-sequence(n) l+block-mapping(n) s-l+block-collection(n,c) %YAML 1.2 --- !!map { ? !!str \"sequence\" : !!seq [ !!str \"entry\", !!seq [ !!str \"nested\" ], ], ? !!str \"mapping\" : !!map { ? !!str \"foo\" : !!str \"bar\", }, } Chapter 9. YAML Character Stream 9.1. Documents A YAML character stream may contain several documents. Each document is completely independent from the rest. 9.1.1. Document Prefix A document may be preceded by a prefix specifying the character encoding , and optional comment lines. Note that all documents in a stream must use the same character encoding . However it is valid to re-specify the encoding using a byte order mark for each document in the stream. This makes it easier to concatenate streams. The existence of the optional prefix does not necessarily indicate the existence of an actual document . [202] l-document-prefix ::= c-byte-order-mark ? l-comment * Example 9.1. Document Prefix # Comment # lines Document Legend: l-document-prefix %YAML 1.2 --- !!str \"Document\" 9.1.2. Document Markers Using directives creates a potential ambiguity. It is valid to have a “ %” character at the start of a line (e.g. as the first character of the second line of a plain scalar ). How, then, to distinguish between an actual directive and a content line that happens to start with a “ %” character? The solution is the use of two special marker lines to control the processing of directives , one at the start of a document and one at the end. At the start of a document , lines beginning with a “ %” character are assumed to be directives . The (possibly empty) list of directives is terminated by a directives end marker line. Lines following this marker can safely use “ %” as the first character. At the end of a document , a document end marker line is used to signal the parser to begin scanning for directives again. The existence of this optional document suffix does not necessarily indicate the existence of an actual following document . Obviously, the actual content lines are therefore forbidden to begin with either of these markers. [203] c-directives-end ::= “ -” “ -” “ -” [204] c-document-end ::= “ .” “ .” “ .” [205] l-document-suffix ::= c-document-end s-l-comments [206] c-forbidden ::= /* Start of line */ ( c-directives-end | c-document-end ) ( b-char | s-white | /* End of file */ ) Example 9.2. Document Markers %YAML 1.2 --- Document ... # Suffix %YAML 1.2 --- !!str \"Document\" Legend: c-directives-end c-document-end l-document-suffix 9.1.3. Bare Documents A bare document does not begin with any directives or marker lines. Such documents are very “ clean” as they contain nothing other than the content . In this case, the first non-comment line may not start with a “ %” first character. Document nodes are indented as if they have a parent indented at -1 spaces . Since a node must be more indented than its parent node , this allows the document’s node to be indented at zero or more spaces . [207] l-bare-document ::= s-l+block-node(-1,block-in) /* Excluding c-forbidden content */ Example 9.3. Bare Documents Bare document ... # No document ... | %!PS-Adobe-2.0 # Not the first line %YAML 1.2 --- !!str \"Bare document\" %YAML 1.2 --- !!str \"%!PS-Adobe-2.0\\n\" Legend: l-bare-document 9.1.4. Explicit Documents An explicit document begins with an explicit directives end marker line but no directives . Since the existence of the document is indicated by this marker , the document itself may be completely empty . [208] l-explicit-document ::= c-directives-end ( l-bare-document | ( e-node s-l-comments ) ) Example 9.4. Explicit Documents --- { matches % : 20 } ... --- # Empty ... Legend: l-explicit-document %YAML 1.2 --- !!map { !!str \"matches %\": !!int \"20\" } ... %YAML 1.2 --- !!null \"\" 9.1.5. Directives Documents A directives document begins with some directives followed by an explicit directives end marker line. [209] l-directive-document ::= l-directive + l-explicit-document Example 9.5. Directives Documents %YAML 1.2 --- | %!PS-Adobe-2.0 ... %YAML1.2 --- # Empty ... Legend: l-explicit-document %YAML 1.2 --- !!str \"%!PS-Adobe-2.0\\n\" ... %YAML 1.2 --- !!null \"\" 9.2. Streams A YAML stream consists of zero or more documents . Subsequent documents require some sort of separation marker line. If a document is not terminated by a document end marker line, then the following document must begin with a directives end marker line. The stream format is intentionally “ sloppy” to better support common use cases, such as stream concatenation. [210] l-any-document ::= l-directive-document | l-explicit-document | l-bare-document [211] l-yaml-stream ::= l-document-prefix * l-any-document ? ( l-document-suffix + l-document-prefix * l-any-document ? | l-document-prefix * l-explicit-document ? )* Example 9.6. Stream Document --- # Empty ... %YAML 1.2 --- matches %: 20 Legend: l-any-document l-document-suffix l-explicit-document %YAML 1.2 --- !!str \"Document\" ... %YAML 1.2 --- !!null \"\" ... %YAML 1.2 --- !!map { !!str \"matches %\": !!int \"20\" } A sequence of bytes is a well-formed stream if, taken as a whole, it complies with the above l-yaml-stream production. Some common use case that can take advantage of the YAML stream structure are: Appending to Streams Allowing multiple documents in a single stream makes YAML suitable for log files and similar applications . Note that each document is independent of the rest, allowing for heterogeneous log file entries. Concatenating Streams Concatenating two YAML streams requires both to use the same character encoding . In addition, it is necessary to separate the last document of the first stream and the first document of the second stream. This is easily ensured by inserting a document end marker between the two streams. Note that this is safe regardless of the content of either stream. In particular, either or both may be empty, and the first stream may or may not already contain such a marker. Communication Streams The document end marker allows signaling the end of a document without closing the stream or starting the next document . This allows the receiver to complete processing a document without having to wait for the next one to arrive. The sender may also transmit \"keep-alive\" messages in the form of comment lines or repeated document end markers without signalling the start of the next document . Chapter 10. Recommended Schemas A YAML schema is a combination of a set of tags and a mechanism for resolving non-specific tags . 10.1. Failsafe Schema The failsafe schema is guaranteed to work with any YAML document . It is therefore the recommended schema for generic YAML tools. A YAML processor should therefore support this schema , at least as an option. 10.1.1. Tags 10.1.1.1. Generic Mapping URI: tag:yaml.org,2002:map Kind: Mapping . Definition: Represents an associative container, where each key is unique in the association and mapped to exactly one value . YAML places no restrictions on the type of keys ; in particular, they are not restricted to being scalars . Example bindings to native types include Perl’s hash, Python’s dictionary, and Java’s Hashtable. Example 10.1. !!map Examples Block style: !!map Clark : Evans Ingy : döt Net Oren : Ben-Kiki Flow style: !!map { Clark: Evans, Ingy: döt Net, Oren: Ben-Kiki } 10.1.1.2. Generic Sequence URI: tag:yaml.org,2002:seq Kind: Sequence . Definition: Represents a collection indexed by sequential integers starting with zero. Example bindings to native types include Perl’s array, Python’s list or tuple, and Java’s array or Vector. Example 10.2. !!seq Examples Block style: !!seq - Clark Evans - Ingy döt Net - Oren Ben-Kiki Flow style: !!seq [ Clark Evans, Ingy döt Net, Oren Ben-Kiki ] 10.1.1.3. Generic String URI: tag:yaml.org,2002:str Kind: Scalar . Definition: Represents a Unicode string, a sequence of zero or more Unicode characters. This type is usually bound to the native language’s string type, or, for languages lacking one (such as C), to a character array. Canonical Form: The obvious. Example 10.3. !!str Examples Block style: !!str |- String: just a theory. Flow style: !!str \"String: just a theory.\" 10.1.2. Tag Resolution All nodes with the “ !” non-specific tag are resolved , by the standard convention , to “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map”, or “ tag:yaml.org,2002:str”, according to their kind . All nodes with the “ ?” non-specific tag are left unresolved . This constrains the application to deal with a partial representation . 10.2. JSON Schema The JSON schema is the lowest common denominator of most modern computer languages, and allows parsing JSON files. A YAML processor should therefore support this schema , at least as an option. It is also strongly recommended that other schemas should be based on it. 10.2.1. Tags The JSON schema uses the following tags in addition to those defined by the failsafe schema: 10.2.1.1. Null URI: tag:yaml.org,2002:null Kind: Scalar . Definition: Represents the lack of a value. This is typically bound to a native null-like value (e.g., undef in Perl, None in Python). Note that a null is different from an empty string. Also, a mapping entry with some key and a null value is valid, and different from not having that key in the mapping . Canonical Form: null. Example 10.4. !!null Examples !!null null: value for null key key with null value: !!null null 10.2.1.2. Boolean URI: tag:yaml.org,2002:bool Kind: Scalar . Definition: Represents a true/false value. In languages without a native Boolean type (such as C), is usually bound to a native integer type, using one for true and zero for false. Canonical Form: Either true or false. Example 10.5. !!bool Examples YAML is a superset of JSON: !!bool true Pluto is a planet: !!bool false 10.2.1.3. Integer URI: tag:yaml.org,2002:int Kind: Scalar . Definition: Represents arbitrary sized finite mathematical integers. Scalars of this type should be bound to a native integer data type, if possible. Some languages (such as Perl) provide only a “ number” type that allows for both integer and floating-point values. A YAML processor may use such a type for integers, as long as they round-trip properly. In some languages (such as C), an integer may overflow the native type’s storage capability. A YAML processor may reject such a value as an error, truncate it with a warning, or find some other manner to round-trip it. In general, integers representable using 32 binary digits should safely round-trip through most systems. Canonical Form: Decimal integer notation, with a leading “ -” character for negative values, matching the regular expression 0 | -? [1-9] [0-9]* Example 10.6. !!int Examples negative: !!int -12 zero: !!int 0 positive: !!int 34 10.2.1.4. Floating Point URI: tag:yaml.org,2002:float Kind: Scalar . Definition: Represents an approximation to real numbers, including three special values (positive and negative infinity, and “ not a number”). Some languages (such as Perl) provide only a “ number” type that allows for both integer and floating-point values. A YAML processor may use such a type for floating-point numbers, as long as they round-trip properly. Not all floating-point values can be stored exactly in any given native type. Hence a float value may change by “ a small amount” when round-tripped. The supported range and accuracy depends on the implementation, though 32 bit IEEE floats should be safe. Since YAML does not specify a particular accuracy, using floating-point mapping keys requires great care and is not recommended. Canonical Form: Either 0, .inf, -.inf, .nan, or scientific notation matching the regular expression -? [1-9] ( \\. [0-9]* [1-9] )? ( e [-+] [1-9] [0-9]* )?. Example 10.7. !!float Examples negative: !!float -1 zero: !!float 0 positive: !!float 2.3e4 infinity: !!float .inf not a number: !!float .nan 10.2.2. Tag Resolution The JSON schema tag resolution is an extension of the failsafe schema tag resolution . All nodes with the “ !” non-specific tag are resolved , by the standard convention , to “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map”, or “ tag:yaml.org,2002:str”, according to their kind . Collections with the “ ?” non-specific tag (that is, untagged collections ) are resolved to “ tag:yaml.org,2002:seq” or “ tag:yaml.org,2002:map” according to their kind . Scalars with the “ ?” non-specific tag (that is, plain scalars ) are matched with a list of regular expressions (first match wins, e.g. 0 is resolved as !!int). In principle, JSON files should not contain any scalars that do not match at least one of these. Hence the YAML processor should consider them to be an error. Regular expression Resolved to tag null tag:yaml.org,2002:null true | false tag:yaml.org,2002:bool -? ( 0 | [1-9] [0-9]* ) tag:yaml.org,2002:int -? ( 0 | [1-9] [0-9]* ) ( \\. [0-9]* )? ( [eE] [-+]? [0-9]+ )? tag:yaml.org,2002:float * Error Example 10.8. JSON Tag Resolution A null: null Booleans: [ true, false ] Integers: [ 0, -0, 3, -19 ] Floats: [ 0., -0.0, 12e03, -2E+05 ] Invalid: [ True, Null, 0o7, 0x3A, +12.3 ] %YAML 1.2 --- !!map { !!str \"A null\" : !!null \"null\", !!str \"Booleans: !!seq [ !!bool \"true\", !!bool \"false\" ], !!str \"Integers\": !!seq [ !!int \"0\", !!int \"-0\", !!int \"3\", !!int \"-19\" ], !!str \"Floats\": !!seq [ !!float \"0.\", !!float \"-0.0\", !!float \"12e03\", !!float \"-2E+05\" ], !!str \"Invalid\": !!seq [ # Rejected by the schema True, Null, 0o7, 0x3A, +12.3, ], } ... 10.3. Core Schema The Core schema is an extension of the JSON schema , allowing for more human-readable presentation of the same types. This is the recommended default schema that YAML processor should use unless instructed otherwise. It is also strongly recommended that other schemas should be based on it. 10.3.1. Tags The core schema uses the same tags as the JSON schema . 10.3.2. Tag Resolution The core schema tag resolution is an extension of the JSON schema tag resolution . All nodes with the “ !” non-specific tag are resolved , by the standard convention , to “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map”, or “ tag:yaml.org,2002:str”, according to their kind . Collections with the “ ?” non-specific tag (that is, untagged collections ) are resolved to “ tag:yaml.org,2002:seq” or “ tag:yaml.org,2002:map” according to their kind . Scalars with the “ ?” non-specific tag (that is, plain scalars ) are matched with an extended list of regular expressions. However, in this case, if none of the regular expressions matches, the scalar is resolved to tag:yaml.org,2002:str (that is, considered to be a string). Regular expression Resolved to tag null | Null | NULL | ~ tag:yaml.org,2002:null /* Empty */ tag:yaml.org,2002:null true | True | TRUE | false | False | FALSE tag:yaml.org,2002:bool [-+]? [0-9]+ tag:yaml.org,2002:int (Base 10) 0o [0-7]+ tag:yaml.org,2002:int (Base 8) 0x [0-9a-fA-F]+ tag:yaml.org,2002:int (Base 16) [-+]? ( \\. [0-9]+ | [0-9]+ ( \\. [0-9]* )? ) ( [eE] [-+]? [0-9]+ )? tag:yaml.org,2002:float (Number) [-+]? ( \\.inf | \\.Inf | \\.INF ) tag:yaml.org,2002:float (Infinity) \\.nan | \\.NaN | \\.NAN tag:yaml.org,2002:float (Not a number) * tag:yaml.org,2002:str (Default) Example 10.9. Core Tag Resolution A null: null Also a null: # Empty Not a null: \"\" Booleans: [ true, True, false, FALSE ] Integers: [ 0, 0o7, 0x3A, -19 ] Floats: [ 0., -0.0, .5, +12e03, -2E+05 ] Also floats: [ .inf, -.Inf, +.INF, .NAN ] %YAML 1.2 --- !!map { !!str \"A null\" : !!null \"null\", !!str \"Also a null\" : !!null \"\", !!str \"Not a null\" : !!str \"\", !!str \"Booleans: !!seq [ !!bool \"true\", !!bool \"True\", !!bool \"false\", !!bool \"FALSE\", ], !!str \"Integers\": !!seq [ !!int \"0\", !!int \"0o7\", !!int \"0x3A\", !!int \"-19\", ], !!str \"Floats\": !!seq [ !!float \"0.\", !!float \"-0.0\", !!float \".5\", !!float \"+12e03\", !!float \"-2E+05\" ], !!str \"Also floats\": !!seq [ !!float \".inf\", !!float \"-.Inf\", !!float \"+.INF\", !!float \".NAN\", ], } ... 10.4. Other Schemas None of the above recommended schemas preclude the use of arbitrary explicit tags . Hence YAML processors for a particular programming language typically provide some form of local tags that map directly to the language’s native data structures (e.g., !ruby/object:Set). While such local tags are useful for ad-hoc applications , they do not suffice for stable, interoperable cross- application or cross-platform data exchange. Interoperable schemas make use of global tags (URIs) that represent the same data across different programming languages. In addition, an interoperable schema may provide additional tag resolution rules. Such rules may provide additional regular expressions, as well as consider the path to the node . This allows interoperable schemas to use untagged nodes . It is strongly recommended that such schemas be based on the core schema defined above. In addition, it is strongly recommended that such schemas make as much use as possible of the the YAML tag repository at http://yaml.org/type/ . This repository provides recommended global tags for increasing the portability of YAML documents between different applications . The tag repository is intentionally left out of the scope of this specification. This allows it to evolve to better support YAML applications . Hence, developers are encouraged to submit new “ universal” types to the repository. The yaml-core mailing list at http://lists.sourceforge.net/lists/listinfo/yaml-core is the preferred method for such submissions, as well as raising any questions regarding this draft. Index Indicators ! tag indicator, Tags , Indicator Characters , Node Tags ! local tag, Tags , Tag Handles , Tag Prefixes , Node Tags ! non-specific tag, Resolved Tags , Node Tags , Tag Resolution , Tag Resolution , Tag Resolution ! primary tag handle, Tag Handles !! secondary tag handle, Tag Handles !…! named handle, Tag Handles , Node Tags \" double-quoted style, Indicator Characters , Double-Quoted Style # comment, Collections , Indicator Characters , Comments , Plain Style , Block Indentation Indicator % directive, Indicator Characters , Directives , Document Markers , Bare Documents % escaping in URI, Tags , Miscellaneous Characters , Node Tags & anchor, Structures , Indicator Characters , Node Anchors ' reserved indicator, Indicator Characters ' single-quoted style, Indicator Characters , Single-Quoted Style * alias, Structures , Indicator Characters , Alias Nodes + keep chomping, Block Chomping Indicator , end flow entry, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Collection Styles , Flow Sequences , Flow Mappings - block sequence entry, Introduction , Collections , Structures , Production Parameters , Indicator Characters , Indentation Spaces , Plain Style , Block Collection Styles , Block Sequences , Block Nodes - strip chomping, Block Chomping Indicator : mapping value, Introduction , Collections , Structures , Indicator Characters , Indentation Spaces , Plain Style , Flow Mappings , Block Mappings <…> verbatim tag, Node Tags > folded style, Scalars , Indicator Characters , Folded Style ? mapping key, Structures , Indicator Characters , Indentation Spaces , Plain Style , Flow Mappings , Block Mappings ? non-specific tag, Resolved Tags , Node Tags , Tag Resolution , Tag Resolution , Tag Resolution @ reserved indicator, Indicator Characters [ start flow sequence, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Sequences \\ escaping in double-quoted scalars, Escaped Characters , Double-Quoted Style ] end flow sequence, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Sequences { start flow mapping, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Mappings | literal style, Scalars , Indicator Characters , Literal Style } end flow mapping, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Mappings prefix, Document Prefix A alias, Introduction , Prior Art , Structures , Dump , Serialization Tree , Anchors and Aliases , Loading Failure Points , Well-Formed Streams and Identified Aliases , Resolved Tags , Indicator Characters , Node Anchors , Flow Styles , Alias Nodes , Flow Nodes identified, Structures , Anchors and Aliases , Well-Formed Streams and Identified Aliases unidentified, Loading Failure Points , Well-Formed Streams and Identified Aliases anchor, Structures , Dump , Serialization Tree , Anchors and Aliases , Well-Formed Streams and Identified Aliases , Resolved Tags , Indicator Characters , Node Properties , Flow Styles , Alias Nodes , Flow Nodes application, Introduction , Prior Art , Tags , Processing YAML Information , Dump , Information Models , Tags , Serialization Tree , Keys Order , Resolved Tags , Available Tags , Tag Prefixes , Node Tags , Streams , Tag Resolution , Other Schemas B block scalar header, Comments , Block Scalar Headers , Block Chomping Indicator byte order mark, Character Encodings , Document Prefix C character encoding, Character Encodings , Document Prefix , Streams in URI, Miscellaneous Characters chomping, Production Parameters , Line Folding , Block Chomping Indicator , Literal Style , Folded Style clip, Production Parameters , Block Chomping Indicator keep, Production Parameters , Block Chomping Indicator strip, Production Parameters , Block Chomping Indicator collection, Prior Art , Representation Graph , Nodes , Node Comparison , Anchors and Aliases , Node Styles , Comments , Resolved Tags , Recognized and Valid Tags , Tag Resolution , Tag Resolution comment, Collections , Processes , Dump , Load , Presentation Stream , Comments , Resolved Tags , Indicator Characters , Comments , Separation Lines , Plain Style , Block Scalar Headers , Block Chomping Indicator , Document Prefix , Streams compose, Processes , Load , Keys Order , Anchors and Aliases , Resolved Tags , Recognized and Valid Tags , Available Tags , Node Anchors construct, Processes , Load , Serialization Tree , Loading Failure Points , Recognized and Valid Tags , Available Tags , Flow Styles , Generic Mapping , Generic Sequence , Generic String , Null , Boolean , Integer content, Structures , Dump , Nodes , Tags , Node Comparison , Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Character Encodings , Line Break Characters , Escaped Characters , Indentation Spaces , Separation Spaces , Line Prefixes , Empty Lines , Line Folding , Comments , Directives , Tag Handles , Node Properties , Node Tags , Node Anchors , Alias Nodes , Empty Nodes , Flow Scalar Styles , Double-Quoted Style , Single-Quoted Style , Plain Style , Block Scalar Headers , Block Indentation Indicator , Block Chomping Indicator , Literal Style , Document Markers , Bare Documents valid, Recognized and Valid Tags context, Production Parameters , Plain Style block-in, Production Parameters , Block Nodes block-key, Production Parameters , Flow Collection Styles block-out, Production Parameters , Block Nodes flow-in, Production Parameters , Flow Collection Styles flow-key, Production Parameters , Flow Collection Styles flow-out, Production Parameters , Flow Collection Styles D directive, Structures , Dump , Load , Presentation Stream , Directives , Indicator Characters , Directives , Document Markers , Bare Documents , Explicit Documents , Directives Documents reserved, Directives , Directives TAG, Tags , Directives , Indicator Characters , Directives , “TAG” Directives , Node Tags YAML, Directives , Directives , “YAML” Directives document, Prior Art , Structures , Presentation Stream , Directives , Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Character Encodings , Line Break Characters , “YAML” Directives , Tag Prefixes , Alias Nodes , Documents , Document Prefix , Document Markers , Explicit Documents , Streams , Failsafe Schema , Other Schemas bare, Bare Documents directives, Directives Documents explicit, Explicit Documents suffix, Document Markers dump, Processes , Dump E empty line, Prior Art , Scalars , Empty Lines , Line Folding , Block Indentation Indicator , Block Chomping Indicator , Literal Style , Folded Style equality, Relation to JSON , Dump , Representation Graph , Nodes , Tags , Node Comparison , Scalar Formats , Loading Failure Points , Recognized and Valid Tags escaping in double-quoted scalars, Prior Art , Scalars , Character Set , Character Encodings , Miscellaneous Characters , Escaped Characters , Double-Quoted Style in single-quoted scalars, Single-Quoted Style in URIs, Miscellaneous Characters non-content line break, Double-Quoted Style I identity, Node Comparison indicator, Introduction , Prior Art , Collections , Node Styles , Production Parameters , Indicator Characters , Line Folding , Plain Style , Flow Mappings , Flow Nodes , Block Styles , Block Scalar Headers , Block Collection Styles indentation, Block Indentation Indicator reserved, Indicator Characters information model, Information Models invalid content, Loading Failure Points , Recognized and Valid Tags J JSON compatibility, Character Set , Character Encodings , Line Break Characters , Escaped Characters , Comments , “YAML” Directives , Flow Mappings , Block Mappings JSON-like, Flow Mappings , Flow Nodes K key, Relation to JSON , Structures , Dump , Information Models , Representation Graph , Nodes , Node Comparison , Serialization Tree , Keys Order , Resolved Tags , Indicator Characters , Flow Mappings , Block Mappings , Generic Mapping , Null , Floating Point implicit, Separation Lines , Double-Quoted Style , Single-Quoted Style , Plain Style , Flow Collection Styles , Flow Mappings , Block Mappings , Block Nodes order, Processes , Dump , Load , Information Models , Serialization Tree , Keys Order key: value pair, Introduction , Collections , Structures , Nodes , Keys Order , Node Styles , Plain Style , Flow Mappings , Block Collection Styles , Block Mappings kind, Dump , Representation Graph , Nodes , Tags , Node Comparison , Node Styles , Resolved Tags , Node Tags , Tag Resolution , Tag Resolution , Tag Resolution L line break, Prior Art , Scalars , Production Parameters , Production Naming Conventions , Line Break Characters , White Space Characters , Empty Lines , Line Folding , Comments , Double-Quoted Style , Block Scalar Headers , Block Chomping Indicator , Literal Style , Folded Style non-ASCII, Line Break Characters , “YAML” Directives normalization, Line Break Characters , Literal Style line folding, Prior Art , Scalars , Line Folding , Flow Styles , Double-Quoted Style , Single-Quoted Style , Plain Style , Block Chomping Indicator , Folded Style block, Line Folding , Folded Style flow, Line Folding , Double-Quoted Style line prefix, Line Prefixes , Empty Lines load, Processes , Load , Loading Failure Points failure point, Load , Loading Failure Points M mapping, Introduction , Prior Art , Relation to JSON , Collections , Structures , Dump , Representation Graph , Nodes , Tags , Node Comparison , Keys Order , Resolved Tags , Plain Style , Flow Sequences , Flow Mappings , Generic Mapping , Null marker, Presentation Stream , Document Markers , Bare Documents , Explicit Documents , Streams directives end, Structures , Document Markers , Explicit Documents , Directives Documents , Streams document end, Structures , Document Markers , Streams more-indented, Scalars , Line Folding , Folded Style N native data structure, Introduction , Goals , Prior Art , Relation to JSON , Processing YAML Information , Processes , Dump , Load , Representation Graph , Nodes , Tags , Node Comparison , Serialization Tree , Loading Failure Points , Recognized and Valid Tags , Available Tags , Node Tags , Flow Styles , Generic Mapping , Generic Sequence , Generic String , Null , Boolean , Integer , Floating Point , Other Schemas need not, Terminology node, Structures , Dump , Representation Graph , Nodes , Tags , Node Comparison , Serialization Tree , Keys Order , Anchors and Aliases , Presentation Stream , Node Styles , Comments , Loading Failure Points , Well-Formed Streams and Identified Aliases , Resolved Tags , Recognized and Valid Tags , Syntax Conventions , Indentation Spaces , Node Properties , Node Tags , Node Anchors , Alias Nodes , Empty Nodes , Flow Mappings , Flow Nodes , Block Indentation Indicator , Block Sequences , Bare Documents , Tag Resolution , Tag Resolution , Tag Resolution , Other Schemas completely empty, Empty Nodes , Flow Collection Styles , Flow Mappings , Block Sequences , Explicit Documents property, Node Properties , Alias Nodes , Empty Nodes , Flow Mappings , Flow Nodes , Block Sequences , Block Mappings , Block Nodes root, Representation Graph , Resolved Tags P parse, Load , Presentation Stream , Resolved Tags , Production Parameters , Line Break Characters , Escaped Characters , Tag Handles , Node Tags , Flow Mappings , Block Mappings , Block Nodes , Document Markers , JSON Schema present, Processing YAML Information , Dump , Load , Nodes , Node Comparison , Presentation Stream , Scalar Formats , Character Set , Miscellaneous Characters , Node Tags , Alias Nodes , Block Mappings , Core Schema presentation, Processing YAML Information , Information Models , Presentation Stream , Production Parameters detail, Dump , Load , Information Models , Presentation Stream , Node Styles , Scalar Formats , Comments , Directives , Resolved Tags , Character Encodings , Line Break Characters , Escaped Characters , Indentation Spaces , Separation Spaces , Line Prefixes , Line Folding , Comments , Directives , Tag Handles , Node Tags , Flow Scalar Styles , Block Chomping Indicator printable character, Introduction , Prior Art , Character Set , White Space Characters , Escaped Characters , Single-Quoted Style , Literal Style processor, Terminology , Processing YAML Information , Dump , Node Comparison , Presentation Stream , Directives , Well-Formed Streams and Identified Aliases , Resolved Tags , Recognized and Valid Tags , Available Tags , Character Set , Character Encodings , Line Break Characters , Miscellaneous Characters , Comments , Directives , “YAML” Directives , Tag Handles , Node Tags , Node Anchors , Flow Mappings , Block Indentation Indicator , Failsafe Schema , JSON Schema , Integer , Floating Point , Tag Resolution , Core Schema , Other Schemas R represent, Introduction , Prior Art , Dump , Tags , Node Comparison , Keys Order , Generic Mapping , Generic Sequence , Generic String , Null , Boolean , Integer , Floating Point , Other Schemas representation, Processing YAML Information , Processes , Dump , Load , Information Models , Representation Graph , Nodes , Node Comparison , Serialization Tree , Keys Order , Anchors and Aliases , Presentation Stream , Node Styles , Scalar Formats , Comments , Directives , Available Tags , Node Anchors complete, Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Available Tags partial, Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Tag Resolution required, Terminology S scalar, Introduction , Prior Art , Scalars , Dump , Representation Graph , Nodes , Tags , Node Comparison , Scalar Formats , Comments , Recognized and Valid Tags , Line Break Characters , Separation Spaces , Line Prefixes , Comments , Empty Nodes , Block Chomping Indicator , Generic Mapping , Generic String , Null , Boolean , Integer , Floating Point , Tag Resolution , Tag Resolution canonical form, Prior Art , Tags , Node Comparison , Scalar Formats , Loading Failure Points content format, Dump , Load , Tags , Node Comparison , Presentation Stream , Scalar Formats , Loading Failure Points schema, Recommended Schemas , Failsafe Schema , JSON Schema , Tags , Core Schema , Tags , Other Schemas core, Core Schema , Tag Resolution , Other Schemas failsafe, Tags , Failsafe Schema , Tags , Tag Resolution JSON, Tags , JSON Schema , Tag Resolution , Core Schema , Tags , Tag Resolution sequence, Introduction , Prior Art , Dump , Representation Graph , Nodes , Tags , Node Comparison , Keys Order , Resolved Tags , Flow Mappings , Generic Sequence serialization, Processing YAML Information , Processes , Dump , Load , Information Models , Serialization Tree , Anchors and Aliases , Presentation Stream , Node Styles , Scalar Formats , Comments , Directives , Node Anchors detail, Dump , Load , Information Models , Keys Order , Anchors and Aliases , Node Anchors serialize, Introduction , Prior Art , Relation to JSON , Dump , Load , Keys Order , Anchors and Aliases , Alias Nodes shall, Terminology space, Prior Art , Scalars , White Space Characters , Indentation Spaces , Line Folding , Single-Quoted Style , Plain Style , Block Indentation Indicator , Folded Style , Block Sequences , Block Nodes , Bare Documents indentation, Introduction , Prior Art , Collections , Dump , Load , Information Models , Node Styles , Resolved Tags , Production Parameters , Production Naming Conventions , Indentation Spaces , Separation Spaces , Line Prefixes , Line Folding , Comments , Separation Lines , Directives , Block Styles , Block Indentation Indicator , Block Chomping Indicator , Literal Style , Block Sequences , Block Nodes , Bare Documents separation, Separation Spaces , Comments , Flow Mappings , Block Sequences white, Production Naming Conventions , White Space Characters , Separation Spaces , Line Prefixes , Line Folding , Comments , Double-Quoted Style , Single-Quoted Style , Plain Style , Flow Mappings , Literal Style , Folded Style , Block Sequences stream, Prior Art , Processing YAML Information , Processes , Dump , Load , Presentation Stream , Loading Failure Points , Well-Formed Streams and Identified Aliases , Resolved Tags , Syntax Conventions , Character Set , Character Encodings , Miscellaneous Characters , Comments , Tag Prefixes , Empty Nodes , Documents , Streams ill-formed, Load , Loading Failure Points , Well-Formed Streams and Identified Aliases well-formed, Well-Formed Streams and Identified Aliases , Streams style, Dump , Load , Information Models , Presentation Stream , Node Styles , Scalar Formats , Resolved Tags , Node Tags , Double-Quoted Style , Plain Style block, Prior Art , Scalars , Node Styles , Production Parameters , Indentation Spaces , Block Styles , Block Sequences collection, Collections , Structures , Indentation Spaces , Flow Collection Styles , Block Collection Styles , Block Sequences , Block Nodes folded, Scalars , Node Styles , Indicator Characters , Line Folding , Block Scalar Styles , Literal Style , Folded Style literal, Prior Art , Scalars , Node Styles , Indicator Characters , Block Scalar Styles , Literal Style , Folded Style mapping, Node Styles , Production Parameters , Block Mappings , Block Nodes scalar, Node Styles , Block Scalar Styles , Block Scalar Headers , Block Indentation Indicator , Block Chomping Indicator sequence, Collections , Node Styles , Production Parameters , Indicator Characters , Block Sequences , Block Mappings , Block Nodes compact block collection, Node Styles , Block Sequences , Block Mappings flow, Prior Art , Collections , Scalars , Node Styles , Production Parameters , Line Folding , Flow Styles , Flow Sequences , Flow Nodes , Block Nodes collection, Syntax Conventions , Production Parameters , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Collection Styles double-quoted, Prior Art , Scalars , Node Styles , Syntax Conventions , Character Set , Character Encodings , Indicator Characters , Escaped Characters , Flow Scalar Styles , Double-Quoted Style , Flow Nodes mapping, Collections , Node Styles , Production Parameters , Indicator Characters , Flow Mappings , Block Mappings plain, Scalars , Node Styles , Resolved Tags , Production Parameters , Indicator Characters , Node Tags , Empty Nodes , Flow Scalar Styles , Plain Style , Flow Mappings , Flow Nodes , Block Collection Styles , Block Sequences , Block Mappings , Block Nodes , Document Markers , Tag Resolution , Tag Resolution scalar, Scalars , Node Styles , Line Prefixes , Line Folding , Flow Scalar Styles sequence, Collections , Node Styles , Indicator Characters , Flow Sequences , Flow Mappings single-quoted, Node Styles , Production Parameters , Indicator Characters , Flow Scalar Styles , Single-Quoted Style scalar, Node Styles , Escaped Characters , Empty Lines , Flow Scalar Styles , Literal Style single key:value pair mapping, Keys Order , Node Styles , Flow Sequences , Flow Mappings , Block Mappings T tab, Prior Art , Character Set , White Space Characters , Indentation Spaces , Separation Spaces , Line Prefixes , Block Indentation Indicator tag, Prior Art , Tags , Dump , Representation Graph , Nodes , Tags , Node Comparison , Scalar Formats , Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Available Tags , Syntax Conventions , Production Parameters , Indicator Characters , Miscellaneous Characters , “TAG” Directives , Tag Prefixes , Node Properties , Node Tags , Flow Styles , Recommended Schemas , Tags , Tags , Other Schemas available, Available Tags global, Prior Art , Tags , Dump , Tags , Resolved Tags , Tag Handles , Tag Prefixes , Node Tags , Other Schemas handle, Tags , Processes , Dump , Indicator Characters , “TAG” Directives , Tag Handles , Tag Prefixes , Node Tags named, Miscellaneous Characters , Tag Handles , Node Tags primary, Tag Handles secondary, Tag Handles local, Prior Art , Tags , Dump , Tags , Resolved Tags , Indicator Characters , Tag Handles , Tag Prefixes , Node Tags , Other Schemas non-specific, Tags , Dump , Loading Failure Points , Resolved Tags , Indicator Characters , Node Tags , Recommended Schemas , Tag Resolution , Tag Resolution , Other Schemas prefix, “TAG” Directives , Tag Prefixes , Node Tags property, Resolved Tags , Indicator Characters , Node Tags recognized, Recognized and Valid Tags repository, Tags , Tag Handles , Other Schemas bool, Boolean float, Tags , Floating Point int, Tags , Integer map, Tags , Generic Mapping null, Tags , Empty Nodes , Null seq, Tags , Generic Sequence str, Tags , Generic String resolution, Tags , Loading Failure Points , Resolved Tags , Node Tags , Flow Scalar Styles , Recommended Schemas , Tag Resolution , Tag Resolution , Tag Resolution , Other Schemas convention, Resolved Tags , Node Tags , Tag Resolution , Tag Resolution , Tag Resolution shorthand, Tags , Miscellaneous Characters , “TAG” Directives , Tag Handles , Tag Prefixes , Node Tags specific, Resolved Tags , Node Tags unavailable, Load , Loading Failure Points , Available Tags unrecognized, Loading Failure Points , Recognized and Valid Tags unresolved, Loading Failure Points , Resolved Tags verbatim, Node Tags trimming, Line Folding V value, Dump , Nodes , Node Comparison , Resolved Tags , Indicator Characters , Flow Mappings , Block Mappings , Generic Mapping , Null Y YAML 1.1 processing, Line Break Characters , “YAML” Directives ",
                "urlTerms": [
                    "spec",
                    "html"
                ],
                "titleTerms": [
                    "yaml",
                    "markup",
                    "language",
                    "yaml™",
                    "version"
                ]
            }
        },
        {
            "timestamp": 1608988283692,
            "collection": "visits",
            "objectPk": [
                1608988283677,
                "yaml.org/spec/1.2/spec.html"
            ],
            "operation": "create",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "time": 1608988283677
            }
        },
        {
            "timestamp": 1608988283734,
            "collection": "annotations",
            "objectPk": "https://yaml.org/spec/1.2/spec.html#tag/global//#1608988279277",
            "operation": "create",
            "object": {
                "pageTitle": "YAML Ain’t Markup Language (YAML™) Version 1.2",
                "pageUrl": "yaml.org/spec/1.2/spec.html",
                "body": "Dumping native data structures to a character stream is done using the following three stages:\r\n\r\nRepresenting Native Data Structures\r\n\r\n    YAML represents any native data structure using three node kinds: sequence - an ordered series of entries; mapping - an unordered association of unique keys to values; and scalar - any datum with opaque structure presentable as a series of Unicode characters. Combined, these primitives generate directed graph structures. These primitives were chosen because they are both powerful and familiar: the sequence corresponds to a Perl array and a Python list, the mapping corresponds to a Perl hash table and a Python dictionary. The scalar represents strings, integers, dates, and other atomic data types.\r\n\r\n    Each YAML node requires, in addition to its kind and content, a tag specifying its data type. Type specifiers are either global URIs, or are local in scope to a single application. For example, an integer is represented in YAML with a scalar plus the global tag “tag:yaml.org,2002:int”. Similarly, an invoice object, particular to a given organization, could be represented as a mapping together with the local tag “!invoice”. This simple model can represent any data structure independent of programming language.\r\nSerializing the Representation Graph\r\n    For sequential access mediums, such as an event callback API, a YAML representation must be serialized to an ordered tree. Since in a YAML representation, mapping keys are unordered and nodes may be referenced more than once (have more than one incoming “arrow”), the serialization process is required to impose an ordering on the mapping keys and to replace the second and subsequent references to a given node with place holders called aliases. YAML does not specify how these serialization details are chosen. It is up to the YAML processor to come up with human-friendly key order and anchor names, possibly with the help of the application. The result of this process, a YAML serialization tree, can then be traversed to produce a series of event calls for one-pass processing of YAML data. \r\nPresenting the Serialization Tree\r\n    The final output process is presenting the YAML serializations as a character stream in a human-friendly manner. To maximize human readability, YAML offers a rich set of stylistic options which go far beyond the minimal functional needs of simple data storage. Therefore the YAML processor is required to introduce various presentation details when creating the stream, such as the choice of node styles, how to format scalar content, the amount of indentation, which tag handles to use, the node tags to leave unspecified, the set of directives to provide and possibly even what comments to add. While some of this can be done with the help of the application, in general this process should be guided by the preferences of the user. ",
                "comment": "",
                "selector": {
                    "quote": "Dumping native data structures to a character stream is done using the following three stages:\r\n\r\nRepresenting Native Data Structures\r\n\r\n    YAML represents any native data structure using three node kinds: sequence - an ordered series of entries; mapping - an unordered association of unique keys to values; and scalar - any datum with opaque structure presentable as a series of Unicode characters. Combined, these primitives generate directed graph structures. These primitives were chosen because they are both powerful and familiar: the sequence corresponds to a Perl array and a Python list, the mapping corresponds to a Perl hash table and a Python dictionary. The scalar represents strings, integers, dates, and other atomic data types.\r\n\r\n    Each YAML node requires, in addition to its kind and content, a tag specifying its data type. Type specifiers are either global URIs, or are local in scope to a single application. For example, an integer is represented in YAML with a scalar plus the global tag “tag:yaml.org,2002:int”. Similarly, an invoice object, particular to a given organization, could be represented as a mapping together with the local tag “!invoice”. This simple model can represent any data structure independent of programming language.\r\nSerializing the Representation Graph\r\n    For sequential access mediums, such as an event callback API, a YAML representation must be serialized to an ordered tree. Since in a YAML representation, mapping keys are unordered and nodes may be referenced more than once (have more than one incoming “arrow”), the serialization process is required to impose an ordering on the mapping keys and to replace the second and subsequent references to a given node with place holders called aliases. YAML does not specify how these serialization details are chosen. It is up to the YAML processor to come up with human-friendly key order and anchor names, possibly with the help of the application. The result of this process, a YAML serialization tree, can then be traversed to produce a series of event calls for one-pass processing of YAML data. \r\nPresenting the Serialization Tree\r\n    The final output process is presenting the YAML serializations as a character stream in a human-friendly manner. To maximize human readability, YAML offers a rich set of stylistic options which go far beyond the minimal functional needs of simple data storage. Therefore the YAML processor is required to introduce various presentation details when creating the stream, such as the choice of node styles, how to format scalar content, the amount of indentation, which tag handles to use, the node tags to leave unspecified, the set of directives to provide and possibly even what comments to add. While some of this can be done with the help of the application, in general this process should be guided by the preferences of the user. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[1]/div[5]/div[2]/div[3]/p[1]/em[1]",
                                "startOffset": 0,
                                "endContainer": "/div[1]/div[5]/div[2]/div[3]/div[2]/dl[1]/dd[3]",
                                "endOffset": 958
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 45610,
                                "end": 49670
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "Dumping native data structures to a\n          character stream is done using\n          the following three stages:\n        \n            \n              \n                \n                  Representing Native Data Structures\n                \n                \n                  \n                YAML represents any\n                native data\n                structure using three node\n                kinds: sequence\n                - an ordered series of entries; mapping - an unordered association\n                of unique keys to values; and scalar - any datum with opaque\n                structure presentable as a series of Unicode characters.\n                Combined, these primitives generate directed graph structures.\n                These primitives were chosen because they are both powerful and\n                familiar: the sequence\n                corresponds to a Perl array and a Python list, the mapping corresponds to a Perl hash\n                table and a Python dictionary. The scalar represents strings, integers,\n                dates, and other atomic data types.\n              \n                  \n                Each YAML node requires, in\n                addition to its kind and\n                content, a tag specifying its data type. Type\n                specifiers are either global URIs, or are local in scope to a\n                single application.\n                For example, an integer is represented in YAML with a scalar plus the global tag\n                “tag:yaml.org,2002:int”. Similarly, an invoice\n                object, particular to a given organization, could be\n                represented as a mapping\n                together with the local tag\n                “!invoice”. This simple model can represent any\n                data structure independent of programming language.\n              \n                \n                \n                  Serializing the Representation Graph\n                \n                \n              For sequential access mediums, such as an event callback API, a\n              YAML representation\n              must be serialized to an\n              ordered tree. Since in a YAML representation, mapping keys are unordered and nodes may be referenced more than once\n              (have more than one incoming “arrow”), the\n              serialization process is required to impose an ordering on the\n              mapping keys and to replace the\n              second and subsequent references to a given node with place holders called aliases. YAML does not specify how\n              these serialization details are chosen. It\n              is up to the YAML processor to come up with\n              human-friendly key\n              order and anchor\n              names, possibly with the help of the application. The result of this\n              process, a YAML serialization\n              tree, can then be traversed to produce a series of\n              event calls for one-pass processing of YAML data.\n            \n                \n                  Presenting the Serialization Tree\n                \n                \n              The final output process is presenting the YAML serializations as a character\n              stream in a human-friendly\n              manner. To maximize human readability, YAML offers a rich set of\n              stylistic options which go far beyond the minimal functional\n              needs of simple data storage. Therefore the YAML processor is required to introduce\n              various presentation details when creating\n              the stream, such as the\n              choice of node styles, how to\n              format\n              scalar content, the amount of indentation, which tag handles to use,\n              the node tags to leave unspecified, the\n              set of directives to\n              provide and possibly even what comments to add. While some of this\n              can be done with the help of the application, in general this\n              process should be guided by the preferences of the user.\n            ",
                                "prefix": "        \n            \n          ",
                                "suffix": "\n              \n            \n   "
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T13:11:19.277Z",
                "lastEdited": "2020-12-26T13:11:19.277Z",
                "url": "https://yaml.org/spec/1.2/spec.html#tag/global//#1608988279277"
            }
        },
        {
            "timestamp": 1608988331073,
            "collection": "annotations",
            "objectPk": "https://yaml.org/spec/1.2/spec.html#application///#1608987751184",
            "operation": "update",
            "object": {
                "pageTitle": "YAML Ain’t Markup Language (YAML™) Version 1.2",
                "pageUrl": "yaml.org/spec/1.2/spec.html",
                "body": "A YAML processor need not expose the serialization or representation stages. It may translate directly between native data structures and a character stream (dump and load in the diagram above). However, such a direct translation should take place so that the native data structures are constructed only from information available in the representation. In particular, mapping key order, comments, and tag handles should not be referenced during composition. ",
                "comment": "#dump #YAML",
                "selector": {
                    "quote": "A YAML processor need not expose the serialization or representation stages. It may translate directly between native data structures and a character stream (dump and load in the diagram above). However, such a direct translation should take place so that the native data structures are constructed only from information available in the representation. In particular, mapping key order, comments, and tag handles should not be referenced during composition. ",
                    "descriptor": {
                        "strategy": "hyp-anchoring",
                        "content": [
                            {
                                "type": "RangeSelector",
                                "startContainer": "/div[1]/div[5]/div[2]/p[2]",
                                "startOffset": 9,
                                "endContainer": "/div[1]/div[5]/div[2]/p[2]",
                                "endOffset": 530
                            },
                            {
                                "type": "TextPositionSelector",
                                "start": 44934,
                                "end": 45455
                            },
                            {
                                "type": "TextQuoteSelector",
                                "exact": "A YAML processor need not expose the serialization or representation stages. It may\n        translate directly between native data structures and a character stream (dump and load in the diagram above). However, such a\n        direct translation should take place so that the native data structures are\n        constructed only from\n        information available in the representation. In particular,\n        mapping key order,\n        comments, and tag handles should not be\n        referenced during composition.\n      ",
                                "prefix": " \n          \n          \n        ",
                                "suffix": "\n          \n            \n       "
                            }
                        ]
                    }
                },
                "createdWhen": "2020-12-26T13:02:31.184Z",
                "lastEdited": "2020-12-26T13:12:10.987Z",
                "url": "https://yaml.org/spec/1.2/spec.html#application///#1608987751184"
            }
        },
        {
            "timestamp": 1608988356692,
            "collection": "customLists",
            "objectPk": 1608988356680,
            "operation": "create",
            "object": {
                "id": 1608988356680,
                "name": "YAML",
                "searchableName": "YAML",
                "isDeletable": true,
                "isNestable": true,
                "createdAt": "2020-12-26T13:12:36.680Z",
                "nameTerms": [
                    "yaml"
                ]
            }
        },
        {
            "timestamp": 1608988361278,
            "collection": "pages",
            "objectPk": "yaml.org/spec/1.2/spec.html",
            "operation": "update",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "fullUrl": "https://yaml.org/spec/1.2/spec.html#id2708649",
                "domain": "yaml.org",
                "hostname": "yaml.org",
                "fullTitle": "YAML Ain’t Markup Language (YAML™) Version 1.2",
                "text": " YAML Ain’t Markup Language ( YAML ) Version 1.2 3rd Edition, Patched at 2009-10-01 Oren Ben-Kiki < oren@ben-kiki.org > Clark Evans < cce@clarkevans.com > Ingy döt Net < ingy@ingy.net > Latest (patched) version: HTML: http://yaml.org/spec/1.2/spec.html PDF: http://yaml.org/spec/1.2/spec.pdf PS: http://yaml.org/spec/1.2/spec.ps Errata: http://yaml.org/spec/1.2/errata.html Previous (original) version: http://yaml.org/spec/1.2/2009-07-21/spec.html Copyright © 2001-2009 Oren Ben-Kiki, Clark Evans, Ingy döt Net This document may be freely copied, provided it is not modified. Status of this Document This document reflects the third version of YAML data serialization language. The content of the specification was arrived at by consensus of its authors and through user feedback on the yaml-core mailing list. We encourage implementers to please update their software with support for this version. The primary objective of this revision is to bring YAML into compliance with JSON as an official subset. YAML 1.2 is compatible with 1.1 for most practical applications - this is a minor revision. An expected source of incompatibility with prior versions of YAML, especially the syck implementation, is the change in implicit typing rules. We have removed unique implicit typing rules and have updated these rules to align them with JSON's productions. In this version of YAML, boolean values may be serialized as “ true” or “ false”; the empty scalar as “ null”. Unquoted numeric values are a superset of JSON's numeric production. Other changes in the specification were the removal of the Unicode line breaks and production bug fixes. We also define 3 built-in implicit typing rule sets: untyped, strict JSON, and a more flexible YAML rule set that extends JSON typing. The difference between late 1.0 drafts which syck 0.55 implements and the 1.1 revision of this specification is much more extensive. We fixed usability issues with the tagging syntax. In particular, the single exclamation was re-defined for private types and a simple prefixing mechanism was introduced. This revision also fixed many production edge cases and introduced a type repository. Therefore, there are several incompatibilities between syck and this revision as well. The list of known errors in this specification is available at http://yaml.org/spec/1.2/errata.html . Please report errors in this document to the yaml-core mailing list. This revision contains fixes for all errors known as of 2009-10-01. We wish to thank implementers who have tirelessly tracked earlier versions of this specification, and our fabulous user community whose feedback has both validated and clarified our direction. Abstract YAML (rhymes with “ camel”) is a human-friendly, cross language, Unicode based data serialization language designed around the common native data types of agile programming languages. It is broadly useful for programming needs ranging from configuration files to Internet messaging to object persistence to data auditing. Together with the Unicode standard for characters , this specification provides all the information necessary to understand YAML Version 1.2 and to create programs that process YAML information. Table of Contents 1. Introduction 1.1. Goals 1.2. Prior Art 1.3. Relation to JSON 1.4. Relation to XML 1.5. Terminology 2. Preview 2.1. Collections 2.2. Structures 2.3. Scalars 2.4. Tags 2.5. Full Length Example 3. Processing YAML Information 3.1. Processes 3.1.1. Dump 3.1.2. Load 3.2. Information Models 3.2.1. Representation Graph 3.2.1.1. Nodes 3.2.1.2. Tags 3.2.1.3. Node Comparison 3.2.2. Serialization Tree 3.2.2.1. Keys Order 3.2.2.2. Anchors and Aliases 3.2.3. Presentation Stream 3.2.3.1. Node Styles 3.2.3.2. Scalar Formats 3.2.3.3. Comments 3.2.3.4. Directives 3.3. Loading Failure Points 3.3.1. Well-Formed Streams and Identified Aliases 3.3.2. Resolved Tags 3.3.3. Recognized and Valid Tags 3.3.4. Available Tags 4. Syntax Conventions 4.1. Production Parameters 4.2. Production Naming Conventions 5. Characters 5.1. Character Set 5.2. Character Encodings 5.3. Indicator Characters 5.4. Line Break Characters 5.5. White Space Characters 5.6. Miscellaneous Characters 5.7. Escaped Characters 6. Basic Structures 6.1. Indentation Spaces 6.2. Separation Spaces 6.3. Line Prefixes 6.4. Empty Lines 6.5. Line Folding 6.6. Comments 6.7. Separation Lines 6.8. Directives 6.8.1. “ YAML” Directives 6.8.2. “ TAG” Directives 6.8.2.1. Tag Handles 6.8.2.2. Tag Prefixes 6.9. Node Properties 6.9.1. Node Tags 6.9.2. Node Anchors 7. Flow Styles 7.1. Alias Nodes 7.2. Empty Nodes 7.3. Flow Scalar Styles 7.3.1. Double-Quoted Style 7.3.2. Single-Quoted Style 7.3.3. Plain Style 7.4. Flow Collection Styles 7.4.1. Flow Sequences 7.4.2. Flow Mappings 7.5. Flow Nodes 8. Block Styles 8.1. Block Scalar Styles 8.1.1. Block Scalar Headers 8.1.1.1. Block Indentation Indicator 8.1.1.2. Block Chomping Indicator 8.1.2. Literal Style 8.1.3. Folded Style 8.2. Block Collection Styles 8.2.1. Block Sequences 8.2.2. Block Mappings 8.2.3. Block Nodes 9. YAML Character Stream 9.1. Documents 9.1.1. Document Prefix 9.1.2. Document Markers 9.1.3. Bare Documents 9.1.4. Explicit Documents 9.1.5. Directives Documents 9.2. Streams 10. Recommended Schemas 10.1. Failsafe Schema 10.1.1. Tags 10.1.1.1. Generic Mapping 10.1.1.2. Generic Sequence 10.1.1.3. Generic String 10.1.2. Tag Resolution 10.2. JSON Schema 10.2.1. Tags 10.2.1.1. Null 10.2.1.2. Boolean 10.2.1.3. Integer 10.2.1.4. Floating Point 10.2.2. Tag Resolution 10.3. Core Schema 10.3.1. Tags 10.3.2. Tag Resolution 10.4. Other Schemas Index Chapter 1. Introduction “ YAML Ain’t Markup Language” (abbreviated YAML) is a data serialization language designed to be human-friendly and work well with modern programming languages for common everyday tasks. This specification is both an introduction to the YAML language and the concepts supporting it, and also a complete specification of the information needed to develop applications for processing YAML. Open, interoperable and readily understandable tools have advanced computing immensely. YAML was designed from the start to be useful and friendly to people working with data. It uses Unicode printable characters, some of which provide structural information and the rest containing the data itself. YAML achieves a unique cleanness by minimizing the amount of structural characters and allowing the data to show itself in a natural and meaningful way. For example, indentation may be used for structure, colons separate key: value pairs , and dashes are used to create “ bullet” lists . There are myriad flavors of data structures , but they can all be adequately represented with three basic primitives: mappings (hashes/dictionaries), sequences (arrays/lists) and scalars (strings/numbers). YAML leverages these primitives, and adds a simple typing system and aliasing mechanism to form a complete language for serializing any native data structure . While most programming languages can use YAML for data serialization, YAML excels in working with those languages that are fundamentally built around the three basic primitives. These include the new wave of agile languages such as Perl, Python, PHP, Ruby, and Javascript. There are hundreds of different languages for programming, but only a handful of languages for storing and transferring data. Even though its potential is virtually boundless, YAML was specifically created to work well for common use cases such as: configuration files, log files, interprocess messaging, cross-language data sharing, object persistence, and debugging of complex data structures. When data is easy to view and understand, programming becomes a simpler task. 1.1. Goals The design goals for YAML are, in decreasing priority: YAML is easily readable by humans. YAML data is portable between programming languages. YAML matches the native data structures of agile languages. YAML has a consistent model to support generic tools. YAML supports one-pass processing. YAML is expressive and extensible. YAML is easy to implement and use. 1.2. Prior Art YAML’s initial direction was set by the data serialization and markup language discussions among SML-DEV members . Later on, it directly incorporated experience from Ingy döt Net’s Perl module Data::Denter . Since then, YAML has matured through ideas and support from its user community. YAML integrates and builds upon concepts described by C , Java , Perl , Python , Ruby , RFC0822 (MAIL), RFC1866 (HTML), RFC2045 (MIME), RFC2396 (URI), XML , SAX , SOAP , and JSON . The syntax of YAML was motivated by Internet Mail (RFC0822) and remains partially compatible with that standard. Further, borrowing from MIME (RFC2045), YAML’s top-level production is a stream of independent documents , ideal for message-based distributed processing systems. YAML’s indentation -based scoping is similar to Python’s (without the ambiguities caused by tabs ). Indented blocks facilitate easy inspection of the data’s structure. YAML’s literal style leverages this by enabling formatted text to be cleanly mixed within an indented structure without troublesome escaping . YAML also allows the use of traditional indicator -based scoping similar to JSON’s and Perl’s. Such flow content can be freely nested inside indented blocks . YAML’s double-quoted style uses familiar C-style escape sequences . This enables ASCII encoding of non- printable or 8-bit (ISO 8859-1) characters such as “ \\x3B” . Non- printable 16-bit Unicode and 32-bit (ISO/IEC 10646) characters are supported with escape sequences such as “ \\u003B” and “ \\U0000003B” . Motivated by HTML’s end-of-line normalization, YAML’s line folding employs an intuitive method of handling line breaks . A single line break is folded into a single space , while empty lines are interpreted as line break characters. This technique allows for paragraphs to be word-wrapped without affecting the canonical form of the scalar content . YAML’s core type system is based on the requirements of agile languages such as Perl, Python, and Ruby. YAML directly supports both collections ( mappings , sequences ) and scalars . Support for these common types enables programmers to use their language’s native data structures for YAML manipulation, instead of requiring a special document object model (DOM). Like XML’s SOAP, YAML supports serializing a graph of native data structures through an aliasing mechanism. Also like SOAP, YAML provides for application -defined types . This allows YAML to represent rich data structures required for modern distributed computing. YAML provides globally unique type names using a namespace mechanism inspired by Java’s DNS-based package naming convention and XML’s URI-based namespaces. In addition, YAML allows for private types specific to a single application . YAML was designed to support incremental interfaces that include both input (“ getNextEvent()”) and output (“ sendNextEvent()”) one-pass interfaces. Together, these enable YAML to support the processing of large documents (e.g. transaction logs) or continuous streams (e.g. feeds from a production machine). 1.3. Relation to JSON Both JSON and YAML aim to be human readable data interchange formats. However, JSON and YAML have different priorities. JSON’s foremost design goal is simplicity and universality. Thus, JSON is trivial to generate and parse, at the cost of reduced human readability. It also uses a lowest common denominator information model, ensuring any JSON data can be easily processed by every modern programming environment. In contrast, YAML’s foremost design goals are human readability and support for serializing arbitrary native data structures . Thus, YAML allows for extremely readable files, but is more complex to generate and parse. In addition, YAML ventures beyond the lowest common denominator data types, requiring more complex processing when crossing between different programming environments. YAML can therefore be viewed as a natural superset of JSON, offering improved human readability and a more complete information model. This is also the case in practice; every JSON file is also a valid YAML file. This makes it easy to migrate from JSON to YAML if/when the additional features are required. JSON's RFC4627 requires that mappings keys merely “ SHOULD” be unique , while YAML insists they “ MUST” be. Technically, YAML therefore complies with the JSON spec, choosing to treat duplicates as an error. In practice, since JSON is silent on the semantics of such duplicates, the only portable JSON files are those with unique keys, which are therefore valid YAML files. It may be useful to define a intermediate format between YAML and JSON. Such a format would be trivial to parse (but not very human readable), like JSON. At the same time, it would allow for serializing arbitrary native data structures , like YAML. Such a format might also serve as YAML’s \"canonical format\". Defining such a “ YSON” format (YSON is a Serialized Object Notation) can be done either by enhancing the JSON specification or by restricting the YAML specification. Such a definition is beyond the scope of this specification. 1.4. Relation to XML Newcomers to YAML often search for its correlation to the eXtensible Markup Language (XML). Although the two languages may actually compete in several application domains, there is no direct correlation between them. YAML is primarily a data serialization language. XML was designed to be backwards compatible with the Standard Generalized Markup Language (SGML), which was designed to support structured documentation. XML therefore had many design constraints placed on it that YAML does not share. XML is a pioneer in many domains, YAML is the result of lessons learned from XML and other technologies. It should be mentioned that there are ongoing efforts to define standard XML/YAML mappings. This generally requires that a subset of each language be used. For more information on using both XML and YAML, please visit http://yaml.org/xml . 1.5. Terminology This specification uses key words based on RFC2119 to indicate requirement level. In particular, the following words are used to describe the actions of a YAML processor : May The word may, or the adjective optional, mean that conforming YAML processors are permitted to, but need not behave as described. Should The word should, or the adjective recommended, mean that there could be reasons for a YAML processor to deviate from the behavior described, but that such deviation could hurt interoperability and should therefore be advertised with appropriate notice. Must The word must, or the term required or shall, mean that the behavior described is an absolute requirement of the specification. The rest of this document is arranged as follows. Chapter 2 provides a short preview of the main YAML features. Chapter 3 describes the YAML information model, and the processes for converting from and to this model and the YAML text format. The bulk of the document, chapters 4 through 9 , formally define this text format. Finally, chapter 10 recommends basic YAML schemas. Chapter 2. Preview This section provides a quick glimpse into the expressive power of YAML. It is not expected that the first-time reader grok all of the examples. Rather, these selections are used as motivation for the remainder of the specification. 2.1. Collections YAML’s block collections use indentation for scope and begin each entry on its own line. Block sequences indicate each entry with a dash and space ( “ - ” ). Mappings use a colon and space ( “ : ” ) to mark each key: value pair . Comments begin with an octothorpe (also called a “ hash”, “ sharp”, “ pound”, or “ number sign” - “ #” ). Example 2.1. Sequence of Scalars (ball players) - Mark McGwire - Sammy Sosa - Ken Griffey Example 2.2. Mapping Scalars to Scalars (player statistics) hr: 65 # Home runs avg: 0.278 # Batting average rbi: 147 # Runs Batted In Example 2.3. Mapping Scalars to Sequences (ball clubs in each league) american: - Boston Red Sox - Detroit Tigers - New York Yankees national: - New York Mets - Chicago Cubs - Atlanta Braves Example 2.4. Sequence of Mappings (players’ statistics) - name: Mark McGwire hr: 65 avg: 0.278 - name: Sammy Sosa hr: 63 avg: 0.288 YAML also has flow styles , using explicit indicators rather than indentation to denote scope. The flow sequence is written as a comma separated list within square brackets . In a similar manner, the flow mapping uses curly braces . Example 2.5. Sequence of Sequences - [name , hr, avg ] - [Mark McGwire, 65, 0.278] - [Sammy Sosa , 63, 0.288] Example 2.6. Mapping of Mappings Mark McGwire: {hr: 65, avg: 0.278} Sammy Sosa: { hr: 63, avg: 0.288 } 2.2. Structures YAML uses three dashes ( “ ---” ) to separate directives from document content . This also serves to signal the start of a document if no directives are present. Three dots ( “ ...” ) indicate the end of a document without starting a new one, for use in communication channels. Example 2.7. Two Documents in a Stream (each with a leading comment) # Ranking of 1998 home runs --- - Mark McGwire - Sammy Sosa - Ken Griffey # Team ranking --- - Chicago Cubs - St Louis Cardinals Example 2.8. Play by Play Feed from a Game --- time: 20:03:20 player: Sammy Sosa action: strike (miss) ... --- time: 20:03:47 player: Sammy Sosa action: grand slam ... Repeated nodes (objects) are first identified by an anchor (marked with the ampersand - “ &” ), and are then aliased (referenced with an asterisk - “ *” ) thereafter. Example 2.9. Single Document with Two Comments --- hr: # 1998 hr ranking - Mark McGwire - Sammy Sosa rbi: # 1998 rbi ranking - Sammy Sosa - Ken Griffey Example 2.10. Node for “ Sammy Sosa” appears twice in this document --- hr: - Mark McGwire # Following node labeled SS - &SS Sammy Sosa rbi: - *SS # Subsequent occurrence - Ken Griffey A question mark and space ( “ ? ” ) indicate a complex mapping key . Within a block collection , key: value pairs can start immediately following the dash , colon , or question mark . Example 2.11. Mapping between Sequences ? - Detroit Tigers - Chicago cubs : - 2001-07-23 ? [ New York Yankees, Atlanta Braves ] : [ 2001-07-02, 2001-08-12, 2001-08-14 ] Example 2.12. Compact Nested Mapping --- # Products purchased - item : Super Hoop quantity: 1 - item : Basketball quantity: 4 - item : Big Shoes quantity: 1 2.3. Scalars Scalar content can be written in block notation, using a literal style (indicated by “ |” ) where all line breaks are significant. Alternatively, they can be written with the folded style (denoted by “ >” ) where each line break is folded to a space unless it ends an empty or a more-indented line. Example 2.13. In literals, newlines are preserved # ASCII Art --- | \\//||\\/|| // || ||__ Example 2.14. In the folded scalars, newlines become spaces --- > Mark McGwire's year was crippled by a knee injury. Example 2.15. Folded newlines are preserved for \"more indented\" and blank lines > Sammy Sosa completed another fine season with great stats. 63 Home Runs 0.288 Batting Average What a year! Example 2.16. Indentation determines scope name: Mark McGwire accomplishment: > Mark set a major league home run record in 1998. stats: | 65 Home Runs 0.278 Batting Average YAML’s flow scalars include the plain style (most examples thus far) and two quoted styles. The double-quoted style provides escape sequences . The single-quoted style is useful when escaping is not needed. All flow scalars can span multiple lines; line breaks are always folded . Example 2.17. Quoted Scalars unicode: \"Sosa did fine.\\u263A\" control: \"\\b1998\\t1999\\t2000\\n\" hex esc: \"\\x0d\\x0a is \\r\\n\" single: '\"Howdy!\" he cried.' quoted: ' # Not a ''comment''.' tie-fighter: '|\\-*-/|' Example 2.18. Multi-line Flow Scalars plain: This unquoted scalar spans many lines. quoted: \"So does this quoted scalar.\\n\" 2.4. Tags In YAML, untagged nodes are given a type depending on the application . The examples in this specification generally use the seq , map and str types from the fail safe schema . A few examples also use the int , float , and null types from the JSON schema . The repository includes additional types such as binary , omap , set and others. Example 2.19. Integers canonical: 12345 decimal: +12345 octal: 0o14 hexadecimal: 0xC Example 2.20. Floating Point canonical: 1.23015e+3 exponential: 12.3015e+02 fixed: 1230.15 negative infinity: -.inf not a number: .NaN Example 2.21. Miscellaneous null: booleans: [ true, false ] string: '012345' Example 2.22. Timestamps canonical: 2001-12-15T02:59:43.1Z iso8601: 2001-12-14t21:59:43.10-05:00 spaced: 2001-12-14 21:59:43.10 -5 date: 2002-12-14 Explicit typing is denoted with a tag using the exclamation point ( “ !” ) symbol. Global tags are URIs and may be specified in a tag shorthand notation using a handle . Application -specific local tags may also be used. Example 2.23. Various Explicit Tags --- not-date: !!str 2002-04-28 picture: !!binary | R0lGODlhDAAMAIQAAP//9/X 17unp5WZmZgAAAOfn515eXv Pz7Y6OjuDg4J+fn5OTk6enp 56enmleECcgggoBADs= application specific tag: !something | The semantics of the tag above may be different for different documents. Example 2.24. Global Tags %TAG ! tag:clarkevans.com,2002: --- !shape # Use the ! handle for presenting # tag:clarkevans.com,2002:circle - !circle center: &ORIGIN {x: 73, y: 129} radius: 7 - !line start: *ORIGIN finish: { x: 89, y: 102 } - !label start: *ORIGIN color: 0xFFEEBB text: Pretty vector drawing. Example 2.25. Unordered Sets # Sets are represented as a # Mapping where each key is # associated with a null value --- !!set ? Mark McGwire ? Sammy Sosa ? Ken Griff Example 2.26. Ordered Mappings # Ordered maps are represented as # A sequence of mappings, with # each mapping having one key --- !!omap - Mark McGwire: 65 - Sammy Sosa: 63 - Ken Griffy: 58 2.5. Full Length Example Below are two full-length examples of YAML. On the left is a sample invoice; on the right is a sample log file. Example 2.27. Invoice --- !<tag:clarkevans.com,2002:invoice> invoice: 34843 date : 2001-01-23 bill-to: &id001 given : Chris family : Dumars address: lines: | 458 Walkman Dr. Suite #292 city : Royal Oak state : MI postal : 48046 ship-to: *id001 product: - sku : BL394D quantity : 4 description : Basketball price : 450.00 - sku : BL4438H quantity : 1 description : Super Hoop price : 2392.00 tax : 251.42 total: 4443.52 comments: Late afternoon is best. Backup contact is Nancy Billsmer @ 338-4338. Example 2.28. Log File --- Time: 2001-11-23 15:01:42 -5 User: ed Warning: This is an error message for the log file --- Time: 2001-11-23 15:02:31 -5 User: ed Warning: A slightly different error message. --- Date: 2001-11-23 15:03:17 -5 User: ed Fatal: Unknown variable \"bar\" Stack: - file: TopClass.py line: 23 code: | x = MoreObject(\"345\\n\") - file: MoreClass.py line: 58 code: |- foo = bar Chapter 3. Processing YAML Information YAML is both a text format and a method for presenting any native data structure in this format. Therefore, this specification defines two concepts: a class of data objects called YAML representations , and a syntax for presenting YAML representations as a series of characters, called a YAML stream . A YAML processor is a tool for converting information between these complementary views. It is assumed that a YAML processor does its work on behalf of another module, called an application. This chapter describes the information structures a YAML processor must provide to or obtain from the application. YAML information is used in two ways: for machine processing, and for human consumption. The challenge of reconciling these two perspectives is best done in three distinct translation stages: representation , serialization , and presentation . Representation addresses how YAML views native data structures to achieve portability between programming environments. Serialization concerns itself with turning a YAML representation into a serial form, that is, a form with sequential access constraints. Presentation deals with the formatting of a YAML serialization as a series of characters in a human-friendly manner. 3.1. Processes Translating between native data structures and a character stream is done in several logically distinct stages, each with a well defined input and output data model, as shown in the following diagram: Figure 3.1. Processing Overview A YAML processor need not expose the serialization or representation stages. It may translate directly between native data structures and a character stream ( dump and load in the diagram above). However, such a direct translation should take place so that the native data structures are constructed only from information available in the representation . In particular, mapping key order , comments , and tag handles should not be referenced during composition . 3.1.1. Dump Dumping native data structures to a character stream is done using the following three stages: Representing Native Data Structures YAML represents any native data structure using three node kinds : sequence - an ordered series of entries; mapping - an unordered association of unique keys to values ; and scalar - any datum with opaque structure presentable as a series of Unicode characters. Combined, these primitives generate directed graph structures. These primitives were chosen because they are both powerful and familiar: the sequence corresponds to a Perl array and a Python list, the mapping corresponds to a Perl hash table and a Python dictionary. The scalar represents strings, integers, dates, and other atomic data types. Each YAML node requires, in addition to its kind and content , a tag specifying its data type. Type specifiers are either global URIs, or are local in scope to a single application . For example, an integer is represented in YAML with a scalar plus the global tag “ tag:yaml.org,2002:int”. Similarly, an invoice object, particular to a given organization, could be represented as a mapping together with the local tag “ !invoice”. This simple model can represent any data structure independent of programming language. Serializing the Representation Graph For sequential access mediums, such as an event callback API, a YAML representation must be serialized to an ordered tree. Since in a YAML representation , mapping keys are unordered and nodes may be referenced more than once (have more than one incoming “ arrow”), the serialization process is required to impose an ordering on the mapping keys and to replace the second and subsequent references to a given node with place holders called aliases . YAML does not specify how these serialization details are chosen. It is up to the YAML processor to come up with human-friendly key order and anchor names, possibly with the help of the application . The result of this process, a YAML serialization tree , can then be traversed to produce a series of event calls for one-pass processing of YAML data. Presenting the Serialization Tree The final output process is presenting the YAML serializations as a character stream in a human-friendly manner. To maximize human readability, YAML offers a rich set of stylistic options which go far beyond the minimal functional needs of simple data storage. Therefore the YAML processor is required to introduce various presentation details when creating the stream , such as the choice of node styles , how to format scalar content , the amount of indentation , which tag handles to use, the node tags to leave unspecified , the set of directives to provide and possibly even what comments to add. While some of this can be done with the help of the application , in general this process should be guided by the preferences of the user. 3.1.2. Load Loading native data structures from a character stream is done using the following three stages: Parsing the Presentation Stream Parsing is the inverse process of presentation , it takes a stream of characters and produces a series of events. Parsing discards all the details introduced in the presentation process, reporting only the serialization events. Parsing can fail due to ill-formed input. Composing the Representation Graph Composing takes a series of serialization events and produces a representation graph . Composing discards all the details introduced in the serialization process, producing only the representation graph . Composing can fail due to any of several reasons, detailed below . Constructing Native Data Structures The final input process is constructing native data structures from the YAML representation . Construction must be based only on the information available in the representation , and not on additional serialization or presentation details such as comments , directives , mapping key order , node styles , scalar content format , indentation levels etc. Construction can fail due to the unavailability of the required native data types . 3.2. Information Models This section specifies the formal details of the results of the above processes. To maximize data portability between programming languages and implementations, users of YAML should be mindful of the distinction between serialization or presentation properties and those which are part of the YAML representation . Thus, while imposing a order on mapping keys is necessary for flattening YAML representations to a sequential access medium, this serialization detail must not be used to convey application level information. In a similar manner, while indentation technique and a choice of a node style are needed for the human readability, these presentation details are neither part of the YAML serialization nor the YAML representation . By carefully separating properties needed for serialization and presentation , YAML representations of application information will be consistent and portable between various programming environments. The following diagram summarizes the three information models. Full arrows denote composition, hollow arrows denote inheritance, “ 1” and “ *” denote “ one” and “ many” relationships. A single “ +” denotes serialization details, a double “ ++” denotes presentation details. Figure 3.2. Information Models 3.2.1. Representation Graph YAML’s representation of native data structure is a rooted, connected, directed graph of tagged nodes . By “ directed graph” we mean a set of nodes and directed edges (“ arrows”), where each edge connects one node to another (see a formal definition ). All the nodes must be reachable from the root node via such edges. Note that the YAML graph may include cycles, and a node may have more than one incoming edge. Nodes that are defined in terms of other nodes are collections ; nodes that are independent of any other nodes are scalars . YAML supports two kinds of collection nodes : sequences and mappings . Mapping nodes are somewhat tricky because their keys are unordered and must be unique . Figure 3.3. Representation Model 3.2.1.1. Nodes A YAML node represents a single native data structure . Such nodes have content of one of three kinds: scalar, sequence, or mapping. In addition, each node has a tag which serves to restrict the set of possible values the content can have. Scalar The content of a scalar node is an opaque datum that can be presented as a series of zero or more Unicode characters. Sequence The content of a sequence node is an ordered series of zero or more nodes. In particular, a sequence may contain the same node more than once. It could even contain itself (directly or indirectly). Mapping The content of a mapping node is an unordered set of key: value node pairs, with the restriction that each of the keys is unique . YAML places no further restrictions on the nodes. In particular, keys may be arbitrary nodes, the same node may be used as the value of several key: value pairs, and a mapping could even contain itself as a key or a value (directly or indirectly). When appropriate, it is convenient to consider sequences and mappings together, as collections. In this view, sequences are treated as mappings with integer keys starting at zero. Having a unified collections view for sequences and mappings is helpful both for theoretical analysis and for creating practical YAML tools and APIs. This strategy is also used by the Javascript programming language. 3.2.1.2. Tags YAML represents type information of native data structures with a simple identifier, called a tag. Global tags are URIs and hence globally unique across all applications . The “ tag:” URI scheme is recommended for all global YAML tags. In contrast, local tags are specific to a single application . Local tags start with “ !”, are not URIs and are not expected to be globally unique. YAML provides a “ TAG” directive to make tag notation less verbose; it also offers easy migration from local to global tags. To ensure this, local tags are restricted to the URI character set and use URI character escaping . YAML does not mandate any special relationship between different tags that begin with the same substring. Tags ending with URI fragments (containing “ #”) are no exception; tags that share the same base URI but differ in their fragment part are considered to be different, independent tags. By convention, fragments are used to identify different “ variants” of a tag, while “ /” is used to define nested tag “ namespace” hierarchies. However, this is merely a convention, and each tag may employ its own rules. For example, Perl tags may use “ ::” to express namespace hierarchies, Java tags may use “ .”, etc. YAML tags are used to associate meta information with each node . In particular, each tag must specify the expected node kind ( scalar , sequence , or mapping ). Scalar tags must also provide a mechanism for converting formatted content to a canonical form for supporting equality testing. Furthermore, a tag may provide additional information such as the set of allowed content values for validation, a mechanism for tag resolution , or any other data that is applicable to all of the tag’s nodes . 3.2.1.3. Node Comparison Since YAML mappings require key uniqueness, representations must include a mechanism for testing the equality of nodes . This is non-trivial since YAML allows various ways to format scalar content . For example, the integer eleven can be written as “ 0o13” (octal) or “ 0xB” (hexadecimal). If both notations are used as keys in the same mapping , only a YAML processor which recognizes integer formats would correctly flag the duplicate key as an error. Canonical Form YAML supports the need for scalar equality by requiring that every scalar tag must specify a mechanism for producing the canonical form of any formatted content . This form is a Unicode character string which also presents the same content , and can be used for equality testing. While this requirement is stronger than a well defined equality operator, it has other uses, such as the production of digital signatures. Equality Two nodes must have the same tag and content to be equal. Since each tag applies to exactly one kind , this implies that the two nodes must have the same kind to be equal. Two scalars are equal only when their tags and canonical forms are equal character-by-character. Equality of collections is defined recursively. Two sequences are equal only when they have the same tag and length, and each node in one sequence is equal to the corresponding node in the other sequence . Two mappings are equal only when they have the same tag and an equal set of keys , and each key in this set is associated with equal values in both mappings . Different URI schemes may define different rules for testing the equality of URIs. Since a YAML processor cannot be reasonably expected to be aware of them all, it must resort to a simple character-by-character comparison of tags to ensure consistency. This also happens to be the comparison method defined by the “ tag:” URI scheme. Tags in a YAML stream must therefore be presented in a canonical way so that such comparison would yield the correct results. Identity Two nodes are identical only when they represent the same native data structure . Typically, this corresponds to a single memory address. Identity should not be confused with equality; two equal nodes need not have the same identity. A YAML processor may treat equal scalars as if they were identical. In contrast, the separate identity of two distinct but equal collections must be preserved. 3.2.2. Serialization Tree To express a YAML representation using a serial API, it is necessary to impose an order on mapping keys and employ alias nodes to indicate a subsequent occurrence of a previously encountered node . The result of this process is a serialization tree, where each node has an ordered set of children. This tree can be traversed for a serial event-based API. Construction of native data structures from the serial interface should not use key order or anchor names for the preservation of application data. Figure 3.4. Serialization Model 3.2.2.1. Keys Order In the representation model, mapping keys do not have an order. To serialize a mapping , it is necessary to impose an ordering on its keys . This order is a serialization detail and should not be used when composing the representation graph (and hence for the preservation of application data). In every case where node order is significant, a sequence must be used. For example, an ordered mapping can be represented as a sequence of mappings , where each mapping is a single key: value pair . YAML provides convenient compact notation for this case. 3.2.2.2. Anchors and Aliases In the representation graph , a node may appear in more than one collection . When serializing such data, the first occurrence of the node is identified by an anchor. Each subsequent occurrence is serialized as an alias node which refers back to this anchor. Otherwise, anchor names are a serialization detail and are discarded once composing is completed. When composing a representation graph from serialized events, an alias node refers to the most recent node in the serialization having the specified anchor. Therefore, anchors need not be unique within a serialization . In addition, an anchor need not have an alias node referring to it. It is therefore possible to provide an anchor for all nodes in serialization . 3.2.3. Presentation Stream A YAML presentation is a stream of Unicode characters making use of of styles , scalar content formats , comments , directives and other presentation details to present a YAML serialization in a human readable way. Although a YAML processor may provide these details when parsing , they should not be reflected in the resulting serialization . YAML allows several serialization trees to be contained in the same YAML character stream, as a series of documents separated by markers . Documents appearing in the same stream are independent; that is, a node must not appear in more than one serialization tree or representation graph . Figure 3.5. Presentation Model 3.2.3.1. Node Styles Each node is presented in some style, depending on its kind . The node style is a presentation detail and is not reflected in the serialization tree or representation graph . There are two groups of styles. Block styles use indentation to denote structure; In contrast, flow styles styles rely on explicit indicators . YAML provides a rich set of scalar styles. Block scalar styles include the literal style and the folded style . Flow scalar styles include the plain style and two quoted styles, the single-quoted style and the double-quoted style . These styles offer a range of trade-offs between expressive power and readability. Normally, block sequences and mappings begin on the next line. In some cases, YAML also allows nested block collections to start in-line for a more compact notation . In addition, YAML provides a compact notation for flow mappings with a single key: value pair , nested inside a flow sequence . These allow for a natural “ ordered mapping” notation. Figure 3.6. Kind/Style Combinations 3.2.3.2. Scalar Formats YAML allows scalars to be presented in several formats. For example, the integer “ 11” might also be written as “ 0xB”. Tags must specify a mechanism for converting the formatted content to a canonical form for use in equality testing. Like node style , the format is a presentation detail and is not reflected in the serialization tree and representation graph . 3.2.3.3. Comments Comments are a presentation detail and must not have any effect on the serialization tree or representation graph . In particular, comments are not associated with a particular node . The usual purpose of a comment is to communicate between the human maintainers of a file. A typical example is comments in a configuration file. Comments must not appear inside scalars , but may be interleaved with such scalars inside collections . 3.2.3.4. Directives Each document may be associated with a set of directives . A directive has a name and an optional sequence of parameters. Directives are instructions to the YAML processor , and like all other presentation details are not reflected in the YAML serialization tree or representation graph . This version of YAML defines a two directives, “ YAML” and “ TAG” . All other directives are reserved for future versions of YAML. 3.3. Loading Failure Points The process of loading native data structures from a YAML stream has several potential failure points. The character stream may be ill-formed , aliases may be unidentified , unspecified tags may be unresolvable , tags may be unrecognized , the content may be invalid , and a native type may be unavailable . Each of these failures results with an incomplete loading. A partial representation need not resolve the tag of each node , and the canonical form of formatted scalar content need not be available. This weaker representation is useful for cases of incomplete knowledge of the types used in the document . In contrast, a complete representation specifies the tag of each node , and provides the canonical form of formatted scalar content , allowing for equality testing. A complete representation is required in order to construct native data structures . Figure 3.7. Loading Failure Points 3.3.1. Well-Formed Streams and Identified Aliases A well-formed character stream must match the BNF productions specified in the following chapters. Successful loading also requires that each alias shall refer to a previous node identified by the anchor . A YAML processor should reject ill-formed streams and unidentified aliases. A YAML processor may recover from syntax errors, possibly by ignoring certain parts of the input, but it must provide a mechanism for reporting such errors. 3.3.2. Resolved Tags Typically, most tags are not explicitly specified in the character stream . During parsing , nodes lacking an explicit tag are given a non-specific tag: “ !” for non- plain scalars , and “ ?” for all other nodes . Composing a complete representation requires each such non-specific tag to be resolved to a specific tag, be it a global tag or a local tag . Resolving the tag of a node must only depend on the following three parameters: (1) the non-specific tag of the node , (2) the path leading from the root to the node , and (3) the content (and hence the kind ) of the node . When a node has more than one occurrence (using aliases ), tag resolution must depend only on the path to the first ( anchored ) occurrence of the node . Note that resolution must not consider presentation details such as comments , indentation and node style . Also, resolution must not consider the content of any other node , except for the content of the key nodes directly along the path leading from the root to the resolved node . Finally, resolution must not consider the content of a sibling node in a collection , or the content of the value node associated with a key node being resolved. These rules ensure that tag resolution can be performed as soon as a node is first encountered in the stream , typically before its content is parsed . Also, tag resolution only requires referring to a relatively small number of previously parsed nodes . Thus, in most cases, tag resolution in one-pass processors is both possible and practical. YAML processors should resolve nodes having the “ !” non-specific tag as “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map” or “ tag:yaml.org,2002:str” depending on their kind . This tag resolution convention allows the author of a YAML character stream to effectively “ disable” the tag resolution process. By explicitly specifying a “ !” non-specific tag property , the node would then be resolved to a “ vanilla” sequence , mapping , or string, according to its kind . Application specific tag resolution rules should be restricted to resolving the “ ?” non-specific tag, most commonly to resolving plain scalars . These may be matched against a set of regular expressions to provide automatic resolution of integers, floats, timestamps, and similar types. An application may also match the content of mapping nodes against sets of expected keys to automatically resolve points, complex numbers, and similar types. Resolved sequence node types such as the “ ordered mapping” are also possible. That said, tag resolution is specific to the application . YAML processors should therefore provide a mechanism allowing the application to override and expand these default tag resolution rules. If a document contains unresolved tags, the YAML processor is unable to compose a complete representation graph. In such a case, the YAML processor may compose a partial representation , based on each node’s kind and allowing for non-specific tags. 3.3.3. Recognized and Valid Tags To be valid, a node must have a tag which is recognized by the YAML processor and its content must satisfy the constraints imposed by this tag . If a document contains a scalar node with an unrecognized tag or invalid content, only a partial representation may be composed . In contrast, a YAML processor can always compose a complete representation for an unrecognized or an invalid collection , since collection equality does not depend upon knowledge of the collection’s data type. However, such a complete representation cannot be used to construct a native data structure . 3.3.4. Available Tags In a given processing environment, there need not be an available native type corresponding to a given tag . If a node’s tag is unavailable, a YAML processor will not be able to construct a native data structure for it. In this case, a complete representation may still be composed , and an application may wish to use this representation directly. Chapter 4. Syntax Conventions The following chapters formally define the syntax of YAML character streams , using parameterized BNF productions. Each BNF production is both named and numbered for easy reference. Whenever possible, basic structures are specified before the more complex structures using them in a “ bottom up” fashion. The order of alternatives inside a production is significant. Subsequent alternatives are only considered when previous ones fails. See for example the b-break production. In addition, production matching is expected to be greedy. Optional ( ?), zero-or-more ( *) and one-or-more ( +) patterns are always expected to match as much of the input as possible. The productions are accompanied by examples, which are given side-by-side next to equivalent YAML text in an explanatory format. This format uses only flow collections , double-quoted scalars , and explicit tags for each node . A reference implementation using the productions is available as the YamlReference Haskell package. This reference implementation is also available as an interactive web application at http://dev.yaml.org/ypaste . 4.1. Production Parameters YAML’s syntax is designed for maximal human readability. This requires parsing to depend on the surrounding text. For notational compactness, this dependency is expressed using parameterized BNF productions. This context sensitivity is the cause of most of the complexity of the YAML syntax definition. It is further complicated by struggling with the human tendency to look ahead when interpreting text. These complications are of course the source of most of YAML’s power to present data in a very human readable way. Productions use any of the following parameters: Indentation: n or m Many productions use an explicit indentation level parameter. This is less elegant than Python’s “ indent” and “ undent” conceptual tokens. However it is required to formally express YAML’s indentation rules. Context: c This parameter allows productions to tweak their behavior according to their surrounding. YAML supports two groups of contexts, distinguishing between block styles and flow styles . In block styles , indentation is used to delineate structure. To capture human perception of indentation the rules require special treatment of the “ -” character, used in block sequences . Hence in some cases productions need to behave differently inside block sequences ( block-in context) and outside them ( block-out context). In flow styles , explicit indicators are used to delineate structure. These styles can be viewed as the natural extension of JSON to cover tagged , single-quoted and plain scalars . Since the latter have no delineating indicators , they are subject to some restrictions to avoid ambiguities. These restrictions depend on where they appear: as implicit keys directly inside a block mapping ( block-key); as implicit keys inside a flow mapping ( flow-key); as values inside a flow collection ( flow-in); or as values outside one ( flow-out). (Block) Chomping: t Block scalars offer three possible mechanisms for chomping any trailing line breaks : strip , clip and keep . Unlike the previous parameters, this only controls interpretation; the line breaks are valid in all cases. 4.2. Production Naming Conventions To make it easier to follow production combinations, production names use a Hungarian-style naming convention. Each production is given a prefix based on the type of characters it begins and ends with. e- A production matching no characters. c- A production starting and ending with a special character. b- A production matching a single line break . nb- A production starting and ending with a non- break character. s- A production starting and ending with a white space character. ns- A production starting and ending with a non- space character. l- A production matching complete line(s). X - Y - A production starting with an X - character and ending with a Y - character, where X - and Y - are any of the above prefixes. X +, X - Y + A production as above, with the additional property that the matched content indentation level is greater than the specified n parameter. Chapter 5. Characters 5.1. Character Set To ensure readability, YAML streams use only the printable subset of the Unicode character set. The allowed character range explicitly excludes the C0 control block #x0-#x1F (except for TAB #x9, LF #xA, and CR #xD which are allowed), DEL #x7F, the C1 control block #x80-#x9F (except for NEL #x85 which is allowed), the surrogate block #xD800-#xDFFF, #xFFFE, and #xFFFF. On input, a YAML processor must accept all Unicode characters except those explicitly excluded above. On output, a YAML processor must only produce acceptable characters. Any excluded characters must be presented using escape sequences. In addition, any allowed characters known to be non-printable should also be escaped . This isn’t mandatory since a full implementation would require extensive character property tables. [1] c-printable ::= #x9 | #xA | #xD | [#x20-#x7E] /* 8 bit */ | #x85 | [#xA0-#xD7FF] | [#xE000-#xFFFD] /* 16 bit */ | [#x10000-#x10FFFF] /* 32 bit */ To ensure JSON compatibility , YAML processors must allow all non-control characters inside quoted scalars . To ensure readability, non-printable characters should be escaped on output, even inside such scalars . Note that JSON quoted scalars cannot span multiple lines or contain tabs , but YAML quoted scalars can. [2] nb-json ::= #x9 | [#x20-#x10FFFF] 5.2. Character Encodings All characters mentioned in this specification are Unicode code points. Each such code point is written as one or more bytes depending on the character encoding used. Note that in UTF-16, characters above #xFFFF are written as four bytes, using a surrogate pair. The character encoding is a presentation detail and must not be used to convey content information. On input, a YAML processor must support the UTF-8 and UTF-16 character encodings. For JSON compatibility , the UTF-32 encodings must also be supported. If a character stream begins with a byte order mark, the character encoding will be taken to be as as indicated by the byte order mark. Otherwise, the stream must begin with an ASCII character. This allows the encoding to be deduced by the pattern of null ( #x00) characters. To make it easier to concatenate streams , byte order marks may appear at the start of any document . However all documents in the same stream must use the same character encoding. To allow for JSON compatibility , byte order marks are also allowed inside quoted scalars . For readability, such content byte order marks should be escaped on output. The encoding can therefore be deduced by matching the first few bytes of the stream with the following table rows (in order): Byte0 Byte1 Byte2 Byte3 Encoding Explicit BOM #x00 #x00 #xFE #xFF UTF-32BE ASCII first character #x00 #x00 #x00 any UTF-32BE Explicit BOM #xFF #xFE #x00 #x00 UTF-32LE ASCII first character any #x00 #x00 #x00 UTF-32LE Explicit BOM #xFE #xFF UTF-16BE ASCII first character #x00 any UTF-16BE Explicit BOM #xFF #xFE UTF-16LE ASCII first character any #x00 UTF-16LE Explicit BOM #xEF #xBB #xBF UTF-8 Default UTF-8 The recommended output encoding is UTF-8. If another encoding is used, it is recommended that an explicit byte order mark be used, even if the first stream character is ASCII. For more information about the byte order mark and the Unicode character encoding schemes see the Unicode FAQ . [3] c-byte-order-mark ::= #xFEFF In the examples, byte order mark characters are displayed as “ ”. Example 5.1. Byte Order Mark # Comment only. Legend: c-byte-order-mark # This stream contains no # documents, only comments. Example 5.2. Invalid Byte Order Mark - Invalid use of BOM - Inside a document. ERROR: A BOM must not appear inside a document. 5.3. Indicator Characters Indicators are characters that have special semantics. [4] c-sequence-entry ::= “ -” A “ -” ( #x2D, hyphen) denotes a block sequence entry. [5] c-mapping-key ::= “ ?” A “ ?” ( #x3F, question mark) denotes a mapping key . [6] c-mapping-value ::= “ :” A “ :” ( #x3A, colon) denotes a mapping value . Example 5.3. Block Structure Indicators sequence : - one - two mapping : ? sky : blue sea : green Legend: c-sequence-entry c-mapping-key c-mapping-value %YAML 1.2 --- !!map { ? !!str \"sequence\" : !!seq [ !!str \"one\", !!str \"two\" ], ? !!str \"mapping\" : !!map { ? !!str \"sky\" : !!str \"blue\", ? !!str \"sea\" : !!str \"green\", }, } [7] c-collect-entry ::= “ ,” A “ ,” ( #x2C, comma) ends a flow collection entry. [8] c-sequence-start ::= “ [” A “ [” ( #x5B, left bracket) starts a flow sequence . [9] c-sequence-end ::= “ ]” A “ ]” ( #x5D, right bracket) ends a flow sequence . [10] c-mapping-start ::= “ {” A “ {” ( #x7B, left brace) starts a flow mapping . [11] c-mapping-end ::= “ }” A “ }” ( #x7D, right brace) ends a flow mapping . Example 5.4. Flow Collection Indicators sequence: [ one , two , ] mapping: { sky: blue , sea: green } Legend: c-sequence-start c-sequence-end c-mapping-start c-mapping-end c-collect-entry %YAML 1.2 --- !!map { ? !!str \"sequence\" : !!seq [ !!str \"one\", !!str \"two\" ], ? !!str \"mapping\" : !!map { ? !!str \"sky\" : !!str \"blue\", ? !!str \"sea\" : !!str \"green\", }, } [12] c-comment ::= “ #” An “ #” ( #x23, octothorpe, hash, sharp, pound, number sign) denotes a comment . Example 5.5. Comment Indicator # Comment only. Legend: c-comment # This stream contains no # documents, only comments. [13] c-anchor ::= “ &” An “ &” ( #x26, ampersand) denotes a node’s anchor property . [14] c-alias ::= “ *” An “ *” ( #x2A, asterisk) denotes an alias node . [15] c-tag ::= “ !” The “ !” ( #x21, exclamation) is heavily overloaded for specifying node tags . It is used to denote tag handles used in tag directives and tag properties ; to denote local tags ; and as the non-specific tag for non- plain scalars . Example 5.6. Node Property Indicators anchored: !local &anchor value alias: *anchor Legend: c-tag c-anchor c-alias %YAML 1.2 --- !!map { ? !!str \"anchored\" : !local &A1 \"value\", ? !!str \"alias\" : *A1, } [16] c-literal ::= “ |” A “ |” ( 7C, vertical bar) denotes a literal block scalar . [17] c-folded ::= “ >” A “ >” ( #x3E, greater than) denotes a folded block scalar . Example 5.7. Block Scalar Indicators literal: | some text folded: > some text Legend: c-literal c-folded %YAML 1.2 --- !!map { ? !!str \"literal\" : !!str \"some\\ntext\\n\", ? !!str \"folded\" : !!str \"some text\\n\", } [18] c-single-quote ::= “ '” An “ '” ( #x27, apostrophe, single quote) surrounds a single-quoted flow scalar . [19] c-double-quote ::= “ \"” A “ \"” ( #x22, double quote) surrounds a double-quoted flow scalar . Example 5.8. Quoted Scalar Indicators single: 'text ' double: \"text \" Legend: c-single-quote c-double-quote %YAML 1.2 --- !!map { ? !!str \"single\" : !!str \"text\", ? !!str \"double\" : !!str \"text\", } [20] c-directive ::= “ %” A “ %” ( #x25, percent) denotes a directive line. Example 5.9. Directive Indicator %YAML 1.2 --- text Legend: c-directive %YAML 1.2 --- !!str \"text\" [21] c-reserved ::= “ @” | “ `” The “ @” ( #x40, at) and “ `” ( #x60, grave accent) are reserved for future use. Example 5.10. Invalid use of Reserved Indicators commercial-at: @text grave-accent: `text ERROR: Reserved indicators can't start a plain scalar. Any indicator character: [22] c-indicator ::= “ -” | “ ?” | “ :” | “ ,” | “ [” | “ ]” | “ {” | “ }” | “ #” | “ &” | “ *” | “ !” | “ |” | “ >” | “ '” | “ \"” | “ %” | “ @” | “ `” The “ [” , “ ]” , “ {” , “ }” and “ ,” indicators denote structure in flow collections . They are therefore forbidden in some cases, to avoid ambiguity in several constructs. This is handled on a case-by-case basis by the relevant productions. [23] c-flow-indicator ::= “ ,” | “ [” | “ ]” | “ {” | “ }” 5.4. Line Break Characters YAML recognizes the following ASCII line break characters. [24] b-line-feed ::= #xA /* LF */ [25] b-carriage-return ::= #xD /* CR */ [26] b-char ::= b-line-feed | b-carriage-return All other characters, including the form feed ( #x0C), are considered to be non-break characters. Note that these include the non-ASCII line breaks: next line ( #x85), line separator ( #x2028) and paragraph separator ( #x2029). YAML version 1.1 did support the above non-ASCII line break characters; however, JSON does not. Hence, to ensure JSON compatibility , YAML treats them as non-break characters as of version 1.2. In theory this would cause incompatibility with version 1.1 ; in practice these characters were rarely (if ever) used. YAML 1.2 processors parsing a version 1.1 document should therefore treat these line breaks as non-break characters, with an appropriate warning. [27] nb-char ::= c-printable - b-char - c-byte-order-mark Line breaks are interpreted differently by different systems, and have several widely used formats. [28] b-break ::= ( b-carriage-return b-line-feed ) /* DOS, Windows */ | b-carriage-return /* MacOS upto 9.x */ | b-line-feed /* UNIX, MacOS X */ Line breaks inside scalar content must be normalized by the YAML processor . Each such line break must be parsed into a single line feed character. The original line break format is a presentation detail and must not be used to convey content information. [29] b-as-line-feed ::= b-break Outside scalar content , YAML allows any line break to be used to terminate lines. [30] b-non-content ::= b-break On output, a YAML processor is free to emit line breaks using whatever convention is most appropriate. In the examples, line breaks are sometimes displayed using the “ ” glyph for clarity. Example 5.11. Line Break Characters | Line break (no glyph) Line break (glyphed) Legend: b-break %YAML 1.2 --- !!str \"line break (no glyph)\\n\\ line break (glyphed)\\n\" 5.5. White Space Characters YAML recognizes two white space characters: space and tab. [31] s-space ::= #x20 /* SP */ [32] s-tab ::= #x9 /* TAB */ [33] s-white ::= s-space | s-tab The rest of the ( printable ) non- break characters are considered to be non-space characters. [34] ns-char ::= nb-char - s-white In the examples, tab characters are displayed as the glyph “ ”. Space characters are sometimes displayed as the glyph “ ·” for clarity. Example 5.12. Tabs and Spaces # Tabs and spaces quoted: ·\"Quoted \" block: | ··void main() { ·· printf(\"Hello, world!\\n\"); ··} Legend: s-space s-tab %YAML 1.2 --- !!map { ? !!str \"quoted\" : \"Quoted \\t\", ? !!str \"block\" : \"void main() {\\n\\ \\tprintf(\\\"Hello, world!\\\\n\\\");\\n\\ }\\n\", } 5.6. Miscellaneous Characters The YAML syntax productions make use of the following additional character classes: A decimal digit for numbers: [35] ns-dec-digit ::= [#x30-#x39] /* 0-9 */ A hexadecimal digit for escape sequences : [36] ns-hex-digit ::= ns-dec-digit | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */ ASCII letter (alphabetic) characters: [37] ns-ascii-letter ::= [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */ Word (alphanumeric) characters for identifiers: [38] ns-word-char ::= ns-dec-digit | ns-ascii-letter | “ -” URI characters for tags , as specified in RFC2396 , with the addition of the “ [” and “ ]” for presenting IPv6 addresses as proposed in RFC2732 . By convention, any URI characters other than the allowed printable ASCII characters are first encoded in UTF-8, and then each byte is escaped using the “ %” character. The YAML processor must not expand such escaped characters. Tag characters must be preserved and compared exactly as presented in the YAML stream , without any processing. [39] ns-uri-char ::= “ %” ns-hex-digit ns-hex-digit | ns-word-char | “ #” | “ ;” | “ /” | “ ?” | “ :” | “ @” | “ &” | “ =” | “ +” | “ $” | “ ,” | “ _” | “ .” | “ !” | “ ~” | “ *” | “ '” | “ (” | “ )” | “ [” | “ ]” The “ !” character is used to indicate the end of a named tag handle ; hence its use in tag shorthands is restricted. In addition, such shorthands must not contain the “ [” , “ ]” , “ {” , “ }” and “ ,” characters. These characters would cause ambiguity with flow collection structures. [40] ns-tag-char ::= ns-uri-char - “ !” - c-flow-indicator 5.7. Escaped Characters All non- printable characters must be escaped. YAML escape sequences use the “ \\” notation common to most modern computer languages. Each escape sequence must be parsed into the appropriate Unicode character. The original escape sequence is a presentation detail and must not be used to convey content information. Note that escape sequences are only interpreted in double-quoted scalars . In all other scalar styles , the “ \\” character has no special meaning and non- printable characters are not available. [41] c-escape ::= “ \\” YAML escape sequences are a superset of C’s escape sequences: [42] ns-esc-null ::= “ 0” Escaped ASCII null ( #x0) character. [43] ns-esc-bell ::= “ a” Escaped ASCII bell ( #x7) character. [44] ns-esc-backspace ::= “ b” Escaped ASCII backspace ( #x8) character. [45] ns-esc-horizontal-tab ::= “ t” | #x9 Escaped ASCII horizontal tab ( #x9) character. This is useful at the start or the end of a line to force a leading or trailing tab to become part of the content . [46] ns-esc-line-feed ::= “ n” Escaped ASCII line feed ( #xA) character. [47] ns-esc-vertical-tab ::= “ v” Escaped ASCII vertical tab ( #xB) character. [48] ns-esc-form-feed ::= “ f” Escaped ASCII form feed ( #xC) character. [49] ns-esc-carriage-return ::= “ r” Escaped ASCII carriage return ( #xD) character. [50] ns-esc-escape ::= “ e” Escaped ASCII escape ( #x1B) character. [51] ns-esc-space ::= #x20 Escaped ASCII space ( #x20) character. This is useful at the start or the end of a line to force a leading or trailing space to become part of the content . [52] ns-esc-double-quote ::= “ \"” Escaped ASCII double quote ( #x22). [53] ns-esc-slash ::= “ /” Escaped ASCII slash ( #x2F), for JSON compatibility . [54] ns-esc-backslash ::= “ \\” Escaped ASCII back slash ( #x5C). [55] ns-esc-next-line ::= “ N” Escaped Unicode next line ( #x85) character. [56] ns-esc-non-breaking-space ::= “ _” Escaped Unicode non-breaking space ( #xA0) character. [57] ns-esc-line-separator ::= “ L” Escaped Unicode line separator ( #x2028) character. [58] ns-esc-paragraph-separator ::= “ P” Escaped Unicode paragraph separator ( #x2029) character. [59] ns-esc-8-bit ::= “ x” ( ns-hex-digit × 2 ) Escaped 8-bit Unicode character. [60] ns-esc-16-bit ::= “ u” ( ns-hex-digit × 4 ) Escaped 16-bit Unicode character. [61] ns-esc-32-bit ::= “ U” ( ns-hex-digit × 8 ) Escaped 32-bit Unicode character. Any escaped character: [62] c-ns-esc-char ::= “ \\” ( ns-esc-null | ns-esc-bell | ns-esc-backspace | ns-esc-horizontal-tab | ns-esc-line-feed | ns-esc-vertical-tab | ns-esc-form-feed | ns-esc-carriage-return | ns-esc-escape | ns-esc-space | ns-esc-double-quote | ns-esc-slash | ns-esc-backslash | ns-esc-next-line | ns-esc-non-breaking-space | ns-esc-line-separator | ns-esc-paragraph-separator | ns-esc-8-bit | ns-esc-16-bit | ns-esc-32-bit ) Example 5.13. Escaped Characters \"Fun with \\\\ \\\" \\a \\b \\e \\f \\ \\n \\r \\t \\v \\0 \\ \\ \\_ \\N \\L \\P \\ \\x41 \\u0041 \\U00000041\" Legend: c-ns-esc-char %YAML 1.2 --- \"Fun with \\x5C \\x22 \\x07 \\x08 \\x1B \\x0C \\x0A \\x0D \\x09 \\x0B \\x00 \\x20 \\xA0 \\x85 \\u2028 \\u2029 A A A\" Example 5.14. Invalid Escaped Characters Bad escapes: \"\\ c \\x q-\" ERROR: - c is an invalid escaped character. - q and - are invalid hex digits. Chapter 6. Basic Structures 6.1. Indentation Spaces In YAML block styles , structure is determined by indentation. In general, indentation is defined as a zero or more space characters at the start of a line. To maintain portability, tab characters must not be used in indentation, since different systems treat tabs differently. Note that most modern editors may be configured so that pressing the tab key results in the insertion of an appropriate number of spaces . The amount of indentation is a presentation detail and must not be used to convey content information. [63] s-indent(n) ::= s-space × n A block style construct is terminated when encountering a line which is less indented than the construct. The productions use the notation “ s-indent(<n)” and “ s-indent( n)” to express this. [64] s-indent(<n) ::= s-space × m /* Where m < n */ [65] s-indent( n) ::= s-space × m /* Where m n */ Each node must be indented further than its parent node . All sibling nodes must use the exact same indentation level. However the content of each sibling node may be further indented independently. Example 6.1. Indentation Spaces ··# Leading comment line spaces are ···# neither content nor indentation. ···· Not indented: ·By one space: | ····By four ···· ··spaces ·Flow style: [ # Leading spaces ·· ·By two, # in flow style ··Also by two, # are neither ·· Still by two # content nor ·· ··] # indentation. Legend: s-indent(n) Content Neither content nor indentation %YAML 1.2 - - - !!map { ? !!str \"Not indented\" : !!map { ? !!str \"By one space\" : !!str \"By four\\n spaces\\n\", ? !!str \"Flow style\" : !!seq [ !!str \"By two\", !!str \"Also by two\", !!str \"Still by two\", ] } } The “ -” , “ ?” and “ :” characters used to denote block collection entries are perceived by people to be part of the indentation. This is handled on a case-by-case basis by the relevant productions. Example 6.2. Indentation Indicators ?·a : · - b ·· - ·· - c ····· -·d Legend: Total Indentation s-indent(n) Indicator as indentation %YAML 1.2 --- !!map { ? !!str \"a\" : !!seq [ !!str \"b\", !!seq [ !!str \"c\", !!str \"d\" ] ], } 6.2. Separation Spaces Outside indentation and scalar content , YAML uses white space characters for separation between tokens within a line. Note that such white space may safely include tab characters. Separation spaces are a presentation detail and must not be used to convey content information. [66] s-separate-in-line ::= s-white + | /* Start of line */ Example 6.3. Separation Spaces - ·foo: ·bar - - ·baz - baz Legend: s-separate-in-line %YAML 1.2 --- !!seq [ !!map { ? !!str \"foo\" : !!str \"bar\", }, !!seq [ !!str \"baz\", !!str \"baz\" ], ] 6.3. Line Prefixes Inside scalar content , each line begins with a non- content line prefix. This prefix always includes the indentation . For flow scalar styles it additionally includes all leading white space , which may contain tab characters. Line prefixes are a presentation detail and must not be used to convey content information. [67] s-line-prefix(n,c) ::= c = block-out s-block-line-prefix(n) c = block-in s-block-line-prefix(n) c = flow-out s-flow-line-prefix(n) c = flow-in s-flow-line-prefix(n) [68] s-block-line-prefix(n) ::= s-indent(n) [69] s-flow-line-prefix(n) ::= s-indent(n) s-separate-in-line ? Example 6.4. Line Prefixes plain: text ··lines quoted: \"text ·· lines\" block: | ··text ··· lines Legend: s-flow-line-prefix(n) s-block-line-prefix(n) s-indent(n) %YAML 1.2 --- !!map { ? !!str \"plain\" : !!str \"text lines\", ? !!str \"quoted\" : !!str \"text lines\", ? !!str \"block\" : !!str \"text\\n· lines\\n\", } 6.4. Empty Lines An empty line line consists of the non- content prefix followed by a line break . [70] l-empty(n,c) ::= ( s-line-prefix(n,c) | s-indent(<n) ) b-as-line-feed The semantics of empty lines depend on the scalar style they appear in. This is handled on a case-by-case basis by the relevant productions. Example 6.5. Empty Lines Folding: \"Empty line ··· as a line feed\" Chomping: | Clipped empty lines · Legend: l-empty(n,c) %YAML 1.2 --- !!map { ? !!str \"Folding\" : !!str \"Empty line\\nas a line feed\", ? !!str \"Chomping\" : !!str \"Clipped empty lines\\n\", } 6.5. Line Folding Line folding allows long lines to be broken for readability, while retaining the semantics of the original long line. If a line break is followed by an empty line , it is trimmed; the first line break is discarded and the rest are retained as content . [71] b-l-trimmed(n,c) ::= b-non-content l-empty(n,c) + Otherwise (the following line is not empty ), the line break is converted to a single space ( #x20). [72] b-as-space ::= b-break A folded non- empty line may end with either of the above line breaks . [73] b-l-folded(n,c) ::= b-l-trimmed(n,c) | b-as-space Example 6.6. Line Folding >- trimmed ·· · as space %YAML 1.2 --- !!str \"trimmed\\n\\n\\nas space\" Legend: b-l-trimmed(n,c) b-as-space The above rules are common to both the folded block style and the scalar flow styles . Folding does distinguish between these cases in the following way: Block Folding In the folded block style , the final line break and trailing empty lines are subject to chomping , and are never folded. In addition, folding does not apply to line breaks surrounding text lines that contain leading white space . Note that such a more-indented line may consist only of such leading white space . The combined effect of the block line folding rules is that each “ paragraph” is interpreted as a line, empty lines are interpreted as a line feed, and the formatting of more-indented lines is preserved. Example 6.7. Block Folding > ··foo · · ·· ·bar ··baz %YAML 1.2 --- !!str \"foo \\n\\n\\t bar\\n\\nbaz\\n\" Legend: b-l-folded(n,c) Non-content spaces Content spaces Flow Folding Folding in flow styles provides more relaxed semantics. Flow styles typically depend on explicit indicators rather than indentation to convey structure. Hence spaces preceding or following the text in a line are a presentation detail and must not be used to convey content information. Once all such spaces have been discarded, all line breaks are folded, without exception. The combined effect of the flow line folding rules is that each “ paragraph” is interpreted as a line, empty lines are interpreted as line feeds, and text can be freely more-indented without affecting the content information. [74] s-flow-folded(n) ::= s-separate-in-line ? b-l-folded(n,flow-in) s-flow-line-prefix(n) Example 6.8. Flow Folding \" ··foo · · ·· ·bar ··baz \" %YAML 1.2 --- !!str \" foo\\nbar\\nbaz \" Legend: s-flow-folded(n) Non-content spaces 6.6. Comments An explicit comment is marked by a “ #” indicator. Comments are a presentation detail and must not be used to convey content information. Comments must be separated from other tokens by white space characters. To ensure JSON compatibility , YAML processors must allow for the omission of the final comment line break of the input stream . However, as this confuses many tools, YAML processors should terminate the stream with an explicit line break on output. [75] c-nb-comment-text ::= “ #” nb-char * [76] b-comment ::= b-non-content | /* End of file */ [77] s-b-comment ::= ( s-separate-in-line c-nb-comment-text ? )? b-comment Example 6.9. Separated Comment key: ···· # Comment value eof Legend: c-nb-comment-text b-comment s-b-comment %YAML 1.2 --- !!map { ? !!str \"key\" : !!str \"value\", } Outside scalar content , comments may appear on a line of their own, independent of the indentation level. Note that outside scalar content , a line containing only white space characters is taken to be a comment line. [78] l-comment ::= s-separate-in-line c-nb-comment-text ? b-comment Example 6.10. Comment Lines ·· # Comment ··· # This stream contains no # documents, only comments. Legend: s-b-comment l-comment In most cases, when a line may end with a comment, YAML allows it to be followed by additional comment lines. The only exception is a comment ending a block scalar header . [79] s-l-comments ::= ( s-b-comment | /* Start of line */ ) l-comment * Example 6.11. Multi-Line Comments key: ····# Comment ········# lines value %YAML 1.2 --- !!map { ? !!str \"key\" : !!str \"value\", } Legend: s-b-comment l-comment s-l-comments 6.7. Separation Lines Implicit keys are restricted to a single line. In all other cases, YAML allows tokens to be separated by multi-line (possibly empty) comments . Note that structures following multi-line comment separation must be properly indented , even though there is no such restriction on the separation comment lines themselves. [80] s-separate(n,c) ::= c = block-out s-separate-lines(n) c = block-in s-separate-lines(n) c = flow-out s-separate-lines(n) c = flow-in s-separate-lines(n) c = block-key s-separate-in-line c = flow-key s-separate-in-line [81] s-separate-lines(n) ::= ( s-l-comments s-flow-line-prefix(n) ) | s-separate-in-line Example 6.12. Separation Spaces { ·first: ·Sammy, ·last: ·Sosa ·}: # Statistics: ··hr: ··# Home runs ·····65 ··avg: ·# Average ···0.278 Legend: s-separate-in-line s-separate-lines(n) s-indent(n) %YAML 1.2 --- !!map { ? !!map { ? !!str \"first\" : !!str \"Sammy\", ? !!str \"last\" : !!str \"Sosa\", } : !!map { ? !!str \"hr\" : !!int \"65\", ? !!str \"avg\" : !!float \"0.278\", }, } 6.8. Directives Directives are instructions to the YAML processor . This specification defines two directives, “ YAML” and “ TAG” , and reserves all other directives for future use. There is no way to define private directives. This is intentional. Directives are a presentation detail and must not be used to convey content information. [82] l-directive ::= “ %” ( ns-yaml-directive | ns-tag-directive | ns-reserved-directive ) s-l-comments Each directive is specified on a separate non- indented line starting with the “ %” indicator, followed by the directive name and a list of parameters. The semantics of these parameters depends on the specific directive. A YAML processor should ignore unknown directives with an appropriate warning. [83] ns-reserved-directive ::= ns-directive-name ( s-separate-in-line ns-directive-parameter )* [84] ns-directive-name ::= ns-char + [85] ns-directive-parameter ::= ns-char + Example 6.13. Reserved Directives % FOO bar baz # Should be ignored # with a warning. --- \"foo\" %YAML 1.2 --- !!str \"foo\" Legend: ns-reserved-directive ns-directive-name ns-directive-parameter 6.8.1. “ YAML” Directives The “ YAML” directive specifies the version of YAML the document conforms to. This specification defines version “ 1.2”, including recommendations for YAML 1.1 processing. A version 1.2 YAML processor must accept documents with an explicit “ %YAML 1.2” directive, as well as documents lacking a “ YAML” directive. Such documents are assumed to conform to the 1.2 version specification. Documents with a “ YAML” directive specifying a higher minor version (e.g. “ %YAML 1.3”) should be processed with an appropriate warning. Documents with a “ YAML” directive specifying a higher major version (e.g. “ %YAML 2.0”) should be rejected with an appropriate error message. A version 1.2 YAML processor must also accept documents with an explicit “ %YAML 1.1” directive. Note that version 1.2 is mostly a superset of version 1.1, defined for the purpose of ensuring JSON compatibility. Hence a version 1.2 processor should process version 1.1 documents as if they were version 1.2, giving a warning on points of incompatibility (handling of non-ASCII line breaks , as described above ). [86] ns-yaml-directive ::= “ Y” “ A” “ M” “ L” s-separate-in-line ns-yaml-version [87] ns-yaml-version ::= ns-dec-digit + “ .” ns-dec-digit + Example 6.14. “ YAML” directive % YAML 1.3 # Attempt parsing # with a warning --- \"foo\" %YAML 1.2 --- !!str \"foo\" Legend: ns-yaml-directive ns-yaml-version It is an error to specify more than one “ YAML” directive for the same document, even if both occurrences give the same version number. Example 6.15. Invalid Repeated YAML directive %YAML 1.2 % YAML 1.1 foo ERROR: The YAML directive must only be given at most once per document. 6.8.2. “ TAG” Directives The “ TAG” directive establishes a tag shorthand notation for specifying node tags . Each “ TAG” directive associates a handle with a prefix . This allows for compact and readable tag notation. [88] ns-tag-directive ::= “ T” “ A” “ G” s-separate-in-line c-tag-handle s-separate-in-line ns-tag-prefix Example 6.16. “ TAG” directive % TAG !yaml! tag:yaml.org,2002: --- !yaml!str \"foo\" %YAML 1.2 --- !!str \"foo\" Legend: ns-tag-directive c-tag-handle ns-tag-prefix It is an error to specify more than one “ TAG” directive for the same handle in the same document, even if both occurrences give the same prefix . Example 6.17. Invalid Repeated TAG directive %TAG ! !foo %TAG ! !foo bar ERROR: The TAG directive must only be given at most once per handle in the same document. 6.8.2.1. Tag Handles The tag handle exactly matches the prefix of the affected tag shorthand . There are three tag handle variants: [89] c-tag-handle ::= c-named-tag-handle | c-secondary-tag-handle | c-primary-tag-handle Primary Handle The primary tag handle is a single “ !” character. This allows using the most compact possible notation for a single “ primary” name space. By default, the prefix associated with this handle is “ !” . Thus, by default, shorthands using this handle are interpreted as local tags . It is possible to override the default behavior by providing an explicit “ TAG” directive, associating a different prefix for this handle. This provides smooth migration from using local tags to using global tags , by the simple addition of a single “ TAG” directive. [90] c-primary-tag-handle ::= “ !” Example 6.18. Primary Tag Handle # Private !foo \"bar\" ... # Global %TAG ! tag:example.com,2000:app/ --- !foo \"bar\" %YAML 1.2 --- !<!foo> \"bar\" ... --- !<tag:example.com,2000:app/foo> \"bar\" Legend: c-primary-tag-handle Secondary Handle The secondary tag handle is written as “ !!”. This allows using a compact notation for a single “ secondary” name space. By default, the prefix associated with this handle is “ tag:yaml.org,2002:”. This prefix is used by the YAML tag repository . It is possible to override this default behavior by providing an explicit “ TAG” directive associating a different prefix for this handle. [91] c-secondary-tag-handle ::= “ !” “ !” Example 6.19. Secondary Tag Handle %TAG !! tag:example.com,2000:app/ --- !!int 1 - 3 # Interval, not integer Legend: c-secondary-tag-handle %YAML 1.2 --- !<tag:example.com,2000:app/int> \"1 - 3\" Named Handles A named tag handle surrounds a non-empty name with “ !” characters. A handle name must not be used in a tag shorthand unless an explicit “ TAG” directive has associated some prefix with it. The name of the handle is a presentation detail and must not be used to convey content information. In particular, the YAML processor need not preserve the handle name once parsing is completed. [92] c-named-tag-handle ::= “ !” ns-word-char + “ !” Example 6.20. Tag Handles %TAG !e! tag:example.com,2000:app/ --- !e!foo \"bar\" Legend: c-named-tag-handle %YAML 1.2 --- !<tag:example.com,2000:app/foo> \"bar\" 6.8.2.2. Tag Prefixes There are two tag prefix variants: [93] ns-tag-prefix ::= c-ns-local-tag-prefix | ns-global-tag-prefix Local Tag Prefix If the prefix begins with a “ !” character, shorthands using the handle are expanded to a local tag . Note that such a tag is intentionally not a valid URI, and its semantics are specific to the application . In particular, two documents in the same stream may assign different semantics to the same local tag . [94] c-ns-local-tag-prefix ::= “ !” ns-uri-char * Example 6.21. Local Tag Prefix %TAG !m! !my- --- # Bulb here !m!light fluorescent ... %TAG !m! !my- --- # Color here !m!light green Legend: c-ns-local-tag-prefix %YAML 1.2 --- !<!my-light> \"fluorescent\" ... %YAML 1.2 --- !<!my-light> \"green\" Global Tag Prefix If the prefix begins with a character other than “ !” , it must to be a valid URI prefix, and should contain at least the scheme and the authority. Shorthands using the associated handle are expanded to globally unique URI tags, and their semantics is consistent across applications . In particular, every documents in every stream must assign the same semantics to the same global tag . [95] ns-global-tag-prefix ::= ns-tag-char ns-uri-char * Example 6.22. Global Tag Prefix %TAG !e! tag:example.com,2000:app/ --- - !e!foo \"bar\" Legend: ns-global-tag-prefix %YAML 1.2 --- !<tag:example.com,2000:app/foo> \"bar\" 6.9. Node Properties Each node may have two optional properties, anchor and tag , in addition to its content . Node properties may be specified in any order before the node’s content . Either or both may be omitted. [96] c-ns-properties(n,c) ::= ( c-ns-tag-property ( s-separate(n,c) c-ns-anchor-property )? ) | ( c-ns-anchor-property ( s-separate(n,c) c-ns-tag-property )? ) Example 6.23. Node Properties !!str &a1 \"foo\": !!str bar &a2 baz : *a1 Legend: c-ns-properties(n,c) c-ns-anchor-property c-ns-tag-property %YAML 1.2 --- !!map { ? &B1 !!str \"foo\" : !!str \"bar\", ? !!str \"baz\" : *B1, } 6.9.1. Node Tags The tag property identifies the type of the native data structure presented by the node . A tag is denoted by the “ !” indicator. [97] c-ns-tag-property ::= c-verbatim-tag | c-ns-shorthand-tag | c-non-specific-tag Verbatim Tags A tag may be written verbatim by surrounding it with the “ <” and “ >” characters. In this case, the YAML processor must deliver the verbatim tag as-is to the application . In particular, verbatim tags are not subject to tag resolution . A verbatim tag must either begin with a “ !” (a local tag ) or be a valid URI (a global tag ). [98] c-verbatim-tag ::= “ !” “ <” ns-uri-char + “ >” Example 6.24. Verbatim Tags !<tag:yaml.org,2002:str> foo : !<!bar> baz Legend: c-verbatim-tag %YAML 1.2 --- !!map { ? !<tag:yaml.org,2002:str> \"foo\" : !<!bar> \"baz\", } Example 6.25. Invalid Verbatim Tags - !< !> foo - !< $:?> bar ERROR: - Verbatim tags aren't resolved, so ! is invalid. - The $:? tag is neither a global URI tag nor a local tag starting with “ !”. Tag Shorthands A tag shorthand consists of a valid tag handle followed by a non-empty suffix. The tag handle must be associated with a prefix , either by default or by using a “ TAG” directive . The resulting parsed tag is the concatenation of the prefix and the suffix, and must either begin with “ !” (a local tag ) or be a valid URI (a global tag ). The choice of tag handle is a presentation detail and must not be used to convey content information. In particular, the tag handle may be discarded once parsing is completed. The suffix must not contain any “ !” character. This would cause the tag shorthand to be interpreted as having a named tag handle . In addition, the suffix must not contain the “ [” , “ ]” , “ {” , “ }” and “ ,” characters. These characters would cause ambiguity with flow collection structures. If the suffix needs to specify any of the above restricted characters, they must be escaped using the “ %” character. This behavior is consistent with the URI character escaping rules (specifically, section 2.3 of RFC2396 ). [99] c-ns-shorthand-tag ::= c-tag-handle ns-tag-char + Example 6.26. Tag Shorthands %TAG !e! tag:example.com,2000:app/ --- - !local foo - !!str bar - !e!tag%21 baz Legend: c-ns-shorthand-tag %YAML 1.2 --- !!seq [ !<!local> \"foo\", !<tag:yaml.org,2002:str> \"bar\", !<tag:example.com,2000:app/tag!> \"baz\" ] Example 6.27. Invalid Tag Shorthands %TAG !e! tag:example,2000:app/ --- - !e! foo - !h!bar baz ERROR: - The !o! handle has no suffix. - The !h! handle wasn't declared. Non-Specific Tags If a node has no tag property, it is assigned a non-specific tag that needs to be resolved to a specific one. This non-specific tag is “ !” for non- plain scalars and “ ?” for all other nodes . This is the only case where the node style has any effect on the content information. It is possible for the tag property to be explicitly set to the “ !” non-specific tag . By convention , this “ disables” tag resolution , forcing the node to be interpreted as “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map”, or “ tag:yaml.org,2002:str”, according to its kind . There is no way to explicitly specify the “ ?” non-specific tag. This is intentional. [100] c-non-specific-tag ::= “ !” Example 6.28. Non-Specific Tags # Assuming conventional resolution: - \"12\" - 12 - ! 12 Legend: c-non-specific-tag %YAML 1.2 --- !!seq [ !<tag:yaml.org,2002:str> \"12\", !<tag:yaml.org,2002:int> \"12\", !<tag:yaml.org,2002:str> \"12\", ] 6.9.2. Node Anchors An anchor is denoted by the “ &” indicator. It marks a node for future reference. An alias node can then be used to indicate additional inclusions of the anchored node . An anchored node need not be referenced by any alias nodes ; in particular, it is valid for all nodes to be anchored. [101] c-ns-anchor-property ::= “ &” ns-anchor-name Note that as a serialization detail , the anchor name is preserved in the serialization tree . However, it is not reflected in the representation graph and must not be used to convey content information. In particular, the YAML processor need not preserve the anchor name once the representation is composed . Anchor names must not contain the “ [” , “ ]” , “ {” , “ }” and “ ,” characters. These characters would cause ambiguity with flow collection structures. [102] ns-anchor-char ::= ns-char - c-flow-indicator [103] ns-anchor-name ::= ns-anchor-char + Example 6.29. Node Anchors First occurrence: & anchor Value Second occurrence: * anchor Legend: c-ns-anchor-property ns-anchor-name %YAML 1.2 --- !!map { ? !!str \"First occurrence\" : &A !!str \"Value\", ? !!str \"Second occurrence\" : *A, } Chapter 7. Flow Styles YAML’s flow styles can be thought of as the natural extension of JSON to cover folding long content lines for readability, tagging nodes to control construction of native data structures , and using anchors and aliases to reuse constructed object instances. 7.1. Alias Nodes Subsequent occurrences of a previously serialized node are presented as alias nodes. The first occurrence of the node must be marked by an anchor to allow subsequent occurrences to be presented as alias nodes. An alias node is denoted by the “ *” indicator. The alias refers to the most recent preceding node having the same anchor . It is an error for an alias node to use an anchor that does not previously occur in the document . It is not an error to specify an anchor that is not used by any alias node. Note that an alias node must not specify any properties or content , as these were already specified at the first occurrence of the node . [104] c-ns-alias-node ::= “ *” ns-anchor-name Example 7.1. Alias Nodes First occurrence: & anchor Foo Second occurrence: * anchor Override anchor: & anchor Bar Reuse anchor: * anchor Legend: c-ns-alias-node ns-anchor-name %YAML 1.2 --- !!map { ? !!str \"First occurrence\" : &A !!str \"Foo\", ? !!str \"Override anchor\" : &B !!str \"Bar\", ? !!str \"Second occurrence\" : *A, ? !!str \"Reuse anchor\" : *B, } 7.2. Empty Nodes YAML allows the node content to be omitted in many cases. Nodes with empty content are interpreted as if they were plain scalars with an empty value. Such nodes are commonly resolved to a “ null” value. [105] e-scalar ::= /* Empty */ In the examples, empty scalars are sometimes displayed as the glyph “ °” for clarity. Note that this glyph corresponds to a position in the characters stream rather than to an actual character. Example 7.2. Empty Content { foo : !!str °, !!str ° : bar, } Legend: e-scalar %YAML 1.2 --- !!map { ? !!str \"foo\" : !!str \"\", ? !!str \"\" : !!str \"bar\", } Both the node’s properties and node content are optional. This allows for a completely empty node. Completely empty nodes are only valid when following some explicit indication for their existence. [106] e-node ::= e-scalar Example 7.3. Completely Empty Flow Nodes { ? foo : °, °: bar, } Legend: e-node %YAML 1.2 --- !!map { ? !!str \"foo\" : !!null \"\", ? !!null \"\" : !!str \"bar\", } 7.3. Flow Scalar Styles YAML provides three flow scalar styles: double-quoted , single-quoted and plain (unquoted). Each provides a different trade-off between readability and expressive power. The scalar style is a presentation detail and must not be used to convey content information, with the exception that plain scalars are distinguished for the purpose of tag resolution . 7.3.1. Double-Quoted Style The double-quoted style is specified by surrounding “ \"” indicators. This is the only style capable of expressing arbitrary strings, by using “ \\” escape sequences . This comes at the cost of having to escape the “ \\” and “ \"” characters. [107] nb-double-char ::= c-ns-esc-char | ( nb-json - “ \\” - “ \"” ) [108] ns-double-char ::= nb-double-char - s-white Double-quoted scalars are restricted to a single line when contained inside an implicit key . [109] c-double-quoted(n,c) ::= “ \"” nb-double-text(n,c) “ \"” [110] nb-double-text(n,c) ::= c = flow-out nb-double-multi-line(n) c = flow-in nb-double-multi-line(n) c = block-key nb-double-one-line c = flow-key nb-double-one-line [111] nb-double-one-line ::= nb-double-char * Example 7.4. Double Quoted Implicit Keys \" implicit block key\" : [ \" implicit flow key\" : value, ] Legend: nb-double-one-line c-double-quoted(n,c) %YAML 1.2 --- !!map { ? !!str \"implicit block key\" : !!seq [ !!map { ? !!str \"implicit flow key\" : !!str \"value\", } ] } In a multi-line double-quoted scalar, line breaks are are subject to flow line folding , which discards any trailing white space characters. It is also possible to escape the line break character. In this case, the line break is excluded from the content , and the trailing white space characters are preserved. Combined with the ability to escape white space characters, this allows double-quoted lines to be broken at arbitrary positions. [112] s-double-escaped(n) ::= s-white * “ \\” b-non-content l-empty(n,flow-in) * s-flow-line-prefix(n) [113] s-double-break(n) ::= s-double-escaped(n) | s-flow-folded(n) Example 7.5. Double Quoted Line Breaks \"folded · to a space, · to a line feed, or · \\ ·\\· non-content\" %YAML 1.2 --- !!str \"folded to a space,\\n\\ to a line feed, \\ or \\t \\tnon-content\" Legend: s-flow-folded(n) s-double-escaped(n) All leading and trailing white space characters are excluded from the content . Each continuation line must therefore contain at least one non- space character. Empty lines, if any, are consumed as part of the line folding . [114] nb-ns-double-in-line ::= ( s-white * ns-double-char )* [115] s-double-next-line(n) ::= s-double-break(n) ( ns-double-char nb-ns-double-in-line ( s-double-next-line(n) | s-white * ) )? [116] nb-double-multi-line(n) ::= nb-ns-double-in-line ( s-double-next-line(n) | s-white * ) Example 7.6. Double Quoted Lines \" ·1st non-empty · 2nd non-empty · 3rd non-empty·\" %YAML 1.2 --- !!str \" 1st non-empty\\n\\ 2nd non-empty \\ 3rd non-empty \" Legend: nb-ns-double-in-line s-double-next-line(n) 7.3.2. Single-Quoted Style The single-quoted style is specified by surrounding “ '” indicators. Therefore, within a single-quoted scalar, such characters need to be repeated. This is the only form of escaping performed in single-quoted scalars. In particular, the “ \\” and “ \"” characters may be freely used. This restricts single-quoted scalars to printable characters. In addition, it is only possible to break a long single-quoted line where a space character is surrounded by non- spaces . [117] c-quoted-quote ::= “ '” “ '” [118] nb-single-char ::= c-quoted-quote | ( nb-json - “ '” ) [119] ns-single-char ::= nb-single-char - s-white Example 7.7. Single Quoted Characters 'here ''s to \"quotes\"' Legend: c-quoted-quote %YAML 1.2 --- !!str \"here's to \\\"quotes\\\"\" Single-quoted scalars are restricted to a single line when contained inside a implicit key . [120] c-single-quoted(n,c) ::= “ '” nb-single-text(n,c) “ '” [121] nb-single-text(n,c) ::= c = flow-out nb-single-multi-line(n) c = flow-in nb-single-multi-line(n) c = block-key nb-single-one-line c = flow-key nb-single-one-line [122] nb-single-one-line ::= nb-single-char * Example 7.8. Single Quoted Implicit Keys ' implicit block key' : [ ' implicit flow key' : value, ] Legend: nb-single-one-line c-single-quoted(n,c) %YAML 1.2 --- !!map { ? !!str \"implicit block key\" : !!seq [ !!map { ? !!str \"implicit flow key\" : !!str \"value\", } ] } All leading and trailing white space characters are excluded from the content . Each continuation line must therefore contain at least one non- space character. Empty lines, if any, are consumed as part of the line folding . [123] nb-ns-single-in-line ::= ( s-white * ns-single-char )* [124] s-single-next-line(n) ::= s-flow-folded(n) ( ns-single-char nb-ns-single-in-line ( s-single-next-line(n) | s-white * ) )? [125] nb-single-multi-line(n) ::= nb-ns-single-in-line ( s-single-next-line(n) | s-white * ) Example 7.9. Single Quoted Lines ' ·1st non-empty · 2nd non-empty · 3rd non-empty·' %YAML 1.2 --- !!str \" 1st non-empty\\n\\ 2nd non-empty \\ 3rd non-empty \" Legend: nb-ns-single-in-line(n) s-single-next-line(n) 7.3.3. Plain Style The plain (unquoted) style has no identifying indicators and provides no form of escaping. It is therefore the most readable, most limited and most context sensitive style . In addition to a restricted character set, a plain scalar must not be empty, or contain leading or trailing white space characters. It is only possible to break a long plain line where a space character is surrounded by non- spaces . Plain scalars must not begin with most indicators , as this would cause ambiguity with other YAML constructs. However, the “ :” , “ ?” and “ -” indicators may be used as the first character if followed by a non- space “ safe” character, as this causes no ambiguity. [126] ns-plain-first(c) ::= ( ns-char - c-indicator ) | ( ( “ ?” | “ :” | “ -” ) /* Followed by an ns-plain-safe(c) ) */ ) Plain scalars must never contain the “ : ” and “ #” character combinations. Such combinations would cause ambiguity with mapping key: value pairs and comments . In addition, inside flow collections , or when used as implicit keys , plain scalars must not contain the “ [” , “ ]” , “ {” , “ }” and “ ,” characters. These characters would cause ambiguity with flow collection structures. [127] ns-plain-safe(c) ::= c = flow-out ns-plain-safe-out c = flow-in ns-plain-safe-in c = block-key ns-plain-safe-out c = flow-key ns-plain-safe-in [128] ns-plain-safe-out ::= ns-char [129] ns-plain-safe-in ::= ns-char - c-flow-indicator [130] ns-plain-char(c) ::= ( ns-plain-safe(c) - “ :” - “ #” ) | ( /* An ns-char preceding */ “ #” ) | ( “ :” /* Followed by an ns-plain-safe(c) */ ) Example 7.10. Plain Characters # Outside flow collection: - : :vector - \" : - ()\" - Up , up, and away! - -123 - http ://example.com/foo #bar # Inside flow collection: - [ : :vector, \" : - ()\", \"Up , up and away!\", -123, http ://example.com/foo #bar ] %YAML 1.2 --- !!seq [ !!str \"::vector\", !!str \": - ()\", !!str \"Up, up, and away!\", !!int \"-123\", !!str \"http://example.com/foo#bar\", !!seq [ !!str \"::vector\", !!str \": - ()\", !!str \"Up, up, and away!\", !!int \"-123\", !!str \"http://example.com/foo#bar\", ], ] Legend: ns-plain-first(c) Not ns-plain-first(c) ns-plain-char(c) Not ns-plain-char(c) Plain scalars are further restricted to a single line when contained inside an implicit key . [131] ns-plain(n,c) ::= c = flow-out ns-plain-multi-line(n,c) c = flow-in ns-plain-multi-line(n,c) c = block-key ns-plain-one-line(c) c = flow-key ns-plain-one-line(c) [132] nb-ns-plain-in-line(c) ::= ( s-white * ns-plain-char(c) )* [133] ns-plain-one-line(c) ::= ns-plain-first(c) nb-ns-plain-in-line(c) Example 7.11. Plain Implicit Keys implicit block key : [ implicit flow key : value, ] Legend: ns-plain-one-line(c) %YAML 1.2 --- !!map { ? !!str \"implicit block key\" : !!seq [ !!map { ? !!str \"implicit flow key\" : !!str \"value\", } ] } All leading and trailing white space characters are excluded from the content . Each continuation line must therefore contain at least one non- space character. Empty lines, if any, are consumed as part of the line folding . [134] s-ns-plain-next-line(n,c) ::= s-flow-folded(n) ns-plain-char(c) nb-ns-plain-in-line(c) [135] ns-plain-multi-line(n,c) ::= ns-plain-one-line(c) s-ns-plain-next-line(n,c) * Example 7.12. Plain Lines 1st non-empty · 2nd non-empty · 3rd non-empty %YAML 1.2 --- !!str \"1st non-empty\\n\\ 2nd non-empty \\ 3rd non-empty\" Legend: nb-ns-plain-in-line(c) s-ns-plain-next-line(n,c) 7.4. Flow Collection Styles A flow collection may be nested within a block collection ( flow-out context ), nested within another flow collection ( flow-in context ), or be a part of an implicit key ( flow-key context or block-key context ). Flow collection entries are terminated by the “ ,” indicator. The final “ ,” may be omitted. This does not cause ambiguity because flow collection entries can never be completely empty . [136] in-flow(c) ::= c = flow-out flow-in c = flow-in flow-in c = block-key flow-key c = flow-key flow-key 7.4.1. Flow Sequences Flow sequence content is denoted by surrounding “ [” and “ ]” characters. [137] c-flow-sequence(n,c) ::= “ [” s-separate(n,c) ? ns-s-flow-seq-entries(n, in-flow(c) ) ? “ ]” Sequence entries are separated by a “ ,” character. [138] ns-s-flow-seq-entries(n,c) ::= ns-flow-seq-entry(n,c) s-separate(n,c) ? ( “ ,” s-separate(n,c) ? ns-s-flow-seq-entries(n,c) ? )? Example 7.13. Flow Sequence - [ one, two, ] - [ three , four ] Legend: c-sequence-start c-sequence-end ns-flow-seq-entry(n,c) %YAML 1.2 --- !!seq [ !!seq [ !!str \"one\", !!str \"two\", ], !!seq [ !!str \"three\", !!str \"four\", ], ] Any flow node may be used as a flow sequence entry. In addition, YAML provides a compact notation for the case where a flow sequence entry is a mapping with a single key: value pair . [139] ns-flow-seq-entry(n,c) ::= ns-flow-pair(n,c) | ns-flow-node(n,c) Example 7.14. Flow Sequence Entries [ \"double quoted\", 'single quoted', plain text, [ nested ], single: pair, ] Legend: ns-flow-node(n,c) ns-flow-pair(n,c) %YAML 1.2 --- !!seq [ !!str \"double quoted\", !!str \"single quoted\", !!str \"plain text\", !!seq [ !!str \"nested\", ], !!map { ? !!str \"single\" : !!str \"pair\", }, ] 7.4.2. Flow Mappings Flow mappings are denoted by surrounding “ {” and “ }” characters. [140] c-flow-mapping(n,c) ::= “ {” s-separate(n,c) ? ns-s-flow-map-entries(n, in-flow(c) ) ? “ }” Mapping entries are separated by a “ ,” character. [141] ns-s-flow-map-entries(n,c) ::= ns-flow-map-entry(n,c) s-separate(n,c) ? ( “ ,” s-separate(n,c) ? ns-s-flow-map-entries(n,c) ? )? Example 7.15. Flow Mappings - { one : two , three: four , } - { five: six, seven : eight } Legend: c-mapping-start c-mapping-end ns-flow-map-entry(n,c) %YAML 1.2 --- !!seq [ !!map { ? !!str \"one\" : !!str \"two\", ? !!str \"three\" : !!str \"four\", }, !!map { ? !!str \"five\" : !!str \"six\", ? !!str \"seven\" : !!str \"eight\", }, ] If the optional “ ?” mapping key indicator is specified, the rest of the entry may be completely empty . [142] ns-flow-map-entry(n,c) ::= ( “ ?” s-separate(n,c) ns-flow-map-explicit-entry(n,c) ) | ns-flow-map-implicit-entry(n,c) [143] ns-flow-map-explicit-entry(n,c) ::= ns-flow-map-implicit-entry(n,c) | ( e-node /* Key */ e-node /* Value */ ) Example 7.16. Flow Mapping Entries { ? explicit: entry, implicit: entry, ? ° ° } Legend: ns-flow-map-explicit-entry(n,c) ns-flow-map-implicit-entry(n,c) e-node %YAML 1.2 --- !!map { ? !!str \"explicit\" : !!str \"entry\", ? !!str \"implicit\" : !!str \"entry\", ? !!null \"\" : !!null \"\", } Normally, YAML insists the “ :” mapping value indicator be separated from the value by white space . A benefit of this restriction is that the “ :” character can be used inside plain scalars , as long as it is not followed by white space . This allows for unquoted URLs and timestamps. It is also a potential source for confusion as “ a:1” is a plain scalar and not a key: value pair . Note that the value may be completely empty since its existence is indicated by the “ :”. [144] ns-flow-map-implicit-entry(n,c) ::= ns-flow-map-yaml-key-entry(n,c) | c-ns-flow-map-empty-key-entry(n,c) | c-ns-flow-map-json-key-entry(n,c) [145] ns-flow-map-yaml-key-entry(n,c) ::= ns-flow-yaml-node(n,c) ( ( s-separate(n,c) ? c-ns-flow-map-separate-value(n,c) ) | e-node ) [146] c-ns-flow-map-empty-key-entry(n,c) ::= e-node /* Key */ c-ns-flow-map-separate-value(n,c) [147] c-ns-flow-map-separate-value(n,c) ::= “ :” /* Not followed by an ns-plain-safe(c) */ ( ( s-separate(n,c) ns-flow-node(n,c) ) | e-node /* Value */ ) Example 7.17. Flow Mapping Separate Values { unquoted· :·\"separate\", http://foo.com, omitted value : °, ° :·omitted key, } Legend: ns-flow-yaml-node(n,c) e-node c-ns-flow-map-separate-value(n,c) %YAML 1.2 --- !!map { ? !!str \"unquoted\" : !!str \"separate\", ? !!str \"http://foo.com\" : !!null \"\", ? !!str \"omitted value\" : !!null \"\", ? !!null \"\" : !!str \"omitted key\", } To ensure JSON compatibility , if a key inside a flow mapping is JSON-like , YAML allows the following value to be specified adjacent to the “ :”. This causes no ambiguity, as all JSON-like keys are surrounded by indicators . However, as this greatly reduces readability, YAML processors should separate the value from the “ :” on output, even in this case. [148] c-ns-flow-map-json-key-entry(n,c) ::= c-flow-json-node(n,c) ( ( s-separate(n,c) ? c-ns-flow-map-adjacent-value(n,c) ) | e-node ) [149] c-ns-flow-map-adjacent-value(n,c) ::= “ :” ( ( s-separate(n,c) ? ns-flow-node(n,c) ) | e-node ) /* Value */ Example 7.18. Flow Mapping Adjacent Values { \"adjacent\": value, \"readable\": ·value, \"empty\": ° } Legend: c-flow-json-node(n,c) e-node c-ns-flow-map-adjacent-value(n,c) %YAML 1.2 --- !!map { ? !!str \"adjacent\" : !!str \"value\", ? !!str \"readable\" : !!str \"value\", ? !!str \"empty\" : !!null \"\", } A more compact notation is usable inside flow sequences , if the mapping contains a single key: value pair. This notation does not require the surrounding “ {” and “ }” characters. Note that it is not possible to specify any node properties for the mapping in this case. Example 7.19. Single Pair Flow Mappings [ foo: bar ] Legend: ns-flow-pair(n,c) %YAML 1.2 --- !!seq [ !!map { ? !!str \"foo\" : !!str \"bar\" } ] If the “ ?” indicator is explicitly specified, parsing is unambiguous, and the syntax is identical to the general case. [150] ns-flow-pair(n,c) ::= ( “ ?” s-separate(n,c) ns-flow-map-explicit-entry(n,c) ) | ns-flow-pair-entry(n,c) Example 7.20. Single Pair Explicit Entry [ ? foo bar : baz ] Legend: ns-flow-map-explicit-entry(n,c) %YAML 1.2 --- !!seq [ !!map { ? !!str \"foo bar\" : !!str \"baz\", }, ] If the “ ?” indicator is omitted, parsing needs to see past the implicit key to recognize it as such. To limit the amount of lookahead required, the “ :” indicator must appear at most 1024 Unicode characters beyond the start of the key . In addition, the key is restricted to a single line. Note that YAML allows arbitrary nodes to be used as keys . In particular, a key may be a sequence or a mapping . Thus, without the above restrictions, practical one-pass parsing would have been impossible to implement. [151] ns-flow-pair-entry(n,c) ::= ns-flow-pair-yaml-key-entry(n,c) | c-ns-flow-map-empty-key-entry(n,c) | c-ns-flow-pair-json-key-entry(n,c) [152] ns-flow-pair-yaml-key-entry(n,c) ::= ns-s-implicit-yaml-key(flow-key) c-ns-flow-map-separate-value(n,c) [153] c-ns-flow-pair-json-key-entry(n,c) ::= c-s-implicit-json-key(flow-key) c-ns-flow-map-adjacent-value(n,c) [154] ns-s-implicit-yaml-key(c) ::= ns-flow-yaml-node(n/a,c) s-separate-in-line ? /* At most 1024 characters altogether */ [155] c-s-implicit-json-key(c) ::= c-flow-json-node(n/a,c) s-separate-in-line ? /* At most 1024 characters altogether */ Example 7.21. Single Pair Implicit Entries - [ YAML· : separate ] - [ ° : empty key entry ] - [ {JSON: like} :adjacent ] Legend: ns-s-implicit-yaml-key c-s-implicit-json-key e-node Value %YAML 1.2 --- !!seq [ !!seq [ !!map { ? !!str \"YAML\" : !!str \"separate\" }, ], !!seq [ !!map { ? !!null \"\" : !!str \"empty key entry\" }, ], !!seq [ !!map { ? !!map { ? !!str \"JSON\" : !!str \"like\" } : \"adjacent\", }, ], ] Example 7.22. Invalid Implicit Keys [ foo bar: invalid, \"foo ...>1K characters...bar\": invalid ] ERROR: - The foo bar key spans multiple lines - The foo...bar key is too long 7.5. Flow Nodes JSON-like flow styles all have explicit start and end indicators . The only flow style that does not have this property is the plain scalar . Note that none of the “ JSON-like” styles is actually acceptable by JSON. Even the double-quoted style is a superset of the JSON string format. [156] ns-flow-yaml-content(n,c) ::= ns-plain(n,c) [157] c-flow-json-content(n,c) ::= c-flow-sequence(n,c) | c-flow-mapping(n,c) | c-single-quoted(n,c) | c-double-quoted(n,c) [158] ns-flow-content(n,c) ::= ns-flow-yaml-content(n,c) | c-flow-json-content(n,c) Example 7.23. Flow Content - [ a, b ] - { a: b } - \"a\" - 'b' - c Legend: c-flow-json-content(n,c) ns-flow-yaml-content(n,c) %YAML 1.2 --- !!seq [ !!seq [ !!str \"a\", !!str \"b\" ], !!map { ? !!str \"a\" : !!str \"b\" }, !!str \"a\", !!str \"b\", !!str \"c\", ] A complete flow node also has optional node properties , except for alias nodes which refer to the anchored node properties . [159] ns-flow-yaml-node(n,c) ::= c-ns-alias-node | ns-flow-yaml-content(n,c) | ( c-ns-properties(n,c) ( ( s-separate(n,c) ns-flow-yaml-content(n,c) ) | e-scalar ) ) [160] c-flow-json-node(n,c) ::= ( c-ns-properties(n,c) s-separate(n,c) )? c-flow-json-content(n,c) [161] ns-flow-node(n,c) ::= c-ns-alias-node | ns-flow-content(n,c) | ( c-ns-properties(n,c) ( ( s-separate(n,c) ns-flow-content(n,c) ) | e-scalar ) ) Example 7.24. Flow Nodes - !!str \"a\" - 'b' - &anchor \"c\" - *anchor - !!str° Legend: c-flow-json-node(n,c) ns-flow-yaml-node(n,c) %YAML 1.2 --- !!seq [ !!str \"a\", !!str \"b\", &A !!str \"c\", *A, !!str \"\", ] Chapter 8. Block Styles YAML’s block styles employ indentation rather than indicators to denote structure. This results in a more human readable (though less compact) notation. 8.1. Block Scalar Styles YAML provides two block scalar styles, literal and folded . Each provides a different trade-off between readability and expressive power. 8.1.1. Block Scalar Headers Block scalars are controlled by a few indicators given in a header preceding the content itself. This header is followed by a non-content line break with an optional comment . This is the only case where a comment must not be followed by additional comment lines. [162] c-b-block-header(m,t) ::= ( ( c-indentation-indicator(m) c-chomping-indicator(t) ) | ( c-chomping-indicator(t) c-indentation-indicator(m) ) ) s-b-comment Example 8.1. Block Scalar Header - | # Empty header literal - > 1 # Indentation indicator ·folded - |+ # Chomping indicator keep - > 1- # Both indicators ·strip %YAML 1.2 --- !!seq [ !!str \"literal\\n\", !!str \"·folded\\n\", !!str \"keep\\n\\n\", !!str \"·strip\", ] Legend: c-b-block-header(m,t) 8.1.1.1. Block Indentation Indicator Typically, the indentation level of a block scalar is detected from its first non- empty line. It is an error for any of the leading empty lines to contain more spaces than the first non- empty line . Detection fails when the first non- empty line contains leading content space characters. Content may safely start with a tab or a “ #” character. When detection would fail, YAML requires that the indentation level for the content be given using an explicit indentation indicator. This level is specified as the integer number of the additional indentation spaces used for the content , relative to its parent node . It is always valid to specify an indentation indicator for a block scalar node, though a YAML processor should only emit an explicit indentation indicator for cases where detection will fail. [163] c-indentation-indicator(m) ::= ns-dec-digit m = ns-dec-digit - #x30 /* Empty */ m = auto-detect() Example 8.2. Block Indentation Indicator - |° ·detected - > ° · ·· ··# detected - |1 ··explicit - > ° · ·detected %YAML 1.2 --- !!seq [ !!str \"detected\\n\", !!str \"\\n\\n# detected\\n\", !!str \"·explicit\\n\", !!str \"\\t·detected\\n\", ] Legend: c-indentation-indicator(m) s-indent(n) Example 8.3. Invalid Block Scalar Indentation Indicators - |· · ·text - > ··text ·text - |2 ·text ERROR: - A leading all-space line must not have too many spaces. - A following text line must not be less indented. - The text is less indented than the indicated level. 8.1.1.2. Block Chomping Indicator Chomping controls how final line breaks and trailing empty lines are interpreted. YAML provides three chomping methods: Strip Stripping is specified by the “ -” chomping indicator. In this case, the final line break and any trailing empty lines are excluded from the scalar’s content . Clip Clipping is the default behavior used if no explicit chomping indicator is specified. In this case, the final line break character is preserved in the scalar’s content . However, any trailing empty lines are excluded from the scalar’s content . Keep Keeping is specified by the “ +” chomping indicator. In this case, the final line break and any trailing empty lines are considered to be part of the scalar’s content . These additional lines are not subject to folding . The chomping method used is a presentation detail and must not be used to convey content information. [164] c-chomping-indicator(t) ::= “ -” t = strip “ +” t = keep /* Empty */ t = clip The interpretation of the final line break of a block scalar is controlled by the chomping indicator specified in the block scalar header . [165] b-chomped-last(t) ::= t = strip b-non-content | /* End of file */ t = clip b-as-line-feed | /* End of file */ t = keep b-as-line-feed | /* End of file */ Example 8.4. Chomping Final Line Break strip: |- text clip: | text keep: |+ text Legend: b-non-content b-as-line-feed %YAML 1.2 --- !!map { ? !!str \"strip\" : !!str \"text\", ? !!str \"clip\" : !!str \"text\\n\", ? !!str \"keep\" : !!str \"text\\n\", } The interpretation of the trailing empty lines following a block scalar is also controlled by the chomping indicator specified in the block scalar header . [166] l-chomped-empty(n,t) ::= t = strip l-strip-empty(n) t = clip l-strip-empty(n) t = keep l-keep-empty(n) [167] l-strip-empty(n) ::= ( s-indent( n) b-non-content )* l-trail-comments(n) ? [168] l-keep-empty(n) ::= l-empty(n,block-in) * l-trail-comments(n) ? Explicit comment lines may follow the trailing empty lines . To prevent ambiguity, the first such comment line must be less indented than the block scalar content . Additional comment lines, if any, are not so restricted. This is the only case where the indentation of comment lines is constrained. [169] l-trail-comments(n) ::= s-indent(<n) c-nb-comment-text b-comment l-comment * Example 8.5. Chomping Trailing Lines # Strip # Comments: strip: |- # text ·· ·# Clip ··# comments: clip: | # text · ·# Keep ··# comments: keep: |+ # text ·# Trail ··# comments. %YAML 1.2 --- !!map { ? !!str \"strip\" : !!str \"# text\", ? !!str \"clip\" : !!str \"# text\\n\", ? !!str \"keep\" : !!str \"# text\\n\", } Legend: l-strip-empty(n) l-keep-empty(n) l-trail-comments(n) If a block scalar consists only of empty lines , then these lines are considered as trailing lines and hence are affected by chomping. Example 8.6. Empty Scalar Chomping strip: >- clip: > keep: |+ Legend: l-strip-empty(n) l-keep-empty(n) %YAML 1.2 --- !!map { ? !!str \"strip\" : !!str \"\", ? !!str \"clip\" : !!str \"\", ? !!str \"keep\" : !!str \"\\n\", } 8.1.2. Literal Style The literal style is denoted by the “ |” indicator. It is the simplest, most restricted, and most readable scalar style . [170] c-l+literal(n) ::= “ |” c-b-block-header(m,t) l-literal-content(n+m,t) Example 8.7. Literal Scalar | ·literal · text Legend: c-l+literal(n) %YAML 1.2 --- !!str \"literal\\n\\ttext\\n\" Inside literal scalars, all ( indented ) characters are considered to be content , including white space characters. Note that all line break characters are normalized . In addition, empty lines are not folded , though final line breaks and trailing empty lines are chomped . There is no way to escape characters inside literal scalars. This restricts them to printable characters. In addition, there is no way to break a long literal line. [171] l-nb-literal-text(n) ::= l-empty(n,block-in) * s-indent(n) nb-char + [172] b-nb-literal-next(n) ::= b-as-line-feed l-nb-literal-text(n) [173] l-literal-content(n,t) ::= ( l-nb-literal-text(n) b-nb-literal-next(n) * b-chomped-last(t) )? l-chomped-empty(n,t) Example 8.8. Literal Content |· ·· ··literal ··· ·· ··text ·# Comment %YAML 1.2 --- !!str \"\\n\\nliteral\\n·\\n\\ntext\\n\" Legend: l-nb-literal-text(n) b-nb-literal-next(n) b-chomped-last(t) l-chomped-empty(n,t) 8.1.3. Folded Style The folded style is denoted by the “ >” indicator. It is similar to the literal style ; however, folded scalars are subject to line folding . [174] c-l+folded(n) ::= “ >” c-b-block-header(m,t) l-folded-content(n+m,t) Example 8.9. Folded Scalar > ·folded ·text %YAML 1.2 --- !!str \"folded text\\n\" Legend: c-l+folded(n) Folding allows long lines to be broken anywhere a single space character separates two non- space characters. [175] s-nb-folded-text(n) ::= s-indent(n) ns-char nb-char * [176] l-nb-folded-lines(n) ::= s-nb-folded-text(n) ( b-l-folded(n,block-in) s-nb-folded-text(n) )* Example 8.10. Folded Lines > ·folded ·line ·next ·line * bullet * list * lines ·last ·line # Comment %YAML 1.2 --- !!str \"\\n\\ folded line\\n\\ next line\\n\\ \\ * bullet\\n \\n\\ \\ * list\\n\\ \\ * lines\\n\\ \\n\\ last line\\n\" Legend: s-nb-folded-text(n) l-nb-folded-lines(n) (The following three examples duplicate this example, each highlighting different productions.) Lines starting with white space characters ( more-indented lines) are not folded . [177] s-nb-spaced-text(n) ::= s-indent(n) s-white nb-char * [178] b-l-spaced(n) ::= b-as-line-feed l-empty(n,block-in) * [179] l-nb-spaced-lines(n) ::= s-nb-spaced-text(n) ( b-l-spaced(n) s-nb-spaced-text(n) )* Example 8.11. More Indented Lines > folded line next line ···* bullet ···* list ···* lines last line # Comment %YAML 1.2 --- !!str \"\\n\\ folded line\\n\\ next line\\n\\ \\ * bullet\\n \\n\\ \\ * list\\n\\ \\ * lines\\n\\ \\n\\ last line\\n\" Legend: s-nb-spaced-text(n) l-nb-spaced-lines(n) Line breaks and empty lines separating folded and more-indented lines are also not folded . [180] l-nb-same-lines(n) ::= l-empty(n,block-in) * ( l-nb-folded-lines(n) | l-nb-spaced-lines(n) ) [181] l-nb-diff-lines(n) ::= l-nb-same-lines(n) ( b-as-line-feed l-nb-same-lines(n) )* Example 8.12. Empty Separation Lines > folded line next line * bullet * list * line last line # Comment %YAML 1.2 --- !!str \"\\n\\ folded line\\n\\ next line\\n\\ \\ * bullet\\n \\n\\ \\ * list\\n\\ \\ * lines\\n\\ \\n\\ last line\\n\" Legend: b-as-line-feed (separation) l-empty(n,c) The final line break , and trailing empty lines if any, are subject to chomping and are never folded . [182] l-folded-content(n,t) ::= ( l-nb-diff-lines(n) b-chomped-last(t) )? l-chomped-empty(n,t) Example 8.13. Final Empty Lines > folded line next line * bullet * list * line last line # Comment %YAML 1.2 --- !!str \"\\n\\ folded line\\n\\ next line\\n\\ \\ * bullet\\n \\n\\ \\ * list\\n\\ \\ * lines\\n\\ \\n\\ last line\\n\" Legend: b-chomped-last(t) l-chomped-empty(n,t) 8.2. Block Collection Styles For readability, block collections styles are not denoted by any indicator . Instead, YAML uses a lookahead method, where a block collection is distinguished from a plain scalar only when a key: value pair or a sequence entry is seen. 8.2.1. Block Sequences A block sequence is simply a series of nodes , each denoted by a leading “ -” indicator. The “ -” indicator must be separated from the node by white space . This allows “ -” to be used as the first character in a plain scalar if followed by a non-space character (e.g. “ -1”). [183] l+block-sequence(n) ::= ( s-indent(n+m) c-l-block-seq-entry(n+m) )+ /* For some fixed auto-detected m > 0 */ [184] c-l-block-seq-entry(n) ::= “ -” /* Not followed by an ns-char */ s-l+block-indented(n,block-in) Example 8.14. Block Sequence block sequence: ·· - one - two : three Legend: c-l-block-seq-entry(n) auto-detected s-indent(n) %YAML 1.2 --- !!map { ? !!str \"block sequence\" : !!seq [ !!str \"one\", !!map { ? !!str \"two\" : !!str \"three\" }, ], } The entry node may be either completely empty , be a nested block node , or use a compact in-line notation. The compact notation may be used when the entry is itself a nested block collection . In this case, both the “ -” indicator and the following spaces are considered to be part of the indentation of the nested collection . Note that it is not possible to specify node properties for such a collection . [185] s-l+block-indented(n,c) ::= ( s-indent(m) ( ns-l-compact-sequence(n+1+m) | ns-l-compact-mapping(n+1+m) ) ) | s-l+block-node(n,c) | ( e-node s-l-comments ) [186] ns-l-compact-sequence(n) ::= c-l-block-seq-entry(n) ( s-indent(n) c-l-block-seq-entry(n) )* Example 8.15. Block Sequence Entry Types - ° # Empty - | block node - ·- one # Compact ··- two # sequence - one: two # Compact mapping Legend: Empty s-l+block-node(n,c) ns-l-compact-sequence(n) ns-l-compact-mapping(n) %YAML 1.2 --- !!seq [ !!null \"\", !!str \"block node\\n\", !!seq [ !!str \"one\" !!str \"two\", ], !!map { ? !!str \"one\" : !!str \"two\", }, ] 8.2.2. Block Mappings A Block mapping is a series of entries, each presenting a key: value pair . [187] l+block-mapping(n) ::= ( s-indent(n+m) ns-l-block-map-entry(n+m) )+ /* For some fixed auto-detected m > 0 */ Example 8.16. Block Mappings block mapping: · key: value Legend: ns-l-block-map-entry(n) auto-detected s-indent(n) %YAML 1.2 --- !!map { ? !!str \"block mapping\" : !!map { ? !!str \"key\" : !!str \"value\", }, } If the “ ?” indicator is specified, the optional value node must be specified on a separate line, denoted by the “ :” indicator. Note that YAML allows here the same compact in-line notation described above for block sequence entries. [188] ns-l-block-map-entry(n) ::= c-l-block-map-explicit-entry(n) | ns-l-block-map-implicit-entry(n) [189] c-l-block-map-explicit-entry(n) ::= c-l-block-map-explicit-key(n) ( l-block-map-explicit-value(n) | e-node ) [190] c-l-block-map-explicit-key(n) ::= “ ?” s-l+block-indented(n,block-out) [191] l-block-map-explicit-value(n) ::= s-indent(n) “ :” s-l+block-indented(n,block-out) Example 8.17. Explicit Block Mapping Entries ? explicit key # Empty value ° ? | block key :·- one # Explicit compact ··- two # block value Legend: c-l-block-map-explicit-key(n) l-block-map-explicit-value(n) e-node %YAML 1.2 --- !!map { ? !!str \"explicit key\" : !!str \"\", ? !!str \"block key\\n\" : !!seq [ !!str \"one\", !!str \"two\", ], } If the “ ?” indicator is omitted, parsing needs to see past the implicit key , in the same way as in the single key: value pair flow mapping . Hence, such keys are subject to the same restrictions; they are limited to a single line and must not span more than 1024 Unicode characters. [192] ns-l-block-map-implicit-entry(n) ::= ( ns-s-block-map-implicit-key | e-node ) c-l-block-map-implicit-value(n) [193] ns-s-block-map-implicit-key ::= c-s-implicit-json-key(block-key) | ns-s-implicit-yaml-key(block-key) In this case, the value may be specified on the same line as the implicit key . Note however that in block mappings the value must never be adjacent to the “ :”, as this greatly reduces readability and is not required for JSON compatibility (unlike the case in flow mappings ). There is no compact notation for in-line values . Also, while both the implicit key and the value following it may be empty, the “ :” indicator is mandatory. This prevents a potential ambiguity with multi-line plain scalars . [194] c-l-block-map-implicit-value(n) ::= “ :” ( s-l+block-node(n,block-out) | ( e-node s-l-comments ) ) Example 8.18. Implicit Block Mapping Entries plain key : in-line value ° :° # Both empty \"quoted key\" : - entry Legend: ns-s-block-map-implicit-key c-l-block-map-implicit-value(n) %YAML 1.2 --- !!map { ? !!str \"plain key\" : !!str \"in-line value\", ? !!null \"\" : !!null \"\", ? !!str \"quoted key\" : !!seq [ !!str \"entry\" ], } A compact in-line notation is also available. This compact notation may be nested inside block sequences and explicit block mapping entries. Note that it is not possible to specify node properties for such a nested mapping. [195] ns-l-compact-mapping(n) ::= ns-l-block-map-entry(n) ( s-indent(n) ns-l-block-map-entry(n) )* Example 8.19. Compact Block Mappings - sun: yellow - ? earth: blue : moon: white Legend: ns-l-compact-mapping(n) %YAML 1.2 --- !!seq [ !!map { !!str \"sun\" : !!str \"yellow\", }, !!map { ? !!map { ? !!str \"earth\" : !!str \"blue\" }, : !!map { ? !!str \"moon\" : !!str \"white\" }, } ] 8.2.3. Block Nodes YAML allows flow nodes to be embedded inside block collections (but not vice-versa). Flow nodes must be indented by at least one more space than the parent block collection . Note that flow nodes may begin on a following line. It is at this point that parsing needs to distinguish between a plain scalar and an implicit key starting a nested block mapping . [196] s-l+block-node(n,c) ::= s-l+block-in-block(n,c) | s-l+flow-in-block(n) [197] s-l+flow-in-block(n) ::= s-separate(n+1,flow-out) ns-flow-node(n+1,flow-out) s-l-comments Example 8.20. Block Node Types - ··\"flow in block\" -· > Block scalar -· !!map # Block collection foo : bar Legend: s-l+flow-in-block(n) s-l+block-in-block(n,c) %YAML 1.2 --- !!seq [ !!str \"flow in block\", !!str \"Block scalar\\n\", !!map { ? !!str \"foo\" : !!str \"bar\", }, ] The block node’s properties may span across several lines. In this case, they must be indented by at least one more space than the block collection , regardless of the indentation of the block collection entries. [198] s-l+block-in-block(n,c) ::= s-l+block-scalar(n,c) | s-l+block-collection(n,c) [199] s-l+block-scalar(n,c) ::= s-separate(n+1,c) ( c-ns-properties(n+1,c) s-separate(n+1,c) )? ( c-l+literal(n) | c-l+folded(n) ) Example 8.21. Block Scalar Nodes literal: |2 ··value folded: ···!foo ··>1 ·value Legend: c-l+literal(n) c-l+folded(n) %YAML 1.2 --- !!map { ? !!str \"literal\" : !!str \"value\", ? !!str \"folded\" : !<!foo> \"value\", } Since people perceive the “ -” indicator as indentation , nested block sequences may be indented by one less space to compensate, except, of course, if nested inside another block sequence ( block-out context vs. block-in context ). [200] s-l+block-collection(n,c) ::= ( s-separate(n+1,c) c-ns-properties(n+1,c) )? s-l-comments ( l+block-sequence( seq-spaces(n,c) ) | l+block-mapping(n) ) [201] seq-spaces(n,c) ::= c = block-out n-1 c = block-in n Example 8.22. Block Collection Nodes sequence: !!seq - entry - !!seq - nested mapping: !!map foo: bar Legend: l+block-sequence(n) l+block-mapping(n) s-l+block-collection(n,c) %YAML 1.2 --- !!map { ? !!str \"sequence\" : !!seq [ !!str \"entry\", !!seq [ !!str \"nested\" ], ], ? !!str \"mapping\" : !!map { ? !!str \"foo\" : !!str \"bar\", }, } Chapter 9. YAML Character Stream 9.1. Documents A YAML character stream may contain several documents. Each document is completely independent from the rest. 9.1.1. Document Prefix A document may be preceded by a prefix specifying the character encoding , and optional comment lines. Note that all documents in a stream must use the same character encoding . However it is valid to re-specify the encoding using a byte order mark for each document in the stream. This makes it easier to concatenate streams. The existence of the optional prefix does not necessarily indicate the existence of an actual document . [202] l-document-prefix ::= c-byte-order-mark ? l-comment * Example 9.1. Document Prefix # Comment # lines Document Legend: l-document-prefix %YAML 1.2 --- !!str \"Document\" 9.1.2. Document Markers Using directives creates a potential ambiguity. It is valid to have a “ %” character at the start of a line (e.g. as the first character of the second line of a plain scalar ). How, then, to distinguish between an actual directive and a content line that happens to start with a “ %” character? The solution is the use of two special marker lines to control the processing of directives , one at the start of a document and one at the end. At the start of a document , lines beginning with a “ %” character are assumed to be directives . The (possibly empty) list of directives is terminated by a directives end marker line. Lines following this marker can safely use “ %” as the first character. At the end of a document , a document end marker line is used to signal the parser to begin scanning for directives again. The existence of this optional document suffix does not necessarily indicate the existence of an actual following document . Obviously, the actual content lines are therefore forbidden to begin with either of these markers. [203] c-directives-end ::= “ -” “ -” “ -” [204] c-document-end ::= “ .” “ .” “ .” [205] l-document-suffix ::= c-document-end s-l-comments [206] c-forbidden ::= /* Start of line */ ( c-directives-end | c-document-end ) ( b-char | s-white | /* End of file */ ) Example 9.2. Document Markers %YAML 1.2 --- Document ... # Suffix %YAML 1.2 --- !!str \"Document\" Legend: c-directives-end c-document-end l-document-suffix 9.1.3. Bare Documents A bare document does not begin with any directives or marker lines. Such documents are very “ clean” as they contain nothing other than the content . In this case, the first non-comment line may not start with a “ %” first character. Document nodes are indented as if they have a parent indented at -1 spaces . Since a node must be more indented than its parent node , this allows the document’s node to be indented at zero or more spaces . [207] l-bare-document ::= s-l+block-node(-1,block-in) /* Excluding c-forbidden content */ Example 9.3. Bare Documents Bare document ... # No document ... | %!PS-Adobe-2.0 # Not the first line %YAML 1.2 --- !!str \"Bare document\" %YAML 1.2 --- !!str \"%!PS-Adobe-2.0\\n\" Legend: l-bare-document 9.1.4. Explicit Documents An explicit document begins with an explicit directives end marker line but no directives . Since the existence of the document is indicated by this marker , the document itself may be completely empty . [208] l-explicit-document ::= c-directives-end ( l-bare-document | ( e-node s-l-comments ) ) Example 9.4. Explicit Documents --- { matches % : 20 } ... --- # Empty ... Legend: l-explicit-document %YAML 1.2 --- !!map { !!str \"matches %\": !!int \"20\" } ... %YAML 1.2 --- !!null \"\" 9.1.5. Directives Documents A directives document begins with some directives followed by an explicit directives end marker line. [209] l-directive-document ::= l-directive + l-explicit-document Example 9.5. Directives Documents %YAML 1.2 --- | %!PS-Adobe-2.0 ... %YAML1.2 --- # Empty ... Legend: l-explicit-document %YAML 1.2 --- !!str \"%!PS-Adobe-2.0\\n\" ... %YAML 1.2 --- !!null \"\" 9.2. Streams A YAML stream consists of zero or more documents . Subsequent documents require some sort of separation marker line. If a document is not terminated by a document end marker line, then the following document must begin with a directives end marker line. The stream format is intentionally “ sloppy” to better support common use cases, such as stream concatenation. [210] l-any-document ::= l-directive-document | l-explicit-document | l-bare-document [211] l-yaml-stream ::= l-document-prefix * l-any-document ? ( l-document-suffix + l-document-prefix * l-any-document ? | l-document-prefix * l-explicit-document ? )* Example 9.6. Stream Document --- # Empty ... %YAML 1.2 --- matches %: 20 Legend: l-any-document l-document-suffix l-explicit-document %YAML 1.2 --- !!str \"Document\" ... %YAML 1.2 --- !!null \"\" ... %YAML 1.2 --- !!map { !!str \"matches %\": !!int \"20\" } A sequence of bytes is a well-formed stream if, taken as a whole, it complies with the above l-yaml-stream production. Some common use case that can take advantage of the YAML stream structure are: Appending to Streams Allowing multiple documents in a single stream makes YAML suitable for log files and similar applications . Note that each document is independent of the rest, allowing for heterogeneous log file entries. Concatenating Streams Concatenating two YAML streams requires both to use the same character encoding . In addition, it is necessary to separate the last document of the first stream and the first document of the second stream. This is easily ensured by inserting a document end marker between the two streams. Note that this is safe regardless of the content of either stream. In particular, either or both may be empty, and the first stream may or may not already contain such a marker. Communication Streams The document end marker allows signaling the end of a document without closing the stream or starting the next document . This allows the receiver to complete processing a document without having to wait for the next one to arrive. The sender may also transmit \"keep-alive\" messages in the form of comment lines or repeated document end markers without signalling the start of the next document . Chapter 10. Recommended Schemas A YAML schema is a combination of a set of tags and a mechanism for resolving non-specific tags . 10.1. Failsafe Schema The failsafe schema is guaranteed to work with any YAML document . It is therefore the recommended schema for generic YAML tools. A YAML processor should therefore support this schema , at least as an option. 10.1.1. Tags 10.1.1.1. Generic Mapping URI: tag:yaml.org,2002:map Kind: Mapping . Definition: Represents an associative container, where each key is unique in the association and mapped to exactly one value . YAML places no restrictions on the type of keys ; in particular, they are not restricted to being scalars . Example bindings to native types include Perl’s hash, Python’s dictionary, and Java’s Hashtable. Example 10.1. !!map Examples Block style: !!map Clark : Evans Ingy : döt Net Oren : Ben-Kiki Flow style: !!map { Clark: Evans, Ingy: döt Net, Oren: Ben-Kiki } 10.1.1.2. Generic Sequence URI: tag:yaml.org,2002:seq Kind: Sequence . Definition: Represents a collection indexed by sequential integers starting with zero. Example bindings to native types include Perl’s array, Python’s list or tuple, and Java’s array or Vector. Example 10.2. !!seq Examples Block style: !!seq - Clark Evans - Ingy döt Net - Oren Ben-Kiki Flow style: !!seq [ Clark Evans, Ingy döt Net, Oren Ben-Kiki ] 10.1.1.3. Generic String URI: tag:yaml.org,2002:str Kind: Scalar . Definition: Represents a Unicode string, a sequence of zero or more Unicode characters. This type is usually bound to the native language’s string type, or, for languages lacking one (such as C), to a character array. Canonical Form: The obvious. Example 10.3. !!str Examples Block style: !!str |- String: just a theory. Flow style: !!str \"String: just a theory.\" 10.1.2. Tag Resolution All nodes with the “ !” non-specific tag are resolved , by the standard convention , to “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map”, or “ tag:yaml.org,2002:str”, according to their kind . All nodes with the “ ?” non-specific tag are left unresolved . This constrains the application to deal with a partial representation . 10.2. JSON Schema The JSON schema is the lowest common denominator of most modern computer languages, and allows parsing JSON files. A YAML processor should therefore support this schema , at least as an option. It is also strongly recommended that other schemas should be based on it. 10.2.1. Tags The JSON schema uses the following tags in addition to those defined by the failsafe schema: 10.2.1.1. Null URI: tag:yaml.org,2002:null Kind: Scalar . Definition: Represents the lack of a value. This is typically bound to a native null-like value (e.g., undef in Perl, None in Python). Note that a null is different from an empty string. Also, a mapping entry with some key and a null value is valid, and different from not having that key in the mapping . Canonical Form: null. Example 10.4. !!null Examples !!null null: value for null key key with null value: !!null null 10.2.1.2. Boolean URI: tag:yaml.org,2002:bool Kind: Scalar . Definition: Represents a true/false value. In languages without a native Boolean type (such as C), is usually bound to a native integer type, using one for true and zero for false. Canonical Form: Either true or false. Example 10.5. !!bool Examples YAML is a superset of JSON: !!bool true Pluto is a planet: !!bool false 10.2.1.3. Integer URI: tag:yaml.org,2002:int Kind: Scalar . Definition: Represents arbitrary sized finite mathematical integers. Scalars of this type should be bound to a native integer data type, if possible. Some languages (such as Perl) provide only a “ number” type that allows for both integer and floating-point values. A YAML processor may use such a type for integers, as long as they round-trip properly. In some languages (such as C), an integer may overflow the native type’s storage capability. A YAML processor may reject such a value as an error, truncate it with a warning, or find some other manner to round-trip it. In general, integers representable using 32 binary digits should safely round-trip through most systems. Canonical Form: Decimal integer notation, with a leading “ -” character for negative values, matching the regular expression 0 | -? [1-9] [0-9]* Example 10.6. !!int Examples negative: !!int -12 zero: !!int 0 positive: !!int 34 10.2.1.4. Floating Point URI: tag:yaml.org,2002:float Kind: Scalar . Definition: Represents an approximation to real numbers, including three special values (positive and negative infinity, and “ not a number”). Some languages (such as Perl) provide only a “ number” type that allows for both integer and floating-point values. A YAML processor may use such a type for floating-point numbers, as long as they round-trip properly. Not all floating-point values can be stored exactly in any given native type. Hence a float value may change by “ a small amount” when round-tripped. The supported range and accuracy depends on the implementation, though 32 bit IEEE floats should be safe. Since YAML does not specify a particular accuracy, using floating-point mapping keys requires great care and is not recommended. Canonical Form: Either 0, .inf, -.inf, .nan, or scientific notation matching the regular expression -? [1-9] ( \\. [0-9]* [1-9] )? ( e [-+] [1-9] [0-9]* )?. Example 10.7. !!float Examples negative: !!float -1 zero: !!float 0 positive: !!float 2.3e4 infinity: !!float .inf not a number: !!float .nan 10.2.2. Tag Resolution The JSON schema tag resolution is an extension of the failsafe schema tag resolution . All nodes with the “ !” non-specific tag are resolved , by the standard convention , to “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map”, or “ tag:yaml.org,2002:str”, according to their kind . Collections with the “ ?” non-specific tag (that is, untagged collections ) are resolved to “ tag:yaml.org,2002:seq” or “ tag:yaml.org,2002:map” according to their kind . Scalars with the “ ?” non-specific tag (that is, plain scalars ) are matched with a list of regular expressions (first match wins, e.g. 0 is resolved as !!int). In principle, JSON files should not contain any scalars that do not match at least one of these. Hence the YAML processor should consider them to be an error. Regular expression Resolved to tag null tag:yaml.org,2002:null true | false tag:yaml.org,2002:bool -? ( 0 | [1-9] [0-9]* ) tag:yaml.org,2002:int -? ( 0 | [1-9] [0-9]* ) ( \\. [0-9]* )? ( [eE] [-+]? [0-9]+ )? tag:yaml.org,2002:float * Error Example 10.8. JSON Tag Resolution A null: null Booleans: [ true, false ] Integers: [ 0, -0, 3, -19 ] Floats: [ 0., -0.0, 12e03, -2E+05 ] Invalid: [ True, Null, 0o7, 0x3A, +12.3 ] %YAML 1.2 --- !!map { !!str \"A null\" : !!null \"null\", !!str \"Booleans: !!seq [ !!bool \"true\", !!bool \"false\" ], !!str \"Integers\": !!seq [ !!int \"0\", !!int \"-0\", !!int \"3\", !!int \"-19\" ], !!str \"Floats\": !!seq [ !!float \"0.\", !!float \"-0.0\", !!float \"12e03\", !!float \"-2E+05\" ], !!str \"Invalid\": !!seq [ # Rejected by the schema True, Null, 0o7, 0x3A, +12.3, ], } ... 10.3. Core Schema The Core schema is an extension of the JSON schema , allowing for more human-readable presentation of the same types. This is the recommended default schema that YAML processor should use unless instructed otherwise. It is also strongly recommended that other schemas should be based on it. 10.3.1. Tags The core schema uses the same tags as the JSON schema . 10.3.2. Tag Resolution The core schema tag resolution is an extension of the JSON schema tag resolution . All nodes with the “ !” non-specific tag are resolved , by the standard convention , to “ tag:yaml.org,2002:seq”, “ tag:yaml.org,2002:map”, or “ tag:yaml.org,2002:str”, according to their kind . Collections with the “ ?” non-specific tag (that is, untagged collections ) are resolved to “ tag:yaml.org,2002:seq” or “ tag:yaml.org,2002:map” according to their kind . Scalars with the “ ?” non-specific tag (that is, plain scalars ) are matched with an extended list of regular expressions. However, in this case, if none of the regular expressions matches, the scalar is resolved to tag:yaml.org,2002:str (that is, considered to be a string). Regular expression Resolved to tag null | Null | NULL | ~ tag:yaml.org,2002:null /* Empty */ tag:yaml.org,2002:null true | True | TRUE | false | False | FALSE tag:yaml.org,2002:bool [-+]? [0-9]+ tag:yaml.org,2002:int (Base 10) 0o [0-7]+ tag:yaml.org,2002:int (Base 8) 0x [0-9a-fA-F]+ tag:yaml.org,2002:int (Base 16) [-+]? ( \\. [0-9]+ | [0-9]+ ( \\. [0-9]* )? ) ( [eE] [-+]? [0-9]+ )? tag:yaml.org,2002:float (Number) [-+]? ( \\.inf | \\.Inf | \\.INF ) tag:yaml.org,2002:float (Infinity) \\.nan | \\.NaN | \\.NAN tag:yaml.org,2002:float (Not a number) * tag:yaml.org,2002:str (Default) Example 10.9. Core Tag Resolution A null: null Also a null: # Empty Not a null: \"\" Booleans: [ true, True, false, FALSE ] Integers: [ 0, 0o7, 0x3A, -19 ] Floats: [ 0., -0.0, .5, +12e03, -2E+05 ] Also floats: [ .inf, -.Inf, +.INF, .NAN ] %YAML 1.2 --- !!map { !!str \"A null\" : !!null \"null\", !!str \"Also a null\" : !!null \"\", !!str \"Not a null\" : !!str \"\", !!str \"Booleans: !!seq [ !!bool \"true\", !!bool \"True\", !!bool \"false\", !!bool \"FALSE\", ], !!str \"Integers\": !!seq [ !!int \"0\", !!int \"0o7\", !!int \"0x3A\", !!int \"-19\", ], !!str \"Floats\": !!seq [ !!float \"0.\", !!float \"-0.0\", !!float \".5\", !!float \"+12e03\", !!float \"-2E+05\" ], !!str \"Also floats\": !!seq [ !!float \".inf\", !!float \"-.Inf\", !!float \"+.INF\", !!float \".NAN\", ], } ... 10.4. Other Schemas None of the above recommended schemas preclude the use of arbitrary explicit tags . Hence YAML processors for a particular programming language typically provide some form of local tags that map directly to the language’s native data structures (e.g., !ruby/object:Set). While such local tags are useful for ad-hoc applications , they do not suffice for stable, interoperable cross- application or cross-platform data exchange. Interoperable schemas make use of global tags (URIs) that represent the same data across different programming languages. In addition, an interoperable schema may provide additional tag resolution rules. Such rules may provide additional regular expressions, as well as consider the path to the node . This allows interoperable schemas to use untagged nodes . It is strongly recommended that such schemas be based on the core schema defined above. In addition, it is strongly recommended that such schemas make as much use as possible of the the YAML tag repository at http://yaml.org/type/ . This repository provides recommended global tags for increasing the portability of YAML documents between different applications . The tag repository is intentionally left out of the scope of this specification. This allows it to evolve to better support YAML applications . Hence, developers are encouraged to submit new “ universal” types to the repository. The yaml-core mailing list at http://lists.sourceforge.net/lists/listinfo/yaml-core is the preferred method for such submissions, as well as raising any questions regarding this draft. Index Indicators ! tag indicator, Tags , Indicator Characters , Node Tags ! local tag, Tags , Tag Handles , Tag Prefixes , Node Tags ! non-specific tag, Resolved Tags , Node Tags , Tag Resolution , Tag Resolution , Tag Resolution ! primary tag handle, Tag Handles !! secondary tag handle, Tag Handles !…! named handle, Tag Handles , Node Tags \" double-quoted style, Indicator Characters , Double-Quoted Style # comment, Collections , Indicator Characters , Comments , Plain Style , Block Indentation Indicator % directive, Indicator Characters , Directives , Document Markers , Bare Documents % escaping in URI, Tags , Miscellaneous Characters , Node Tags & anchor, Structures , Indicator Characters , Node Anchors ' reserved indicator, Indicator Characters ' single-quoted style, Indicator Characters , Single-Quoted Style * alias, Structures , Indicator Characters , Alias Nodes + keep chomping, Block Chomping Indicator , end flow entry, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Collection Styles , Flow Sequences , Flow Mappings - block sequence entry, Introduction , Collections , Structures , Production Parameters , Indicator Characters , Indentation Spaces , Plain Style , Block Collection Styles , Block Sequences , Block Nodes - strip chomping, Block Chomping Indicator : mapping value, Introduction , Collections , Structures , Indicator Characters , Indentation Spaces , Plain Style , Flow Mappings , Block Mappings <…> verbatim tag, Node Tags > folded style, Scalars , Indicator Characters , Folded Style ? mapping key, Structures , Indicator Characters , Indentation Spaces , Plain Style , Flow Mappings , Block Mappings ? non-specific tag, Resolved Tags , Node Tags , Tag Resolution , Tag Resolution , Tag Resolution @ reserved indicator, Indicator Characters [ start flow sequence, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Sequences \\ escaping in double-quoted scalars, Escaped Characters , Double-Quoted Style ] end flow sequence, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Sequences { start flow mapping, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Mappings | literal style, Scalars , Indicator Characters , Literal Style } end flow mapping, Collections , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Mappings prefix, Document Prefix A alias, Introduction , Prior Art , Structures , Dump , Serialization Tree , Anchors and Aliases , Loading Failure Points , Well-Formed Streams and Identified Aliases , Resolved Tags , Indicator Characters , Node Anchors , Flow Styles , Alias Nodes , Flow Nodes identified, Structures , Anchors and Aliases , Well-Formed Streams and Identified Aliases unidentified, Loading Failure Points , Well-Formed Streams and Identified Aliases anchor, Structures , Dump , Serialization Tree , Anchors and Aliases , Well-Formed Streams and Identified Aliases , Resolved Tags , Indicator Characters , Node Properties , Flow Styles , Alias Nodes , Flow Nodes application, Introduction , Prior Art , Tags , Processing YAML Information , Dump , Information Models , Tags , Serialization Tree , Keys Order , Resolved Tags , Available Tags , Tag Prefixes , Node Tags , Streams , Tag Resolution , Other Schemas B block scalar header, Comments , Block Scalar Headers , Block Chomping Indicator byte order mark, Character Encodings , Document Prefix C character encoding, Character Encodings , Document Prefix , Streams in URI, Miscellaneous Characters chomping, Production Parameters , Line Folding , Block Chomping Indicator , Literal Style , Folded Style clip, Production Parameters , Block Chomping Indicator keep, Production Parameters , Block Chomping Indicator strip, Production Parameters , Block Chomping Indicator collection, Prior Art , Representation Graph , Nodes , Node Comparison , Anchors and Aliases , Node Styles , Comments , Resolved Tags , Recognized and Valid Tags , Tag Resolution , Tag Resolution comment, Collections , Processes , Dump , Load , Presentation Stream , Comments , Resolved Tags , Indicator Characters , Comments , Separation Lines , Plain Style , Block Scalar Headers , Block Chomping Indicator , Document Prefix , Streams compose, Processes , Load , Keys Order , Anchors and Aliases , Resolved Tags , Recognized and Valid Tags , Available Tags , Node Anchors construct, Processes , Load , Serialization Tree , Loading Failure Points , Recognized and Valid Tags , Available Tags , Flow Styles , Generic Mapping , Generic Sequence , Generic String , Null , Boolean , Integer content, Structures , Dump , Nodes , Tags , Node Comparison , Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Character Encodings , Line Break Characters , Escaped Characters , Indentation Spaces , Separation Spaces , Line Prefixes , Empty Lines , Line Folding , Comments , Directives , Tag Handles , Node Properties , Node Tags , Node Anchors , Alias Nodes , Empty Nodes , Flow Scalar Styles , Double-Quoted Style , Single-Quoted Style , Plain Style , Block Scalar Headers , Block Indentation Indicator , Block Chomping Indicator , Literal Style , Document Markers , Bare Documents valid, Recognized and Valid Tags context, Production Parameters , Plain Style block-in, Production Parameters , Block Nodes block-key, Production Parameters , Flow Collection Styles block-out, Production Parameters , Block Nodes flow-in, Production Parameters , Flow Collection Styles flow-key, Production Parameters , Flow Collection Styles flow-out, Production Parameters , Flow Collection Styles D directive, Structures , Dump , Load , Presentation Stream , Directives , Indicator Characters , Directives , Document Markers , Bare Documents , Explicit Documents , Directives Documents reserved, Directives , Directives TAG, Tags , Directives , Indicator Characters , Directives , “TAG” Directives , Node Tags YAML, Directives , Directives , “YAML” Directives document, Prior Art , Structures , Presentation Stream , Directives , Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Character Encodings , Line Break Characters , “YAML” Directives , Tag Prefixes , Alias Nodes , Documents , Document Prefix , Document Markers , Explicit Documents , Streams , Failsafe Schema , Other Schemas bare, Bare Documents directives, Directives Documents explicit, Explicit Documents suffix, Document Markers dump, Processes , Dump E empty line, Prior Art , Scalars , Empty Lines , Line Folding , Block Indentation Indicator , Block Chomping Indicator , Literal Style , Folded Style equality, Relation to JSON , Dump , Representation Graph , Nodes , Tags , Node Comparison , Scalar Formats , Loading Failure Points , Recognized and Valid Tags escaping in double-quoted scalars, Prior Art , Scalars , Character Set , Character Encodings , Miscellaneous Characters , Escaped Characters , Double-Quoted Style in single-quoted scalars, Single-Quoted Style in URIs, Miscellaneous Characters non-content line break, Double-Quoted Style I identity, Node Comparison indicator, Introduction , Prior Art , Collections , Node Styles , Production Parameters , Indicator Characters , Line Folding , Plain Style , Flow Mappings , Flow Nodes , Block Styles , Block Scalar Headers , Block Collection Styles indentation, Block Indentation Indicator reserved, Indicator Characters information model, Information Models invalid content, Loading Failure Points , Recognized and Valid Tags J JSON compatibility, Character Set , Character Encodings , Line Break Characters , Escaped Characters , Comments , “YAML” Directives , Flow Mappings , Block Mappings JSON-like, Flow Mappings , Flow Nodes K key, Relation to JSON , Structures , Dump , Information Models , Representation Graph , Nodes , Node Comparison , Serialization Tree , Keys Order , Resolved Tags , Indicator Characters , Flow Mappings , Block Mappings , Generic Mapping , Null , Floating Point implicit, Separation Lines , Double-Quoted Style , Single-Quoted Style , Plain Style , Flow Collection Styles , Flow Mappings , Block Mappings , Block Nodes order, Processes , Dump , Load , Information Models , Serialization Tree , Keys Order key: value pair, Introduction , Collections , Structures , Nodes , Keys Order , Node Styles , Plain Style , Flow Mappings , Block Collection Styles , Block Mappings kind, Dump , Representation Graph , Nodes , Tags , Node Comparison , Node Styles , Resolved Tags , Node Tags , Tag Resolution , Tag Resolution , Tag Resolution L line break, Prior Art , Scalars , Production Parameters , Production Naming Conventions , Line Break Characters , White Space Characters , Empty Lines , Line Folding , Comments , Double-Quoted Style , Block Scalar Headers , Block Chomping Indicator , Literal Style , Folded Style non-ASCII, Line Break Characters , “YAML” Directives normalization, Line Break Characters , Literal Style line folding, Prior Art , Scalars , Line Folding , Flow Styles , Double-Quoted Style , Single-Quoted Style , Plain Style , Block Chomping Indicator , Folded Style block, Line Folding , Folded Style flow, Line Folding , Double-Quoted Style line prefix, Line Prefixes , Empty Lines load, Processes , Load , Loading Failure Points failure point, Load , Loading Failure Points M mapping, Introduction , Prior Art , Relation to JSON , Collections , Structures , Dump , Representation Graph , Nodes , Tags , Node Comparison , Keys Order , Resolved Tags , Plain Style , Flow Sequences , Flow Mappings , Generic Mapping , Null marker, Presentation Stream , Document Markers , Bare Documents , Explicit Documents , Streams directives end, Structures , Document Markers , Explicit Documents , Directives Documents , Streams document end, Structures , Document Markers , Streams more-indented, Scalars , Line Folding , Folded Style N native data structure, Introduction , Goals , Prior Art , Relation to JSON , Processing YAML Information , Processes , Dump , Load , Representation Graph , Nodes , Tags , Node Comparison , Serialization Tree , Loading Failure Points , Recognized and Valid Tags , Available Tags , Node Tags , Flow Styles , Generic Mapping , Generic Sequence , Generic String , Null , Boolean , Integer , Floating Point , Other Schemas need not, Terminology node, Structures , Dump , Representation Graph , Nodes , Tags , Node Comparison , Serialization Tree , Keys Order , Anchors and Aliases , Presentation Stream , Node Styles , Comments , Loading Failure Points , Well-Formed Streams and Identified Aliases , Resolved Tags , Recognized and Valid Tags , Syntax Conventions , Indentation Spaces , Node Properties , Node Tags , Node Anchors , Alias Nodes , Empty Nodes , Flow Mappings , Flow Nodes , Block Indentation Indicator , Block Sequences , Bare Documents , Tag Resolution , Tag Resolution , Tag Resolution , Other Schemas completely empty, Empty Nodes , Flow Collection Styles , Flow Mappings , Block Sequences , Explicit Documents property, Node Properties , Alias Nodes , Empty Nodes , Flow Mappings , Flow Nodes , Block Sequences , Block Mappings , Block Nodes root, Representation Graph , Resolved Tags P parse, Load , Presentation Stream , Resolved Tags , Production Parameters , Line Break Characters , Escaped Characters , Tag Handles , Node Tags , Flow Mappings , Block Mappings , Block Nodes , Document Markers , JSON Schema present, Processing YAML Information , Dump , Load , Nodes , Node Comparison , Presentation Stream , Scalar Formats , Character Set , Miscellaneous Characters , Node Tags , Alias Nodes , Block Mappings , Core Schema presentation, Processing YAML Information , Information Models , Presentation Stream , Production Parameters detail, Dump , Load , Information Models , Presentation Stream , Node Styles , Scalar Formats , Comments , Directives , Resolved Tags , Character Encodings , Line Break Characters , Escaped Characters , Indentation Spaces , Separation Spaces , Line Prefixes , Line Folding , Comments , Directives , Tag Handles , Node Tags , Flow Scalar Styles , Block Chomping Indicator printable character, Introduction , Prior Art , Character Set , White Space Characters , Escaped Characters , Single-Quoted Style , Literal Style processor, Terminology , Processing YAML Information , Dump , Node Comparison , Presentation Stream , Directives , Well-Formed Streams and Identified Aliases , Resolved Tags , Recognized and Valid Tags , Available Tags , Character Set , Character Encodings , Line Break Characters , Miscellaneous Characters , Comments , Directives , “YAML” Directives , Tag Handles , Node Tags , Node Anchors , Flow Mappings , Block Indentation Indicator , Failsafe Schema , JSON Schema , Integer , Floating Point , Tag Resolution , Core Schema , Other Schemas R represent, Introduction , Prior Art , Dump , Tags , Node Comparison , Keys Order , Generic Mapping , Generic Sequence , Generic String , Null , Boolean , Integer , Floating Point , Other Schemas representation, Processing YAML Information , Processes , Dump , Load , Information Models , Representation Graph , Nodes , Node Comparison , Serialization Tree , Keys Order , Anchors and Aliases , Presentation Stream , Node Styles , Scalar Formats , Comments , Directives , Available Tags , Node Anchors complete, Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Available Tags partial, Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Tag Resolution required, Terminology S scalar, Introduction , Prior Art , Scalars , Dump , Representation Graph , Nodes , Tags , Node Comparison , Scalar Formats , Comments , Recognized and Valid Tags , Line Break Characters , Separation Spaces , Line Prefixes , Comments , Empty Nodes , Block Chomping Indicator , Generic Mapping , Generic String , Null , Boolean , Integer , Floating Point , Tag Resolution , Tag Resolution canonical form, Prior Art , Tags , Node Comparison , Scalar Formats , Loading Failure Points content format, Dump , Load , Tags , Node Comparison , Presentation Stream , Scalar Formats , Loading Failure Points schema, Recommended Schemas , Failsafe Schema , JSON Schema , Tags , Core Schema , Tags , Other Schemas core, Core Schema , Tag Resolution , Other Schemas failsafe, Tags , Failsafe Schema , Tags , Tag Resolution JSON, Tags , JSON Schema , Tag Resolution , Core Schema , Tags , Tag Resolution sequence, Introduction , Prior Art , Dump , Representation Graph , Nodes , Tags , Node Comparison , Keys Order , Resolved Tags , Flow Mappings , Generic Sequence serialization, Processing YAML Information , Processes , Dump , Load , Information Models , Serialization Tree , Anchors and Aliases , Presentation Stream , Node Styles , Scalar Formats , Comments , Directives , Node Anchors detail, Dump , Load , Information Models , Keys Order , Anchors and Aliases , Node Anchors serialize, Introduction , Prior Art , Relation to JSON , Dump , Load , Keys Order , Anchors and Aliases , Alias Nodes shall, Terminology space, Prior Art , Scalars , White Space Characters , Indentation Spaces , Line Folding , Single-Quoted Style , Plain Style , Block Indentation Indicator , Folded Style , Block Sequences , Block Nodes , Bare Documents indentation, Introduction , Prior Art , Collections , Dump , Load , Information Models , Node Styles , Resolved Tags , Production Parameters , Production Naming Conventions , Indentation Spaces , Separation Spaces , Line Prefixes , Line Folding , Comments , Separation Lines , Directives , Block Styles , Block Indentation Indicator , Block Chomping Indicator , Literal Style , Block Sequences , Block Nodes , Bare Documents separation, Separation Spaces , Comments , Flow Mappings , Block Sequences white, Production Naming Conventions , White Space Characters , Separation Spaces , Line Prefixes , Line Folding , Comments , Double-Quoted Style , Single-Quoted Style , Plain Style , Flow Mappings , Literal Style , Folded Style , Block Sequences stream, Prior Art , Processing YAML Information , Processes , Dump , Load , Presentation Stream , Loading Failure Points , Well-Formed Streams and Identified Aliases , Resolved Tags , Syntax Conventions , Character Set , Character Encodings , Miscellaneous Characters , Comments , Tag Prefixes , Empty Nodes , Documents , Streams ill-formed, Load , Loading Failure Points , Well-Formed Streams and Identified Aliases well-formed, Well-Formed Streams and Identified Aliases , Streams style, Dump , Load , Information Models , Presentation Stream , Node Styles , Scalar Formats , Resolved Tags , Node Tags , Double-Quoted Style , Plain Style block, Prior Art , Scalars , Node Styles , Production Parameters , Indentation Spaces , Block Styles , Block Sequences collection, Collections , Structures , Indentation Spaces , Flow Collection Styles , Block Collection Styles , Block Sequences , Block Nodes folded, Scalars , Node Styles , Indicator Characters , Line Folding , Block Scalar Styles , Literal Style , Folded Style literal, Prior Art , Scalars , Node Styles , Indicator Characters , Block Scalar Styles , Literal Style , Folded Style mapping, Node Styles , Production Parameters , Block Mappings , Block Nodes scalar, Node Styles , Block Scalar Styles , Block Scalar Headers , Block Indentation Indicator , Block Chomping Indicator sequence, Collections , Node Styles , Production Parameters , Indicator Characters , Block Sequences , Block Mappings , Block Nodes compact block collection, Node Styles , Block Sequences , Block Mappings flow, Prior Art , Collections , Scalars , Node Styles , Production Parameters , Line Folding , Flow Styles , Flow Sequences , Flow Nodes , Block Nodes collection, Syntax Conventions , Production Parameters , Indicator Characters , Miscellaneous Characters , Node Tags , Node Anchors , Plain Style , Flow Collection Styles double-quoted, Prior Art , Scalars , Node Styles , Syntax Conventions , Character Set , Character Encodings , Indicator Characters , Escaped Characters , Flow Scalar Styles , Double-Quoted Style , Flow Nodes mapping, Collections , Node Styles , Production Parameters , Indicator Characters , Flow Mappings , Block Mappings plain, Scalars , Node Styles , Resolved Tags , Production Parameters , Indicator Characters , Node Tags , Empty Nodes , Flow Scalar Styles , Plain Style , Flow Mappings , Flow Nodes , Block Collection Styles , Block Sequences , Block Mappings , Block Nodes , Document Markers , Tag Resolution , Tag Resolution scalar, Scalars , Node Styles , Line Prefixes , Line Folding , Flow Scalar Styles sequence, Collections , Node Styles , Indicator Characters , Flow Sequences , Flow Mappings single-quoted, Node Styles , Production Parameters , Indicator Characters , Flow Scalar Styles , Single-Quoted Style scalar, Node Styles , Escaped Characters , Empty Lines , Flow Scalar Styles , Literal Style single key:value pair mapping, Keys Order , Node Styles , Flow Sequences , Flow Mappings , Block Mappings T tab, Prior Art , Character Set , White Space Characters , Indentation Spaces , Separation Spaces , Line Prefixes , Block Indentation Indicator tag, Prior Art , Tags , Dump , Representation Graph , Nodes , Tags , Node Comparison , Scalar Formats , Loading Failure Points , Resolved Tags , Recognized and Valid Tags , Available Tags , Syntax Conventions , Production Parameters , Indicator Characters , Miscellaneous Characters , “TAG” Directives , Tag Prefixes , Node Properties , Node Tags , Flow Styles , Recommended Schemas , Tags , Tags , Other Schemas available, Available Tags global, Prior Art , Tags , Dump , Tags , Resolved Tags , Tag Handles , Tag Prefixes , Node Tags , Other Schemas handle, Tags , Processes , Dump , Indicator Characters , “TAG” Directives , Tag Handles , Tag Prefixes , Node Tags named, Miscellaneous Characters , Tag Handles , Node Tags primary, Tag Handles secondary, Tag Handles local, Prior Art , Tags , Dump , Tags , Resolved Tags , Indicator Characters , Tag Handles , Tag Prefixes , Node Tags , Other Schemas non-specific, Tags , Dump , Loading Failure Points , Resolved Tags , Indicator Characters , Node Tags , Recommended Schemas , Tag Resolution , Tag Resolution , Other Schemas prefix, “TAG” Directives , Tag Prefixes , Node Tags property, Resolved Tags , Indicator Characters , Node Tags recognized, Recognized and Valid Tags repository, Tags , Tag Handles , Other Schemas bool, Boolean float, Tags , Floating Point int, Tags , Integer map, Tags , Generic Mapping null, Tags , Empty Nodes , Null seq, Tags , Generic Sequence str, Tags , Generic String resolution, Tags , Loading Failure Points , Resolved Tags , Node Tags , Flow Scalar Styles , Recommended Schemas , Tag Resolution , Tag Resolution , Tag Resolution , Other Schemas convention, Resolved Tags , Node Tags , Tag Resolution , Tag Resolution , Tag Resolution shorthand, Tags , Miscellaneous Characters , “TAG” Directives , Tag Handles , Tag Prefixes , Node Tags specific, Resolved Tags , Node Tags unavailable, Load , Loading Failure Points , Available Tags unrecognized, Loading Failure Points , Recognized and Valid Tags unresolved, Loading Failure Points , Resolved Tags verbatim, Node Tags trimming, Line Folding V value, Dump , Nodes , Node Comparison , Resolved Tags , Indicator Characters , Flow Mappings , Block Mappings , Generic Mapping , Null Y YAML 1.1 processing, Line Break Characters , “YAML” Directives ",
                "urlTerms": [
                    "spec",
                    "html"
                ],
                "titleTerms": [
                    "yaml",
                    "markup",
                    "language",
                    "yaml™",
                    "version"
                ]
            }
        },
        {
            "timestamp": 1608988361600,
            "collection": "visits",
            "objectPk": [
                1608988361593,
                "yaml.org/spec/1.2/spec.html"
            ],
            "operation": "create",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "time": 1608988361593
            }
        },
        {
            "timestamp": 1608988361624,
            "collection": "pageListEntries",
            "objectPk": [
                1608988356680,
                "yaml.org/spec/1.2/spec.html"
            ],
            "operation": "create",
            "object": {
                "listId": 1608988356680,
                "pageUrl": "yaml.org/spec/1.2/spec.html",
                "fullUrl": "https://yaml.org/spec/1.2/spec.html#id2708649",
                "createdAt": "2020-12-26T13:12:41.613Z"
            }
        },
        {
            "timestamp": 1608988410749,
            "collection": "visits",
            "objectPk": [
                1608988410721,
                "yaml.org/spec/1.2/spec.html"
            ],
            "operation": "create",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "time": 1608988410721
            }
        },
        {
            "timestamp": 1608988410973,
            "collection": "tags",
            "objectPk": [
                "YAML",
                "yaml.org/spec/1.2/spec.html"
            ],
            "operation": "create",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "name": "YAML"
            }
        },
        {
            "timestamp": 1608988414445,
            "collection": "visits",
            "objectPk": [
                1608988414427,
                "yaml.org/spec/1.2/spec.html"
            ],
            "operation": "create",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "time": 1608988414427
            }
        },
        {
            "timestamp": 1608988414484,
            "collection": "tags",
            "objectPk": [
                "template",
                "yaml.org/spec/1.2/spec.html"
            ],
            "operation": "create",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "name": "template"
            }
        },
        {
            "timestamp": 1608988423514,
            "collection": "visits",
            "objectPk": [
                1608988423494,
                "yaml.org/spec/1.2/spec.html"
            ],
            "operation": "create",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "time": 1608988423494
            }
        },
        {
            "timestamp": 1608988423631,
            "collection": "tags",
            "objectPk": [
                "data",
                "yaml.org/spec/1.2/spec.html"
            ],
            "operation": "create",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "name": "data"
            }
        },
        {
            "timestamp": 1608988429884,
            "collection": "visits",
            "objectPk": [
                1608988429868,
                "yaml.org/spec/1.2/spec.html"
            ],
            "operation": "create",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "time": 1608988429868
            }
        },
        {
            "timestamp": 1608988429912,
            "collection": "tags",
            "objectPk": [
                "pro",
                "yaml.org/spec/1.2/spec.html"
            ],
            "operation": "create",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "name": "pro"
            }
        },
        {
            "timestamp": 1608988435776,
            "collection": "visits",
            "objectPk": [
                1608988435765,
                "yaml.org/spec/1.2/spec.html"
            ],
            "operation": "create",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "time": 1608988435765
            }
        },
        {
            "timestamp": 1608988435835,
            "collection": "tags",
            "objectPk": [
                "programming",
                "yaml.org/spec/1.2/spec.html"
            ],
            "operation": "create",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "name": "programming"
            }
        },
        {
            "timestamp": 1608988441762,
            "collection": "visits",
            "objectPk": [
                1608988441752,
                "yaml.org/spec/1.2/spec.html"
            ],
            "operation": "create",
            "object": {
                "url": "yaml.org/spec/1.2/spec.html",
                "time": 1608988441752
            }
        },
        {
            "timestamp": 1608988441817,
            "collection": "tags",
            "objectPk": [
                "wikipedia",
                "yaml.org/spec/1.2/spec.html"
            ],
            "operation": "create",
            "object": {}
        },
        {
            "timestamp": 1608988442876,
            "collection": "tags",
            "objectPk": [
                "wikipedia",
                "yaml.org/spec/1.2/spec.html"
            ],
            "operation": "delete",
            "object": {}
        }
    ]
}